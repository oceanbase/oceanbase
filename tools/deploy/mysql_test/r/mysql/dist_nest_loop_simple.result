drop database if exists yy;
drop table if exists t1;
drop table if exists t2;
drop table if exists t4;
drop table if exists t5;
drop table if exists t6;
drop table if exists t11;
drop table if exists t12;
drop table if exists t13;
drop table if exists t15;
create database yy;
use yy;
create table t1(c1 int(11) , c2 int(11) , c3 int(11), primary key (c2, c3)) partition by range columns(c2, c3) (partition p0 values less than (1,1), partition p1 values less than (100,100));
create table t2(c1 int(11) not null, c2 int(11) not null, c3 int(11) not null, primary key (c1, c2, c3)) partition by hash(c1) partitions 2;
create table t11(c1 int primary key, c2 int) partition by hash (c1) partitions 5;
create table t12(c1 int primary key, c2 int, c3 varchar(32)) partition by hash (c1) partitions 3;
create table t13(c1 int primary key, c2 int, c3 varchar(32)) partition by hash (c1) partitions 2;
create index idx_t11_c2 on t11(c2) LOCAL;
create table t15(c1 int, c2 int, c3 int, primary key(c2,c3)) partition by key(c2, c3) partitions 3;
create index idx_t15_c2 on t15(c2) LOCAL;
create index idx_t15_c3 on t15(c3) LOCAL;
explain  select /*+use_nl(t1 t2)*/ * from t1 left join t2 on t1.c2= t2.c2 and t1.c3= t2.c3;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR                     |        |1       |8           |
|1 |└─EXCHANGE OUT DISTR               |:EX10001|1       |7           |
|2 |  └─NESTED-LOOP OUTER JOIN         |        |1       |5           |
|3 |    ├─PX PARTITION ITERATOR        |        |1       |5           |
|4 |    │ └─TABLE FULL SCAN            |t1      |1       |5           |
|5 |    └─MATERIAL                     |        |1       |6           |
|6 |      └─EXCHANGE IN DISTR          |        |1       |6           |
|7 |        └─EXCHANGE OUT DISTR (PKEY)|:EX10000|1       |6           |
|8 |          └─PX PARTITION ITERATOR  |        |1       |5           |
|9 |            └─TABLE FULL SCAN      |t2      |1       |5           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c2], [t2.c2], [t1.c3], [t2.c3], [t1.c1], [t2.c1]), filter(nil), rowset=16
      conds([t1.c2 = t2.c2], [t1.c3 = t2.c3]), nl_params_(nil), use_batch=false
  3 - output([t1.c2], [t1.c3], [t1.c1]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.c2], [t1.c3], [t1.c1]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), rowset=16
  6 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), rowset=16
  7 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), rowset=16
      (#keys=2, [t2.c2], [t2.c3]), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      force partition granule
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
drop table t1;
create table t1 (c1 int(11) , c2 int(11) , c3 int(11), primary key (c2, c3)) partition by key(c2) partitions 2;
explain  select /*+use_nl(t1 t2)*/ * from t1 left join t2 on t1.c2= t2.c2 and t1.c3= t2.c3;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR                     |        |1       |8           |
|1 |└─EXCHANGE OUT DISTR               |:EX10001|1       |7           |
|2 |  └─NESTED-LOOP OUTER JOIN         |        |1       |5           |
|3 |    ├─PX PARTITION ITERATOR        |        |1       |5           |
|4 |    │ └─TABLE FULL SCAN            |t1      |1       |5           |
|5 |    └─MATERIAL                     |        |1       |6           |
|6 |      └─EXCHANGE IN DISTR          |        |1       |6           |
|7 |        └─EXCHANGE OUT DISTR (PKEY)|:EX10000|1       |6           |
|8 |          └─PX PARTITION ITERATOR  |        |1       |5           |
|9 |            └─TABLE FULL SCAN      |t2      |1       |5           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c2], [t2.c2], [t1.c3], [t2.c3], [t1.c1], [t2.c1]), filter(nil), rowset=16
      conds([t1.c2 = t2.c2], [t1.c3 = t2.c3]), nl_params_(nil), use_batch=false
  3 - output([t1.c2], [t1.c3], [t1.c1]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.c2], [t1.c3], [t1.c1]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), rowset=16
  6 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), rowset=16
  7 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), rowset=16
      (#keys=1, [t2.c2]), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      force partition granule
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
drop table t1;
create table t1 (c1 int(11) , c2 int(11) , c3 int(11), c4 date, primary key (c2, c3)) partition by range columns(c2)
(partition p0 values less than (1), partition p1 values less than (100));
explain  select * from t1 join t2 on t1.c2= t2.c2;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |1       |14          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|1       |13          |
|2 |  └─HASH JOIN                    |        |1       |11          |
|3 |    ├─EXCHANGE IN DISTR          |        |1       |6           |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|1       |6           |
|5 |    │   └─PX PARTITION ITERATOR  |        |1       |5           |
|6 |    │     └─TABLE FULL SCAN      |t2      |1       |5           |
|7 |    └─PX PARTITION ITERATOR      |        |1       |5           |
|8 |      └─TABLE FULL SCAN          |t1      |1       |5           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c2], [t2.c2], [t2.c1], [t2.c3], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), rowset=16
  4 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), rowset=16
      (#keys=1, [t2.c2]), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      force partition granule
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
explain  select /*+use_nl(t1 t2)*/ * from t1 join t2 on t1.c3= t2.c3;
Query Plan
=================================================================
|ID|OPERATOR                     |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |NESTED-LOOP JOIN             |        |1       |7           |
|1 |├─PX COORDINATOR             |        |1       |7           |
|2 |│ └─EXCHANGE OUT DISTR       |:EX10000|1       |6           |
|3 |│   └─PX PARTITION ITERATOR  |        |1       |5           |
|4 |│     └─TABLE FULL SCAN      |t1      |1       |5           |
|5 |└─MATERIAL                   |        |1       |6           |
|6 |  └─PX COORDINATOR           |        |1       |6           |
|7 |    └─EXCHANGE OUT DISTR     |:EX20000|1       |6           |
|8 |      └─PX PARTITION ITERATOR|        |1       |5           |
|9 |        └─TABLE FULL SCAN    |t2      |1       |5           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      conds([t1.c3 = t2.c3]), nl_params_(nil), use_batch=false
  1 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4]), filter(nil), rowset=16
  2 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4]), filter(nil), rowset=16
      dop=1
  3 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      force partition granule
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select /*+use_bnl(t1 t2)*/ * from t1 join t2 on t1.c3= t2.c3;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |1       |13          |
|1 |├─PX COORDINATOR           |        |1       |6           |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|1       |6           |
|3 |│   └─PX PARTITION ITERATOR|        |1       |5           |
|4 |│     └─TABLE FULL SCAN    |t2      |1       |5           |
|5 |└─PX COORDINATOR           |        |1       |7           |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|1       |6           |
|7 |    └─PX PARTITION ITERATOR|        |1       |5           |
|8 |      └─TABLE FULL SCAN    |t1      |1       |5           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      equal_conds([t1.c3 = t2.c3]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      force partition granule
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4]), filter(nil), rowset=16
  6 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4]), filter(nil), rowset=16
      dop=1
  7 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      force partition granule
  8 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
explain  select /*+use_nl(t1 t2)*/ * from t1 left join t2 on t1.c2= t2.c2;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR                     |        |1       |8           |
|1 |└─EXCHANGE OUT DISTR               |:EX10001|1       |7           |
|2 |  └─NESTED-LOOP OUTER JOIN         |        |1       |5           |
|3 |    ├─PX PARTITION ITERATOR        |        |1       |5           |
|4 |    │ └─TABLE FULL SCAN            |t1      |1       |5           |
|5 |    └─MATERIAL                     |        |1       |6           |
|6 |      └─EXCHANGE IN DISTR          |        |1       |6           |
|7 |        └─EXCHANGE OUT DISTR (PKEY)|:EX10000|1       |6           |
|8 |          └─PX PARTITION ITERATOR  |        |1       |5           |
|9 |            └─TABLE FULL SCAN      |t2      |1       |5           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c2], [t2.c2], [t1.c3], [t1.c1], [t1.c4], [t2.c1], [t2.c3]), filter(nil), rowset=16
      conds([t1.c2 = t2.c2]), nl_params_(nil), use_batch=false
  3 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), rowset=16
  6 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), rowset=16
  7 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), rowset=16
      (#keys=1, [t2.c2]), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      force partition granule
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select /*+use_nl(t1 t2)*/ * from t1 left join t2 on t1.c1= t2.c1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |1       |24          |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|1       |23          |
|2 |  └─NESTED-LOOP OUTER JOIN        |        |1       |21          |
|3 |    ├─PX PARTITION ITERATOR       |        |1       |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |1       |5           |
|5 |    └─DISTRIBUTED TABLE RANGE SCAN|t2      |1       |31          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      conds(nil), nl_params_([t1.c1(:0)]), use_batch=true
  3 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([GROUP_ID], [t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN ; MAX), 
      range_cond([:0 = t2.c1])
explain  select /*+use_nl(t1 t2)*/ * from t1 left join t2 on t1.c2= t2.c2 and t1.c3= t2.c3;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR                     |        |1       |8           |
|1 |└─EXCHANGE OUT DISTR               |:EX10001|1       |7           |
|2 |  └─NESTED-LOOP OUTER JOIN         |        |1       |5           |
|3 |    ├─PX PARTITION ITERATOR        |        |1       |5           |
|4 |    │ └─TABLE FULL SCAN            |t1      |1       |5           |
|5 |    └─MATERIAL                     |        |1       |6           |
|6 |      └─EXCHANGE IN DISTR          |        |1       |6           |
|7 |        └─EXCHANGE OUT DISTR (PKEY)|:EX10000|1       |6           |
|8 |          └─PX PARTITION ITERATOR  |        |1       |5           |
|9 |            └─TABLE FULL SCAN      |t2      |1       |5           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c2], [t2.c2], [t1.c3], [t2.c3], [t1.c1], [t1.c4], [t2.c1]), filter(nil), rowset=16
      conds([t1.c2 = t2.c2], [t1.c3 = t2.c3]), nl_params_(nil), use_batch=false
  3 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), rowset=16
  6 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), rowset=16
  7 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), rowset=16
      (#keys=1, [t2.c2]), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      force partition granule
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select /*+use_nl(t1 t2)*/ * from t1 left join t2 on t1.c1= t2.c1 and t1.c3= t2.c3;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |1       |24          |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|1       |23          |
|2 |  └─NESTED-LOOP OUTER JOIN        |        |1       |21          |
|3 |    ├─PX PARTITION ITERATOR       |        |1       |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |1       |5           |
|5 |    └─DISTRIBUTED TABLE RANGE SCAN|t2      |1       |31          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c1], [t1.c3], [t1.c2], [t1.c4], [t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      conds(nil), nl_params_([t1.c1(:0)], [t1.c3(:1)]), use_batch=true
  3 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter([:1 = t2.c3]), rowset=16
      access([GROUP_ID], [t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN ; MAX), 
      range_cond([:0 = t2.c1])
explain  select /*+use_nl(t1 t2)*/ * from t1 join t2 on t1.c2= t2.c2;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |1       |24          |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|1       |23          |
|2 |  └─NESTED-LOOP JOIN              |        |1       |21          |
|3 |    ├─PX PARTITION ITERATOR       |        |1       |5           |
|4 |    │ └─TABLE FULL SCAN           |t2      |1       |5           |
|5 |    └─DISTRIBUTED TABLE RANGE SCAN|t1      |1       |31          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t2.c2], [t2.c1], [t2.c3], [t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([t2.c2(:0)]), use_batch=true
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      force partition granule
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([GROUP_ID], [t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN ; MAX), 
      range_cond([t1.c2 = :0])
explain  select /*+use_nl(t1 t2)*/ * from t1 join t2 on t1.c1= t2.c1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |1       |24          |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|1       |23          |
|2 |  └─NESTED-LOOP JOIN              |        |1       |21          |
|3 |    ├─PX PARTITION ITERATOR       |        |1       |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |1       |5           |
|5 |    └─DISTRIBUTED TABLE RANGE SCAN|t2      |1       |31          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4], [t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      conds(nil), nl_params_([t1.c1(:0)]), use_batch=true
  3 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([GROUP_ID], [t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN ; MAX), 
      range_cond([:0 = t2.c1])
explain  select /*+use_nl(t1 t2)*/ * from t1 join t2 on t1.c2= t2.c2 and t1.c3= t2.c3;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |PX COORDINATOR             |        |1       |24          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000|1       |23          |
|2 |  └─NESTED-LOOP JOIN       |        |1       |21          |
|3 |    ├─PX PARTITION ITERATOR|        |1       |5           |
|4 |    │ └─TABLE FULL SCAN    |t2      |1       |5           |
|5 |    └─DISTRIBUTED TABLE GET|t1      |1       |31          |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t2.c1, t2.c2, t2.c3)]), filter(nil), rowset=16
      dop=1
  2 - output([t2.c2], [t2.c3], [t2.c1], [t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([t2.c2(:0)], [t2.c3(:1)]), use_batch=true
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      force partition granule
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([GROUP_ID], [t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN ; MAX), 
      range_cond([t1.c2 = :0], [t1.c3 = :1])
explain  select c1 from t11 where c2 not in (select c2 from t11);
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH RIGHT ANTI JOIN NA    |        |1       |23          |
|1 |├─PX COORDINATOR           |        |1       |12          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|1       |11          |
|3 |│   └─PX PARTITION ITERATOR|        |1       |11          |
|4 |│     └─TABLE FULL SCAN    |t11     |1       |11          |
|5 |└─PX COORDINATOR           |        |1       |12          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|1       |12          |
|7 |    └─PX PARTITION ITERATOR|        |1       |11          |
|8 |      └─TABLE FULL SCAN    |t11     |1       |11          |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t11.c1]), filter(nil), rowset=16
      equal_conds([t11.c2 = t11.c2]), other_conds(nil)
  1 - output([t11.c2]), filter(nil), rowset=16
  2 - output([t11.c2]), filter(nil), rowset=16
      dop=1
  3 - output([t11.c2]), filter(nil), rowset=16
      force partition granule
  4 - output([t11.c2]), filter(nil), rowset=16
      access([t11.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1]), range(MIN ; MAX)always true
  5 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
  6 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
      dop=1
  7 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
      force partition granule
  8 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
      access([t11.c1], [t11.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1]), range(MIN ; MAX)always true
explain  select c1 from t12 where c1 not in (select c1 from t11 where c2 not in (select c2 from t11));
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |PX COORDINATOR                         |        |1       |30          |
|1 |└─EXCHANGE OUT DISTR                   |:EX10003|1       |30          |
|2 |  └─HASH RIGHT ANTI JOIN               |        |1       |30          |
|3 |    ├─EXCHANGE IN DISTR                |        |1       |23          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)      |:EX10002|1       |23          |
|5 |    │   └─SUBPLAN SCAN                 |VIEW2   |1       |23          |
|6 |    │     └─HASH RIGHT ANTI JOIN NA    |        |1       |23          |
|7 |    │       ├─EXCHANGE IN DISTR        |        |1       |12          |
|8 |    │       │ └─EXCHANGE OUT DISTR     |:EX10000|1       |11          |
|9 |    │       │   └─PX PARTITION ITERATOR|        |1       |11          |
|10|    │       │     └─TABLE FULL SCAN    |t11     |1       |11          |
|11|    │       └─EXCHANGE IN DISTR        |        |1       |12          |
|12|    │         └─EXCHANGE OUT DISTR     |:EX10001|1       |12          |
|13|    │           └─PX PARTITION ITERATOR|        |1       |11          |
|14|    │             └─TABLE FULL SCAN    |t11     |1       |11          |
|15|    └─PX PARTITION ITERATOR            |        |1       |7           |
|16|      └─TABLE FULL SCAN                |t12     |1       |7           |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t12.c1)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t12.c1)]), filter(nil), rowset=16
      dop=1
  2 - output([t12.c1]), filter(nil), rowset=16
      equal_conds([t12.c1 = VIEW2.c1]), other_conds(nil)
  3 - output([VIEW2.c1]), filter(nil), rowset=16
  4 - output([VIEW2.c1]), filter(nil), rowset=16
      (#keys=1, [VIEW2.c1]), is_single, dop=1
  5 - output([VIEW2.c1]), filter(nil), rowset=16
      access([VIEW2.c1])
  6 - output([t11.c1]), filter(nil), rowset=16
      equal_conds([t11.c2 = t11.c2]), other_conds(nil)
  7 - output([t11.c2]), filter(nil), rowset=16
  8 - output([t11.c2]), filter(nil), rowset=16
      dop=1
  9 - output([t11.c2]), filter(nil), rowset=16
      force partition granule
 10 - output([t11.c2]), filter(nil), rowset=16
      access([t11.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1]), range(MIN ; MAX)always true
 11 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
 12 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
      dop=1
 13 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
      force partition granule
 14 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
      access([t11.c1], [t11.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1]), range(MIN ; MAX)always true
 15 - output([t12.c1]), filter(nil), rowset=16
      affinitize, force partition granule
 16 - output([t12.c1]), filter(nil), rowset=16
      access([t12.c1]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
explain  select * from (select /*+use_nl(t11 t12)*/ t12.c1 from t11,t12 where t11.c1=t12.c1 limit 1) v order by v.c1;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |SORT                               |        |1       |24          |
|1 |└─SUBPLAN SCAN                     |v       |1       |23          |
|2 |  └─LIMIT                          |        |1       |23          |
|3 |    └─PX COORDINATOR               |        |1       |23          |
|4 |      └─EXCHANGE OUT DISTR         |:EX10000|1       |23          |
|5 |        └─LIMIT                    |        |1       |23          |
|6 |          └─NESTED-LOOP JOIN       |        |1       |23          |
|7 |            ├─PX PARTITION ITERATOR|        |1       |7           |
|8 |            │ └─TABLE FULL SCAN    |t12     |1       |7           |
|9 |            └─DISTRIBUTED TABLE GET|t11     |1       |77          |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([v.c1]), filter(nil), rowset=16
      sort_keys([v.c1, ASC]), local merge sort
  1 - output([v.c1]), filter(nil), rowset=16
      access([v.c1])
  2 - output([t12.c1]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t12.c1]), filter(nil), rowset=16
  4 - output([t12.c1]), filter(nil), rowset=16
      dop=1
  5 - output([t12.c1]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t12.c1]), filter(nil), rowset=16
      conds(nil), nl_params_([t12.c1(:0)]), use_batch=true
  7 - output([t12.c1]), filter(nil), rowset=16
      force partition granule
  8 - output([t12.c1]), filter(nil), rowset=16
      access([t12.c1]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  9 - output(nil), filter(nil), rowset=16
      access([GROUP_ID]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1]), range(MIN ; MAX), 
      range_cond([t11.c1 = :0])
explain  select count(c1) from t11 group by c1 having c1 in (select t12.c1 from t12 where t11.c1=t12.c2);
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |1       |19          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|1       |19          |
|2 |  └─HASH JOIN                    |        |1       |18          |
|3 |    ├─EXCHANGE IN DISTR          |        |1       |12          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|1       |11          |
|5 |    │   └─PX PARTITION ITERATOR  |        |1       |11          |
|6 |    │     └─TABLE FULL SCAN      |t11     |1       |11          |
|7 |    └─PX PARTITION ITERATOR      |        |1       |7           |
|8 |      └─TABLE FULL SCAN          |t12     |1       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(CASE WHEN t11.c1 IS NOT NULL THEN 1 ELSE 0 END)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(CASE WHEN t11.c1 IS NOT NULL THEN 1 ELSE 0 END)]), filter(nil), rowset=16
      dop=1
  2 - output([t11.c1]), filter(nil), rowset=16
      equal_conds([t11.c1 = t12.c2]), other_conds(nil)
  3 - output([t11.c1]), filter(nil), rowset=16
  4 - output([t11.c1]), filter(nil), rowset=16
      (#keys=1, [t11.c1]), dop=1
  5 - output([t11.c1]), filter(nil), rowset=16
      force partition granule
  6 - output([t11.c1]), filter(nil), rowset=16
      access([t11.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1]), range(MIN ; MAX)always true
  7 - output([t12.c2]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t12.c2]), filter([t12.c2 = t12.c1]), rowset=16
      access([t12.c1], [t12.c2]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t12.c1]), range(MIN ; MAX)always true
explain  select * from t11 where c1 in (select c1 from t12 where (1 = 0 or c1 > 5));
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |1       |19          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|1       |19          |
|2 |  └─HASH JOIN                    |        |1       |18          |
|3 |    ├─EXCHANGE IN DISTR          |        |1       |7           |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|1       |7           |
|5 |    │   └─PX PARTITION ITERATOR  |        |1       |7           |
|6 |    │     └─TABLE RANGE SCAN     |t12     |1       |7           |
|7 |    └─PX PARTITION ITERATOR      |        |1       |11          |
|8 |      └─TABLE RANGE SCAN         |t11     |1       |11          |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t11.c1, t11.c2)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t11.c1, t11.c2)]), filter(nil), rowset=16
      dop=1
  2 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
      equal_conds([t11.c1 = t12.c1]), other_conds(nil)
  3 - output([t12.c1]), filter(nil), rowset=16
  4 - output([t12.c1]), filter(nil), rowset=16
      (#keys=1, [t12.c1]), dop=1
  5 - output([t12.c1]), filter(nil), rowset=16
      force partition granule
  6 - output([t12.c1]), filter(nil), rowset=16
      access([t12.c1]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t12.c1]), range(5 ; MAX), 
      range_cond([t12.c1 > 5])
  7 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t11.c1], [t11.c2]), filter(nil), rowset=16
      access([t11.c1], [t11.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1]), range(5 ; MAX), 
      range_cond([t11.c1 > 5])
create table t4 (c1 int, c2 int, c3 date, c4 int, primary key(c1,c2,c3)) partition by hash(c1) subpartition by range columns(c3)
subpartition template( subpartition p_2016_11_02_00 values less than ('2016-11-02'),
subpartition p_2016_11_03_00 values less than ('2016-11-03'),
subpartition p_max_value values less than (MAXVALUE));
create table t5(c1 int, c2 int, c3 date, c4 int, primary key(c1,c2,c3)) partition by hash(c1) subpartition by range columns(c3)
subpartition template( subpartition p_2016_11_02_00 values less than ('2016-11-02'),
subpartition p_2016_11_03_00 values less than ('2016-11-03'),
subpartition p_max_value values less than (MAXVALUE));
create table t6(c1 int, c2 int, c3 date, c4 int, primary key(c1,c2,c3)) partition by hash(c1) subpartition by range columns(c3)
subpartition template( subpartition p_2016_11_02_00 values less than ('2016-11-02'),
subpartition p_2016_11_03_00 values less than ('2016-11-03'),
subpartition p_max_value values less than (MAXVALUE));
explain  select /*+use_nl(t4 t5)*/ * from t4 left join t5 on t4.c2= t5.c2;
Query Plan
=================================================================
|ID|OPERATOR                     |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN       |        |1       |9           |
|1 |├─PX COORDINATOR             |        |1       |9           |
|2 |│ └─EXCHANGE OUT DISTR       |:EX10000|1       |8           |
|3 |│   └─PX PARTITION ITERATOR  |        |1       |7           |
|4 |│     └─TABLE FULL SCAN      |t4      |1       |7           |
|5 |└─MATERIAL                   |        |1       |9           |
|6 |  └─PX COORDINATOR           |        |1       |9           |
|7 |    └─EXCHANGE OUT DISTR     |:EX20000|1       |8           |
|8 |      └─PX PARTITION ITERATOR|        |1       |7           |
|9 |        └─TABLE FULL SCAN    |t5      |1       |7           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4], [t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      conds([t4.c2 = t5.c2]), nl_params_(nil), use_batch=false
  1 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
  2 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      dop=1
  3 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      force partition granule
  4 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
  6 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
  7 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      dop=1
  8 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      force partition granule
  9 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      access([t5.c1], [t5.c2], [t5.c3], [t5.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t5.c1], [t5.c2], [t5.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select /*+use_nl(t4 t5)*/ * from t4 left join t5 on t4.c1= t5.c1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |1       |58          |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|1       |56          |
|2 |  └─NESTED-LOOP OUTER JOIN        |        |1       |54          |
|3 |    ├─PX PARTITION ITERATOR       |        |1       |7           |
|4 |    │ └─TABLE FULL SCAN           |t4      |1       |7           |
|5 |    └─DISTRIBUTED TABLE RANGE SCAN|t5      |1       |46          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4], [t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([t4.c1(:0)]), use_batch=true
  3 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      force partition granule
  4 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      access([GROUP_ID], [t5.c1], [t5.c2], [t5.c3], [t5.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t5.c1], [t5.c2], [t5.c3]), range(MIN ; MAX), 
      range_cond([:0 = t5.c1])
explain  select /*+use_nl(t4 t5)*/ * from t4 join t5 on t4.c2= t5.c2 and t4.c3= t5.c3;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |PX COORDINATOR           |        |1       |11          |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|1       |10          |
|2 |  └─PX PARTITION ITERATOR|        |1       |7           |
|3 |    └─NESTED-LOOP JOIN   |        |1       |7           |
|4 |      ├─TABLE FULL SCAN  |t4      |1       |7           |
|5 |      └─MATERIAL         |        |1       |7           |
|6 |        └─TABLE FULL SCAN|t5      |1       |7           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([t4.c2], [t5.c2], [t4.c3], [t5.c3], [t4.c1], [t4.c4], [t5.c1], [t5.c4]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t4.c2], [t5.c2], [t4.c3], [t5.c3], [t4.c1], [t4.c4], [t5.c1], [t5.c4]), filter(nil), rowset=16
      conds([t4.c2 = t5.c2], [t4.c3 = t5.c3]), nl_params_(nil), use_batch=false
  4 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t5.c2], [t5.c3], [t5.c1], [t5.c4]), filter(nil), rowset=16
  6 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      access([t5.c1], [t5.c2], [t5.c3], [t5.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t5.c1], [t5.c2], [t5.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select * from t4 left join t5 on t4.c1= t5.c1 and t4.c3 = t5.c3;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |PX COORDINATOR           |        |1       |18          |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|1       |16          |
|2 |  └─PX PARTITION ITERATOR|        |1       |14          |
|3 |    └─HASH OUTER JOIN    |        |1       |14          |
|4 |      ├─TABLE FULL SCAN  |t4      |1       |7           |
|5 |      └─TABLE FULL SCAN  |t5      |1       |7           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([t4.c1], [t5.c1], [t4.c3], [t5.c3], [t4.c2], [t4.c4], [t5.c2], [t5.c4]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t4.c1], [t5.c1], [t4.c3], [t5.c3], [t4.c2], [t4.c4], [t5.c2], [t5.c4]), filter(nil), rowset=16
      equal_conds([t4.c1 = t5.c1], [t4.c3 = t5.c3]), other_conds(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      access([t5.c1], [t5.c2], [t5.c3], [t5.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t5.c1], [t5.c2], [t5.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select /*+use_nl(t4 t5)*/ * from t4 left join t5 on t4.c1= t5.c2 and t4.c3 = t5.c3;
Query Plan
=================================================================
|ID|OPERATOR                     |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |PX COORDINATOR               |        |1       |11          |
|1 |└─EXCHANGE OUT DISTR         |:EX10000|1       |10          |
|2 |  └─PX PARTITION ITERATOR    |        |1       |7           |
|3 |    └─NESTED-LOOP OUTER JOIN |        |1       |7           |
|4 |      ├─TABLE FULL SCAN      |t4      |1       |7           |
|5 |      └─MATERIAL             |        |1       |7           |
|6 |        └─TABLE FULL SCAN    |t5      |1       |7           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([t4.c1], [t5.c2], [t4.c3], [t5.c3], [t4.c2], [t4.c4], [t5.c1], [t5.c4]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t4.c1], [t5.c2], [t4.c3], [t5.c3], [t4.c2], [t4.c4], [t5.c1], [t5.c4]), filter(nil), rowset=16
      conds([t4.c1 = t5.c2], [t4.c3 = t5.c3]), nl_params_(nil), use_batch=false
  4 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t5.c2], [t5.c3], [t5.c1], [t5.c4]), filter(nil), rowset=16
  6 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      access([t5.c1], [t5.c2], [t5.c3], [t5.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t5.c1], [t5.c2], [t5.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select /*+use_nl(t4 t1)*/ * from t4 left join t1 on t4.c1= t1.c1 and t4.c3 = t1.c4;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR                     |        |1       |11          |
|1 |└─EXCHANGE OUT DISTR               |:EX10001|1       |10          |
|2 |  └─NESTED-LOOP OUTER JOIN         |        |1       |7           |
|3 |    ├─PX PARTITION ITERATOR        |        |1       |7           |
|4 |    │ └─TABLE FULL SCAN            |t4      |1       |7           |
|5 |    └─MATERIAL                     |        |1       |7           |
|6 |      └─EXCHANGE IN DISTR          |        |1       |7           |
|7 |        └─EXCHANGE OUT DISTR (PKEY)|:EX10000|1       |6           |
|8 |          └─PX PARTITION ITERATOR  |        |1       |5           |
|9 |            └─TABLE FULL SCAN      |t1      |1       |5           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t1.c1, t1.c2, t1.c3, t1.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t1.c1, t1.c2, t1.c3, t1.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([t4.c1], [t1.c1], [t4.c3], [t1.c4], [t4.c2], [t4.c4], [t1.c2], [t1.c3]), filter(nil), rowset=16
      conds([t4.c1 = t1.c1], [t4.c3 = t1.c4]), nl_params_(nil), use_batch=false
  3 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t1.c1], [t1.c4], [t1.c2], [t1.c3]), filter(nil), rowset=16
  6 - output([t1.c1], [t1.c4], [t1.c2], [t1.c3]), filter(nil), rowset=16
  7 - output([t1.c1], [t1.c4], [t1.c2], [t1.c3]), filter(nil), rowset=16
      (#keys=1, [t1.c4]), dop=1
  8 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      force partition granule
  9 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
explain  select /*+use_nl(t5 t4)*/ * from t5 left join t4 on t4.c1= t5.c2 and t4.c3 = t5.c3;
Query Plan
=================================================================
|ID|OPERATOR                     |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |PX COORDINATOR               |        |1       |27          |
|1 |└─EXCHANGE OUT DISTR         |:EX10000|1       |26          |
|2 |  └─PX PARTITION ITERATOR    |        |1       |23          |
|3 |    └─NESTED-LOOP OUTER JOIN |        |1       |23          |
|4 |      ├─TABLE FULL SCAN      |t5      |1       |7           |
|5 |      └─TABLE RANGE SCAN     |t4      |1       |46          |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t5.c4, t4.c1, t4.c2, t4.c3, t4.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t5.c4, t4.c1, t4.c2, t4.c3, t4.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1], [t5.c4], [t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t5.c2], [t5.c3], [t5.c1], [t5.c4], [t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([t5.c2(:0)], [t5.c3(:1)]), use_batch=true
  4 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      access([t5.c1], [t5.c2], [t5.c3], [t5.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t5.c1], [t5.c2], [t5.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter([t4.c3 = :1]), rowset=16
      access([GROUP_ID], [t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN ; MAX), 
      range_cond([t4.c1 = :0])
explain  select /*+use_nl(t1 t4)*/ * from t1 left join t4 on t4.c1= t1.c1 and t4.c3 = t1.c4;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |1       |25          |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|1       |24          |
|2 |  └─NESTED-LOOP OUTER JOIN        |        |1       |21          |
|3 |    ├─PX PARTITION ITERATOR       |        |1       |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |1       |5           |
|5 |    └─DISTRIBUTED TABLE RANGE SCAN|t4      |1       |46          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t4.c1, t4.c2, t4.c3, t4.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c3, t1.c4, t4.c1, t4.c2, t4.c3, t4.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c1], [t1.c4], [t1.c2], [t1.c3], [t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([t1.c1(:0)], [t1.c4(:1)]), use_batch=true
  3 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.c2], [t1.c3], [t1.c1], [t1.c4]), filter(nil), rowset=16
      access([t1.c2], [t1.c3], [t1.c1], [t1.c4]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c2], [t1.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter([t4.c3 = :1]), rowset=16
      access([GROUP_ID], [t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN ; MAX), 
      range_cond([t4.c1 = :0])
explain  select /*+use_nl(t4 t5)*/ * from t4 left join t5 on t4.c1= t5.c1 and t4.c3 = t5.c3;
Query Plan
=================================================================
|ID|OPERATOR                     |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |PX COORDINATOR               |        |1       |27          |
|1 |└─EXCHANGE OUT DISTR         |:EX10000|1       |26          |
|2 |  └─PX PARTITION ITERATOR    |        |1       |23          |
|3 |    └─NESTED-LOOP OUTER JOIN |        |1       |23          |
|4 |      ├─TABLE FULL SCAN      |t4      |1       |7           |
|5 |      └─TABLE RANGE SCAN     |t5      |1       |46          |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t4.c3, t4.c4, t5.c1, t5.c2, t5.c3, t5.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([t4.c1], [t4.c3], [t4.c2], [t4.c4], [t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t4.c1], [t4.c3], [t4.c2], [t4.c4], [t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([t4.c1(:0)], [t4.c3(:1)]), use_batch=true
  4 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t5.c1], [t5.c2], [t5.c3], [t5.c4]), filter([:1 = t5.c3]), rowset=16
      access([GROUP_ID], [t5.c1], [t5.c2], [t5.c3], [t5.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t5.c1], [t5.c2], [t5.c3]), range(MIN ; MAX), 
      range_cond([:0 = t5.c1])
explain  select  * from (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 1) as a join t5 as b on a.c1 = b.c1 and a.c3 = b.c3 join t6 as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
================================================================================
|ID|OPERATOR                                    |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------
|0 |PX COORDINATOR                              |        |1       |32          |
|1 |└─EXCHANGE OUT DISTR                        |:EX10002|1       |30          |
|2 |  └─HASH JOIN                               |        |1       |26          |
|3 |    ├─PX PARTITION ITERATOR                 |        |1       |7           |
|4 |    │ └─TABLE FULL SCAN                     |c       |1       |7           |
|5 |    └─HASH JOIN                             |        |1       |19          |
|6 |      ├─PX PARTITION ITERATOR               |        |1       |7           |
|7 |      │ └─TABLE FULL SCAN                   |b       |1       |7           |
|8 |      └─EXCHANGE IN DISTR                   |        |1       |12          |
|9 |        └─EXCHANGE OUT DISTR (PKEY)         |:EX10001|1       |11          |
|10|          └─SUBPLAN SCAN                    |a       |1       |10          |
|11|            └─LIMIT                         |        |1       |10          |
|12|              └─EXCHANGE IN MERGE SORT DISTR|        |1       |10          |
|13|                └─EXCHANGE OUT DISTR        |:EX10000|1       |9           |
|14|                  └─TOP-N SORT              |        |1       |7           |
|15|                    └─PX PARTITION ITERATOR |        |1       |7           |
|16|                      └─HASH GROUP BY       |        |1       |7           |
|17|                        └─TABLE FULL SCAN   |t4      |1       |7           |
================================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c1, a.c3, a.yyy, a.max(c4), b.c1, b.c2, b.c3, b.c4, c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(a.c1, a.c3, a.yyy, a.max(c4), b.c1, b.c2, b.c3, b.c4, c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([c.c1], [a.c1], [b.c3], [c.c3], [c.c2], [c.c4], [b.c1], [a.c3], [b.c2], [b.c4], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      equal_conds([c.c1 = a.c1], [b.c3 = c.c3]), other_conds(nil)
  3 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      affinitize, partition wise, force partition granule
  4 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      access([c.c1], [c.c2], [c.c3], [c.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([c.c1], [c.c2], [c.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([a.c1], [b.c3], [b.c1], [a.c3], [b.c2], [b.c4], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1], [a.c3 = b.c3]), other_conds(nil)
  6 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      affinitize, partition wise, force partition granule
  7 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([b.c1], [b.c2], [b.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  8 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
  9 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      (#keys=1, [a.c3]), is_single, dop=1
 10 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      access([a.c1], [a.c3], [a.yyy], [a.max(c4)])
 11 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(1), offset(nil)
 12 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
 13 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
 14 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(1)
 15 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
 16 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
 17 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select  * from t5 as a join (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 1) as b on a.c1 = b.c1 and a.c3 = b.c3 join t6 as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |HASH JOIN                        |        |1       |27          |
|1 |├─SUBPLAN SCAN                   |b       |1       |10          |
|2 |│ └─LIMIT                        |        |1       |10          |
|3 |│   └─PX COORDINATOR MERGE SORT  |        |1       |10          |
|4 |│     └─EXCHANGE OUT DISTR       |:EX10000|1       |9           |
|5 |│       └─TOP-N SORT             |        |1       |7           |
|6 |│         └─PX PARTITION ITERATOR|        |1       |7           |
|7 |│           └─HASH GROUP BY      |        |1       |7           |
|8 |│             └─TABLE FULL SCAN  |t4      |1       |7           |
|9 |└─HASH JOIN                      |        |1       |18          |
|10|  ├─PX COORDINATOR               |        |1       |9           |
|11|  │ └─EXCHANGE OUT DISTR         |:EX20000|1       |8           |
|12|  │   └─PX PARTITION ITERATOR    |        |1       |7           |
|13|  │     └─TABLE FULL SCAN        |a       |1       |7           |
|14|  └─PX COORDINATOR               |        |1       |9           |
|15|    └─EXCHANGE OUT DISTR         |:EX30000|1       |8           |
|16|      └─PX PARTITION ITERATOR    |        |1       |7           |
|17|        └─TABLE FULL SCAN        |c       |1       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [a.c4], [b.c1], [b.c3], [b.yyy], [b.max(c4)], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      equal_conds([b.c1 = c.c1], [b.c3 = c.c3], [a.c3 = b.c3]), other_conds(nil)
  1 - output([b.c1], [b.c3], [b.yyy], [b.max(c4)]), filter(nil), rowset=16
      access([b.c1], [b.c3], [b.yyy], [b.max(c4)])
  2 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
  4 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
  5 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(1)
  6 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
  7 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
  8 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  9 - output([a.c1], [a.c2], [a.c3], [a.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      equal_conds([c.c1 = a.c1]), other_conds(nil)
 10 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
 11 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      dop=1
 12 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      force partition granule
 13 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      access([a.c1], [a.c2], [a.c3], [a.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([a.c1], [a.c2], [a.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 14 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
 15 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      dop=1
 16 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      force partition granule
 17 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      access([c.c1], [c.c2], [c.c3], [c.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([c.c1], [c.c2], [c.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select  * from t5 as a join t6 as b on a.c1 = b.c1 and a.c3 = b.c3 join (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 1) as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
================================================================================
|ID|OPERATOR                                    |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------
|0 |PX COORDINATOR                              |        |1       |32          |
|1 |└─EXCHANGE OUT DISTR                        |:EX10002|1       |30          |
|2 |  └─HASH JOIN                               |        |1       |26          |
|3 |    ├─PX PARTITION ITERATOR                 |        |1       |7           |
|4 |    │ └─TABLE FULL SCAN                     |a       |1       |7           |
|5 |    └─HASH JOIN                             |        |1       |19          |
|6 |      ├─PX PARTITION ITERATOR               |        |1       |7           |
|7 |      │ └─TABLE FULL SCAN                   |b       |1       |7           |
|8 |      └─EXCHANGE IN DISTR                   |        |1       |12          |
|9 |        └─EXCHANGE OUT DISTR (PKEY)         |:EX10001|1       |11          |
|10|          └─SUBPLAN SCAN                    |c       |1       |10          |
|11|            └─LIMIT                         |        |1       |10          |
|12|              └─EXCHANGE IN MERGE SORT DISTR|        |1       |10          |
|13|                └─EXCHANGE OUT DISTR        |:EX10000|1       |9           |
|14|                  └─TOP-N SORT              |        |1       |7           |
|15|                    └─PX PARTITION ITERATOR |        |1       |7           |
|16|                      └─HASH GROUP BY       |        |1       |7           |
|17|                        └─TABLE FULL SCAN   |t4      |1       |7           |
================================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c2, b.c3, b.c4, c.c1, c.c3, c.yyy, c.max(c4))]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c2, b.c3, b.c4, c.c1, c.c3, c.yyy, c.max(c4))]), filter(nil), rowset=16
      dop=1
  2 - output([a.c1], [b.c1], [a.c3], [b.c3], [a.c2], [a.c4], [c.c1], [c.c3], [b.c2], [b.c4], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1], [a.c3 = b.c3]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      affinitize, partition wise, force partition granule
  4 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      access([a.c1], [a.c2], [a.c3], [a.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([a.c1], [a.c2], [a.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([b.c1], [b.c3], [c.c1], [c.c3], [b.c2], [b.c4], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
      equal_conds([b.c1 = c.c1], [b.c3 = c.c3]), other_conds(nil)
  6 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      affinitize, partition wise, force partition granule
  7 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([b.c1], [b.c2], [b.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  8 - output([c.c1], [c.c3], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
  9 - output([c.c1], [c.c3], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
      (#keys=1, [c.c3]), is_single, dop=1
 10 - output([c.c1], [c.c3], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
      access([c.c1], [c.c3], [c.yyy], [c.max(c4)])
 11 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(1), offset(nil)
 12 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
 13 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
 14 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(1)
 15 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
 16 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
 17 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select /*+use_nl(a b) use_nl(b c)*/ * from (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 1) as a join t5 as b on a.c1 = b.c1 and a.c3 = b.c3 join t6 as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
==============================================================================
|ID|OPERATOR                                  |NAME    |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |PX COORDINATOR                            |        |1       |41          |
|1 |└─EXCHANGE OUT DISTR                      |:EX10002|1       |39          |
|2 |  └─HASH JOIN                             |        |1       |35          |
|3 |    ├─EXCHANGE IN DISTR                   |        |1       |12          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)         |:EX10001|1       |11          |
|5 |    │   └─SUBPLAN SCAN                    |a       |1       |10          |
|6 |    │     └─LIMIT                         |        |1       |10          |
|7 |    │       └─EXCHANGE IN MERGE SORT DISTR|        |1       |10          |
|8 |    │         └─EXCHANGE OUT DISTR        |:EX10000|1       |9           |
|9 |    │           └─TOP-N SORT              |        |1       |7           |
|10|    │             └─PX PARTITION ITERATOR |        |1       |7           |
|11|    │               └─HASH GROUP BY       |        |1       |7           |
|12|    │                 └─TABLE FULL SCAN   |t4      |1       |7           |
|13|    └─PX PARTITION ITERATOR               |        |1       |23          |
|14|      └─NESTED-LOOP JOIN                  |        |1       |23          |
|15|        ├─TABLE FULL SCAN                 |b       |1       |7           |
|16|        └─TABLE RANGE SCAN                |c       |1       |46          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c1, a.c3, a.yyy, a.max(c4), b.c1, b.c2, b.c3, b.c4, c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(a.c1, a.c3, a.yyy, a.max(c4), b.c1, b.c2, b.c3, b.c4, c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([a.c1], [b.c1], [a.c3], [b.c3], [a.yyy], [a.max(c4)], [b.c2], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1], [a.c3 = b.c3]), other_conds(nil)
  3 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
  4 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      (#keys=1, [a.c3]), is_single, dop=1
  5 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      access([a.c1], [a.c3], [a.yyy], [a.max(c4)])
  6 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(1), offset(nil)
  7 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
  8 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
  9 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(1)
 10 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
 11 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
 12 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 13 - output([b.c1], [b.c3], [b.c2], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      affinitize, partition wise, force partition granule
 14 - output([b.c1], [b.c3], [b.c2], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([b.c1(:0)], [b.c3(:1)]), use_batch=true
 15 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([b.c1], [b.c2], [b.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 16 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter([:1 = c.c3]), rowset=16
      access([GROUP_ID], [c.c1], [c.c2], [c.c3], [c.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([c.c1], [c.c2], [c.c3]), range(MIN ; MAX), 
      range_cond([:0 = c.c1])
explain  select /*+use_nl(a b) use_nl(b c)*/ * from t5 as a join (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 1) as b on a.c1 = b.c1 and a.c3 = b.c3 join t6 as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
==============================================================================
|ID|OPERATOR                                  |NAME    |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |PX COORDINATOR                            |        |1       |72          |
|1 |└─EXCHANGE OUT DISTR                      |:EX10002|1       |70          |
|2 |  └─HASH JOIN                             |        |1       |66          |
|3 |    ├─EXCHANGE IN DISTR                   |        |1       |12          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)         |:EX10001|1       |11          |
|5 |    │   └─SUBPLAN SCAN                    |b       |1       |10          |
|6 |    │     └─LIMIT                         |        |1       |10          |
|7 |    │       └─EXCHANGE IN MERGE SORT DISTR|        |1       |10          |
|8 |    │         └─EXCHANGE OUT DISTR        |:EX10000|1       |9           |
|9 |    │           └─TOP-N SORT              |        |1       |7           |
|10|    │             └─PX PARTITION ITERATOR |        |1       |7           |
|11|    │               └─HASH GROUP BY       |        |1       |7           |
|12|    │                 └─TABLE FULL SCAN   |t4      |1       |7           |
|13|    └─NESTED-LOOP JOIN                    |        |1       |54          |
|14|      ├─PX PARTITION ITERATOR             |        |1       |7           |
|15|      │ └─TABLE FULL SCAN                 |a       |1       |7           |
|16|      └─DISTRIBUTED TABLE RANGE SCAN      |c       |1       |46          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c3, b.yyy, b.max(c4), c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c3, b.yyy, b.max(c4), c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([b.c1], [c.c1], [b.c3], [c.c3], [a.c3], [b.yyy], [b.max(c4)], [a.c1], [a.c2], [a.c4], [c.c2], [c.c4]), filter(nil), rowset=16
      equal_conds([b.c1 = c.c1], [b.c3 = c.c3], [a.c3 = b.c3]), other_conds(nil)
  3 - output([b.c1], [b.c3], [b.yyy], [b.max(c4)]), filter(nil), rowset=16
  4 - output([b.c1], [b.c3], [b.yyy], [b.max(c4)]), filter(nil), rowset=16
      (#keys=1, [b.c3]), is_single, dop=1
  5 - output([b.c1], [b.c3], [b.yyy], [b.max(c4)]), filter(nil), rowset=16
      access([b.c1], [b.c3], [b.yyy], [b.max(c4)])
  6 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(1), offset(nil)
  7 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
  8 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
  9 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(1)
 10 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
 11 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
 12 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 13 - output([c.c1], [c.c3], [a.c3], [a.c1], [a.c2], [a.c4], [c.c2], [c.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([a.c1(:0)]), use_batch=true
 14 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      affinitize, force partition granule
 15 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      access([a.c1], [a.c2], [a.c3], [a.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([a.c1], [a.c2], [a.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 16 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      access([GROUP_ID], [c.c1], [c.c2], [c.c3], [c.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([c.c1], [c.c2], [c.c3]), range(MIN ; MAX), 
      range_cond([c.c1 = :0])
explain  select /*+use_nl(a b) use_nl(b c)*/ * from t5 as a join t6 as b on a.c1 = b.c1 and a.c3 = b.c3 join (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 1) as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
==============================================================================
|ID|OPERATOR                                  |NAME    |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |PX COORDINATOR                            |        |1       |41          |
|1 |└─EXCHANGE OUT DISTR                      |:EX10002|1       |39          |
|2 |  └─HASH JOIN                             |        |1       |35          |
|3 |    ├─EXCHANGE IN DISTR                   |        |1       |12          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)         |:EX10001|1       |11          |
|5 |    │   └─SUBPLAN SCAN                    |c       |1       |10          |
|6 |    │     └─LIMIT                         |        |1       |10          |
|7 |    │       └─EXCHANGE IN MERGE SORT DISTR|        |1       |10          |
|8 |    │         └─EXCHANGE OUT DISTR        |:EX10000|1       |9           |
|9 |    │           └─TOP-N SORT              |        |1       |7           |
|10|    │             └─PX PARTITION ITERATOR |        |1       |7           |
|11|    │               └─HASH GROUP BY       |        |1       |7           |
|12|    │                 └─TABLE FULL SCAN   |t4      |1       |7           |
|13|    └─PX PARTITION ITERATOR               |        |1       |23          |
|14|      └─NESTED-LOOP JOIN                  |        |1       |23          |
|15|        ├─TABLE FULL SCAN                 |a       |1       |7           |
|16|        └─TABLE RANGE SCAN                |b       |1       |46          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c2, b.c3, b.c4, c.c1, c.c3, c.yyy, c.max(c4))]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c2, b.c3, b.c4, c.c1, c.c3, c.yyy, c.max(c4))]), filter(nil), rowset=16
      dop=1
  2 - output([c.c1], [a.c1], [b.c3], [c.c3], [c.yyy], [c.max(c4)], [a.c3], [a.c2], [a.c4], [b.c1], [b.c2], [b.c4]), filter(nil), rowset=16
      equal_conds([c.c1 = a.c1], [b.c3 = c.c3]), other_conds(nil)
  3 - output([c.c1], [c.c3], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
  4 - output([c.c1], [c.c3], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
      (#keys=1, [c.c3]), is_single, dop=1
  5 - output([c.c1], [c.c3], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
      access([c.c1], [c.c3], [c.yyy], [c.max(c4)])
  6 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(1), offset(nil)
  7 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
  8 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
  9 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(1)
 10 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
 11 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
 12 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 13 - output([a.c1], [b.c3], [a.c3], [a.c2], [a.c4], [b.c1], [b.c2], [b.c4]), filter(nil), rowset=16
      affinitize, partition wise, force partition granule
 14 - output([a.c1], [b.c3], [a.c3], [a.c2], [a.c4], [b.c1], [b.c2], [b.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([a.c1(:0)], [a.c3(:1)]), use_batch=true
 15 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      access([a.c1], [a.c2], [a.c3], [a.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([a.c1], [a.c2], [a.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 16 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([:1 = b.c3]), rowset=16
      access([GROUP_ID], [b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.c1], [b.c2], [b.c3]), range(MIN ; MAX), 
      range_cond([:0 = b.c1])
explain  select /*+use_nl(a b) use_nl(b c)*/ * from (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 2) as a left join t5 as b on a.c1 = b.c1 and a.c3 = b.c3  left join t6 as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
==============================================================================
|ID|OPERATOR                                  |NAME    |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |PX COORDINATOR                            |        |1       |41          |
|1 |└─EXCHANGE OUT DISTR                      |:EX10002|1       |39          |
|2 |  └─HASH OUTER JOIN                       |        |1       |35          |
|3 |    ├─EXCHANGE IN DISTR                   |        |1       |12          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)         |:EX10001|1       |11          |
|5 |    │   └─SUBPLAN SCAN                    |a       |1       |10          |
|6 |    │     └─LIMIT                         |        |1       |10          |
|7 |    │       └─EXCHANGE IN MERGE SORT DISTR|        |1       |10          |
|8 |    │         └─EXCHANGE OUT DISTR        |:EX10000|1       |9           |
|9 |    │           └─TOP-N SORT              |        |1       |7           |
|10|    │             └─PX PARTITION ITERATOR |        |1       |7           |
|11|    │               └─HASH GROUP BY       |        |1       |7           |
|12|    │                 └─TABLE FULL SCAN   |t4      |1       |7           |
|13|    └─PX PARTITION ITERATOR               |        |1       |23          |
|14|      └─NESTED-LOOP OUTER JOIN            |        |1       |23          |
|15|        ├─TABLE FULL SCAN                 |b       |1       |7           |
|16|        └─TABLE RANGE SCAN                |c       |1       |46          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c1, a.c3, a.yyy, a.max(c4), b.c1, b.c2, b.c3, b.c4, c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(a.c1, a.c3, a.yyy, a.max(c4), b.c1, b.c2, b.c3, b.c4, c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([a.c1], [b.c1], [a.c3], [b.c3], [a.yyy], [a.max(c4)], [b.c2], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1], [a.c3 = b.c3]), other_conds(nil)
  3 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
  4 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      (#keys=1, [a.c3]), is_single, dop=1
  5 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      access([a.c1], [a.c3], [a.yyy], [a.max(c4)])
  6 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(2), offset(nil)
  7 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
  8 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
  9 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(2)
 10 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
 11 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
 12 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 13 - output([b.c1], [b.c3], [b.c2], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      affinitize, partition wise, force partition granule
 14 - output([b.c1], [b.c3], [b.c2], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([b.c1(:0)], [b.c3(:1)]), use_batch=true
 15 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([b.c1], [b.c2], [b.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 16 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter([:1 = c.c3]), rowset=16
      access([GROUP_ID], [c.c1], [c.c2], [c.c3], [c.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([c.c1], [c.c2], [c.c3]), range(MIN ; MAX), 
      range_cond([:0 = c.c1])
explain  select /*+use_nl(a b) use_nl(b c)*/ * from t5 as a left join (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 1) as b on a.c1 = b.c1 and a.c3 = b.c3 left join t6 as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
================================================================================
|ID|OPERATOR                                    |NAME    |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------------
|0 |PX COORDINATOR                              |        |1       |74          |
|1 |└─EXCHANGE OUT DISTR                        |:EX10002|1       |72          |
|2 |  └─HASH OUTER JOIN                         |        |1       |68          |
|3 |    ├─PX PARTITION ITERATOR                 |        |1       |7           |
|4 |    │ └─TABLE FULL SCAN                     |a       |1       |7           |
|5 |    └─EXCHANGE IN DISTR                     |        |1       |61          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)           |:EX10001|1       |60          |
|7 |        └─NESTED-LOOP OUTER JOIN            |        |1       |57          |
|8 |          ├─SUBPLAN SCAN                    |b       |1       |10          |
|9 |          │ └─LIMIT                         |        |1       |10          |
|10|          │   └─EXCHANGE IN MERGE SORT DISTR|        |1       |10          |
|11|          │     └─EXCHANGE OUT DISTR        |:EX10000|1       |9           |
|12|          │       └─TOP-N SORT              |        |1       |7           |
|13|          │         └─PX PARTITION ITERATOR |        |1       |7           |
|14|          │           └─HASH GROUP BY       |        |1       |7           |
|15|          │             └─TABLE FULL SCAN   |t4      |1       |7           |
|16|          └─DISTRIBUTED TABLE RANGE SCAN    |c       |1       |46          |
================================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c3, b.yyy, b.max(c4), c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c3, b.yyy, b.max(c4), c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([a.c1], [b.c1], [a.c3], [b.c3], [a.c2], [a.c4], [b.yyy], [b.max(c4)], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1], [a.c3 = b.c3]), other_conds(nil)
  3 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      access([a.c1], [a.c2], [a.c3], [a.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([a.c1], [a.c2], [a.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([b.c1], [b.c3], [b.yyy], [b.max(c4)], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
  6 - output([b.c1], [b.c3], [b.yyy], [b.max(c4)], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      (#keys=1, [b.c3]), is_single, dop=1
  7 - output([b.c1], [b.c3], [b.yyy], [b.max(c4)], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([b.c1(:0)], [b.c3(:1)]), use_batch=true
  8 - output([b.c1], [b.c3], [b.yyy], [b.max(c4)]), filter(nil), rowset=16
      access([b.c1], [b.c3], [b.yyy], [b.max(c4)])
  9 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(1), offset(nil)
 10 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
 11 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
 12 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(1)
 13 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
 14 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
 15 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 16 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter([:1 = c.c3]), rowset=16
      access([GROUP_ID], [c.c1], [c.c2], [c.c3], [c.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([c.c1], [c.c2], [c.c3]), range(MIN ; MAX), 
      range_cond([:0 = c.c1])
explain  select /*+use_nl(a b) use_nl(b c)*/ * from t5 as a left join t6 as b on a.c1 = b.c1 and a.c3 = b.c3 left join (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 1) as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |HASH RIGHT OUTER JOIN            |        |1       |37          |
|1 |├─SUBPLAN SCAN                   |c       |1       |10          |
|2 |│ └─LIMIT                        |        |1       |10          |
|3 |│   └─PX COORDINATOR MERGE SORT  |        |1       |10          |
|4 |│     └─EXCHANGE OUT DISTR       |:EX10000|1       |9           |
|5 |│       └─TOP-N SORT             |        |1       |7           |
|6 |│         └─PX PARTITION ITERATOR|        |1       |7           |
|7 |│           └─HASH GROUP BY      |        |1       |7           |
|8 |│             └─TABLE FULL SCAN  |t4      |1       |7           |
|9 |└─PX COORDINATOR                 |        |1       |27          |
|10|  └─EXCHANGE OUT DISTR           |:EX20000|1       |26          |
|11|    └─PX PARTITION ITERATOR      |        |1       |23          |
|12|      └─NESTED-LOOP OUTER JOIN   |        |1       |23          |
|13|        ├─TABLE FULL SCAN        |a       |1       |7           |
|14|        └─TABLE RANGE SCAN       |b       |1       |46          |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [a.c3], [a.c4], [b.c1], [b.c2], [b.c3], [b.c4], [c.c1], [c.c3], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
      equal_conds([b.c1 = c.c1], [b.c3 = c.c3]), other_conds(nil)
  1 - output([c.c1], [c.c3], [c.yyy], [c.max(c4)]), filter(nil), rowset=16
      access([c.c1], [c.c3], [c.yyy], [c.max(c4)])
  2 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
  4 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
  5 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(1)
  6 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
  7 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
  8 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  9 - output([a.c1], [a.c2], [a.c3], [a.c4], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
 10 - output([a.c1], [a.c2], [a.c3], [a.c4], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      dop=1
 11 - output([a.c1], [a.c2], [a.c3], [a.c4], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      partition wise, force partition granule
 12 - output([a.c1], [a.c2], [a.c3], [a.c4], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      conds(nil), nl_params_([a.c1(:0)], [a.c3(:1)]), use_batch=true
 13 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      access([a.c1], [a.c2], [a.c3], [a.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([a.c1], [a.c2], [a.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 14 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([:1 = b.c3]), rowset=16
      access([GROUP_ID], [b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.c1], [b.c2], [b.c3]), range(MIN ; MAX), 
      range_cond([:0 = b.c1])
explain  select /*+use_nl(c)*/ * from t5 as a left join t6 as b on a.c1 = b.c1 and a.c3 = b.c3 left join t4 as c on b.c1=c.c1 and b.c3 = c.c3;
Query Plan
================================================================
|ID|OPERATOR                    |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------
|0 |PX COORDINATOR              |        |1       |26          |
|1 |└─EXCHANGE OUT DISTR        |:EX10000|1       |25          |
|2 |  └─PX PARTITION ITERATOR   |        |1       |20          |
|3 |    └─HASH RIGHT OUTER JOIN |        |1       |20          |
|4 |      ├─TABLE FULL SCAN     |c       |1       |7           |
|5 |      └─HASH OUTER JOIN     |        |1       |14          |
|6 |        ├─TABLE FULL SCAN   |a       |1       |7           |
|7 |        └─TABLE FULL SCAN   |b       |1       |7           |
================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c2, b.c3, b.c4, c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(a.c1, a.c2, a.c3, a.c4, b.c1, b.c2, b.c3, b.c4, c.c1, c.c2, c.c3, c.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([b.c1], [c.c1], [b.c3], [c.c3], [c.c2], [c.c4], [a.c1], [a.c3], [a.c2], [a.c4], [b.c2], [b.c4]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([b.c1], [c.c1], [b.c3], [c.c3], [c.c2], [c.c4], [a.c1], [a.c3], [a.c2], [a.c4], [b.c2], [b.c4]), filter(nil), rowset=16
      equal_conds([b.c1 = c.c1], [b.c3 = c.c3]), other_conds(nil)
  4 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      access([c.c1], [c.c2], [c.c3], [c.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([c.c1], [c.c2], [c.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([b.c1], [b.c3], [a.c1], [a.c3], [a.c2], [a.c4], [b.c2], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1], [a.c3 = b.c3]), other_conds(nil)
  6 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      access([a.c1], [a.c2], [a.c3], [a.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([a.c1], [a.c2], [a.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([b.c1], [b.c2], [b.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select /*+use_nl(c)*/ * from t5 as a left join t6 as b on a.c1 = b.c1 and a.c3 = b.c3 left join t4 as c on b.c1=c.c1 and b.c3 = c.c3 limit 100;
Query Plan
===================================================================================
|ID|OPERATOR                                       |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                                          |        |1       |30          |
|1 |└─PX COORDINATOR                               |        |1       |30          |
|2 |  └─EXCHANGE OUT DISTR                         |:EX10002|1       |29          |
|3 |    └─LIMIT                                    |        |1       |24          |
|4 |      └─HASH RIGHT OUTER JOIN                  |        |1       |24          |
|5 |        ├─PX PARTITION ITERATOR                |        |1       |7           |
|6 |        │ └─TABLE FULL SCAN                    |c       |1       |7           |
|7 |        └─HASH OUTER JOIN                      |        |1       |18          |
|8 |          ├─EXCHANGE IN DISTR                  |        |1       |11          |
|9 |          │ └─EXCHANGE OUT DISTR (PKEY)        |:EX10001|1       |10          |
|10|          │   └─SUBPLAN SCAN                   |VIEW1   |1       |9           |
|11|          │     └─LIMIT                        |        |1       |9           |
|12|          │       └─EXCHANGE IN DISTR          |        |1       |9           |
|13|          │         └─EXCHANGE OUT DISTR       |:EX10000|1       |8           |
|14|          │           └─LIMIT                  |        |1       |7           |
|15|          │             └─PX PARTITION ITERATOR|        |1       |7           |
|16|          │               └─TABLE FULL SCAN    |a       |1       |7           |
|17|          └─PX PARTITION ITERATOR              |        |1       |7           |
|18|            └─TABLE FULL SCAN                  |b       |1       |7           |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([VIEW1.a.c1], [VIEW1.a.c2], [VIEW1.a.c3], [VIEW1.a.c4], [b.c1], [b.c2], [b.c3], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      limit(100), offset(nil)
  1 - output([VIEW1.a.c1], [VIEW1.a.c2], [VIEW1.a.c3], [VIEW1.a.c4], [b.c1], [b.c2], [b.c3], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
  2 - output([VIEW1.a.c1], [VIEW1.a.c2], [VIEW1.a.c3], [VIEW1.a.c4], [b.c1], [b.c2], [b.c3], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      dop=1
  3 - output([VIEW1.a.c1], [VIEW1.a.c2], [VIEW1.a.c3], [VIEW1.a.c4], [b.c1], [b.c2], [b.c3], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      limit(100), offset(nil)
  4 - output([VIEW1.a.c1], [VIEW1.a.c2], [VIEW1.a.c3], [VIEW1.a.c4], [b.c1], [b.c2], [b.c3], [b.c4], [c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      equal_conds([b.c1 = c.c1], [b.c3 = c.c3]), other_conds(nil)
  5 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      affinitize, partition wise, force partition granule
  6 - output([c.c1], [c.c2], [c.c3], [c.c4]), filter(nil), rowset=16
      access([c.c1], [c.c2], [c.c3], [c.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([c.c1], [c.c2], [c.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([VIEW1.a.c1], [VIEW1.a.c2], [VIEW1.a.c3], [VIEW1.a.c4], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([VIEW1.a.c1 = b.c1], [VIEW1.a.c3 = b.c3]), other_conds(nil)
  8 - output([VIEW1.a.c1], [VIEW1.a.c2], [VIEW1.a.c3], [VIEW1.a.c4]), filter(nil), rowset=16
  9 - output([VIEW1.a.c1], [VIEW1.a.c2], [VIEW1.a.c3], [VIEW1.a.c4]), filter(nil), rowset=16
      (#keys=1, [VIEW1.a.c3]), is_single, dop=1
 10 - output([VIEW1.a.c1], [VIEW1.a.c3], [VIEW1.a.c2], [VIEW1.a.c4]), filter(nil), rowset=16
      access([VIEW1.a.c1], [VIEW1.a.c3], [VIEW1.a.c2], [VIEW1.a.c4])
 11 - output([a.c1], [a.c3], [a.c2], [a.c4]), filter(nil), rowset=16
      limit(100), offset(nil)
 12 - output([a.c1], [a.c3], [a.c2], [a.c4]), filter(nil), rowset=16
 13 - output([a.c1], [a.c3], [a.c2], [a.c4]), filter(nil), rowset=16
      dop=1
 14 - output([a.c1], [a.c3], [a.c2], [a.c4]), filter(nil), rowset=16
      limit(100), offset(nil)
 15 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      force partition granule
 16 - output([a.c1], [a.c2], [a.c3], [a.c4]), filter(nil), rowset=16
      access([a.c1], [a.c2], [a.c3], [a.c4]), partitions(p0sp[0-2])
      limit(100), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([a.c1], [a.c2], [a.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
 17 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      affinitize, partition wise, force partition granule
 18 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([b.c1], [b.c2], [b.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain  select /*+use_bnl(a b)*/ * from (select c1, c3, sum(c2) as yyy, max(c4) from t4 group by c3 order by yyy limit 2) as a left join t5 as b on a.c1 = b.c1 and a.c3 = b.c3 ;
Query Plan
==============================================================================
|ID|OPERATOR                                  |NAME    |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |PX COORDINATOR                            |        |1       |23          |
|1 |└─EXCHANGE OUT DISTR                      |:EX10002|1       |22          |
|2 |  └─HASH RIGHT OUTER JOIN                 |        |1       |19          |
|3 |    ├─PX PARTITION ITERATOR               |        |1       |7           |
|4 |    │ └─TABLE FULL SCAN                   |b       |1       |7           |
|5 |    └─EXCHANGE IN DISTR                   |        |1       |12          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)         |:EX10001|1       |11          |
|7 |        └─SUBPLAN SCAN                    |a       |1       |10          |
|8 |          └─LIMIT                         |        |1       |10          |
|9 |            └─EXCHANGE IN MERGE SORT DISTR|        |1       |10          |
|10|              └─EXCHANGE OUT DISTR        |:EX10000|1       |9           |
|11|                └─TOP-N SORT              |        |1       |7           |
|12|                  └─PX PARTITION ITERATOR |        |1       |7           |
|13|                    └─HASH GROUP BY       |        |1       |7           |
|14|                      └─TABLE FULL SCAN   |t4      |1       |7           |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c1, a.c3, a.yyy, a.max(c4), b.c1, b.c2, b.c3, b.c4)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(a.c1, a.c3, a.yyy, a.max(c4), b.c1, b.c2, b.c3, b.c4)]), filter(nil), rowset=16
      dop=1
  2 - output([a.c1], [b.c1], [a.c3], [b.c3], [b.c2], [b.c4], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1], [a.c3 = b.c3]), other_conds(nil)
  3 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([b.c1], [b.c2], [b.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
  6 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      (#keys=1, [a.c3]), is_single, dop=1
  7 - output([a.c1], [a.c3], [a.yyy], [a.max(c4)]), filter(nil), rowset=16
      access([a.c1], [a.c3], [a.yyy], [a.max(c4)])
  8 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      limit(2), offset(nil)
  9 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC])
 10 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      dop=1
 11 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      sort_keys([T_FUN_SUM(t4.c2), ASC]), topn(2)
 12 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      partition wise, force partition granule
 13 - output([t4.c1], [t4.c3], [T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)]), filter(nil), rowset=16
      group([t4.c3]), agg_func([T_FUN_SUM(t4.c2)], [T_FUN_MAX(t4.c4)])
 14 - output([t4.c1], [t4.c2], [t4.c3], [t4.c4]), filter(nil), rowset=16
      access([t4.c1], [t4.c2], [t4.c3], [t4.c4]), partitions(p0sp[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t4.c1], [t4.c2], [t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
drop database yy;
