drop database if exists hualong;
create database hualong;
use hualong;
create table t1 (pk1 int primary key, a int, b int, c int, d int,
key idx_a(a),
key idx_b(b),
key idx_c(c),
key idx_a_b(a, b),
key idx_b_c(b, c),
key idx_c_a(c, a),
key idx_a_b_c(a, b, c),
key idx_b_c_a(b, c, a),
key idx_c_a_b(c, a, b));
create table t2 (pk2 int primary key, x int, y int, z int,
key idx_x_y_z(x, y, z));
create table t3 (pk1 int primary key, a int, b int, c int, d int,
key idx_a(a),
key idx_b(b),
key idx_c(c),
key idx_a_b(a, b),
key idx_b_c(b, c),
key idx_c_a(c, a),
key idx_a_b_c(a, b, c) storing (d),
key idx_b_c_a(b, c, a) storing (d),
key idx_c_a_b(c, a, b) storing (d));
create table t4 (
a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ',
index idx_t1_0 (a1),
index idx_t1_1 (a1,a2,b,c),
index idx_t1_2 (a1,a2,b));
create table t5 (pk int primary key, v1 int, v2 int, index idx_v1(v1), index idx_v2(v2));
create table t6 (pk int primary key, a int, b int, c int, d int, e int,
index idx_b_c(b, c),
index idx_b_a_c(b, a, c),
index idx_b_e_d_c_a(b, e, d, c, a));
create table t7(a int, b int, c int, d int, e int, f int, key k1(a,c,b), key k2(a,b,c,d,e));
create table t8(a int primary key, b int, c int, d int, e int, f int, index k1(b,c,e), index k2(c,d,e,f));
create table tmp (pk int primary key, c1 int, c2 int, c3 int, c4 int, c5 int,
index idx_c1_c2(c1, c2),
index idx_c1_c2_c3(c1, c2 ,c3),
index idx_c1_c2_c3_c4(c1, c2, c3, c4));
create table t9 (c1 int primary key, c2 int, c3 int, c4 varchar(100), c5 int,
index idx_c2_c5    (c2, c5),
index idx_c2_c3_c5 (c2, c3, c5),
index idx_c4_c5    (c4, c5),
index idx_c4_c3_c5 (c4, c3, c5));
explain select b from t1;
Query Plan
====================================================
|ID|OPERATOR       |NAME     |EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |TABLE FULL SCAN|t1(idx_b)|1       |3           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b]), filter(nil), rowset=16
      access([t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(MIN,MIN ; MAX,MAX)always true
explain select b,c from t1;
Query Plan
======================================================
|ID|OPERATOR       |NAME       |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE FULL SCAN|t1(idx_b_c)|1       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select * from t1;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|t1  |1       |3           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.pk1]), range(MIN ; MAX)always true
explain select b from t1 group by b;
Query Plan
======================================================
|ID|OPERATOR         |NAME     |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |MERGE DISTINCT   |         |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b)|1       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b]), filter(nil), rowset=16
      distinct([t1.b])
  1 - output([t1.b]), filter(nil), rowset=16
      access([t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(MIN,MIN ; MAX,MAX)always true
explain select b, c from t1 group by b,c;
Query Plan
========================================================
|ID|OPERATOR         |NAME       |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |MERGE DISTINCT   |           |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c)|1       |3           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.c])
  1 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select a, b, c from t1 group by b,c;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE GROUP BY   |             |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select b, c from t1 group by c,b;
Query Plan
========================================================
|ID|OPERATOR         |NAME       |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |MERGE DISTINCT   |           |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c)|1       |3           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.c])
  1 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select a, b, c from t1 group by c,b;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE GROUP BY   |             |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select * from t1 where b = 100 group by c,b limit 100;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |LIMIT               |           |1       |8           |
|1 |└─MERGE GROUP BY    |           |1       |8           |
|2 |  └─TABLE RANGE SCAN|t1(idx_b_c)|1       |7           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      limit(100), offset(nil)
  1 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      group([t1.c]), agg_func(nil)
  2 - output([t1.pk1], [t1.b], [t1.a], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.b], [t1.a], [t1.c], [t1.d]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(100,MIN,MIN ; 100,MAX,MAX), 
      range_cond([t1.b = 100])
explain select distinct(b) from t1;
Query Plan
======================================================
|ID|OPERATOR         |NAME     |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |MERGE DISTINCT   |         |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b)|1       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b]), filter(nil), rowset=16
      distinct([t1.b])
  1 - output([t1.b]), filter(nil), rowset=16
      access([t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(MIN,MIN ; MAX,MAX)always true
explain select distinct(b),c from t1;
Query Plan
========================================================
|ID|OPERATOR         |NAME       |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |MERGE DISTINCT   |           |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c)|1       |3           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.c])
  1 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select distinct(b),c from t1 where a > 100;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |HASH DISTINCT     |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t1(idx_a_b_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.c])
  1 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b], [t1.c], [t1.pk1]), range(100,MAX,MAX,MAX ; MAX,MAX,MAX,MAX), 
      range_cond([t1.a > 100])
explain select distinct(c),b from t1;
Query Plan
========================================================
|ID|OPERATOR         |NAME       |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |MERGE DISTINCT   |           |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c)|1       |3           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c], [t1.b]), filter(nil), rowset=16
      distinct([t1.b], [t1.c])
  1 - output([t1.c], [t1.b]), filter(nil), rowset=16
      access([t1.c], [t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select distinct(c),b, d from t1 where b > 200 limit 100;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |LIMIT               |           |1       |8           |
|1 |└─HASH DISTINCT     |           |1       |8           |
|2 |  └─TABLE RANGE SCAN|t1(idx_b_c)|1       |7           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c], [t1.b], [t1.d]), filter(nil), rowset=16
      limit(100), offset(nil)
  1 - output([t1.c], [t1.b], [t1.d]), filter(nil), rowset=16
      distinct([t1.c], [t1.b], [t1.d])
  2 - output([t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.b], [t1.c], [t1.d]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(200,MAX,MAX ; MAX,MAX,MAX), 
      range_cond([t1.b > 200])
explain select b from t1 order by b;
Query Plan
====================================================
|ID|OPERATOR       |NAME     |EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |TABLE FULL SCAN|t1(idx_b)|1       |3           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b]), filter(nil), rowset=16
      access([t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(MIN,MIN ; MAX,MAX)always true
explain select b, c from t1 order by b, c;
Query Plan
======================================================
|ID|OPERATOR       |NAME       |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE FULL SCAN|t1(idx_b_c)|1       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select a, b, c from t1 order by b, c, a;
Query Plan
========================================================
|ID|OPERATOR       |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c, d from t1 where b in (100, 200) order by b, c, a limit 100;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c_a)|1       |12          |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.b], [t1.a], [t1.c], [t1.d]), partitions(p0)
      limit(100), offset(nil), is_index_back=true, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MIN,MIN,MIN ; 100,MAX,MAX,MAX), (200,MIN,MIN,MIN ; 200,MAX,MAX,MAX), 
      range_cond([t1.b IN (100, 200)])
explain select b from t1 where b = 100;
Query Plan
=====================================================
|ID|OPERATOR        |NAME     |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b)|1       |3           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b]), filter(nil), rowset=16
      access([t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(100,MIN ; 100,MAX), 
      range_cond([t1.b = 100])
explain select b, c from t1 where b = 100;
Query Plan
=======================================================
|ID|OPERATOR        |NAME       |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c)|1       |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(100,MIN,MIN ; 100,MAX,MAX), 
      range_cond([t1.b = 100])
explain select b, c, a from t1 where b = 100;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MIN,MIN,MIN ; 100,MAX,MAX,MAX), 
      range_cond([t1.b = 100])
explain select * from t1 where b = 100 limit 100;
Query Plan
=====================================================
|ID|OPERATOR        |NAME     |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b)|1       |7           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.b], [t1.a], [t1.c], [t1.d]), partitions(p0)
      limit(100), offset(nil), is_index_back=true, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(100,MIN ; 100,MAX), 
      range_cond([t1.b = 100])
explain select b, c from t1 where b = 100 and c = 200;
Query Plan
=======================================================
|ID|OPERATOR        |NAME       |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c)|1       |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(100,200,MIN ; 100,200,MAX), 
      range_cond([t1.b = 100], [t1.c = 200])
explain select b, c from t1 where b = 100 or c = 200;
Query Plan
======================================================
|ID|OPERATOR       |NAME       |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE FULL SCAN|t1(idx_b_c)|1       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter([t1.b = 100 OR t1.c = 200]), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select b, c from t1 where b + c = 100;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|t1  |1       |3           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter([t1.b + t1.c = 100]), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.pk1]), range(MIN ; MAX)always true
explain select b from t1 where b in (1, 2, 3);
Query Plan
=====================================================
|ID|OPERATOR        |NAME     |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b)|1       |7           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b]), filter(nil), rowset=16
      access([t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(1,MIN ; 1,MAX), (2,MIN ; 2,MAX), (3,MIN ; 3,MAX), 
      range_cond([t1.b IN (1, 2, 3)])
explain select b, c from t1 where b in (1, 2, 3);
Query Plan
=======================================================
|ID|OPERATOR        |NAME       |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c)|1       |7           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(1,MIN,MIN ; 1,MAX,MAX), (2,MIN,MIN ; 2,MAX,MAX), (3,MIN,MIN ; 3,MAX,MAX), 
      range_cond([t1.b IN (1, 2, 3)])
explain select b, c, a from t1 where b in (1, 2, 3);
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c_a)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), (2,MIN,MIN,MIN ; 2,MAX,MAX,MAX), (3,MIN,MIN,MIN ; 3,MAX,MAX,MAX),
       
      range_cond([t1.b IN (1, 2, 3)])
explain select * from t1 where b in (1, 2, 3) limit 100;
Query Plan
=====================================================
|ID|OPERATOR        |NAME     |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b)|1       |16          |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.b], [t1.a], [t1.c], [t1.d]), partitions(p0)
      limit(100), offset(nil), is_index_back=true, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(1,MIN ; 1,MAX), (2,MIN ; 2,MAX), (3,MIN ; 3,MAX), 
      range_cond([t1.b IN (1, 2, 3)])
explain select b from t1 where b < 100;
Query Plan
=====================================================
|ID|OPERATOR        |NAME     |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b)|1       |3           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b]), filter(nil), rowset=16
      access([t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(NULL,MAX ; 100,MIN), 
      range_cond([t1.b < 100])
explain select b, c from t1 where b < 100;
Query Plan
=======================================================
|ID|OPERATOR        |NAME       |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c)|1       |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(NULL,MAX,MAX ; 100,MIN,MIN), 
      range_cond([t1.b < 100])
explain select b, c, a from t1 where b < 100;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(NULL,MAX,MAX,MAX ; 100,MIN,MIN,MIN), 
      range_cond([t1.b < 100])
explain select * from t1 where b < 100 limit 100;
Query Plan
=====================================================
|ID|OPERATOR        |NAME     |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b)|1       |7           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.b], [t1.a], [t1.c], [t1.d]), partitions(p0)
      limit(100), offset(nil), is_index_back=true, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(NULL,MAX ; 100,MIN), 
      range_cond([t1.b < 100])
explain select b from t1 where b > 0 and b < 100;
Query Plan
=====================================================
|ID|OPERATOR        |NAME     |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b)|1       |3           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b]), filter(nil), rowset=16
      access([t1.b]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(0,MAX ; 100,MIN), 
      range_cond([t1.b > 0], [t1.b < 100])
explain select b, c from t1 where b > 0 and b < 100;
Query Plan
=======================================================
|ID|OPERATOR        |NAME       |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c)|1       |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(0,MAX,MAX ; 100,MIN,MIN), 
      range_cond([t1.b > 0], [t1.b < 100])
explain select b, c, a from t1 where b > 0 and b < 100;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(0,MAX,MAX,MAX ; 100,MIN,MIN,MIN), 
      range_cond([t1.b > 0], [t1.b < 100])
explain select * from t1 where b > 0 and b < 100 limit 100;
Query Plan
=====================================================
|ID|OPERATOR        |NAME     |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b)|1       |7           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.b], [t1.a], [t1.c], [t1.d]), partitions(p0)
      limit(100), offset(nil), is_index_back=true, is_global_index=false, 
      range_key([t1.b], [t1.pk1]), range(0,MAX ; 100,MIN), 
      range_cond([t1.b > 0], [t1.b < 100])
explain select b, c from t1 where b = 100 and c > 0 and c < 100;
Query Plan
=======================================================
|ID|OPERATOR        |NAME       |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c)|1       |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(100,0,MAX ; 100,100,MIN), 
      range_cond([t1.b = 100], [t1.c > 0], [t1.c < 100])
explain select * from t1 where b = 100 and c > 0 and c < 100 limit 100;
Query Plan
=======================================================
|ID|OPERATOR        |NAME       |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c)|1       |7           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.b], [t1.c], [t1.a], [t1.d]), partitions(p0)
      limit(100), offset(nil), is_index_back=true, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.pk1]), range(100,0,MAX ; 100,100,MIN), 
      range_cond([t1.b = 100], [t1.c > 0], [t1.c < 100])
explain select a, b, c from t1 where b = 100 and a > 0 and a < 100 and c > 100;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a > 0], [t1.a < 100]), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,100,MAX,MAX ; 100,MAX,MAX,MAX), 
      range_cond([t1.b = 100], [t1.c > 100])
explain select a, b, c from t1 where b = 100 and a > 0 and a < 100 and c = 200;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,200,0,MAX ; 100,200,100,MIN), 
      range_cond([t1.b = 100], [t1.a > 0], [t1.a < 100], [t1.c = 200])
explain select a, b, c from t1 where b = 100 or c = 100 or a = 100 group by c, b;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE GROUP BY   |             |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  1 - output([t1.b], [t1.c], [t1.a]), filter([(T_OP_OR, t1.b = 100, t1.c = 100, t1.a = 100)]), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 where b in (100, 200, 300) or c in (100, 200, 300) or a in (100, 200, 300) group by c, b;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE GROUP BY   |             |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  1 - output([t1.b], [t1.c], [t1.a]), filter([(T_OP_OR, t1.b IN (100, 200, 300), t1.c IN (100, 200, 300), t1.a IN (100, 200, 300))]), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 where (b > 100 or b < 200) or (c > 100 or c < 200) or (c > 100 or c < 200) group by c, b;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE GROUP BY   |             |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  1 - output([t1.b], [t1.c], [t1.a]), filter([(T_OP_OR, t1.b > 100, t1.b < 200, t1.c > 100, t1.c < 200)]), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c, d from t1 where b = 100 and a > 0 and a < 100 and c = 200 limit 100;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c_a)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.b], [t1.a], [t1.c], [t1.d]), partitions(p0)
      limit(100), offset(nil), is_index_back=true, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,200,0,MAX ; 100,200,100,MIN), 
      range_cond([t1.b = 100], [t1.a > 0], [t1.a < 100], [t1.c = 200])
explain select * from t1 join t2 on t1.pk1 = t2.pk2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |MERGE JOIN       |    |1       |5           |
|1 |├─TABLE FULL SCAN|t2  |1       |3           |
|2 |└─TABLE FULL SCAN|t1  |1       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d], [t2.pk2], [t2.x], [t2.y], [t2.z]), filter(nil), rowset=16
      equal_conds([t1.pk1 = t2.pk2]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.pk2], [t2.x], [t2.y], [t2.z]), filter(nil), rowset=16
      access([t2.pk2], [t2.x], [t2.y], [t2.z]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX)always true
  2 - output([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), filter(nil), rowset=16
      access([t1.pk1], [t1.a], [t1.b], [t1.c], [t1.d]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.pk1]), range(MIN ; MAX)always true
explain select a, b, c from t1 join t2 on t1.b = t2.x;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE JOIN       |             |1       |5           |
|1 |├─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
|2 |└─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.x]), filter(nil), rowset=16
      access([t2.x]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 join t2 where t1.b = t2.x;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE JOIN       |             |1       |5           |
|1 |├─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
|2 |└─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.x]), filter(nil), rowset=16
      access([t2.x]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 join t2 on t1.b = t2.x and t1.c = t2.y;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE JOIN       |             |1       |5           |
|1 |├─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
|2 |└─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x], [t1.c = t2.y]), other_conds(nil)
      merge_directions([ASC], [ASC])
  1 - output([t2.x], [t2.y]), filter(nil), rowset=16
      access([t2.x], [t2.y]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 join t2 where t1.b = t2.x and t1.c = t2.y;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE JOIN       |             |1       |5           |
|1 |├─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
|2 |└─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x], [t1.c = t2.y]), other_conds(nil)
      merge_directions([ASC], [ASC])
  1 - output([t2.x], [t2.y]), filter(nil), rowset=16
      access([t2.x], [t2.y]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 join t2 on t1.b = t2.x and t1.c = t2.y and t1.a = t2.z;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE JOIN       |             |1       |5           |
|1 |├─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
|2 |└─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x], [t1.c = t2.y], [t1.a = t2.z]), other_conds(nil)
      merge_directions([ASC], [ASC], [ASC])
  1 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t2.x], [t2.y], [t2.z]), filter(nil), rowset=16
      access([t2.x], [t2.y], [t2.z]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 join t2 where t1.b = t2.x and t1.c = t2.y and t1.a = t2.z;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE JOIN       |             |1       |5           |
|1 |├─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
|2 |└─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x], [t1.c = t2.y], [t1.a = t2.z]), other_conds(nil)
      merge_directions([ASC], [ASC], [ASC])
  1 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t2.x], [t2.y], [t2.z]), filter(nil), rowset=16
      access([t2.x], [t2.y], [t2.z]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select t.a, t.b, t.c from t1 as t join t1 as tt join t1 as ttt on t.b = tt.c and t.c = tt.a and ttt.c > 100;
Query Plan
===================================================================
|ID|OPERATOR                   |NAME        |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |            |1       |5           |
|1 |├─MERGE JOIN               |            |1       |5           |
|2 |│ ├─TABLE FULL SCAN        |tt(idx_c_a) |1       |3           |
|3 |│ └─TABLE FULL SCAN        |t(idx_b_c_a)|1       |3           |
|4 |└─MATERIAL                 |            |1       |3           |
|5 |  └─TABLE RANGE SCAN       |ttt(idx_c)  |1       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([t.a], [t.b], [t.c]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([t.a], [t.b], [t.c]), filter(nil), rowset=16
      equal_conds([t.b = tt.c], [t.c = tt.a]), other_conds(nil)
      merge_directions([ASC], [ASC])
  2 - output([tt.c], [tt.a]), filter(nil), rowset=16
      access([tt.c], [tt.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt.c], [tt.a], [tt.pk1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  3 - output([t.b], [t.c], [t.a]), filter(nil), rowset=16
      access([t.b], [t.c], [t.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t.b], [t.c], [t.a], [t.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  4 - output(nil), filter(nil), rowset=16
  5 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([ttt.c], [ttt.pk1]), range(100,MAX ; MAX,MAX), 
      range_cond([ttt.c > 100])
explain select a, b, c from t1 left join t2 on t1.b = t2.x order by b, c;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE OUTER JOIN |             |1       |5           |
|1 |├─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
|2 |└─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t2.x]), filter(nil), rowset=16
      access([t2.x]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t2 left join t1 on t1.b = t2.x order by b, c;
Query Plan
============================================================
|ID|OPERATOR           |NAME         |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |SORT               |             |1       |5           |
|1 |└─MERGE OUTER JOIN |             |1       |5           |
|2 |  ├─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
|3 |  └─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      sort_keys([t1.b, ASC], [t1.c, ASC])
  1 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x]), other_conds(nil)
      merge_directions([ASC])
  2 - output([t2.x]), filter(nil), rowset=16
      access([t2.x]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  3 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 union select x, y, z from t2;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE FULL SCAN   |t1(idx_a_b_c)|1       |3           |
|2 |└─TABLE FULL SCAN   |t2(idx_x_y_z)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t2.x], [t2.y], [t2.z]), filter(nil), rowset=16
      access([t2.x], [t2.y], [t2.z]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain (select a, b, c from t1 order by c, b, a )union select x, y, z from t2;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE FULL SCAN   |t1(idx_a_b_c)|1       |3           |
|2 |└─TABLE FULL SCAN   |t2(idx_x_y_z)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t2.x], [t2.y], [t2.z]), filter(nil), rowset=16
      access([t2.x], [t2.y], [t2.z]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select b, c, a from t1 where b > 100 union select x, y, z from t2 where x > 100;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE RANGE SCAN  |t1(idx_b_c_a)|1       |3           |
|2 |└─TABLE RANGE SCAN  |t2(idx_x_y_z)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MAX,MAX,MAX ; MAX,MAX,MAX,MAX), 
      range_cond([t1.b > 100])
  2 - output([t2.x], [t2.y], [t2.z]), filter(nil), rowset=16
      access([t2.x], [t2.y], [t2.z]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(100,MAX,MAX,MAX ; MAX,MAX,MAX,MAX), 
      range_cond([t2.x > 100])
explain select b, c, a from t1 where b > 100 and b < 200 union select x, y, z from t2 where x > 100 and x < 200;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE RANGE SCAN  |t1(idx_b_c_a)|1       |3           |
|2 |└─TABLE RANGE SCAN  |t2(idx_x_y_z)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MAX,MAX,MAX ; 200,MIN,MIN,MIN), 
      range_cond([t1.b > 100], [t1.b < 200])
  2 - output([t2.x], [t2.y], [t2.z]), filter(nil), rowset=16
      access([t2.x], [t2.y], [t2.z]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(100,MAX,MAX,MAX ; 200,MIN,MIN,MIN), 
      range_cond([t2.x > 100], [t2.x < 200])
explain select a, b, c from t1 where b = 100 group by c;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE GROUP BY    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.c]), agg_func(nil)
  1 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MIN,MIN,MIN ; 100,MAX,MAX,MAX), 
      range_cond([t1.b = 100])
explain select a, b, c from t1 where b > 100 and b < 200 group by c, b;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE GROUP BY    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  1 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MAX,MAX,MAX ; 200,MIN,MIN,MIN), 
      range_cond([t1.b > 100], [t1.b < 200])
explain select a, b, c from t1 where b > 100 and b < 200 group by c, b having sum(c) > 1000;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE GROUP BY    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([T_FUN_SUM(t1.c) > cast(1000, DECIMAL_INT(33, 0))]), rowset=16
      group([t1.b], [t1.c]), agg_func([T_FUN_SUM(t1.c)])
  1 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MAX,MAX,MAX ; 200,MIN,MIN,MIN), 
      range_cond([t1.b > 100], [t1.b < 200])
explain select distinct a, b, c from t1 where b = 100 order by b;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.c], [t1.a])
  1 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MIN,MIN,MIN ; 100,MAX,MAX,MAX), 
      range_cond([t1.b = 100])
explain select distinct a, b, c from t1 where (b > 100 and b < 200) or (a < 200 and a > 100) order by b desc;
Query Plan
==================================================================
|ID|OPERATOR         |NAME                 |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------
|0 |MERGE DISTINCT   |                     |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c_a,Reverse)|1       |3           |
==================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.c], [t1.a])
  1 - output([t1.b], [t1.a], [t1.c]), filter([t1.b > 100 AND t1.b < 200 OR t1.a < 200 AND t1.a > 100]), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select distinct a, b, c from t1 where b = 100 or c = 200 order by b desc, c desc;
Query Plan
==================================================================
|ID|OPERATOR         |NAME                 |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------
|0 |MERGE DISTINCT   |                     |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c_a,Reverse)|1       |3           |
==================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.c], [t1.a])
  1 - output([t1.b], [t1.c], [t1.a]), filter([t1.b = 100 OR t1.c = 200]), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select /*+index(t1 idx_b_c)*/ distinct a, b, c from t1 where b = 100 or c = 200 order by b desc, c desc;
Query Plan
==================================================================
|ID|OPERATOR           |NAME               |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------
|0 |MERGE DISTINCT     |                   |1       |8           |
|1 |└─SORT             |                   |1       |8           |
|2 |  └─TABLE FULL SCAN|t1(idx_b_c,Reverse)|1       |7           |
==================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.c], [t1.a])
  1 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      sort_keys([t1.b, DESC], [t1.c, DESC], [t1.a, ASC]), prefix_pos(2)
  2 - output([t1.b], [t1.c], [t1.a]), filter([t1.b = 100 OR t1.c = 200]), rowset=16
      access([t1.pk1], [t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[true], 
      range_key([t1.b], [t1.c], [t1.pk1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select /*+index(t1 idx_b_c_a)*/ distinct a, b, c from t1 where b = 100 or c = 200 order by b desc, c desc;
Query Plan
==================================================================
|ID|OPERATOR         |NAME                 |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------
|0 |MERGE DISTINCT   |                     |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c_a,Reverse)|1       |3           |
==================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.c], [t1.a])
  1 - output([t1.b], [t1.c], [t1.a]), filter([t1.b = 100 OR t1.c = 200]), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select distinct a, b, c from t1 where b in (100, 200) or c in (200, 400) order by b desc, c desc;
Query Plan
==================================================================
|ID|OPERATOR         |NAME                 |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------
|0 |MERGE DISTINCT   |                     |1       |3           |
|1 |└─TABLE FULL SCAN|t1(idx_b_c_a,Reverse)|1       |3           |
==================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      distinct([t1.b], [t1.c], [t1.a])
  1 - output([t1.b], [t1.c], [t1.a]), filter([t1.b IN (100, 200) OR t1.c IN (200, 400)]), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select distinct b, c, a from t1 where b > 100 and b < 200 and c > 100 and a > 100 order by b, c;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t1(idx_b_c_a)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      distinct([t1.b], [t1.c], [t1.a])
  1 - output([t1.b], [t1.c], [t1.a]), filter([t1.c > 100], [t1.a > 100]), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MAX,MAX,MAX ; 200,MIN,MIN,MIN), 
      range_cond([t1.b > 100], [t1.b < 200])
explain select distinct a, b, c from t1 group by c, b order by c;
Query Plan
============================================================
|ID|OPERATOR           |NAME         |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |SORT               |             |1       |3           |
|1 |└─MERGE GROUP BY   |             |1       |3           |
|2 |  └─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      sort_keys([t1.c, ASC])
  1 - output([t1.c], [t1.a], [t1.b]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select distinct a, b, c from t1 join t2 where t1.b = t2.x and t1.c = t2.y group by c, b order by b, c;
Query Plan
============================================================
|ID|OPERATOR           |NAME         |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |MERGE GROUP BY     |             |1       |5           |
|1 |└─MERGE JOIN       |             |1       |5           |
|2 |  ├─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
|3 |  └─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  1 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x], [t1.c = t2.y]), other_conds(nil)
      merge_directions([ASC], [ASC])
  2 - output([t2.x], [t2.y]), filter(nil), rowset=16
      access([t2.x], [t2.y]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 join t2 on t1.b != t2.x group by c, b;
Query Plan
==============================================================
|ID|OPERATOR             |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE GROUP BY       |             |1       |3           |
|1 |└─NESTED-LOOP JOIN   |             |1       |3           |
|2 |  ├─TABLE FULL SCAN  |t1(idx_b_c_a)|1       |3           |
|3 |  └─MATERIAL         |             |1       |3           |
|4 |    └─TABLE FULL SCAN|t2           |1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  1 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      conds([t1.b != t2.x]), nl_params_(nil), use_batch=false
  2 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  3 - output([t2.x]), filter(nil), rowset=16
  4 - output([t2.x]), filter(nil), rowset=16
      access([t2.x]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX)always true
explain select a, b, c from t1 join t2 on t1.b = t2.x and t1.c = t2.y group by c, b;
Query Plan
============================================================
|ID|OPERATOR           |NAME         |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |MERGE GROUP BY     |             |1       |5           |
|1 |└─MERGE JOIN       |             |1       |5           |
|2 |  ├─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
|3 |  └─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      group([t1.b], [t1.c]), agg_func(nil)
  1 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x], [t1.c = t2.y]), other_conds(nil)
      merge_directions([ASC], [ASC])
  2 - output([t2.x], [t2.y]), filter(nil), rowset=16
      access([t2.x], [t2.y]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a, b, c from t1 join t2 on t1.b = t2.x order by b, c;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE JOIN       |             |1       |5           |
|1 |├─TABLE FULL SCAN|t1(idx_b_c_a)|1       |3           |
|2 |└─TABLE FULL SCAN|t2(idx_x_y_z)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([t1.b = t2.x]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t1.b], [t1.a], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.a], [t1.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t2.x]), filter(nil), rowset=16
      access([t2.x]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a,b,c from t3 where d in (select pk2 from t2) group by a,b;
Query Plan
==============================================================
|ID|OPERATOR             |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |HASH GROUP BY        |             |1       |5           |
|1 |└─MERGE JOIN         |             |1       |5           |
|2 |  ├─TABLE FULL SCAN  |t2           |1       |3           |
|3 |  └─SORT             |             |1       |3           |
|4 |    └─TABLE FULL SCAN|t3(idx_a_b_c)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      group([t3.a], [t3.b]), agg_func(nil)
  1 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      equal_conds([t3.d = t2.pk2]), other_conds(nil)
      merge_directions([ASC])
  2 - output([t2.pk2]), filter(nil), rowset=16
      access([t2.pk2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX)always true
  3 - output([t3.a], [t3.b], [t3.c], [t3.d]), filter(nil), rowset=16
      sort_keys([t3.d, ASC])
  4 - output([t3.d], [t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      access([t3.d], [t3.a], [t3.b], [t3.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t3.a], [t3.b], [t3.c], [t3.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a,b,c from t3 where d not in (select pk2 from t2) group by a,b;
Query Plan
===================================================================
|ID|OPERATOR                  |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |HASH GROUP BY             |             |1       |5           |
|1 |└─HASH RIGHT ANTI JOIN SNA|             |1       |5           |
|2 |  ├─TABLE FULL SCAN       |t2           |1       |3           |
|3 |  └─TABLE FULL SCAN       |t3(idx_a_b_c)|1       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      group([t3.a], [t3.b]), agg_func(nil)
  1 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      equal_conds([t3.d = t2.pk2]), other_conds(nil)
  2 - output([t2.pk2]), filter(nil), rowset=16
      access([t2.pk2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX)always true
  3 - output([t3.d], [t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      access([t3.d], [t3.a], [t3.b], [t3.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t3.a], [t3.b], [t3.c], [t3.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a,b,c from t3 where d in (select pk2 from t2) order by a,b;
Query Plan
==============================================================
|ID|OPERATOR             |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |SORT                 |             |1       |5           |
|1 |└─MERGE JOIN         |             |1       |5           |
|2 |  ├─TABLE FULL SCAN  |t2           |1       |3           |
|3 |  └─SORT             |             |1       |3           |
|4 |    └─TABLE FULL SCAN|t3(idx_a_b_c)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      sort_keys([t3.a, ASC], [t3.b, ASC])
  1 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      equal_conds([t3.d = t2.pk2]), other_conds(nil)
      merge_directions([ASC])
  2 - output([t2.pk2]), filter(nil), rowset=16
      access([t2.pk2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX)always true
  3 - output([t3.a], [t3.b], [t3.c], [t3.d]), filter(nil), rowset=16
      sort_keys([t3.d, ASC])
  4 - output([t3.d], [t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      access([t3.d], [t3.a], [t3.b], [t3.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t3.a], [t3.b], [t3.c], [t3.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a,b,c from t3 where d not in (select pk2 from t2) order by a,b;
Query Plan
===================================================================
|ID|OPERATOR                  |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                      |             |1       |5           |
|1 |└─HASH RIGHT ANTI JOIN SNA|             |1       |5           |
|2 |  ├─TABLE FULL SCAN       |t2           |1       |3           |
|3 |  └─TABLE FULL SCAN       |t3(idx_a_b_c)|1       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      sort_keys([t3.a, ASC], [t3.b, ASC])
  1 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      equal_conds([t3.d = t2.pk2]), other_conds(nil)
  2 - output([t2.pk2]), filter(nil), rowset=16
      access([t2.pk2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX)always true
  3 - output([t3.d], [t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      access([t3.d], [t3.a], [t3.b], [t3.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t3.a], [t3.b], [t3.c], [t3.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select distinct a,b,c from t3 where d in (select pk2 from t2);
Query Plan
==============================================================
|ID|OPERATOR             |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |HASH DISTINCT        |             |1       |5           |
|1 |└─MERGE JOIN         |             |1       |5           |
|2 |  ├─TABLE FULL SCAN  |t2           |1       |3           |
|3 |  └─SORT             |             |1       |3           |
|4 |    └─TABLE FULL SCAN|t3(idx_a_b_c)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      distinct([t3.a], [t3.b], [t3.c])
  1 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      equal_conds([t3.d = t2.pk2]), other_conds(nil)
      merge_directions([ASC])
  2 - output([t2.pk2]), filter(nil), rowset=16
      access([t2.pk2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX)always true
  3 - output([t3.a], [t3.b], [t3.c], [t3.d]), filter(nil), rowset=16
      sort_keys([t3.d, ASC])
  4 - output([t3.d], [t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      access([t3.d], [t3.a], [t3.b], [t3.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t3.a], [t3.b], [t3.c], [t3.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select distinct a,b,c from t3 where d not in (select pk2 from t2);
Query Plan
===================================================================
|ID|OPERATOR                  |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |HASH DISTINCT             |             |1       |5           |
|1 |└─HASH RIGHT ANTI JOIN SNA|             |1       |5           |
|2 |  ├─TABLE FULL SCAN       |t2           |1       |3           |
|3 |  └─TABLE FULL SCAN       |t3(idx_a_b_c)|1       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      distinct([t3.a], [t3.b], [t3.c])
  1 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      equal_conds([t3.d = t2.pk2]), other_conds(nil)
  2 - output([t2.pk2]), filter(nil), rowset=16
      access([t2.pk2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX)always true
  3 - output([t3.d], [t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      access([t3.d], [t3.a], [t3.b], [t3.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t3.a], [t3.b], [t3.c], [t3.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select distinct a,b,c from t3 where d in (select pk2 from t2) union select x,y,z from t2;
Query Plan
================================================================
|ID|OPERATOR               |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------
|0 |MERGE UNION DISTINCT   |             |2       |7           |
|1 |├─TABLE FULL SCAN      |t2(idx_x_y_z)|1       |3           |
|2 |└─SORT                 |             |1       |5           |
|3 |  └─MERGE JOIN         |             |1       |5           |
|4 |    ├─TABLE FULL SCAN  |t2           |1       |3           |
|5 |    └─SORT             |             |1       |3           |
|6 |      └─TABLE FULL SCAN|t3(idx_a_b_c)|1       |3           |
================================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([t2.x], [t2.y], [t2.z]), filter(nil), rowset=16
      access([t2.x], [t2.y], [t2.z]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.x], [t2.y], [t2.z], [t2.pk2]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      sort_keys([t3.a, ASC], [t3.b, ASC], [t3.c, ASC])
  3 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      equal_conds([t3.d = t2.pk2]), other_conds(nil)
      merge_directions([ASC])
  4 - output([t2.pk2]), filter(nil), rowset=16
      access([t2.pk2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX)always true
  5 - output([t3.a], [t3.b], [t3.c], [t3.d]), filter(nil), rowset=16
      sort_keys([t3.d, ASC])
  6 - output([t3.d], [t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      access([t3.d], [t3.a], [t3.b], [t3.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t3.a], [t3.b], [t3.c], [t3.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select distinct a,b,c from t3 where d > any (select pk2 from t2);
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE DISTINCT      |             |1       |19          |
|1 |└─NESTED-LOOP JOIN  |             |1       |19          |
|2 |  ├─TABLE FULL SCAN |t3(idx_a_b_c)|1       |3           |
|3 |  └─TABLE RANGE SCAN|t2           |1       |16          |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      distinct([t3.a], [t3.b], [t3.c])
  1 - output([t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      conds(nil), nl_params_([t3.d(:0)]), use_batch=true
  2 - output([t3.d], [t3.a], [t3.b], [t3.c]), filter(nil), rowset=16
      access([t3.d], [t3.a], [t3.b], [t3.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t3.a], [t3.b], [t3.c], [t3.pk1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  3 - output(nil), filter(nil), rowset=16
      access([GROUP_ID]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.pk2]), range(MIN ; MAX), 
      range_cond([:0 > t2.pk2])
explain select a, b, c from t1 where b = 100 and c < 100 and c > 100 order by c desc limit 0, 100;
Query Plan
=================================================================
|ID|OPERATOR        |NAME                 |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |TABLE RANGE SCAN|t1(idx_b_c_a,Reverse)|0       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      limit(100), offset(0), is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(MAX,MAX,MAX,MAX ; MIN,MIN,MIN,MIN)always false, 
      range_cond([t1.b = 100], [t1.c < 100], [t1.c > 100])
explain select a, b, c from t1 where b = 100 or (b = 200 and c = 300) order by c desc limit 0, 100;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |LIMIT               |             |1       |5           |
|1 |└─TOP-N SORT        |             |1       |5           |
|2 |  └─TABLE RANGE SCAN|t1(idx_b_c_a)|1       |5           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      limit(100), offset(0)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      sort_keys([t1.c, DESC]), topn(100 + 0)
  2 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MIN,MIN,MIN ; 100,MAX,MAX,MAX), (200,300,MIN,MIN ; 200,300,MAX,MAX), 
      range_cond([t1.b = 100 OR t1.b = 200 AND t1.c = 300])
explain select a, b, c from t1 where (b = 200 and c = 300) or (b = 100) order by c desc limit 0, 100;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |LIMIT               |             |1       |5           |
|1 |└─TOP-N SORT        |             |1       |5           |
|2 |  └─TABLE RANGE SCAN|t1(idx_b_c_a)|1       |5           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      limit(100), offset(0)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      sort_keys([t1.c, DESC]), topn(100 + 0)
  2 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c], [t1.a], [t1.pk1]), range(100,MIN,MIN,MIN ; 100,MAX,MAX,MAX), (200,300,MIN,MIN ; 200,300,MAX,MAX), 
      range_cond([t1.b = 200 AND t1.c = 300 OR t1.b = 100])
explain select a1, a2, b, min(c), max(c) from t4 group by a1, a2, b;
Query Plan
=========================================================
|ID|OPERATOR         |NAME        |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |MERGE GROUP BY   |            |1       |3           |
|1 |└─TABLE FULL SCAN|t4(idx_t1_1)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t4.a1], [t4.a2], [t4.b], [T_FUN_MIN(t4.c)], [T_FUN_MAX(t4.c)]), filter(nil), rowset=16
      group([t4.a1], [t4.a2], [t4.b]), agg_func([T_FUN_MIN(t4.c)], [T_FUN_MAX(t4.c)])
  1 - output([t4.a1], [t4.a2], [t4.b], [t4.c]), filter(nil), rowset=16
      access([t4.a1], [t4.a2], [t4.b], [t4.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t4.a1], [t4.a2], [t4.b], [t4.c], [t4.__pk_increment]), range(MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX)always true
explain select v1, pk from t5 where pk = 100 and v1 = 100 order by v1 desc;
Query Plan
=========================================
|ID|OPERATOR |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------
|0 |TABLE GET|t5  |1       |5           |
=========================================
Outputs & filters:
-------------------------------------
  0 - output([t5.v1], [t5.pk]), filter([t5.v1 = 100]), rowset=16
      access([t5.pk], [t5.v1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t5.pk]), range[100 ; 100], 
      range_cond([t5.pk = 100])
explain select v1, pk from t5 where pk = 100 and v1 = 200 order by v1 desc;
Query Plan
=========================================
|ID|OPERATOR |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------
|0 |TABLE GET|t5  |1       |5           |
=========================================
Outputs & filters:
-------------------------------------
  0 - output([t5.v1], [t5.pk]), filter([t5.v1 = 200]), rowset=16
      access([t5.pk], [t5.v1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t5.pk]), range[100 ; 100], 
      range_cond([t5.pk = 100])
explain select a from t6 where b = 1 order by c desc limit 9;
Query Plan
===============================================================
|ID|OPERATOR        |NAME               |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |TABLE RANGE SCAN|t6(idx_b_c,Reverse)|1       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      access([t6.pk], [t6.a]), partitions(p0)
      limit(9), offset(nil), is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_c)*/ a from t6 where b = 1 order by c desc limit 9;
Query Plan
===============================================================
|ID|OPERATOR        |NAME               |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |TABLE RANGE SCAN|t6(idx_b_c,Reverse)|1       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      access([t6.pk], [t6.a]), partitions(p0)
      limit(9), offset(nil), is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ a from t6 where b = 1 order by c desc limit 9;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |TOP-N SORT        |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.c, DESC]), topn(9)
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select b, c from t6 where a = 1 order by b, c;
Query Plan
========================================================
|ID|OPERATOR       |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |TABLE FULL SCAN|t6(idx_b_a_c)|1       |3           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select /*+index(t6 idx_b_c)*/ b, c from t6 where a = 1 order by b, c;
Query Plan
======================================================
|ID|OPERATOR       |NAME       |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE FULL SCAN|t6(idx_b_c)|1       |7           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.pk], [t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.c], [t6.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select /*+index(t6 idx_b_a_c)*/ b, c from t6 where a = 1 order by b, c;
Query Plan
========================================================
|ID|OPERATOR       |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |TABLE FULL SCAN|t6(idx_b_a_c)|1       |3           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a from t6 where b = 1 and a = 2 order by c;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      access([t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MIN,MIN ; 1,2,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a = 2])
explain select /*+index(t6 idx_b_c)*/ a from t6 where b = 1 and a = 2 order by c;
Query Plan
=======================================================
|ID|OPERATOR        |NAME       |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter([t6.a = 2]), rowset=16
      access([t6.pk], [t6.a]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ a from t6 where b = 1 and a = 2 order by c;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      access([t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MIN,MIN ; 1,2,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a = 2])
explain select a from t6 where b = 1 or b = 2 order by a;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT              |             |1       |5           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |5           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.a, ASC])
  1 - output([t6.a]), filter(nil), rowset=16
      access([t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), (2,MIN,MIN,MIN ; 2,MAX,MAX,MAX), 
      range_cond([t6.b = 1 OR t6.b = 2])
explain select a from t6 where b = 1 and c = 2 order by a;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter([t6.c = 2]), rowset=16
      access([t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_c)*/ a from t6 where b = 1 and c = 2 order by a;
Query Plan
=========================================================
|ID|OPERATOR          |NAME       |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SORT              |           |1       |7           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.a, ASC])
  1 - output([t6.a]), filter(nil), rowset=16
      access([t6.pk], [t6.a]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,2,MIN ; 1,2,MAX), 
      range_cond([t6.b = 1], [t6.c = 2])
explain select /*+index(t6 idx_b_a_c)*/ a from t6 where b = 1 and c = 2 order by a;
Query Plan
=========================================================
|ID|OPERATOR        |NAME         |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter([t6.c = 2]), rowset=16
      access([t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select a from t6 where b = 1 order by a, c desc;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT              |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.a, ASC], [t6.c, DESC]), prefix_pos(1)
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_c)*/ a from t6 where b = 1 order by a, c desc;
Query Plan
=========================================================
|ID|OPERATOR          |NAME       |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SORT              |           |1       |7           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.a, ASC], [t6.c, DESC])
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.pk], [t6.a], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ a from t6 where b = 1 order by a, c desc;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT              |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.a, ASC], [t6.c, DESC]), prefix_pos(1)
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select a from t6 where b > 1 order by c desc;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT              |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.c, DESC])
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MAX,MAX,MAX ; MAX,MAX,MAX,MAX), 
      range_cond([t6.b > 1])
explain select a from t6 where b = 1 and d = 2 order by e, c, a;
Query Plan
=============================================================
|ID|OPERATOR        |NAME             |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |TABLE RANGE SCAN|t6(idx_b_e_d_c_a)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter([t6.d = 2]), rowset=16
      access([t6.d], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select a from t6 where e = 1 and c = 2 order by b, d, a;
Query Plan
============================================================
|ID|OPERATOR       |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |TABLE FULL SCAN|t6(idx_b_e_d_c_a)|1       |3           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.e], [t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_c)*/ a from t6 where e = 1 and c = 2 order by b, d, a;
Query Plan
========================================================
|ID|OPERATOR         |NAME       |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |SORT             |           |1       |8           |
|1 |└─TABLE FULL SCAN|t6(idx_b_c)|1       |8           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.b, ASC], [t6.d, ASC], [t6.a, ASC]), prefix_pos(1)
  1 - output([t6.a], [t6.b], [t6.d]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.pk], [t6.e], [t6.c], [t6.a], [t6.b], [t6.d]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false,true], 
      range_key([t6.b], [t6.c], [t6.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_e_d_c_a)*/ a from t6 where e = 1 and c = 2 order by b, d, a;
Query Plan
============================================================
|ID|OPERATOR       |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |TABLE FULL SCAN|t6(idx_b_e_d_c_a)|1       |3           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.e], [t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
explain select a from t6 where b = 1 and a > 2 order by c;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |SORT              |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.c, ASC])
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MAX,MAX ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a > 2])
explain select a from t6 where b = 1 group by c limit 9;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |LIMIT               |           |1       |7           |
|1 |└─MERGE GROUP BY    |           |1       |7           |
|2 |  └─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      limit(9), offset(nil)
  1 - output([t6.a]), filter(nil), rowset=16
      group([t6.c]), agg_func(nil)
  2 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.pk], [t6.a], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_c)*/ a from t6 where b = 1 group by c limit 9;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |LIMIT               |           |1       |7           |
|1 |└─MERGE GROUP BY    |           |1       |7           |
|2 |  └─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      limit(9), offset(nil)
  1 - output([t6.a]), filter(nil), rowset=16
      group([t6.c]), agg_func(nil)
  2 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.pk], [t6.a], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ a from t6 where b = 1 group by c limit 9;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |LIMIT               |             |1       |3           |
|1 |└─HASH GROUP BY     |             |1       |3           |
|2 |  └─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      limit(9), offset(nil)
  1 - output([t6.a]), filter(nil), rowset=16
      group([t6.c]), agg_func(nil)
  2 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select b, c from t6 where a = 1 group by b, c;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE DISTINCT   |             |1       |3           |
|1 |└─TABLE FULL SCAN|t6(idx_b_a_c)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.c]), filter(nil), rowset=16
      distinct([t6.b], [t6.c])
  1 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select /*+index(t6 idx_b_c)*/ b, c from t6 where a = 1 group by b, c;
Query Plan
========================================================
|ID|OPERATOR         |NAME       |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |MERGE DISTINCT   |           |1       |7           |
|1 |└─TABLE FULL SCAN|t6(idx_b_c)|1       |7           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.c]), filter(nil), rowset=16
      distinct([t6.b], [t6.c])
  1 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.pk], [t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.c], [t6.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select /*+index(t6 idx_b_a_c)*/ b, c from t6 where a = 1 group by b, c;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE DISTINCT   |             |1       |3           |
|1 |└─TABLE FULL SCAN|t6(idx_b_a_c)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.c]), filter(nil), rowset=16
      distinct([t6.b], [t6.c])
  1 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select a from t6 where b = 1 and a = 2 group by c;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE GROUP BY    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.c]), agg_func(nil)
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MIN,MIN ; 1,2,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a = 2])
explain select /*+index(t6 idx_b_c)*/ a from t6 where b = 1 and a = 2 group by c;
Query Plan
=========================================================
|ID|OPERATOR          |NAME       |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |MERGE GROUP BY    |           |1       |7           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.c]), agg_func(nil)
  1 - output([t6.a], [t6.c]), filter([t6.a = 2]), rowset=16
      access([t6.pk], [t6.a], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ a from t6 where b = 1 and a = 2 group by c;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE GROUP BY    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.c]), agg_func(nil)
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MIN,MIN ; 1,2,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a = 2])
explain select a from t6 where b = 1 or b = 2 group by a;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |HASH DISTINCT     |             |1       |5           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |5           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      distinct([t6.a])
  1 - output([t6.a]), filter(nil), rowset=16
      access([t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), (2,MIN,MIN,MIN ; 2,MAX,MAX,MAX), 
      range_cond([t6.b = 1 OR t6.b = 2])
explain select a from t6 where b = 1 and c = 2 group by a;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      distinct([t6.a])
  1 - output([t6.a]), filter([t6.c = 2]), rowset=16
      access([t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_c)*/ a from t6 where b = 1 and c = 2 group by a;
Query Plan
=========================================================
|ID|OPERATOR          |NAME       |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |HASH DISTINCT     |           |1       |8           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      distinct([t6.a])
  1 - output([t6.a]), filter(nil), rowset=16
      access([t6.pk], [t6.a]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,2,MIN ; 1,2,MAX), 
      range_cond([t6.b = 1], [t6.c = 2])
explain select /*+index(t6 idx_b_a_c)*/ a from t6 where b = 1 and c = 2 group by a;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      distinct([t6.a])
  1 - output([t6.a]), filter([t6.c = 2]), rowset=16
      access([t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select a from t6 where b = 1 group by a, c;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE GROUP BY    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.a], [t6.c]), agg_func(nil)
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_c)*/ a from t6 where b = 1 group by a, c;
Query Plan
=========================================================
|ID|OPERATOR          |NAME       |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |HASH GROUP BY     |           |1       |8           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.a], [t6.c]), agg_func(nil)
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.pk], [t6.a], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ a from t6 where b = 1 group by a, c;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE GROUP BY    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.a], [t6.c]), agg_func(nil)
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select a from t6 where b > 1 group by c desc;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE GROUP BY      |             |1       |3           |
|1 |└─SORT              |             |1       |3           |
|2 |  └─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.c]), agg_func(nil)
  1 - output([t6.c], [t6.a]), filter(nil), rowset=16
      sort_keys([t6.c, DESC])
  2 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MAX,MAX,MAX ; MAX,MAX,MAX,MAX), 
      range_cond([t6.b > 1])
explain select a from t6 where b = 1 and d = 2 group by e, c, a;
Query Plan
===============================================================
|ID|OPERATOR          |NAME             |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |MERGE GROUP BY    |                 |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_e_d_c_a)|1       |3           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.e], [t6.c], [t6.a]), agg_func(nil)
  1 - output([t6.a], [t6.e], [t6.c]), filter([t6.d = 2]), rowset=16
      access([t6.d], [t6.a], [t6.e], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select a from t6 where e = 1 and c = 2 group by b, d, a;
Query Plan
==============================================================
|ID|OPERATOR         |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE GROUP BY   |                 |1       |3           |
|1 |└─TABLE FULL SCAN|t6(idx_b_e_d_c_a)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.b], [t6.d], [t6.a]), agg_func(nil)
  1 - output([t6.a], [t6.b], [t6.d]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.e], [t6.c], [t6.a], [t6.b], [t6.d]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_c)*/ a from t6 where e = 1 and c = 2 group by b, d, a;
Query Plan
========================================================
|ID|OPERATOR         |NAME       |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |HASH GROUP BY    |           |1       |8           |
|1 |└─TABLE FULL SCAN|t6(idx_b_c)|1       |8           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.b], [t6.d], [t6.a]), agg_func(nil)
  1 - output([t6.a], [t6.b], [t6.d]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.pk], [t6.e], [t6.c], [t6.a], [t6.b], [t6.d]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false,true], 
      range_key([t6.b], [t6.c], [t6.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_e_d_c_a)*/ a from t6 where e = 1 and c = 2 group by b, d, a;
Query Plan
==============================================================
|ID|OPERATOR         |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE GROUP BY   |                 |1       |3           |
|1 |└─TABLE FULL SCAN|t6(idx_b_e_d_c_a)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.b], [t6.d], [t6.a]), agg_func(nil)
  1 - output([t6.a], [t6.b], [t6.d]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.e], [t6.c], [t6.a], [t6.b], [t6.d]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
explain select a from t6 where b = 1 and a > 2 group by c;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |HASH GROUP BY     |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      group([t6.c]), agg_func(nil)
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MAX,MAX ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a > 2])
explain select distinct c from t6 where b = 1 limit 9;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |LIMIT               |           |1       |3           |
|1 |└─MERGE DISTINCT    |           |1       |3           |
|2 |  └─TABLE RANGE SCAN|t6(idx_b_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.c]), filter(nil), rowset=16
      limit(9), offset(nil)
  1 - output([t6.c]), filter(nil), rowset=16
      distinct([t6.c])
  2 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_c)*/ distinct c from t6 where b = 1 limit 9;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |LIMIT               |           |1       |3           |
|1 |└─MERGE DISTINCT    |           |1       |3           |
|2 |  └─TABLE RANGE SCAN|t6(idx_b_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.c]), filter(nil), rowset=16
      limit(9), offset(nil)
  1 - output([t6.c]), filter(nil), rowset=16
      distinct([t6.c])
  2 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ distinct c from t6 where b = 1 limit 9;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |LIMIT               |             |1       |3           |
|1 |└─HASH DISTINCT     |             |1       |3           |
|2 |  └─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.c]), filter(nil), rowset=16
      limit(9), offset(nil)
  1 - output([t6.c]), filter(nil), rowset=16
      distinct([t6.c])
  2 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select distinct b, c from t6 where a = 1;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE DISTINCT   |             |1       |3           |
|1 |└─TABLE FULL SCAN|t6(idx_b_a_c)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.c]), filter(nil), rowset=16
      distinct([t6.b], [t6.c])
  1 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select /*+index(t6 idx_b_c)*/ distinct b, c from t6 where a = 1;
Query Plan
========================================================
|ID|OPERATOR         |NAME       |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |MERGE DISTINCT   |           |1       |7           |
|1 |└─TABLE FULL SCAN|t6(idx_b_c)|1       |7           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.c]), filter(nil), rowset=16
      distinct([t6.b], [t6.c])
  1 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.pk], [t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.c], [t6.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select /*+index(t6 idx_b_a_c)*/ distinct b, c from t6 where a = 1;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |MERGE DISTINCT   |             |1       |3           |
|1 |└─TABLE FULL SCAN|t6(idx_b_a_c)|1       |3           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.c]), filter(nil), rowset=16
      distinct([t6.b], [t6.c])
  1 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select distinct c from t6 where b = 1 and a = 2;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.c]), filter(nil), rowset=16
      distinct([t6.c])
  1 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MIN,MIN ; 1,2,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a = 2])
explain select /*+index(t6 idx_b_c)*/ distinct c from t6 where b = 1 and a = 2;
Query Plan
=========================================================
|ID|OPERATOR          |NAME       |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |MERGE DISTINCT    |           |1       |7           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.c]), filter(nil), rowset=16
      distinct([t6.c])
  1 - output([t6.c]), filter([t6.a = 2]), rowset=16
      access([t6.pk], [t6.a], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ distinct c from t6 where b = 1 and a = 2;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.c]), filter(nil), rowset=16
      distinct([t6.c])
  1 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MIN,MIN ; 1,2,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a = 2])
explain select distinct a from t6 where b = 1 or b = 2;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |HASH DISTINCT     |             |1       |5           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |5           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      distinct([t6.a])
  1 - output([t6.a]), filter(nil), rowset=16
      access([t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), (2,MIN,MIN,MIN ; 2,MAX,MAX,MAX), 
      range_cond([t6.b = 1 OR t6.b = 2])
explain select distinct a from t6 where b = 1 and c = 2;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      distinct([t6.a])
  1 - output([t6.a]), filter([t6.c = 2]), rowset=16
      access([t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_c)*/ distinct a from t6 where b = 1 and c = 2;
Query Plan
=========================================================
|ID|OPERATOR          |NAME       |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |HASH DISTINCT     |           |1       |8           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      distinct([t6.a])
  1 - output([t6.a]), filter(nil), rowset=16
      access([t6.pk], [t6.a]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,2,MIN ; 1,2,MAX), 
      range_cond([t6.b = 1], [t6.c = 2])
explain select /*+index(t6 idx_b_a_c)*/ distinct a from t6 where b = 1 and c = 2;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a]), filter(nil), rowset=16
      distinct([t6.a])
  1 - output([t6.a]), filter([t6.c = 2]), rowset=16
      access([t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select distinct a, c from t6 where b = 1;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a], [t6.c]), filter(nil), rowset=16
      distinct([t6.a], [t6.c])
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_c)*/ distinct a, c from t6 where b = 1;
Query Plan
=========================================================
|ID|OPERATOR          |NAME       |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |HASH DISTINCT     |           |1       |8           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a], [t6.c]), filter(nil), rowset=16
      distinct([t6.a], [t6.c])
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.pk], [t6.a], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ distinct a, c from t6 where b = 1;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE DISTINCT    |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.a], [t6.c]), filter(nil), rowset=16
      distinct([t6.a], [t6.c])
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select distinct c from t6 where b > 1;
Query Plan
=========================================================
|ID|OPERATOR          |NAME       |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |HASH DISTINCT     |           |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_c)|1       |3           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.c]), filter(nil), rowset=16
      distinct([t6.c])
  1 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MAX,MAX ; MAX,MAX,MAX), 
      range_cond([t6.b > 1])
explain select distinct e, c, a from t6 where b = 1 and d = 2;
Query Plan
===============================================================
|ID|OPERATOR          |NAME             |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |MERGE DISTINCT    |                 |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_e_d_c_a)|1       |3           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.e], [t6.c], [t6.a]), filter(nil), rowset=16
      distinct([t6.e], [t6.c], [t6.a])
  1 - output([t6.e], [t6.c], [t6.a]), filter([t6.d = 2]), rowset=16
      access([t6.d], [t6.e], [t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select distinct b, d, a from t6 where e = 1 and c = 2;
Query Plan
==============================================================
|ID|OPERATOR         |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE DISTINCT   |                 |1       |3           |
|1 |└─TABLE FULL SCAN|t6(idx_b_e_d_c_a)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.d], [t6.a]), filter(nil), rowset=16
      distinct([t6.b], [t6.d], [t6.a])
  1 - output([t6.b], [t6.d], [t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.e], [t6.c], [t6.b], [t6.d], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_c)*/ distinct b, d, a from t6 where e = 1 and c = 2;
Query Plan
========================================================
|ID|OPERATOR         |NAME       |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------
|0 |HASH DISTINCT    |           |1       |8           |
|1 |└─TABLE FULL SCAN|t6(idx_b_c)|1       |8           |
========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.d], [t6.a]), filter(nil), rowset=16
      distinct([t6.b], [t6.d], [t6.a])
  1 - output([t6.b], [t6.d], [t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.pk], [t6.e], [t6.c], [t6.b], [t6.d], [t6.a]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false,true], 
      range_key([t6.b], [t6.c], [t6.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_a_c)*/ distinct b, d, a from t6 where e = 1 and c = 2;
Query Plan
==========================================================
|ID|OPERATOR         |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |HASH DISTINCT    |             |1       |8           |
|1 |└─TABLE FULL SCAN|t6(idx_b_a_c)|1       |8           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.d], [t6.a]), filter(nil), rowset=16
      distinct([t6.b], [t6.d], [t6.a])
  1 - output([t6.b], [t6.d], [t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.pk], [t6.e], [t6.c], [t6.b], [t6.d], [t6.a]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false,true], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_e_d_c_a)*/ distinct b, d, a from t6 where e = 1 and c = 2;
Query Plan
==============================================================
|ID|OPERATOR         |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE DISTINCT   |                 |1       |3           |
|1 |└─TABLE FULL SCAN|t6(idx_b_e_d_c_a)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.b], [t6.d], [t6.a]), filter(nil), rowset=16
      distinct([t6.b], [t6.d], [t6.a])
  1 - output([t6.b], [t6.d], [t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.e], [t6.c], [t6.b], [t6.d], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
explain select distinct c from t6 where b = 1 and a > 2;
Query Plan
===========================================================
|ID|OPERATOR          |NAME         |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |HASH DISTINCT     |             |1       |3           |
|1 |└─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([t6.c]), filter(nil), rowset=16
      distinct([t6.c])
  1 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MAX,MAX ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a > 2])
explain (select c from t6 where b = 1 limit 9) union select pk from tmp;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE UNION DISTINCT|           |2       |5           |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_c)|1       |3           |
|2 |└─TABLE FULL SCAN   |tmp        |1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      limit(9), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
  2 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
explain (select /*+index(t6 idx_b_c)*/ c from t6 where b = 1 limit 9) union select pk from tmp;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE UNION DISTINCT|           |2       |5           |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_c)|1       |3           |
|2 |└─TABLE FULL SCAN   |tmp        |1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      limit(9), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
  2 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
explain (select /*+index(t6 idx_b_a_c)*/ c from t6 where b = 1 limit 9) union select pk from tmp;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE FULL SCAN   |tmp          |1       |3           |
|2 |└─SORT              |             |1       |3           |
|3 |  └─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
  2 - output([t6.c]), filter(nil), rowset=16
      sort_keys([t6.c, ASC])
  3 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      limit(9), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
explain select b, c from t6 where a = 1 union select c1, c2 from tmp;
Query Plan
==============================================================
|ID|OPERATOR            |NAME          |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE UNION DISTINCT|              |2       |5           |
|1 |├─TABLE FULL SCAN   |t6(idx_b_a_c) |1       |3           |
|2 |└─TABLE FULL SCAN   |tmp(idx_c1_c2)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16
  1 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([tmp.c1], [tmp.c2]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select /*+index(t6 idx_b_c)*/ b, c from t6 where a = 1 union select c1, c2 from tmp;
Query Plan
==============================================================
|ID|OPERATOR            |NAME          |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE UNION DISTINCT|              |2       |10          |
|1 |├─TABLE FULL SCAN   |t6(idx_b_c)   |1       |7           |
|2 |└─TABLE FULL SCAN   |tmp(idx_c1_c2)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16
  1 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.pk], [t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.c], [t6.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tmp.c1], [tmp.c2]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select /*+index(t6 idx_b_a_c)*/ b, c from t6 where a = 1 union select c1, c2 from tmp;
Query Plan
==============================================================
|ID|OPERATOR            |NAME          |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE UNION DISTINCT|              |2       |5           |
|1 |├─TABLE FULL SCAN   |t6(idx_b_a_c) |1       |3           |
|2 |└─TABLE FULL SCAN   |tmp(idx_c1_c2)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16
  1 - output([t6.b], [t6.c]), filter([t6.a = 1]), rowset=16
      access([t6.a], [t6.b], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([tmp.c1], [tmp.c2]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select c from t6 where b = 1 and a = 2 union select pk from tmp;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_a_c)|1       |3           |
|2 |└─TABLE FULL SCAN   |tmp          |1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MIN,MIN ; 1,2,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a = 2])
  2 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
explain select /*+index(t6 idx_b_c)*/ c from t6 where b = 1 and a = 2 union select pk from tmp;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE UNION DISTINCT|           |2       |10          |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_c)|1       |7           |
|2 |└─TABLE FULL SCAN   |tmp        |1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([t6.c]), filter([t6.a = 2]), rowset=16
      access([t6.pk], [t6.a], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
  2 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
explain select /*+index(t6 idx_b_a_c)*/ c from t6 where b = 1 and a = 2 union select pk from tmp;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_a_c)|1       |3           |
|2 |└─TABLE FULL SCAN   |tmp          |1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MIN,MIN ; 1,2,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a = 2])
  2 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
explain select a from t6 where b = 1 or b = 2 union select pk from tmp;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |7           |
|1 |├─TABLE FULL SCAN   |tmp          |1       |3           |
|2 |└─SORT              |             |1       |5           |
|3 |  └─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |5           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
  2 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.a, ASC])
  3 - output([t6.a]), filter(nil), rowset=16
      access([t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), (2,MIN,MIN,MIN ; 2,MAX,MAX,MAX), 
      range_cond([t6.b = 1 OR t6.b = 2])
explain select a from t6 where b = 1 and c = 2 union select pk from tmp;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_a_c)|1       |3           |
|2 |└─TABLE FULL SCAN   |tmp          |1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([t6.a]), filter([t6.c = 2]), rowset=16
      access([t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
  2 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
explain select /*+index(t6 idx_b_c)*/ a from t6 where b = 1 and c = 2 union select pk from tmp;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE UNION DISTINCT|           |2       |10          |
|1 |├─TABLE FULL SCAN   |tmp        |1       |3           |
|2 |└─SORT              |           |1       |7           |
|3 |  └─TABLE RANGE SCAN|t6(idx_b_c)|1       |7           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
  2 - output([t6.a]), filter(nil), rowset=16
      sort_keys([t6.a, ASC])
  3 - output([t6.a]), filter(nil), rowset=16
      access([t6.pk], [t6.a]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,2,MIN ; 1,2,MAX), 
      range_cond([t6.b = 1], [t6.c = 2])
explain select /*+index(t6 idx_b_a_c)*/ a from t6 where b = 1 and c = 2 union select pk from tmp;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_a_c)|1       |3           |
|2 |└─TABLE FULL SCAN   |tmp          |1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([t6.a]), filter([t6.c = 2]), rowset=16
      access([t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
  2 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
explain select a, c from t6 where b = 1 union select c1, c2 from tmp;
Query Plan
==============================================================
|ID|OPERATOR            |NAME          |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE UNION DISTINCT|              |2       |5           |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_a_c) |1       |3           |
|2 |└─TABLE FULL SCAN   |tmp(idx_c1_c2)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
  2 - output([tmp.c1], [tmp.c2]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select /*+index(t6 idx_b_c)*/ a, c from t6 where b = 1 union select c1, c2 from tmp;
Query Plan
==============================================================
|ID|OPERATOR            |NAME          |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE UNION DISTINCT|              |2       |10          |
|1 |├─TABLE FULL SCAN   |tmp(idx_c1_c2)|1       |3           |
|2 |└─SORT              |              |1       |7           |
|3 |  └─TABLE RANGE SCAN|t6(idx_b_c)   |1       |7           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16
  1 - output([tmp.c1], [tmp.c2]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([t6.a], [t6.c]), filter(nil), rowset=16
      sort_keys([t6.a, ASC], [t6.c, ASC])
  3 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.pk], [t6.a], [t6.c]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t6.b = 1])
explain select /*+index(t6 idx_b_a_c)*/ a, c from t6 where b = 1 union select c1, c2 from tmp;
Query Plan
==============================================================
|ID|OPERATOR            |NAME          |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |MERGE UNION DISTINCT|              |2       |5           |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_a_c) |1       |3           |
|2 |└─TABLE FULL SCAN   |tmp(idx_c1_c2)|1       |3           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16
  1 - output([t6.a], [t6.c]), filter(nil), rowset=16
      access([t6.a], [t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
  2 - output([tmp.c1], [tmp.c2]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select c from t6 where b > 1 union select pk from tmp;
Query Plan
===========================================================
|ID|OPERATOR            |NAME       |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE UNION DISTINCT|           |2       |5           |
|1 |├─TABLE FULL SCAN   |tmp        |1       |3           |
|2 |└─SORT              |           |1       |3           |
|3 |  └─TABLE RANGE SCAN|t6(idx_b_c)|1       |3           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
  2 - output([t6.c]), filter(nil), rowset=16
      sort_keys([t6.c, ASC])
  3 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.c], [t6.pk]), range(1,MAX,MAX ; MAX,MAX,MAX), 
      range_cond([t6.b > 1])
explain select e, c, a from t6 where b = 1 and d = 2 union select c1, c2, c3 from tmp;
Query Plan
=================================================================
|ID|OPERATOR            |NAME             |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |MERGE UNION DISTINCT|                 |2       |5           |
|1 |├─TABLE RANGE SCAN  |t6(idx_b_e_d_c_a)|1       |3           |
|2 |└─TABLE FULL SCAN   |tmp(idx_c1_c2_c3)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([t6.e], [t6.c], [t6.a]), filter([t6.d = 2]), rowset=16
      access([t6.d], [t6.e], [t6.c], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t6.b = 1])
  2 - output([tmp.c1], [tmp.c2], [tmp.c3]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2], [tmp.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.c3], [tmp.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select b, d, a from t6 where e = 1 and c = 2 union select c1, c2, c3 from tmp;
Query Plan
=================================================================
|ID|OPERATOR            |NAME             |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |MERGE UNION DISTINCT|                 |2       |5           |
|1 |├─TABLE FULL SCAN   |t6(idx_b_e_d_c_a)|1       |3           |
|2 |└─TABLE FULL SCAN   |tmp(idx_c1_c2_c3)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([t6.b], [t6.d], [t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.e], [t6.c], [t6.b], [t6.d], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  2 - output([tmp.c1], [tmp.c2], [tmp.c3]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2], [tmp.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.c3], [tmp.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_c)*/ b, d, a from t6 where e = 1 and c = 2 union select c1, c2, c3 from tmp;
Query Plan
=================================================================
|ID|OPERATOR            |NAME             |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |MERGE UNION DISTINCT|                 |2       |10          |
|1 |├─TABLE FULL SCAN   |tmp(idx_c1_c2_c3)|1       |3           |
|2 |└─SORT              |                 |1       |8           |
|3 |  └─TABLE FULL SCAN |t6(idx_b_c)      |1       |8           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([tmp.c1], [tmp.c2], [tmp.c3]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2], [tmp.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.c3], [tmp.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t6.b], [t6.d], [t6.a]), filter(nil), rowset=16
      sort_keys([t6.b, ASC], [t6.d, ASC], [t6.a, ASC]), prefix_pos(1)
  3 - output([t6.b], [t6.d], [t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.pk], [t6.e], [t6.c], [t6.b], [t6.d], [t6.a]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false,true], 
      range_key([t6.b], [t6.c], [t6.pk]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_a_c)*/ b, d, a from t6 where e = 1 and c = 2 union select c1, c2, c3 from tmp;
Query Plan
=================================================================
|ID|OPERATOR            |NAME             |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |MERGE UNION DISTINCT|                 |2       |10          |
|1 |├─TABLE FULL SCAN   |tmp(idx_c1_c2_c3)|1       |3           |
|2 |└─SORT              |                 |1       |8           |
|3 |  └─TABLE FULL SCAN |t6(idx_b_a_c)    |1       |8           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([tmp.c1], [tmp.c2], [tmp.c3]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2], [tmp.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.c3], [tmp.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t6.b], [t6.d], [t6.a]), filter(nil), rowset=16
      sort_keys([t6.b, ASC], [t6.d, ASC], [t6.a, ASC]), prefix_pos(1)
  3 - output([t6.b], [t6.d], [t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.pk], [t6.e], [t6.c], [t6.b], [t6.d], [t6.a]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false,true], 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select  /*+index(t6 idx_b_e_d_c_a)*/ b, d, a from t6 where e = 1 and c = 2 union select c1, c2, c3 from tmp;
Query Plan
=================================================================
|ID|OPERATOR            |NAME             |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |MERGE UNION DISTINCT|                 |2       |5           |
|1 |├─TABLE FULL SCAN   |t6(idx_b_e_d_c_a)|1       |3           |
|2 |└─TABLE FULL SCAN   |tmp(idx_c1_c2_c3)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16
  1 - output([t6.b], [t6.d], [t6.a]), filter([t6.e = 1], [t6.c = 2]), rowset=16
      access([t6.e], [t6.c], [t6.b], [t6.d], [t6.a]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t6.b], [t6.e], [t6.d], [t6.c], [t6.a], [t6.pk]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  2 - output([tmp.c1], [tmp.c2], [tmp.c3]), filter(nil), rowset=16
      access([tmp.c1], [tmp.c2], [tmp.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.c1], [tmp.c2], [tmp.c3], [tmp.pk]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select c from t6 where b = 1 and a > 2 union select pk from tmp;
Query Plan
=============================================================
|ID|OPERATOR            |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |MERGE UNION DISTINCT|             |2       |5           |
|1 |├─TABLE FULL SCAN   |tmp          |1       |3           |
|2 |└─SORT              |             |1       |3           |
|3 |  └─TABLE RANGE SCAN|t6(idx_b_a_c)|1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([UNION([1])]), filter(nil), rowset=16
  1 - output([tmp.pk]), filter(nil), rowset=16
      access([tmp.pk]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tmp.pk]), range(MIN ; MAX)always true
  2 - output([t6.c]), filter(nil), rowset=16
      sort_keys([t6.c, ASC])
  3 - output([t6.c]), filter(nil), rowset=16
      access([t6.c]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t6.b], [t6.a], [t6.c], [t6.pk]), range(1,2,MAX,MAX ; 1,MAX,MAX,MAX), 
      range_cond([t6.b = 1], [t6.a > 2])
explain select * from t7 where a >= 0 and a <= 5 and b = 1;
Query Plan
==================================================
|ID|OPERATOR        |NAME  |EST.ROWS|EST.TIME(us)|
--------------------------------------------------
|0 |TABLE RANGE SCAN|t7(k1)|1       |8           |
==================================================
Outputs & filters:
-------------------------------------
  0 - output([t7.a], [t7.b], [t7.c], [t7.d], [t7.e], [t7.f]), filter([t7.b = 1]), rowset=16
      access([t7.__pk_increment], [t7.a], [t7.b], [t7.c], [t7.d], [t7.e], [t7.f]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[true], 
      range_key([t7.a], [t7.c], [t7.b], [t7.__pk_increment]), range(0,MIN,MIN,MIN ; 5,MAX,MAX,MAX), 
      range_cond([t7.a >= 0], [t7.a <= 5])
explain select * from t8 where e = 1 order by b;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SORT             |    |1       |3           |
|1 |└─TABLE FULL SCAN|t8  |1       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t8.a], [t8.b], [t8.c], [t8.d], [t8.e], [t8.f]), filter(nil), rowset=16
      sort_keys([t8.b, ASC])
  1 - output([t8.a], [t8.e], [t8.b], [t8.c], [t8.d], [t8.f]), filter([t8.e = 1]), rowset=16
      access([t8.a], [t8.e], [t8.b], [t8.c], [t8.d], [t8.f]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t8.a]), range(MIN ; MAX)always true
explain select * from t8 where e = 1 or f = 1 order by b;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SORT             |    |1       |3           |
|1 |└─TABLE FULL SCAN|t8  |1       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t8.a], [t8.b], [t8.c], [t8.d], [t8.e], [t8.f]), filter(nil), rowset=16
      sort_keys([t8.b, ASC])
  1 - output([t8.a], [t8.e], [t8.f], [t8.b], [t8.c], [t8.d]), filter([t8.e = 1 OR t8.f = 1]), rowset=16
      access([t8.a], [t8.e], [t8.f], [t8.b], [t8.c], [t8.d]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t8.a]), range(MIN ; MAX)always true
explain select * from t8 where d = 1 order by b;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SORT             |    |1       |3           |
|1 |└─TABLE FULL SCAN|t8  |1       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t8.a], [t8.b], [t8.c], [t8.d], [t8.e], [t8.f]), filter(nil), rowset=16
      sort_keys([t8.b, ASC])
  1 - output([t8.a], [t8.d], [t8.b], [t8.c], [t8.e], [t8.f]), filter([t8.d = 1]), rowset=16
      access([t8.a], [t8.d], [t8.b], [t8.c], [t8.e], [t8.f]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t8.a]), range(MIN ; MAX)always true
explain select avg(c1) over (partition by c2) from t9 order by c1;
Query Plan
============================================================
|ID|OPERATOR           |NAME         |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |SORT               |             |1       |4           |
|1 |└─WINDOW FUNCTION  |             |1       |4           |
|2 |  └─TABLE FULL SCAN|t9(idx_c2_c5)|1       |3           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c2]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c2]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  2 - output([t9.c1], [t9.c2]), filter(nil), rowset=16
      access([t9.c1], [t9.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c5], [t9.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
explain select avg(c1) over (partition by c2, c3) from t9 order by c1;
Query Plan
===============================================================
|ID|OPERATOR           |NAME            |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT               |                |1       |4           |
|1 |└─WINDOW FUNCTION  |                |1       |4           |
|2 |  └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c2], [t9.c3]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c2], [t9.c3]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  2 - output([t9.c1], [t9.c2], [t9.c3]), filter(nil), rowset=16
      access([t9.c1], [t9.c2], [t9.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (partition by c3) from t9 order by c1;
Query Plan
=================================================================
|ID|OPERATOR             |NAME            |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |SORT                 |                |1       |4           |
|1 |└─WINDOW FUNCTION    |                |1       |4           |
|2 |  └─SORT             |                |1       |3           |
|3 |    └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c3]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c3]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  2 - output([t9.c1], [t9.c3]), filter(nil), rowset=16
      sort_keys([t9.c3, ASC])
  3 - output([t9.c1], [t9.c3]), filter(nil), rowset=16
      access([t9.c1], [t9.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (partition by c3) from t9 where c2 = 2 order by c1;
Query Plan
================================================================
|ID|OPERATOR            |NAME            |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------
|0 |SORT                |                |1       |4           |
|1 |└─WINDOW FUNCTION   |                |1       |4           |
|2 |  └─TABLE RANGE SCAN|t9(idx_c2_c3_c5)|1       |3           |
================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c3]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c3]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  2 - output([t9.c1], [t9.c3]), filter(nil), rowset=16
      access([t9.c1], [t9.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(2,MIN,MIN,MIN ; 2,MAX,MAX,MAX), 
      range_cond([t9.c2 = 2])
explain select avg(c1) over (order by c2, c3) from t9 order by c1;
Query Plan
===============================================================
|ID|OPERATOR           |NAME            |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT               |                |1       |4           |
|1 |└─WINDOW FUNCTION  |                |1       |4           |
|2 |  └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by(nil), order_by([t9.c2, ASC], [t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by(nil), order_by([t9.c2, ASC], [t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
  2 - output([t9.c1], [t9.c2], [t9.c3]), filter(nil), rowset=16
      access([t9.c1], [t9.c2], [t9.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (order by c2, c3 desc) from t9 order by c1;
Query Plan
=================================================================
|ID|OPERATOR             |NAME            |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |SORT                 |                |1       |4           |
|1 |└─WINDOW FUNCTION    |                |1       |4           |
|2 |  └─SORT             |                |1       |3           |
|3 |    └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by(nil), order_by([t9.c2, ASC], [t9.c3, DESC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by(nil), order_by([t9.c2, ASC], [t9.c3, DESC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
  2 - output([t9.c1], [t9.c2], [t9.c3]), filter(nil), rowset=16
      sort_keys([t9.c2, ASC], [t9.c3, DESC]), prefix_pos(1)
  3 - output([t9.c1], [t9.c2], [t9.c3]), filter(nil), rowset=16
      access([t9.c1], [t9.c2], [t9.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (order by c2 desc, c3 desc) from t9 order by c1;
Query Plan
=======================================================================
|ID|OPERATOR           |NAME                    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |SORT               |                        |1       |4           |
|1 |└─WINDOW FUNCTION  |                        |1       |4           |
|2 |  └─TABLE FULL SCAN|t9(idx_c2_c3_c5,Reverse)|1       |3           |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by(nil), order_by([t9.c2, DESC], [t9.c3, DESC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by(nil), order_by([t9.c2, DESC], [t9.c3, DESC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
  2 - output([t9.c1], [t9.c2], [t9.c3]), filter(nil), rowset=16
      access([t9.c1], [t9.c2], [t9.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (order by c3) from t9 where c2 = 2 order by c1;
Query Plan
================================================================
|ID|OPERATOR            |NAME            |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------
|0 |SORT                |                |1       |4           |
|1 |└─WINDOW FUNCTION   |                |1       |4           |
|2 |  └─TABLE RANGE SCAN|t9(idx_c2_c3_c5)|1       |3           |
================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by(nil), order_by([t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by(nil), order_by([t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  2 - output([t9.c1], [t9.c3]), filter(nil), rowset=16
      access([t9.c1], [t9.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(2,MIN,MIN,MIN ; 2,MAX,MAX,MAX), 
      range_cond([t9.c2 = 2])
explain select avg(c1) over (partition by c2 order by c3) from t9 order by c1;
Query Plan
===============================================================
|ID|OPERATOR           |NAME            |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT               |                |1       |4           |
|1 |└─WINDOW FUNCTION  |                |1       |4           |
|2 |  └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  2 - output([t9.c1], [t9.c2], [t9.c3]), filter(nil), rowset=16
      access([t9.c1], [t9.c2], [t9.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (partition by c2 order by c3, c5) from t9 order by c1;
Query Plan
===============================================================
|ID|OPERATOR           |NAME            |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT               |                |1       |4           |
|1 |└─WINDOW FUNCTION  |                |1       |4           |
|2 |  └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC], [t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC], [t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
  2 - output([t9.c1], [t9.c2], [t9.c3], [t9.c5]), filter(nil), rowset=16
      access([t9.c1], [t9.c2], [t9.c3], [t9.c5]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (partition by c2 order by c3, c5 desc) from t9 order by c1;
Query Plan
=================================================================
|ID|OPERATOR             |NAME            |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |SORT                 |                |1       |4           |
|1 |└─WINDOW FUNCTION    |                |1       |4           |
|2 |  └─SORT             |                |1       |3           |
|3 |    └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC], [t9.c5, DESC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC], [t9.c5, DESC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
  2 - output([t9.c1], [t9.c2], [t9.c3], [t9.c5]), filter(nil), rowset=16
      sort_keys([t9.c2, ASC], [t9.c3, ASC], [t9.c5, DESC]), prefix_pos(2)
  3 - output([t9.c1], [t9.c2], [t9.c3], [t9.c5]), filter(nil), rowset=16
      access([t9.c1], [t9.c2], [t9.c3], [t9.c5]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (partition by c3 order by c5) from t9 where c2 = 2 order by c1;
Query Plan
================================================================
|ID|OPERATOR            |NAME            |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------
|0 |SORT                |                |1       |4           |
|1 |└─WINDOW FUNCTION   |                |1       |4           |
|2 |  └─TABLE RANGE SCAN|t9(idx_c2_c3_c5)|1       |3           |
================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c3]), order_by([t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c3]), order_by([t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  2 - output([t9.c1], [t9.c3], [t9.c5]), filter(nil), rowset=16
      access([t9.c1], [t9.c3], [t9.c5]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(2,MIN,MIN,MIN ; 2,MAX,MAX,MAX), 
      range_cond([t9.c2 = 2])
explain select avg(c1) over (partition by c3, c5) from t9 order by c1;
Query Plan
=================================================================
|ID|OPERATOR             |NAME            |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |SORT                 |                |1       |4           |
|1 |└─WINDOW FUNCTION    |                |1       |4           |
|2 |  └─SORT             |                |1       |3           |
|3 |    └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c3], [t9.c5]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c3], [t9.c5]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  2 - output([t9.c1], [t9.c3], [t9.c5]), filter(nil), rowset=16
      sort_keys([t9.c3, ASC], [t9.c5, ASC])
  3 - output([t9.c1], [t9.c3], [t9.c5]), filter(nil), rowset=16
      access([t9.c1], [t9.c3], [t9.c5]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (partition by c3, c5) from t9 order by c4;
Query Plan
=================================================================
|ID|OPERATOR             |NAME            |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |SORT                 |                |1       |5           |
|1 |└─WINDOW FUNCTION    |                |1       |4           |
|2 |  └─SORT             |                |1       |3           |
|3 |    └─TABLE FULL SCAN|t9(idx_c4_c3_c5)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c4, ASC])
  1 - output([t9.c4], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c3], [t9.c5]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c3], [t9.c5]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  2 - output([t9.c4], [t9.c1], [t9.c3], [t9.c5]), filter(nil), rowset=16
      sort_keys([t9.c3, ASC], [t9.c5, ASC])
  3 - output([t9.c1], [t9.c3], [t9.c5], [t9.c4]), filter(nil), rowset=16
      access([t9.c1], [t9.c3], [t9.c5], [t9.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c4], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (order by c3, c5) from t9 order by c1;
Query Plan
=================================================================
|ID|OPERATOR             |NAME            |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |SORT                 |                |1       |4           |
|1 |└─WINDOW FUNCTION    |                |1       |4           |
|2 |  └─SORT             |                |1       |3           |
|3 |    └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by(nil), order_by([t9.c3, ASC], [t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by(nil), order_by([t9.c3, ASC], [t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
  2 - output([t9.c1], [t9.c3], [t9.c5]), filter(nil), rowset=16
      sort_keys([t9.c3, ASC], [t9.c5, ASC])
  3 - output([t9.c1], [t9.c3], [t9.c5]), filter(nil), rowset=16
      access([t9.c1], [t9.c3], [t9.c5]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (order by c3, c5) from t9 order by c4;
Query Plan
=================================================================
|ID|OPERATOR             |NAME            |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |SORT                 |                |1       |5           |
|1 |└─WINDOW FUNCTION    |                |1       |4           |
|2 |  └─SORT             |                |1       |3           |
|3 |    └─TABLE FULL SCAN|t9(idx_c4_c3_c5)|1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))]), filter(nil), rowset=16
      sort_keys([t9.c4, ASC])
  1 - output([t9.c4], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by(nil), order_by([t9.c3, ASC], [t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by(nil), order_by([t9.c3, ASC], [t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
  2 - output([t9.c4], [t9.c1], [t9.c3], [t9.c5]), filter(nil), rowset=16
      sort_keys([t9.c3, ASC], [t9.c5, ASC])
  3 - output([t9.c1], [t9.c3], [t9.c5], [t9.c4]), filter(nil), rowset=16
      access([t9.c1], [t9.c3], [t9.c5], [t9.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c4], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
create index idx_c3_c2_c5 on t9(c3, c2, c5);
explain select avg(c1) over (partition by c2 order by c3),
max(c1) over (partition by c2, c3, c5)
from t9 order by c1;
Query Plan
===============================================================
|ID|OPERATOR           |NAME            |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT               |                |1       |5           |
|1 |└─WINDOW FUNCTION  |                |1       |5           |
|2 |  └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))], [T_FUN_MAX(t9.c1)]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_MAX(t9.c1)], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_MAX(t9.c1)), partition_by([t9.c2], [t9.c3], [t9.c5]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED 
      FOLLOWING)
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  2 - output([t9.c1], [t9.c2], [t9.c3], [t9.c5]), filter(nil), rowset=16
      access([t9.c1], [t9.c2], [t9.c3], [t9.c5]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (partition by c2 order by c3),
max(c1) over (partition by c3 order by c2, c5)
from t9 order by c1;
Query Plan
===================================================================
|ID|OPERATOR               |NAME            |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                   |                |1       |5           |
|1 |└─WINDOW FUNCTION      |                |1       |5           |
|2 |  └─SORT               |                |1       |4           |
|3 |    └─WINDOW FUNCTION  |                |1       |4           |
|4 |      └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))], [T_FUN_MAX(t9.c1)]), filter(nil), rowset=16
      sort_keys([t9.c1, ASC])
  1 - output([t9.c1], [T_FUN_MAX(t9.c1)], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_MAX(t9.c1)), partition_by([t9.c3]), order_by([t9.c2, ASC], [t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT 
      ROW)
  2 - output([t9.c1], [t9.c3], [t9.c2], [t9.c5], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      sort_keys([t9.c3, ASC], [t9.c2, ASC], [t9.c5, ASC])
  3 - output([t9.c1], [t9.c3], [t9.c2], [t9.c5], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c2]), order_by([t9.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  4 - output([t9.c1], [t9.c2], [t9.c3], [t9.c5]), filter(nil), rowset=16
      access([t9.c1], [t9.c2], [t9.c3], [t9.c5]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
explain select avg(c1) over (partition by c3 order by c5),
max(c1) over (partition by c2, c3, c5)
from t9 order by c3, c2, c5;
Query Plan
===================================================================
|ID|OPERATOR               |NAME            |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                   |                |1       |5           |
|1 |└─WINDOW FUNCTION      |                |1       |5           |
|2 |  └─SORT               |                |1       |4           |
|3 |    └─WINDOW FUNCTION  |                |1       |3           |
|4 |      └─TABLE FULL SCAN|t9(idx_c2_c3_c5)|1       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(cast(T_FUN_SUM(t9.c1), DECIMAL_INT(65, 32)) / cast(T_FUN_COUNT(t9.c1), DECIMAL_INT(20, 0)), DECIMAL(15, 4))], [T_FUN_MAX(t9.c1)]), filter(nil), rowset=16
      sort_keys([t9.c3, ASC], [t9.c2, ASC], [t9.c5, ASC]), prefix_pos(1)
  1 - output([t9.c3], [t9.c2], [t9.c5], [T_FUN_MAX(t9.c1)], [T_FUN_SUM(t9.c1)], [T_FUN_COUNT(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_SUM(t9.c1)), partition_by([t9.c3]), order_by([t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_COUNT(t9.c1)), partition_by([t9.c3]), order_by([t9.c5, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  2 - output([t9.c3], [t9.c2], [t9.c5], [t9.c1], [T_FUN_MAX(t9.c1)]), filter(nil), rowset=16
      sort_keys([t9.c3, ASC], [t9.c5, ASC])
  3 - output([t9.c3], [t9.c2], [t9.c5], [t9.c1], [T_FUN_MAX(t9.c1)]), filter(nil), rowset=16
      win_expr(T_FUN_MAX(t9.c1)), partition_by([t9.c2], [t9.c3], [t9.c5]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED 
      FOLLOWING)
  4 - output([t9.c1], [t9.c3], [t9.c5], [t9.c2]), filter(nil), rowset=16
      access([t9.c1], [t9.c3], [t9.c5], [t9.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t9.c2], [t9.c3], [t9.c5], [t9.c1]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
create table t10(pk int primary key, c1 int, c2 int, c3 int, c4 int);
create index t10i1 on t10(c1, c2, c3);
create index t10i2 on t10(c2, c3);
create index t10i3 on t10(c3);
create table t11(pk int primary key, c1 int, c2 int);
create index t11i1 on t11(c1);
create table t12(c1 int, c2 int, c3 int, c4 int, primary key(c1, c2));
create index t12i1 on t12(c2);
create index t12i2 on t12(c3);
explain extended_noaddr select 1 from t10 where c1 < 0 and c1 > 0 and c2 = 1;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t10(t10i1)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter([t10.c2 = 1]), rowset=16
      access([t10.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t10.c1], [t10.c2], [t10.c3], [t10.pk]), range(MAX,MAX,MAX,MAX ; MIN,MIN,MIN,MIN)always false, 
      range_cond([t10.c1 < 0], [t10.c1 > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "hualong"."t10"@"SEL$1" "t10i1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      pruned_index_name:[t10i3]
      unstable_index_name:[t10]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t10 where c2 < 0 and c2 > 0 and c3 = 1;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t10(t10i2)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter([t10.c3 = 1]), rowset=16
      access([t10.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t10.c2], [t10.c3], [t10.pk]), range(MAX,MAX,MAX ; MIN,MIN,MIN)always false, 
      range_cond([t10.c2 < 0], [t10.c2 > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "hualong"."t10"@"SEL$1" "t10i2")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      unstable_index_name:[t10]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t10 where c3 < 0 and c3 > 0 and c2 = 1;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t10(t10i2)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t10.c2], [t10.c3], [t10.pk]), range(MAX,MAX,MAX ; MIN,MIN,MIN)always false, 
      range_cond([t10.c3 < 0], [t10.c3 > 0], [t10.c2 = 1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "hualong"."t10"@"SEL$1" "t10i2")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      pruned_index_name:[t10i3]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t10 where c2 < 0 and c2 > 0 and c4 = 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|t10 |0       |3           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter([t10.c2 < 0], [t10.c2 > 0], [t10.c4 = 2]), rowset=16
      access([t10.c2], [t10.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([t10.pk]), range(MIN ; MAX)always true
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t10"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      pruned_index_name:[t10i3]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 2
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t10 where c3 < 0 and c3 > 0 and c4 = 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|t10 |0       |3           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter([t10.c3 < 0], [t10.c3 > 0], [t10.c4 = 2]), rowset=16
      access([t10.c3], [t10.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([t10.pk]), range(MIN ; MAX)always true
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t10"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 2
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t10 where c2 < 0 and c2 > 0 and c3 = 1 order by c2;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t10(t10i2)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter([t10.c3 = 1]), rowset=16
      access([t10.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t10.c2], [t10.c3], [t10.pk]), range(MAX,MAX,MAX ; MIN,MIN,MIN)always false, 
      range_cond([t10.c2 < 0], [t10.c2 > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "hualong"."t10"@"SEL$1" "t10i2")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      pruned_index_name:[t10i1]
      unstable_index_name:[t10]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t10 where c3 < 0 and c3 > 0 and c2 = 1 order by c3;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t10(t10i2)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t10.c2], [t10.c3], [t10.pk]), range(MAX,MAX,MAX ; MIN,MIN,MIN)always false, 
      range_cond([t10.c3 < 0], [t10.c3 > 0], [t10.c2 = 1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "hualong"."t10"@"SEL$1" "t10i2")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      pruned_index_name:[t10i1, t10i3]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t10 where c2 < 0 and c2 > 0 and c4 = 2 order by c1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SORT             |    |0       |3           |
|1 |└─TABLE FULL SCAN|t10 |0       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      sort_keys([t10.c1, ASC])
  1 - output([t10.c1]), filter([t10.c2 < 0], [t10.c2 > 0], [t10.c4 = 2]), rowset=16
      access([t10.c2], [t10.c4], [t10.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([t10.pk]), range(MIN ; MAX)always true
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t10"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      pruned_index_name:[t10i2, t10i3]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 2
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t10 where c3 < 0 and c3 > 0 and c4 = 2 order by c2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SORT             |    |0       |3           |
|1 |└─TABLE FULL SCAN|t10 |0       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      sort_keys([t10.c2, ASC])
  1 - output([t10.c2]), filter([t10.c3 < 0], [t10.c3 > 0], [t10.c4 = 2]), rowset=16
      access([t10.c3], [t10.c4], [t10.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([t10.pk]), range(MIN ; MAX)always true
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t10"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      pruned_index_name:[t10i1, t10i3]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 2
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t10 where c3 < 0 and c3 > 0 and c4 = 2 order by c3;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SORT             |    |0       |3           |
|1 |└─TABLE FULL SCAN|t10 |0       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      sort_keys([t10.c3, ASC])
  1 - output([t10.c3]), filter([t10.c3 < 0], [t10.c3 > 0], [t10.c4 = 2]), rowset=16
      access([t10.c3], [t10.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([t10.pk]), range(MIN ; MAX)always true
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t10"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t10:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t10i1, t10i2, t10i3, t10]
      pruned_index_name:[t10i1, t10i2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 2
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t11 where pk < 0 and pk > 0;
Query Plan
================================================
|ID|OPERATOR        |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
|0 |TABLE RANGE SCAN|t11 |0       |3           |
================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t11.pk]), range(MAX ; MIN)always false, 
      range_cond([t11.pk < 0], [t11.pk > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t11"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t11 where c1 < 0 and c1 > 0;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t11(t11i1)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1], [t11.pk]), range(MAX,MAX ; MIN,MIN)always false, 
      range_cond([t11.c1 < 0], [t11.c1 > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "hualong"."t11"@"SEL$1" "t11i1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t11 where pk < 0 and pk > 0 and c2 = 1;
Query Plan
================================================
|ID|OPERATOR        |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
|0 |TABLE RANGE SCAN|t11 |0       |3           |
================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter([t11.c2 = 1]), rowset=16
      access([t11.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t11.pk]), range(MAX ; MIN)always false, 
      range_cond([t11.pk < 0], [t11.pk > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t11"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      pruned_index_name:[t11i1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t11 where pk < 0 and pk > 0 and c2 = 1 order by pk;
Query Plan
================================================
|ID|OPERATOR        |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
|0 |TABLE RANGE SCAN|t11 |0       |3           |
================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter([t11.c2 = 1]), rowset=16
      access([t11.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t11.pk]), range(MAX ; MIN)always false, 
      range_cond([t11.pk < 0], [t11.pk > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t11"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      pruned_index_name:[t11i1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t11 where pk < 0 and pk > 0 and c2 = 1 order by c1;
Query Plan
==================================================
|ID|OPERATOR          |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
|0 |SORT              |    |0       |3           |
|1 |└─TABLE RANGE SCAN|t11 |0       |3           |
==================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      sort_keys([t11.c1, ASC])
  1 - output([t11.c1]), filter([t11.c2 = 1]), rowset=16
      access([t11.c2], [t11.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t11.pk]), range(MAX ; MIN)always false, 
      range_cond([t11.pk < 0], [t11.pk > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t11"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t11 where pk < 0 and pk > 0 and c2 = 1 order by c2;
Query Plan
================================================
|ID|OPERATOR        |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
|0 |TABLE RANGE SCAN|t11 |0       |3           |
================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter([t11.c2 = 1]), rowset=16
      access([t11.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t11.pk]), range(MAX ; MIN)always false, 
      range_cond([t11.pk < 0], [t11.pk > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1 > SEL$E230E5BA
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$E230E5BA" "hualong"."t11"@"SEL$1")
      REPLACE_CONST(@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      pruned_index_name:[t11i1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
  Expr Constraints:
      cast(1, INT(11, 0)) = 1 result is TRUE
explain extended_noaddr select 1 from t11 where pk < 0 and pk > 0 and c1 = 1;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t11(t11i1)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1], [t11.pk]), range(MAX,MAX ; MIN,MIN)always false, 
      range_cond([t11.pk < 0], [t11.pk > 0], [t11.c1 = 1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "hualong"."t11"@"SEL$1" "t11i1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t11 where pk < 0 and pk > 0 and c1 = 1 order by pk;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t11(t11i1)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1], [t11.pk]), range(MAX,MAX ; MIN,MIN)always false, 
      range_cond([t11.pk < 0], [t11.pk > 0], [t11.c1 = 1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "hualong"."t11"@"SEL$1" "t11i1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      pruned_index_name:[t11]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t11 where pk < 0 and pk > 0 and c1 = 1 order by c1;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t11(t11i1)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t11.c1], [t11.pk]), range(MAX,MAX ; MIN,MIN)always false, 
      range_cond([t11.pk < 0], [t11.pk > 0], [t11.c1 = 1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1 > SEL$E230E5BA
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$E230E5BA" "hualong"."t11"@"SEL$1" "t11i1")
      REPLACE_CONST(@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
  Expr Constraints:
      cast(1, INT(11, 0)) = 1 result is TRUE
explain extended_noaddr select 1 from t11 where pk < 0 and pk > 0 and c1 = 1 order by c2;
Query Plan
==================================================
|ID|OPERATOR          |NAME|EST.ROWS|EST.TIME(us)|
--------------------------------------------------
|0 |SORT              |    |0       |3           |
|1 |└─TABLE RANGE SCAN|t11 |0       |3           |
==================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      sort_keys([t11.c2, ASC])
  1 - output([t11.c2]), filter([t11.c1 = 1]), rowset=16
      access([t11.c1], [t11.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t11.pk]), range(MAX ; MIN)always false, 
      range_cond([t11.pk < 0], [t11.pk > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t11"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t11:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t11i1, t11]
      pruned_index_name:[t11i1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t12 where c2 < 0 and c2 > 0;
Query Plan
======================================================
|ID|OPERATOR        |NAME      |EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |TABLE RANGE SCAN|t12(t12i1)|0       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t12.c2], [t12.c1]), range(MAX,MAX ; MIN,MIN)always false, 
      range_cond([t12.c2 < 0], [t12.c2 > 0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "hualong"."t12"@"SEL$1" "t12i1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t12:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t12i1, t12i2, t12]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select * from t12 where c2 < 0 and c2 > 0;
Query Plan
================================================
|ID|OPERATOR        |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
|0 |TABLE RANGE SCAN|t12 |0       |3           |
================================================
Outputs & filters:
-------------------------------------
  0 - output([t12.c1], [t12.c2], [t12.c3], [t12.c4]), filter([t12.c2 < 0], [t12.c2 > 0]), rowset=16
      access([t12.c1], [t12.c2], [t12.c3], [t12.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t12.c1], [t12.c2]), range(MAX,MAX ; MIN,MIN)always false
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t12"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t12:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t12i1, t12i2, t12]
      pruned_index_name:[t12i1, t12i2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 0
      :1 => 0
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select 1 from t12 where c2 < 0 and c2 > 0 and c3 = 1;
Query Plan
================================================
|ID|OPERATOR        |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
|0 |TABLE RANGE SCAN|t12 |0       |3           |
================================================
Outputs & filters:
-------------------------------------
  0 - output([1]), filter([t12.c2 < 0], [t12.c2 > 0], [t12.c3 = 1]), rowset=16
      access([t12.c2], [t12.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([t12.c1], [t12.c2]), range(MAX,MAX ; MIN,MIN)always false
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t12"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t12:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t12i1, t12i2, t12]
      pruned_index_name:[t12i1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 1
      :1 => 0
      :2 => 0
      :3 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
explain extended_noaddr select * from t12 where c2 < 0 and c2 > 0 and c3 = 1;
Query Plan
================================================
|ID|OPERATOR        |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------
|0 |TABLE RANGE SCAN|t12 |0       |3           |
================================================
Outputs & filters:
-------------------------------------
  0 - output([t12.c1], [t12.c2], [t12.c3], [t12.c4]), filter([t12.c2 < 0], [t12.c2 > 0], [t12.c3 = 1]), rowset=16
      access([t12.c1], [t12.c2], [t12.c3], [t12.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([t12.c1], [t12.c2]), range(MAX,MAX ; MIN,MIN)always false
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hualong"."t12"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t12:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t12i1, t12i2, t12]
      pruned_index_name:[t12i1, t12i2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      LOCAL
  Parameters:
      :0 => 0
      :1 => 0
      :2 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
set @@recyclebin = 'off';
drop database hualong;
