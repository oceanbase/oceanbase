drop database if exists cte_st;
create database cte_st;
use cte_st;
result_format: 4
create table disemp (
  EMPno  number,
  ENAME varchar(30),
  JOB varchar(30) ,
  MGR number(4),
  HIREDATE date,
  SAL number(7,2),
  COMM number(7,2),
  DEPTNO number(2)
);

INSERT INTO disemp values (7369,'SMITH','CLERK',7902,    str_to_date('1980-11-17','%Y-%m-%d'),800,NULL, 20) ;
INSERT INTO disemp VALUES (7499, 'ALLEN','SALESMAN',7698,str_to_date('1981-01-20','%Y-%m-%d'),1600,300,30) ;
INSERT INTO disemp VALUES (7521,'WARD','SALESMAN',7698,  str_to_date('1981-01-22','%Y-%m-%d'),1250, 500, 30) ;
INSERT INTO disemp VALUES (7566,'JONES','MANAGER',7839,  str_to_date('1981-04-02','%Y-%m-%d'), 2975, NULL, 20) ;
INSERT INTO disemp VALUES (7654,'MARTIN','SALESMAN', 7698, str_to_date('1981-09-28','%Y-%m-%d'), 1250, 1400, 30) ;
INSERT INTO disemp VALUES (7698, 'BLAKE','MANAGER', 7839,  str_to_date('1981-03-01','%Y-%m-%d'), 2850, NULL, 30) ;
INSERT INTO disemp VALUES (7782, 'CLARK','MANAGER', 7839,  str_to_date('1981-06-09','%Y-%m-%d'), 2450, NULL, 10) ;
insert into disemp values (7788,'SCOTT','ANALYST', 7566,   str_to_date('1987-04-19','%Y-%m-%d'), 3000, null, 20) ;
INSERT INTO disemp VALUES (7839, 'KING','PRESIDENT', NULL, str_to_date('1981-11-17','%Y-%m-%d'), 5000, NULL, 10) ;
INSERT INTO disemp VALUES (7844, 'TURNER','SALESMAN', 7698, str_to_date('1981-09-08','%Y-%m-%d'), 1500, 0, 30) ;
INSERT INTO disemp VALUES(7876, 'ADAMS','CLERK', 7788,     str_to_date('1987-05-23','%Y-%m-%d'), 1100, NULL, 20) ;
INSERT INTO disemp VALUES(7900, 'JAMES', 'CLEARK', 7698,   str_to_date('1981-11-03','%Y-%m-%d'), 950, NULL, 30) ;
INSERT INTO disemp VALUES(7902, 'FORD','ANALYST',7566,     str_to_date('1981-11-03','%Y-%m-%d'), 3000, NULL, 20) ;
INSERT INTO disemp VALUES(7934,'MILLER','CLERK', 7782,     str_to_date('1982-01-23','%Y-%m-%d'), 1300,NULL, 10) ;

create table EMP (
  EMPno  number,
  ENAME varchar(30),
  JOB varchar(30),
  MGR number(4),
  HIREDATE date,
  SAL number(7,2),
  COMM number(7,2),
  DEPTNO number(2)
);

insert into EMP values (7369,'SMITH','CLERK',7902,    str_to_date('1980-12-17','%Y-%m-%d'),800,NULL, 20) ;
INSERT INTO EMP VALUES (7499, 'ALLEN','SALESMAN',7698,str_to_date('1981-02-20','%Y-%m-%d'),1600,300,30) ;
INSERT INTO EMP VALUES (7521,'WARD','SALESMAN',7698,  str_to_date('1981-02-22','%Y-%m-%d'),1250, 500, 30) ;
INSERT INTO EMP VALUES (7566,'JONES','MANAGER',7839,  str_to_date('1981-08-02','%Y-%m-%d'), 2975, NULL, 20) ;
INSERT INTO EMP VALUES (7654,'MARTIN','SALESMAN', 7698, str_to_date('1981-09-28','%Y-%m-%d'), 1250, 1400, 30) ;
INSERT INTO EMP VALUES (7698, 'BLAKE','MANAGER', 7839,  str_to_date('1981-05-01','%Y-%m-%d'), 2850, NULL, 30) ;
INSERT INTO EMP VALUES (7782, 'CLARK','MANAGER', 7839,  str_to_date('1981-06-09','%Y-%m-%d'), 2450, NULL, 10) ;
insert into EMP values (7788,'SCOTT','ANALYST', 7566,   str_to_date('1987-08-19','%Y-%m-%d'), 3000, null, 20) ;
INSERT INTO EMP VALUES (7839, 'KING','PRESIDENT', NULL, str_to_date('1981-11-17','%Y-%m-%d'), 5000, NULL, 10) ;
INSERT INTO EMP VALUES (7844, 'TURNER','SALESMAN', 7698, str_to_date('1981-09-08','%Y-%m-%d'), 1500, 0, 30) ;
INSERT INTO EMP VALUES(7876, 'ADAMS','CLERK', 7788,     str_to_date('1987-05-23','%Y-%m-%d'), 1100, NULL, 20) ;
INSERT INTO EMP VALUES(7900, 'JAMES', 'CLEARK', 7698,   str_to_date('1981-12-03','%Y-%m-%d'), 950, NULL, 30) ;
INSERT INTO EMP VALUES(7902, 'FORD','ANALYST',7566,     str_to_date('1981-12-03','%Y-%m-%d'), 3000, NULL, 20) ;
INSERT INTO EMP VALUES(7934,'MILLER','CLERK', 7782,     str_to_date('1982-06-23','%Y-%m-%d'), 1300,NULL, 10) ;

CREATE TABLE emp1 (
  empno    VARCHAR(4000) NOT NULL,
  ename    VARCHAR(14),
  job      VARCHAR(9),
  mgr      VARCHAR(4000),
  hiredate DATE,
  sal      NUMBER(7,2),
  comm     NUMBER(7,2),
  deptno   NUMBER(2));

INSERT INTO emp1 values (7369, 'SMITH', 'CLERK', 7902, str_to_date('1980-12-17', '%Y-%m-%d'), 800, null, 20);
INSERT INTO emp1 values (7499, 'ALLEN', 'SALESMAN', 7698, str_to_date('1981-02-20', '%Y-%m-%d'), 1600, 300, 30);
INSERT INTO emp1 values (7521, 'WARD', 'SALESMAN', 7698, str_to_date('1981-02-22', '%Y-%m-%d'), 1250, 500, 30);
INSERT INTO emp1 values (7566, 'JONES', 'MANAGER', 7839, str_to_date('1981-08-02', '%Y-%m-%d'), 2975, null, 20);
INSERT INTO emp1 values (7654, 'MARTIN', 'SALESMAN', 7698, str_to_date('1981-09-28', '%Y-%m-%d'), 1250, 1400, 30);
INSERT INTO emp1 values (7698, 'BLAKE', 'MANAGER', 7839, str_to_date('1981-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (7782, 'CLARK', 'MANAGER', 7839, str_to_date('1981-06-09' , '%Y-%m-%d'), 2450, null, 10);
INSERT INTO emp1 values (7788, 'SCOTT', 'ANALYST', 7566, str_to_date('1987-08-19', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7839, 'KING', 'PRESIDENT', null, str_to_date('1981-11-17', '%Y-%m-%d'), 5000, null, 10);
INSERT INTO emp1 values (7844, 'TURNER', 'SALESMAN', 7698, str_to_date('1981-09-08', '%Y-%m-%d'), 1500, 0, 30);
INSERT INTO emp1 values (7876, 'ADAMS', 'CLERK', 7788, str_to_date('1987-05-23', '%Y-%m-%d'), 1100, null, 20);
INSERT INTO emp1 values (7900, 'JAMES', 'CLERK', 7698, str_to_date('1981-12-03', '%Y-%m-%d'), 950, null, 30);
INSERT INTO emp1 values (7902, 'FORD', 'ANALYST', 7566, str_to_date('1981-12-03', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7934, 'MILLER', 'CLERK', 7782, str_to_date('1982-01-23', '%Y-%m-%d'), 1300, null, 10);
INSERT INTO emp1 values (8100, 'Eve', 'MANAGER', 7839, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8101, 'Eve1', 'MANAGER', 8100, str_to_date('1984-05-01','%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8108, 'Eve8', 'CLERK', 8101, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);

create table dsemp (id int, name varchar(20), leaderid int) partition by hash (id) partitions 3;
insert into dsemp values(1, 'A', '0');
insert into dsemp values(2, 'AA', '1');
insert into dsemp values(3, 'AB', '1');
insert into dsemp values(4, 'ABA', '3');
insert into dsemp values(5, 'AAA', '2');
insert into dsemp values(6, 'ABB', '3');
insert into dsemp values(7, 'AAA', '5');
insert into dsemp values(8, 'AAA', '7');
insert into dsemp values(9, 'AAAA', '5');
insert into dsemp values(10, 'AAAB', '5');
insert into dsemp values(11, 'AAAC', '5');
insert into dsemp values(12, 'AAAA', '5');

create table dsemp1 (id int, name varchar(20), leaderid int) partition by hash (leaderid) partitions 3;
insert into dsemp1 values(1, 'A', '0');
insert into dsemp1 values(2, 'AA', '1');
insert into dsemp1 values(3, 'AB', '1');
insert into dsemp1 values(4, 'ABA', '3');
insert into dsemp1 values(5, 'AAA', '2');
insert into dsemp1 values(6, 'ABB', '3');
insert into dsemp1 values(7, 'AAA', '5');
insert into dsemp1 values(8, 'AAA', '7');
insert into dsemp1 values(9, 'AAAA', '5');
insert into dsemp1 values(10, 'AAAB', '5');
insert into dsemp1 values(11, 'AAAC', '5');
insert into dsemp1 values(12, 'AAAA', '5');

result_format: 4

##############################
##   section 1  聚合一张表是分布式表（disemp）
##   section 2  聚合的两表是分布式表（disemp，emp1）
##   section 3  聚合的两表在join条件上可能形成wise join（disemp，emp1）
##   section 4  额外添加recursive member变化
##############################

##############################
##   section 1  聚合一张表是分布式表（disemp）
##############################
## =======================================================================
## Test Case 1:
## - recursive with RECURSIVE Query: Nested Loop Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |66          |
|1 | RECURSIVE UNION ALL|    |200     |66          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  NESTED-LOOP JOIN  |    |199     |61          |
|4 |   TABLE SCAN       |r   |199     |1           |
|5 |   MATERIAL         |    |14      |7           |
|6 |    TABLE SCAN      |e   |14      |5           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([r.empno = e.MGR]), nl_params_(nil), batch_join=false
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 2:
## - recursive with RECURSIVE Query: SORT MERGE Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |129         |
|1 | RECURSIVE UNION ALL|    |200     |129         |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  MERGE JOIN        |    |199     |124         |
|4 |   MATERIAL         |    |14      |9           |
|5 |    SORT            |    |14      |8           |
|6 |     TABLE SCAN     |e   |14      |5           |
|7 |   SORT             |    |199     |107         |
|8 |    TABLE SCAN      |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
      merge_directions([ASC])
  4 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      sort_keys([e.MGR, ASC])
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  7 - output([r.empno]), filter(nil), rowset=256
      sort_keys([r.empno, ASC])
  8 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 3:
## - recursive with RECURSIVE Query: Hash Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 4:
## - recursive with RECURSIVE Query: Join in Initialisation Branch
## 与oracle的结果顺序不一样
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |213     |58          |
|1 | RECURSIVE UNION ALL|    |213     |57          |
|2 |  NESTED-LOOP JOIN  |    |14      |14          |
|3 |   TABLE SCAN       |e   |14      |5           |
|4 |   MATERIAL         |    |14      |5           |
|5 |    TABLE SCAN      |d   |14      |5           |
|6 |  HASH JOIN         |    |199     |44          |
|7 |   MATERIAL         |    |14      |15          |
|8 |    HASH JOIN       |    |14      |14          |
|9 |     TABLE SCAN     |d   |14      |5           |
|10|     TABLE SCAN     |e   |14      |5           |
|11|   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([e.SAL = d.SAL]), nl_params_(nil), batch_join=false
  3 - output([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      access([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  4 - output([d.SAL]), filter(nil), rowset=256
  5 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
  6 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  7 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  8 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.SAL = d.SAL]), other_conds(nil)
  9 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
 10 - output([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| BLAKE  |  7698 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| CLARK  |  7782 | 7839 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JONES  |  7566 | 7839 |
| JONES  |  7566 | 7839 |
| KING   |  7839 | NULL |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
+--------+-------+------+

## =======================================================================
## Test Case 6:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on build side and fits in memory
## 与oracle顺序不一致
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 7:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on probe side and fits in memory
## =======================================================================
explain  
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## 测试8-15都是在测试join的顺序或者hint的顺序
## Test Case 8:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp >< emp1 
## =======================================================================
explain  
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |477         |
|1 | SUBPLAN SCAN        |rw  |787     |241         |
|2 |  RECURSIVE UNION ALL|    |787     |239         |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |213         |
|9 |    HASH JOIN        |    |199     |121         |
|10|     TABLE SCAN      |r   |199     |1           |
|11|     TABLE SCAN      |e   |5       |5           |
|12|    TABLE SCAN       |n   |17      |5           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [r.iters], [r.sal], [e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno]), other_conds(nil)
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 9:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump >< emp1 
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |389         |
|1 | SUBPLAN SCAN        |rw  |787     |153         |
|2 |  RECURSIVE UNION ALL|    |787     |151         |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |124         |
|9 |    HASH JOIN        |    |199     |33          |
|10|     TABLE SCAN      |e   |5       |5           |
|11|     TABLE SCAN      |r   |199     |1           |
|12|    TABLE SCAN       |n   |17      |5           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 10 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 10:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< emp1 >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |327         |
|1 | SUBPLAN SCAN        |rw  |787     |91          |
|2 |  RECURSIVE UNION ALL|    |787     |89          |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |63          |
|9 |    MATERIAL         |    |17      |14          |
|10|     HASH JOIN       |    |17      |13          |
|11|      TABLE SCAN     |e   |5       |5           |
|12|      TABLE SCAN     |n   |17      |5           |
|13|    TABLE SCAN       |r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 11:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< disemp >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |330         |
|1 | SUBPLAN SCAN        |rw  |787     |94          |
|2 |  RECURSIVE UNION ALL|    |787     |92          |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |65          |
|9 |    MATERIAL         |    |17      |17          |
|10|     HASH JOIN       |    |17      |16          |
|11|      TABLE SCAN     |n   |17      |5           |
|12|      TABLE SCAN     |e   |5       |5           |
|13|    TABLE SCAN       |r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 11 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 12 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 12:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |128         |
|1 | RECURSIVE UNION ALL|    |200     |127         |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |122         |
|4 |   TABLE SCAN       |r   |199     |1           |
|5 |   TABLE SCAN       |e   |14      |5           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 13:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 14:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===============================================================
|ID|OPERATOR                       |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT                           |    |787     |1854        |
|1 | SUBPLAN SCAN                  |rw  |787     |1618        |
|2 |  RECURSIVE UNION ALL          |    |787     |1616        |
|3 |   HASH JOIN                   |    |62      |25          |
|4 |    HASH JOIN                  |    |17      |13          |
|5 |     TABLE SCAN                |e   |5       |5           |
|6 |     TABLE SCAN                |n1  |17      |5           |
|7 |    TABLE SCAN                 |n2  |17      |5           |
|8 |   HASH JOIN                   |    |725     |1590        |
|9 |    NESTED-LOOP JOIN CARTESIAN |    |3383    |94          |
|10|     TABLE SCAN                |r   |199     |1           |
|11|     MATERIAL                  |    |17      |7           |
|12|      TABLE SCAN               |n   |17      |5           |
|13|    TABLE SCAN                 |e   |5       |5           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR], [r.mgr = e.EMPno]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), batch_join=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 15:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< emp1 >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===============================================================
|ID|OPERATOR                       |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT                           |    |787     |1854        |
|1 | SUBPLAN SCAN                  |rw  |787     |1618        |
|2 |  RECURSIVE UNION ALL          |    |787     |1616        |
|3 |   HASH JOIN                   |    |62      |25          |
|4 |    HASH JOIN                  |    |17      |13          |
|5 |     TABLE SCAN                |e   |5       |5           |
|6 |     TABLE SCAN                |n1  |17      |5           |
|7 |    TABLE SCAN                 |n2  |17      |5           |
|8 |   HASH JOIN                   |    |725     |1590        |
|9 |    NESTED-LOOP JOIN CARTESIAN |    |3383    |94          |
|10|     TABLE SCAN                |r   |199     |1           |
|11|     MATERIAL                  |    |17      |7           |
|12|      TABLE SCAN               |n   |17      |5           |
|13|    TABLE SCAN                 |e   |5       |5           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno], [cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), batch_join=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 16:
## - recursive with RECURSIVE Query: Join Skew handling. No local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 17:
## - recursive with RECURSIVE Query: Join Skew handling with RECURSIVE an additional local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |39          |
|1 | RECURSIVE UNION ALL|    |200     |38          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |33          |
|4 |   TABLE SCAN       |e   |5       |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.EMPno], [e.ENAME]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.ENAME]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
+--------+-------+------+

##############################
##   section 2  聚合的两表是分布式表（disemp，emp1）
##############################
##  
##  emp1 也进行分布式化
drop table emp1;
CREATE TABLE emp1 (
   empno    VARCHAR(4000) NOT NULL,
   ename    VARCHAR(14),
   job      VARCHAR(9),
   mgr      VARCHAR(4000),
   hiredate DATE,
   sal      NUMBER(7,2),
   comm     NUMBER(7,2),
   deptno   NUMBER(2)
);

INSERT INTO emp1 values (7369, 'SMITH', 'CLERK', 7902, str_to_date('1980-12-17', '%Y-%m-%d'), 800, null, 20);
INSERT INTO emp1 values (7499, 'ALLEN', 'SALESMAN', 7698, str_to_date('1981-02-20', '%Y-%m-%d'), 1600, 300, 30);
INSERT INTO emp1 values (7521, 'WARD', 'SALESMAN', 7698, str_to_date('1981-02-22', '%Y-%m-%d'), 1250, 500, 30);
INSERT INTO emp1 values (7566, 'JONES', 'MANAGER', 7839, str_to_date('1981-08-02', '%Y-%m-%d'), 2975, null, 20);
INSERT INTO emp1 values (7654, 'MARTIN', 'SALESMAN', 7698, str_to_date('1981-09-28', '%Y-%m-%d'), 1250, 1400, 30);
INSERT INTO emp1 values (7698, 'BLAKE', 'MANAGER', 7839, str_to_date('1981-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (7782, 'CLARK', 'MANAGER', 7839, str_to_date('1981-06-09' , '%Y-%m-%d'), 2450, null, 10);
INSERT INTO emp1 values (7788, 'SCOTT', 'ANALYST', 7566, str_to_date('1987-08-19', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7839, 'KING', 'PRESIDENT', null, str_to_date('1981-11-17', '%Y-%m-%d'), 5000, null, 10);
INSERT INTO emp1 values (7844, 'TURNER', 'SALESMAN', 7698, str_to_date('1981-09-08', '%Y-%m-%d'), 1500, 0, 30);
INSERT INTO emp1 values (7876, 'ADAMS', 'CLERK', 7788, str_to_date('1987-05-23', '%Y-%m-%d'), 1100, null, 20);
INSERT INTO emp1 values (7900, 'JAMES', 'CLERK', 7698, str_to_date('1981-12-03', '%Y-%m-%d'), 950, null, 30);
INSERT INTO emp1 values (7902, 'FORD', 'ANALYST', 7566, str_to_date('1981-12-03', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7934, 'MILLER', 'CLERK', 7782, str_to_date('1982-01-23', '%Y-%m-%d'), 1300, null, 10);
INSERT INTO emp1 values (8100, 'Eve', 'MANAGER', 7839, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8101, 'Eve1', 'MANAGER', 8100, str_to_date('1984-05-01','%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8108, 'Eve8', 'CLERK', 8101, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);

## =======================================================================
## Test Case 1:
## - recursive with RECURSIVE Query: Nested Loop Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |66          |
|1 | RECURSIVE UNION ALL|    |200     |66          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  NESTED-LOOP JOIN  |    |199     |61          |
|4 |   TABLE SCAN       |r   |199     |1           |
|5 |   MATERIAL         |    |14      |7           |
|6 |    TABLE SCAN      |e   |14      |5           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([r.empno = e.MGR]), nl_params_(nil), batch_join=false
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 2:
## - recursive with RECURSIVE Query: SORT MERGE Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |129         |
|1 | RECURSIVE UNION ALL|    |200     |129         |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  MERGE JOIN        |    |199     |124         |
|4 |   MATERIAL         |    |14      |9           |
|5 |    SORT            |    |14      |8           |
|6 |     TABLE SCAN     |e   |14      |5           |
|7 |   SORT             |    |199     |107         |
|8 |    TABLE SCAN      |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
      merge_directions([ASC])
  4 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      sort_keys([e.MGR, ASC])
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  7 - output([r.empno]), filter(nil), rowset=256
      sort_keys([r.empno, ASC])
  8 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 3:
## - recursive with RECURSIVE Query: Hash Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 4:
## - recursive with RECURSIVE Query: Join in Initialisation Branch
## 与oracle的结果顺序不一样
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |213     |58          |
|1 | RECURSIVE UNION ALL|    |213     |57          |
|2 |  NESTED-LOOP JOIN  |    |14      |14          |
|3 |   TABLE SCAN       |e   |14      |5           |
|4 |   MATERIAL         |    |14      |5           |
|5 |    TABLE SCAN      |d   |14      |5           |
|6 |  HASH JOIN         |    |199     |44          |
|7 |   MATERIAL         |    |14      |15          |
|8 |    HASH JOIN       |    |14      |14          |
|9 |     TABLE SCAN     |d   |14      |5           |
|10|     TABLE SCAN     |e   |14      |5           |
|11|   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([e.SAL = d.SAL]), nl_params_(nil), batch_join=false
  3 - output([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      access([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  4 - output([d.SAL]), filter(nil), rowset=256
  5 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
  6 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  7 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  8 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.SAL = d.SAL]), other_conds(nil)
  9 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
 10 - output([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| BLAKE  |  7698 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| CLARK  |  7782 | 7839 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JONES  |  7566 | 7839 |
| JONES  |  7566 | 7839 |
| KING   |  7839 | NULL |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
+--------+-------+------+

## =======================================================================
## Test Case 6:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on build side and fits in memory
## 与oracle顺序不一致
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 7:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on probe side and fits in memory
## =======================================================================
explain  
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## 测试8-15都是在测试join的顺序或者hint的顺序
## Test Case 8:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp >< emp1 
## =======================================================================
explain  
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |477         |
|1 | SUBPLAN SCAN        |rw  |787     |241         |
|2 |  RECURSIVE UNION ALL|    |787     |239         |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |213         |
|9 |    HASH JOIN        |    |199     |121         |
|10|     TABLE SCAN      |r   |199     |1           |
|11|     TABLE SCAN      |e   |5       |5           |
|12|    TABLE SCAN       |n   |17      |5           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [r.iters], [r.sal], [e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno]), other_conds(nil)
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 9:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump >< emp1 
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |389         |
|1 | SUBPLAN SCAN        |rw  |787     |153         |
|2 |  RECURSIVE UNION ALL|    |787     |151         |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |124         |
|9 |    HASH JOIN        |    |199     |33          |
|10|     TABLE SCAN      |e   |5       |5           |
|11|     TABLE SCAN      |r   |199     |1           |
|12|    TABLE SCAN       |n   |17      |5           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 10 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 10:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< emp1 >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |327         |
|1 | SUBPLAN SCAN        |rw  |787     |91          |
|2 |  RECURSIVE UNION ALL|    |787     |89          |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |63          |
|9 |    MATERIAL         |    |17      |14          |
|10|     HASH JOIN       |    |17      |13          |
|11|      TABLE SCAN     |e   |5       |5           |
|12|      TABLE SCAN     |n   |17      |5           |
|13|    TABLE SCAN       |r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 11:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< disemp >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |330         |
|1 | SUBPLAN SCAN        |rw  |787     |94          |
|2 |  RECURSIVE UNION ALL|    |787     |92          |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |65          |
|9 |    MATERIAL         |    |17      |17          |
|10|     HASH JOIN       |    |17      |16          |
|11|      TABLE SCAN     |n   |17      |5           |
|12|      TABLE SCAN     |e   |5       |5           |
|13|    TABLE SCAN       |r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 11 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 12 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

##oracle ok
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 12:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |128         |
|1 | RECURSIVE UNION ALL|    |200     |127         |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |122         |
|4 |   TABLE SCAN       |r   |199     |1           |
|5 |   TABLE SCAN       |e   |14      |5           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 13:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT /*+log_level(DEBUG)*/ ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 14:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===============================================================
|ID|OPERATOR                       |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT                           |    |787     |1854        |
|1 | SUBPLAN SCAN                  |rw  |787     |1618        |
|2 |  RECURSIVE UNION ALL          |    |787     |1616        |
|3 |   HASH JOIN                   |    |62      |25          |
|4 |    HASH JOIN                  |    |17      |13          |
|5 |     TABLE SCAN                |e   |5       |5           |
|6 |     TABLE SCAN                |n1  |17      |5           |
|7 |    TABLE SCAN                 |n2  |17      |5           |
|8 |   HASH JOIN                   |    |725     |1590        |
|9 |    NESTED-LOOP JOIN CARTESIAN |    |3383    |94          |
|10|     TABLE SCAN                |r   |199     |1           |
|11|     MATERIAL                  |    |17      |7           |
|12|      TABLE SCAN               |n   |17      |5           |
|13|    TABLE SCAN                 |e   |5       |5           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR], [r.mgr = e.EMPno]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), batch_join=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 15:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< emp1 >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===============================================================
|ID|OPERATOR                       |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT                           |    |787     |1854        |
|1 | SUBPLAN SCAN                  |rw  |787     |1618        |
|2 |  RECURSIVE UNION ALL          |    |787     |1616        |
|3 |   HASH JOIN                   |    |62      |25          |
|4 |    HASH JOIN                  |    |17      |13          |
|5 |     TABLE SCAN                |e   |5       |5           |
|6 |     TABLE SCAN                |n1  |17      |5           |
|7 |    TABLE SCAN                 |n2  |17      |5           |
|8 |   HASH JOIN                   |    |725     |1590        |
|9 |    NESTED-LOOP JOIN CARTESIAN |    |3383    |94          |
|10|     TABLE SCAN                |r   |199     |1           |
|11|     MATERIAL                  |    |17      |7           |
|12|      TABLE SCAN               |n   |17      |5           |
|13|    TABLE SCAN                 |e   |5       |5           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno], [cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), batch_join=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 16:
## - recursive with RECURSIVE Query: Join Skew handling. No local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 17:
## - recursive with RECURSIVE Query: Join Skew handling with RECURSIVE an additional local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |39          |
|1 | RECURSIVE UNION ALL|    |200     |38          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |33          |
|4 |   TABLE SCAN       |e   |5       |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.EMPno], [e.ENAME]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.ENAME]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
+--------+-------+------+

##############################
##   section 3  聚合的两表在join条件上可能形成wise join（disemp，emp1）
##############################
##
##  emp1 也进行分布式化
drop table emp1;
CREATE TABLE emp1 (
   empno    VARCHAR(4000) NOT NULL,
   ename    VARCHAR(14),
   job      VARCHAR(9),
   mgr      VARCHAR(4000),
   hiredate DATE,
   sal      NUMBER(7,2),
   comm     NUMBER(7,2),
   deptno   NUMBER(2)
);

INSERT INTO emp1 values (7369, 'SMITH', 'CLERK', 7902, str_to_date('1980-12-17', '%Y-%m-%d'), 800, null, 20);
INSERT INTO emp1 values (7499, 'ALLEN', 'SALESMAN', 7698, str_to_date('1981-02-20', '%Y-%m-%d'), 1600, 300, 30);
INSERT INTO emp1 values (7521, 'WARD', 'SALESMAN', 7698, str_to_date('1981-02-22', '%Y-%m-%d'), 1250, 500, 30);
INSERT INTO emp1 values (7566, 'JONES', 'MANAGER', 7839, str_to_date('1981-08-02', '%Y-%m-%d'), 2975, null, 20);
INSERT INTO emp1 values (7654, 'MARTIN', 'SALESMAN', 7698, str_to_date('1981-09-28', '%Y-%m-%d'), 1250, 1400, 30);
INSERT INTO emp1 values (7698, 'BLAKE', 'MANAGER', 7839, str_to_date('1981-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (7782, 'CLARK', 'MANAGER', 7839, str_to_date('1981-06-09' , '%Y-%m-%d'), 2450, null, 10);
INSERT INTO emp1 values (7788, 'SCOTT', 'ANALYST', 7566, str_to_date('1987-08-19', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7839, 'KING', 'PRESIDENT', null, str_to_date('1981-11-17', '%Y-%m-%d'), 5000, null, 10);
INSERT INTO emp1 values (7844, 'TURNER', 'SALESMAN', 7698, str_to_date('1981-09-08', '%Y-%m-%d'), 1500, 0, 30);
INSERT INTO emp1 values (7876, 'ADAMS', 'CLERK', 7788, str_to_date('1987-05-23', '%Y-%m-%d'), 1100, null, 20);
INSERT INTO emp1 values (7900, 'JAMES', 'CLERK', 7698, str_to_date('1981-12-03', '%Y-%m-%d'), 950, null, 30);
INSERT INTO emp1 values (7902, 'FORD', 'ANALYST', 7566, str_to_date('1981-12-03', '%Y-%m-%d'), 3000, null, 20);
INSERT INTO emp1 values (7934, 'MILLER', 'CLERK', 7782, str_to_date('1982-01-23', '%Y-%m-%d'), 1300, null, 10);
INSERT INTO emp1 values (8100, 'Eve', 'MANAGER', 7839, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8101, 'Eve1', 'MANAGER', 8100, str_to_date('1984-05-01','%Y-%m-%d'), 2850, null, 30);
INSERT INTO emp1 values (8108, 'Eve8', 'CLERK', 8101, str_to_date('1984-05-01', '%Y-%m-%d'), 2850, null, 30);

## =======================================================================
## Test Case 1:
## - recursive with RECURSIVE Query: Nested Loop Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |66          |
|1 | RECURSIVE UNION ALL|    |200     |66          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  NESTED-LOOP JOIN  |    |199     |61          |
|4 |   TABLE SCAN       |r   |199     |1           |
|5 |   MATERIAL         |    |14      |7           |
|6 |    TABLE SCAN      |e   |14      |5           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([r.empno = e.MGR]), nl_params_(nil), batch_join=false
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_NL(r e) */  e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 2:
## - recursive with RECURSIVE Query: SORT MERGE Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |129         |
|1 | RECURSIVE UNION ALL|    |200     |129         |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  MERGE JOIN        |    |199     |124         |
|4 |   MATERIAL         |    |14      |9           |
|5 |    SORT            |    |14      |8           |
|6 |     TABLE SCAN     |e   |14      |5           |
|7 |   SORT             |    |199     |107         |
|8 |    TABLE SCAN      |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
      merge_directions([ASC])
  4 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  5 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      sort_keys([e.MGR, ASC])
  6 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  7 - output([r.empno]), filter(nil), rowset=256
      sort_keys([r.empno, ASC])
  8 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_MERGE(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 3:
## - recursive with RECURSIVE Query: Hash Join
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT /*+log_level(DEBUG)*/ ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 4:
## - recursive with RECURSIVE Query: Join in Initialisation Branch
## 与oracle的结果顺序不一样
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |213     |58          |
|1 | RECURSIVE UNION ALL|    |213     |57          |
|2 |  NESTED-LOOP JOIN  |    |14      |14          |
|3 |   TABLE SCAN       |e   |14      |5           |
|4 |   MATERIAL         |    |14      |5           |
|5 |    TABLE SCAN      |d   |14      |5           |
|6 |  HASH JOIN         |    |199     |44          |
|7 |   MATERIAL         |    |14      |15          |
|8 |    HASH JOIN       |    |14      |14          |
|9 |     TABLE SCAN     |d   |14      |5           |
|10|     TABLE SCAN     |e   |14      |5           |
|11|   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      conds([e.SAL = d.SAL]), nl_params_(nil), batch_join=false
  3 - output([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      access([e.SAL], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  4 - output([d.SAL]), filter(nil), rowset=256
  5 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
  6 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  7 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
  8 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.SAL = d.SAL]), other_conds(nil)
  9 - output([d.SAL]), filter(nil), rowset=256
      access([d.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([d.__pk_increment]), range(MIN ; MAX)always true
 10 - output([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.SAL], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT /*+ USE_NL(e d) */ e.ename, e.mgr, e.empno
    FROM disemp e, disemp d 
    WHERE e.sal = d. sal
    UNION ALL
    SELECT /*+ USE_HASH(r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e, disemp d
    WHERE r.empno = e.mgr and e.sal = d.sal
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ADAMS  |  7876 | 7788 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| ALLEN  |  7499 | 7698 |
| BLAKE  |  7698 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| CLARK  |  7782 | 7839 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| FORD   |  7902 | 7566 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JAMES  |  7900 | 7698 |
| JONES  |  7566 | 7839 |
| JONES  |  7566 | 7839 |
| KING   |  7839 | NULL |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MARTIN |  7654 | 7698 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| MILLER |  7934 | 7782 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| SMITH  |  7369 | 7902 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| TURNER |  7844 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
| WARD   |  7521 | 7698 |
+--------+-------+------+

## =======================================================================
## Test Case 6:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on build side and fits in memory
## 与oracle顺序不一致
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM disemp e, rw r
    WHERE e.mgr = r.empno 
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 7:
## - recursive with RECURSIVE Query: Hash Join without using hints
##                         Static input on probe side and fits in memory
## =======================================================================
explain  
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## 测试8-15都是在测试join的顺序或者hint的顺序
## Test Case 8:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp >< emp1 
## =======================================================================
explain  
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |477         |
|1 | SUBPLAN SCAN        |rw  |787     |241         |
|2 |  RECURSIVE UNION ALL|    |787     |239         |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |213         |
|9 |    HASH JOIN        |    |199     |121         |
|10|     TABLE SCAN      |r   |199     |1           |
|11|     TABLE SCAN      |e   |5       |5           |
|12|    TABLE SCAN       |n   |17      |5           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [r.iters], [r.sal], [e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno]), other_conds(nil)
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, disemp e, emp1 n
  WHERE r.mgr = e.empno and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 9:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump >< emp1 
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |389         |
|1 | SUBPLAN SCAN        |rw  |787     |153         |
|2 |  RECURSIVE UNION ALL|    |787     |151         |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |124         |
|9 |    HASH JOIN        |    |199     |33          |
|10|     TABLE SCAN      |e   |5       |5           |
|11|     TABLE SCAN      |r   |199     |1           |
|12|    TABLE SCAN       |n   |17      |5           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
  9 - output([r.empno], [e.MGR], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 10 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 11 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, rw r, emp1 n
  WHERE e.empno = r.mgr and e.mgr = n.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 10:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< emp1 >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |327         |
|1 | SUBPLAN SCAN        |rw  |787     |91          |
|2 |  RECURSIVE UNION ALL|    |787     |89          |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |63          |
|9 |    MATERIAL         |    |17      |14          |
|10|     HASH JOIN       |    |17      |13          |
|11|      TABLE SCAN     |e   |5       |5           |
|12|      TABLE SCAN     |n   |17      |5           |
|13|    TABLE SCAN       |r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n.empno, DECIMAL(-1, -1))]), other_conds(nil)
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM disemp e, emp1 n, rw r
  WHERE e.mgr = n.empno and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 11:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< disemp >< pump  
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
=====================================================
|ID|OPERATOR             |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |SORT                 |    |787     |330         |
|1 | SUBPLAN SCAN        |rw  |787     |94          |
|2 |  RECURSIVE UNION ALL|    |787     |92          |
|3 |   HASH JOIN         |    |62      |25          |
|4 |    HASH JOIN        |    |17      |13          |
|5 |     TABLE SCAN      |e   |5       |5           |
|6 |     TABLE SCAN      |n1  |17      |5           |
|7 |    TABLE SCAN       |n2  |17      |5           |
|8 |   HASH JOIN         |    |725     |65          |
|9 |    MATERIAL         |    |17      |17          |
|10|     HASH JOIN       |    |17      |16          |
|11|      TABLE SCAN     |n   |17      |5           |
|12|      TABLE SCAN     |e   |5       |5           |
|13|    TABLE SCAN       |r   |199     |1           |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
  9 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 11 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 12 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 13 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 12:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |128         |
|1 | RECURSIVE UNION ALL|    |200     |127         |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |122         |
|4 |   TABLE SCAN       |r   |199     |1           |
|5 |   TABLE SCAN       |e   |14      |5           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
  5 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| JONES  |  7566 | 7839 |
| BLAKE  |  7698 | 7839 |
| CLARK  |  7782 | 7839 |
| SCOTT  |  7788 | 7566 |
| FORD   |  7902 | 7566 |
| ALLEN  |  7499 | 7698 |
| WARD   |  7521 | 7698 |
| MARTIN |  7654 | 7698 |
| TURNER |  7844 | 7698 |
| JAMES  |  7900 | 7698 |
| MILLER |  7934 | 7782 |
| ADAMS  |  7876 | 7788 |
| SMITH  |  7369 | 7902 |
+--------+-------+------+

## =======================================================================
## Test Case 13:
## - recursive with RECURSIVE Query: Join Order tests 
##                         disemp >< pump
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([e.MGR = r.empno]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ ORDERED  USE_HASH (r e) */ e.ename, e.mgr, e.empno
    FROM  disemp e, rw r
    WHERE e.mgr = r.empno
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 14:
## - recursive with RECURSIVE Query: Join Order tests 
##                         emp1 >< pump >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===============================================================
|ID|OPERATOR                       |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT                           |    |787     |1854        |
|1 | SUBPLAN SCAN                  |rw  |787     |1618        |
|2 |  RECURSIVE UNION ALL          |    |787     |1616        |
|3 |   HASH JOIN                   |    |62      |25          |
|4 |    HASH JOIN                  |    |17      |13          |
|5 |     TABLE SCAN                |e   |5       |5           |
|6 |     TABLE SCAN                |n1  |17      |5           |
|7 |    TABLE SCAN                 |n2  |17      |5           |
|8 |   HASH JOIN                   |    |725     |1590        |
|9 |    NESTED-LOOP JOIN CARTESIAN |    |3383    |94          |
|10|     TABLE SCAN                |r   |199     |1           |
|11|     MATERIAL                  |    |17      |7           |
|12|      TABLE SCAN               |n   |17      |5           |
|13|    TABLE SCAN                 |e   |5       |5           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR], [r.mgr = e.EMPno]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), batch_join=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, rw r, disemp e
  WHERE n.empno = e.mgr and r.mgr = e.empno and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 15:
## - recursive with RECURSIVE Query: Join Order tests 
##                         pump >< emp1 >< disemp
## =======================================================================
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
===============================================================
|ID|OPERATOR                       |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SORT                           |    |787     |1854        |
|1 | SUBPLAN SCAN                  |rw  |787     |1618        |
|2 |  RECURSIVE UNION ALL          |    |787     |1616        |
|3 |   HASH JOIN                   |    |62      |25          |
|4 |    HASH JOIN                  |    |17      |13          |
|5 |     TABLE SCAN                |e   |5       |5           |
|6 |     TABLE SCAN                |n1  |17      |5           |
|7 |    TABLE SCAN                 |n2  |17      |5           |
|8 |   HASH JOIN                   |    |725     |1590        |
|9 |    NESTED-LOOP JOIN CARTESIAN |    |3383    |94          |
|10|     TABLE SCAN                |r   |199     |1           |
|11|     MATERIAL                  |    |17      |7           |
|12|      TABLE SCAN               |n   |17      |5           |
|13|    TABLE SCAN                 |e   |5       |5           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      equal_conds([r.mgr = e.EMPno], [cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
  9 - output([r.empno], [r.mgr], [r.iters], [r.sal], [n.empno]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), batch_join=false
 10 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 11 - output([n.empno]), filter(nil), rowset=256
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM rw r, emp1 n, disemp e
  WHERE r.mgr = e.empno and n.empno = e.mgr and e.empno < e.mgr
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7499 | 7839 |     2 | 4450.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7521 | 7839 |     2 | 4100.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7654 | 7839 |     2 | 4100.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

## =======================================================================
## Test Case 16:
## - recursive with RECURSIVE Query: Join Skew handling. No local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |41          |
|1 | RECURSIVE UNION ALL|    |200     |40          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |35          |
|4 |   TABLE SCAN       |e   |14      |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.ENAME], [e.EMPno]), filter(nil), rowset=256
      access([e.MGR], [e.ENAME], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MILLER |  7934 | 7782 |
| JAMES  |  7900 | 7698 |
| TURNER |  7844 | 7698 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
| FORD   |  7902 | 7566 |
| SCOTT  |  7788 | 7566 |
| SMITH  |  7369 | 7902 |
| ADAMS  |  7876 | 7788 |
+--------+-------+------+

## =======================================================================
## Test Case 17:
## - recursive with RECURSIVE Query: Join Skew handling with RECURSIVE an additional local filter
## =======================================================================
explain 
with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
Query Plan
====================================================
|ID|OPERATOR            |NAME|EST.ROWS|EST.TIME(us)|
----------------------------------------------------
|0 |SUBPLAN SCAN        |rw  |200     |39          |
|1 | RECURSIVE UNION ALL|    |200     |38          |
|2 |  TABLE SCAN        |e   |1       |5           |
|3 |  HASH JOIN         |    |199     |33          |
|4 |   TABLE SCAN       |e   |5       |5           |
|5 |   TABLE SCAN       |r   |199     |1           |
====================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.ename], [rw.empno], [rw.mgr]), filter(nil), rowset=256
      access([rw.ename], [rw.empno], [rw.mgr])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=256
  2 - output([e.ENAME], [e.MGR], [e.EMPno]), filter([e.JOB = 'PRESIDENT']), rowset=256
      access([e.JOB], [e.ENAME], [e.MGR], [e.EMPno]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  3 - output([e.ENAME], [e.MGR], [e.EMPno]), filter(nil), rowset=256
      equal_conds([r.empno = e.MGR]), other_conds(nil)
  4 - output([e.MGR], [e.EMPno], [e.ENAME]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.ENAME]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  5 - output([r.empno]), filter(nil), rowset=256
      access([r.empno])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)

with RECURSIVE rw (ename, mgr, empno) AS
(
    SELECT ename, mgr, empno
    FROM disemp e
    WHERE job = 'PRESIDENT'
    UNION ALL
    SELECT /*+ PQ_SKEW (r) */ e.ename, e.mgr, e.empno
    FROM rw r, disemp e
    WHERE r.empno = e.mgr and e.empno < e.mgr
)
SELECT ename, empno, mgr
FROM rw;
+--------+-------+------+
| ename  | empno | mgr  |
+--------+-------+------+
| KING   |  7839 | NULL |
| CLARK  |  7782 | 7839 |
| BLAKE  |  7698 | 7839 |
| JONES  |  7566 | 7839 |
| MARTIN |  7654 | 7698 |
| WARD   |  7521 | 7698 |
| ALLEN  |  7499 | 7698 |
+--------+-------+------+

##############################
##   section 4  额外添加recursive member变化
##############################
create table t1(c1 int, c2 int, c3 int);
insert into t1 values(1, 2, 3);
insert into t1 values(4, 5, 6);
insert into t1 values(7, 8, 9);
insert into t1 values(10, 11, 12);
insert into t1 values(13, 14, 15);
insert into t1 values(16, 17, 18);
insert into t1 values(19, 20, 21);

create table disemp1 (
  EMPno  number,
  ENAME varchar(30),
  JOB varchar(30),
  MGR number(4),
  HIREDATE date,
  SAL number(7,2),
  COMM number(7,2),
  DEPTNO number(2)
);

INSERT INTO disemp1 values (7369,'SMITH','CLERK',7902,    str_to_date('1980-11-17','%Y-%m-%d'),800,NULL, 20) ;
INSERT INTO disemp1 VALUES (7499, 'ALLEN','SALESMAN',7698,str_to_date('1981-01-20','%Y-%m-%d'),1600,300,30) ;
INSERT INTO disemp1 VALUES (7521,'WARD','SALESMAN',7698,  str_to_date('1981-01-22','%Y-%m-%d'),1250, 500, 30) ;
INSERT INTO disemp1 VALUES (7566,'JONES','MANAGER',7839,  str_to_date('1981-04-02','%Y-%m-%d'), 2975, NULL, 20) ;
INSERT INTO disemp1 VALUES (7654,'MARTIN','SALESMAN', 7698, str_to_date('1981-09-28','%Y-%m-%d'), 1250, 1400, 30) ;
INSERT INTO disemp1 VALUES (7698, 'BLAKE','MANAGER', 7839,  str_to_date('1981-03-01','%Y-%m-%d'), 2850, NULL, 30) ;
INSERT INTO disemp1 VALUES (7782, 'CLARK','MANAGER', 7839,  str_to_date('1981-06-09','%Y-%m-%d'), 2450, NULL, 10) ;
insert into disemp1 values (7788,'SCOTT','ANALYST', 7566,   str_to_date('1987-04-19','%Y-%m-%d'), 3000, null, 20) ;
INSERT INTO disemp1 VALUES (7839, 'KING','PRESIDENT', NULL, str_to_date('1981-11-17','%Y-%m-%d'), 5000, NULL, 10) ;
INSERT INTO disemp1 VALUES (7844, 'TURNER','SALESMAN', 7698, str_to_date('1981-09-08','%Y-%m-%d'), 1500, 0, 30) ;
INSERT INTO disemp1 VALUES (7876, 'ADAMS','CLERK', 7788,     str_to_date('1987-05-23','%Y-%m-%d'), 1100, NULL, 20) ;
INSERT INTO disemp1 VALUES (7900, 'JAMES', 'CLEARK', 7698,   str_to_date('1981-11-03','%Y-%m-%d'), 950, NULL, 30) ;
INSERT INTO disemp1 VALUES (7902, 'FORD','ANALYST',7566,     str_to_date('1981-11-03','%Y-%m-%d'), 3000, NULL, 20) ;
INSERT INTO disemp1 VALUES (7934,'MILLER','CLERK', 7782,     str_to_date('1982-01-23','%Y-%m-%d'), 1300,NULL, 10) ;

##   这个case 测试了subplan filter
explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno = e.mgr and e.empno > some (select c1 from t1 group by c1)
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
==========================================================
|ID|OPERATOR                 |NAME |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------
|0 |SORT                     |     |1190    |1013        |
|1 | SUBPLAN SCAN            |rw   |1190    |643         |
|2 |  RECURSIVE UNION ALL    |     |1190    |640         |
|3 |   HASH JOIN             |     |62      |25          |
|4 |    HASH JOIN            |     |17      |13          |
|5 |     TABLE SCAN          |e    |5       |5           |
|6 |     TABLE SCAN          |n1   |17      |5           |
|7 |    TABLE SCAN           |n2   |17      |5           |
|8 |   NESTED-LOOP SEMI JOIN |     |1128    |612         |
|9 |    HASH JOIN            |     |3383    |165         |
|10|     MATERIAL            |     |17      |19          |
|11|      HASH JOIN          |     |17      |15          |
|12|       TABLE SCAN        |n    |17      |5           |
|13|       TABLE SCAN        |e    |1       |5           |
|14|     TABLE SCAN          |r    |199     |1           |
|15|    MATERIAL             |     |7       |6           |
|16|     SUBPLAN SCAN        |VIEW1|7       |6           |
|17|      HASH GROUP BY      |     |7       |6           |
|18|       TABLE SCAN        |t1   |7       |5           |
==========================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      conds([e.EMPno > VIEW1.c1]), nl_params_(nil), batch_join=false
  9 - output([r.empno], [e.MGR], [e.EMPno], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 10 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 12 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 13 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno = e.MGR]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 14 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 15 - output([VIEW1.c1]), filter(nil), rowset=256
 16 - output([VIEW1.c1]), filter(nil), rowset=256
      access([VIEW1.c1])
 17 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil), rowset=256
      group([t1.c1]), agg_func(nil)
 18 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno = e.mgr and e.empno > some (select c1 from t1 group by c1)
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

explain 
with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno = e.mgr and e.empno > some (select c1 from t1 group by c1) and e.empno in (select e.empno from disemp1)
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
Query Plan
==================================================================
|ID|OPERATOR                       |NAME   |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------
|0 |SORT                           |       |1190    |1110        |
|1 | SUBPLAN SCAN                  |rw     |1190    |741         |
|2 |  RECURSIVE UNION ALL          |       |1190    |738         |
|3 |   HASH JOIN                   |       |62      |25          |
|4 |    HASH JOIN                  |       |17      |13          |
|5 |     TABLE SCAN                |e      |5       |5           |
|6 |     TABLE SCAN                |n1     |17      |5           |
|7 |    TABLE SCAN                 |n2     |17      |5           |
|8 |   NESTED-LOOP SEMI JOIN       |       |1128    |710         |
|9 |    NESTED-LOOP JOIN CARTESIAN |       |3383    |263         |
|10|     HASH JOIN                 |       |3383    |165         |
|11|      MATERIAL                 |       |17      |19          |
|12|       HASH JOIN               |       |17      |15          |
|13|        TABLE SCAN             |n      |17      |5           |
|14|        TABLE SCAN             |e      |1       |5           |
|15|      TABLE SCAN               |r      |199     |1           |
|16|     MATERIAL                  |       |1       |4           |
|17|      SUBPLAN SCAN             |VIEW2  |1       |4           |
|18|       TABLE SCAN              |disemp1|1       |4           |
|19|    MATERIAL                   |       |7       |6           |
|20|     SUBPLAN SCAN              |VIEW1  |7       |6           |
|21|      HASH GROUP BY            |       |7       |6           |
|22|       TABLE SCAN              |t1     |7       |5           |
==================================================================
Outputs & filters:
-------------------------------------
  0 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      sort_keys([rw.empno, ASC], [rw.iters, ASC])
  1 - output([rw.empno], [rw.mgr], [rw.iters], [rw.sal]), filter(nil), rowset=256
      access([rw.empno], [rw.mgr], [rw.iters], [rw.sal])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil), rowset=256
  3 - output([e.EMPno], [e.MGR], [1], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.MGR = cast(n2.empno, DECIMAL(-1, -1))]), other_conds(nil)
  4 - output([e.EMPno], [e.MGR], [e.SAL]), filter(nil), rowset=256
      equal_conds([e.EMPno = cast(n1.empno, DECIMAL(-1, -1))]), other_conds(nil)
  5 - output([e.EMPno], [e.MGR], [e.SAL]), filter([e.EMPno < e.MGR]), rowset=256
      access([e.EMPno], [e.MGR], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
  6 - output([n1.empno]), filter(nil), rowset=256
      access([n1.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n1.__pk_increment]), range(MIN ; MAX)always true
  7 - output([n2.empno]), filter(nil), rowset=256
      access([n2.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n2.__pk_increment]), range(MIN ; MAX)always true
  8 - output([r.empno], [e.MGR], [r.iters + 1], [r.sal + e.SAL]), filter(nil), rowset=256
      conds([e.EMPno > VIEW1.c1]), nl_params_(nil), batch_join=false
  9 - output([r.empno], [e.MGR], [e.EMPno], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      conds(nil), nl_params_(nil), batch_join=false
 10 - output([r.empno], [e.MGR], [e.EMPno], [e.SAL], [r.iters], [r.sal]), filter(nil), rowset=256
      equal_conds([e.EMPno = r.mgr]), other_conds(nil)
 11 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
 12 - output([e.MGR], [e.EMPno], [e.SAL]), filter(nil), rowset=256
      equal_conds([cast(n.empno, DECIMAL(-1, -1)) = e.MGR]), other_conds(nil)
 13 - output([n.empno]), filter(nil), rowset=256
      access([n.empno]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([n.__pk_increment]), range(MIN ; MAX)always true
 14 - output([e.MGR], [e.EMPno], [e.SAL]), filter([e.EMPno = e.MGR], [e.EMPno = e.EMPno]), rowset=256
      access([e.MGR], [e.EMPno], [e.SAL]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false],
      range_key([e.__pk_increment]), range(MIN ; MAX)always true
 15 - output([r.mgr], [r.empno], [r.iters], [r.sal]), filter(nil), rowset=256
      access([r.mgr], [r.empno], [r.iters], [r.sal])
      is_index_back=false, is_global_index=false,
      range_key(nil), range(MIN ; MAX)
 16 - output(nil), filter(nil), rowset=256
 17 - output(nil), filter(nil), rowset=256
      access(nil)
 18 - output([1]), filter(nil), rowset=256
      access(nil), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false,
      range_key([disemp1.__pk_increment]), range(MIN ; MAX)always true
 19 - output([VIEW1.c1]), filter(nil), rowset=256
 20 - output([VIEW1.c1]), filter(nil), rowset=256
      access([VIEW1.c1])
 21 - output([cast(t1.c1, DECIMAL(11, 0))]), filter(nil), rowset=256
      group([t1.c1]), agg_func(nil)
 22 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false,
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true

with RECURSIVE rw (empno, mgr, iters, sal) AS
  (
  SELECT e.empno, e.mgr, 1, e.sal
  FROM disemp e, emp1 n1, emp1 n2
  WHERE e.empno = n1.empno and e.mgr = n2.empno and e.empno < e.mgr
  UNION ALL
  SELECT /*+ ORDERED  USE_HASH (r e) */r.empno, e.mgr, r.iters + 1, r.sal + e.sal
  FROM emp1 n, disemp e, rw r
  WHERE n.empno = e.mgr and e.empno = r.mgr and e.empno = e.mgr and e.empno > some (select c1 from t1 group by c1) and e.empno in (select e.empno from disemp1)
  )
  SELECT *
  FROM rw
  ORDER BY 1, 3;
+-------+------+-------+---------+
| empno | mgr  | iters | sal     |
+-------+------+-------+---------+
|  7369 | 7902 |     1 |  800.00 |
|  7499 | 7698 |     1 | 1600.00 |
|  7521 | 7698 |     1 | 1250.00 |
|  7566 | 7839 |     1 | 2975.00 |
|  7654 | 7698 |     1 | 1250.00 |
|  7698 | 7839 |     1 | 2850.00 |
|  7782 | 7839 |     1 | 2450.00 |
+-------+------+-------+---------+

drop database cte_st;
