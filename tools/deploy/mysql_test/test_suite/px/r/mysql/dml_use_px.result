result_format: 4
drop table if exists t_s,t_p,t_p4,t_no_p,t_temp_s,t_temp_p,t_temp_p4,t_temp_p5;

create table t_s(c1 int primary key, c2 int ,c3 int);
create table t_p(c1 int primary key, c2 int ,c3 int) partition by hash(c1)  partitions 4;
create table t_p4(c1 int primary key, c2 int ,c3 int) partition by hash(c1)  partitions 4;
create table t_no_p(c1 int, c2 int ,c3 int) partition by hash(c1)  partitions 4;
create table t_temp_s(c1 int, c2 int, c3 int);
create table t_temp_p(c1 int, c2 int ,c3 int) partition by hash(c1)  partitions 4;
create table t_temp_p4(c1 int, c2 int ,c3 int) partition by hash(c1)  partitions 4;
create table t_temp_p5(c1 int, c2 int ,c3 int) partition by hash(c1)  partitions 5;

## delete测试
insert into t_s(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_s');
explain basic delete /*+no_use_px*/ from t_s;
Query Plan
===========================
|ID|OPERATOR         |NAME|
---------------------------
|0 |DELETE           |    |
|1 |└─TABLE FULL SCAN|t_s |
===========================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range(MIN ; MAX)always true
explain basic delete /*+use_px*/ from t_s;
Query Plan
===========================
|ID|OPERATOR         |NAME|
---------------------------
|0 |DELETE           |    |
|1 |└─TABLE FULL SCAN|t_s |
===========================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range(MIN ; MAX)always true
delete /*+use_px*/ from t_s;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
+----+------+------+
insert into t_s(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_s');
explain basic delete /*+use_px, parallel(10)*/ from t_s;
Query Plan
=====================================
|ID|OPERATOR               |NAME    |
-------------------------------------
|0 |DISTRIBUTED DELETE     |        |
|1 |└─PX COORDINATOR       |        |
|2 |  └─EXCHANGE OUT DISTR |:EX10000|
|3 |    └─PX BLOCK ITERATOR|        |
|4 |      └─TABLE FULL SCAN|t_s     |
=====================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  4 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range(MIN ; MAX)always true
delete /*+use_px, parallel(10)*/ from t_s;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
+----+------+------+

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
explain basic delete /*+no_use_px,parallel(10)*/ from t_p;
Query Plan
=======================================
|ID|OPERATOR                 |NAME    |
---------------------------------------
|0 |PX COORDINATOR           |        |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|
|2 |  └─PX PARTITION ITERATOR|        |
|3 |    └─DELETE             |        |
|4 |      └─TABLE FULL SCAN  |t_p     |
=======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range(MIN ; MAX)always true
explain basic delete /*+use_px,parallel(10)*/ from t_p;
Query Plan
=======================================
|ID|OPERATOR                 |NAME    |
---------------------------------------
|0 |PX COORDINATOR           |        |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|
|2 |  └─PX PARTITION ITERATOR|        |
|3 |    └─DELETE             |        |
|4 |      └─TABLE FULL SCAN  |t_p     |
=======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range(MIN ; MAX)always true
delete /*+use_px,parallel(10)*/ from t_p;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
+----+------+------+

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
explain basic delete /*+no_use_px,parallel(10)*/ from t_p where c1 >= 5;
Query Plan
=======================================
|ID|OPERATOR                 |NAME    |
---------------------------------------
|0 |PX COORDINATOR           |        |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|
|2 |  └─PX PARTITION ITERATOR|        |
|3 |    └─DELETE             |        |
|4 |      └─TABLE RANGE SCAN |t_p     |
=======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; MAX), 
      range_cond([t_p.c1 >= 5])
explain basic delete /*+use_px,parallel(10)*/ from t_p where c1 >= 5;
Query Plan
=======================================
|ID|OPERATOR                 |NAME    |
---------------------------------------
|0 |PX COORDINATOR           |        |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|
|2 |  └─PX PARTITION ITERATOR|        |
|3 |    └─DELETE             |        |
|4 |      └─TABLE RANGE SCAN |t_p     |
=======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; MAX), 
      range_cond([t_p.c1 >= 5])
delete /*+use_px,parallel(10)*/ from t_p where c1 >= 5;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
+----+------+------+
delete from t_p;

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
explain basic delete /*+use_px*/ from t_p where c1 = 5;
Query Plan
=====================
|ID|OPERATOR   |NAME|
---------------------
|0 |DELETE     |    |
|1 |└─TABLE GET|t_p |
=====================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p1)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; 5], 
      range_cond([t_p.c1 = 5])
explain basic delete /*+use_px,parallel(10)*/ from t_p where c1 = 5;
Query Plan
=====================================
|ID|OPERATOR               |NAME    |
-------------------------------------
|0 |DISTRIBUTED DELETE     |        |
|1 |└─PX COORDINATOR       |        |
|2 |  └─EXCHANGE OUT DISTR |:EX10000|
|3 |    └─PX BLOCK ITERATOR|        |
|4 |      └─TABLE GET      |t_p     |
=====================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p1)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; 5], 
      range_cond([t_p.c1 = 5])
explain basic delete /*+no_use_px,parallel(10)*/ from t_p where c1 = 5;
Query Plan
=====================================
|ID|OPERATOR               |NAME    |
-------------------------------------
|0 |DISTRIBUTED DELETE     |        |
|1 |└─PX COORDINATOR       |        |
|2 |  └─EXCHANGE OUT DISTR |:EX10000|
|3 |    └─PX BLOCK ITERATOR|        |
|4 |      └─TABLE GET      |t_p     |
=====================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p1)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; 5], 
      range_cond([t_p.c1 = 5])
delete /*+use_px,parallel(10)*/ from t_p where c1 = 5;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
+----+------+------+
delete from t_p;

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
insert into t_p4(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
call dbms_stats.gather_table_stats('test','t_p4');
explain basic delete /*+no_use_px, use_nl(t_p,t_p4), parallel(10)*/ t_p from t_p,t_p4 where t_p.c1 = t_p4.c1 and t_p.c1 >= 5;
Query Plan
===================================================
|ID|OPERATOR                             |NAME    |
---------------------------------------------------
|0 |DISTRIBUTED DELETE                   |        |
|1 |└─PX COORDINATOR                     |        |
|2 |  └─EXCHANGE OUT DISTR               |:EX10001|
|3 |    └─NESTED-LOOP JOIN               |        |
|4 |      ├─EXCHANGE IN DISTR            |        |
|5 |      │ └─EXCHANGE OUT DISTR (RANDOM)|:EX10000|
|6 |      │   └─PX BLOCK ITERATOR        |        |
|7 |      │     └─TABLE RANGE SCAN       |t_p4    |
|8 |      └─DISTRIBUTED TABLE GET        |t_p     |
===================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_([t_p4.c1(:0)]), use_batch=true
  4 - output([t_p4.c1]), filter(nil), rowset=16
  5 - output([t_p4.c1]), filter(nil), rowset=16
      dop=10
  6 - output([t_p4.c1]), filter(nil), rowset=16
  7 - output([t_p4.c1]), filter(nil), rowset=16
      access([t_p4.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p4.c1]), range[5 ; MAX), 
      range_cond([t_p4.c1 >= 5])
  8 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([GROUP_ID], [t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range(MIN ; MAX), 
      range_cond([t_p.c1 = :0])
explain basic delete /*+use_px, parallel(10)*/ t_p from t_p,t_p4 where t_p.c1 = t_p4.c1 and t_p.c1 >= 5;
Query Plan
======================================================
|ID|OPERATOR                                |NAME    |
------------------------------------------------------
|0 |DISTRIBUTED DELETE                      |        |
|1 |└─PX COORDINATOR                        |        |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001|
|3 |    └─SHARED HASH JOIN                  |        |
|4 |      ├─PART JOIN FILTER CREATE         |:RF0000 |
|5 |      │ └─EXCHANGE IN DISTR             |        |
|6 |      │   └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000|
|7 |      │     └─PX BLOCK ITERATOR         |        |
|8 |      │       └─TABLE RANGE SCAN        |t_p4    |
|9 |      └─PX BLOCK HASH JOIN-FILTER       |:RF0000 |
|10|        └─TABLE RANGE SCAN              |t_p     |
======================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      equal_conds([t_p.c1 = t_p4.c1]), other_conds(nil)
  4 - output([t_p4.c1]), filter(nil), rowset=16
      RF_TYPE(bloom), RF_EXPR[calc_tablet_id(t_p4.c1)]
  5 - output([t_p4.c1]), filter(nil), rowset=16
  6 - output([t_p4.c1]), filter(nil), rowset=16
      dop=10
  7 - output([t_p4.c1]), filter(nil), rowset=16
  8 - output([t_p4.c1]), filter(nil), rowset=16
      access([t_p4.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p4.c1]), range[5 ; MAX), 
      range_cond([t_p4.c1 >= 5])
  9 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
 10 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; MAX), 
      range_cond([t_p.c1 >= 5])
delete /*+use_px, parallel(10)*/ t_p from t_p,t_p4 where t_p.c1 = t_p4.c1 and t_p.c1 >= 5;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
+----+------+------+
delete from t_p;

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
explain basic delete /*+no_use_px, parallel(10)*/ t_p from t_p,t_p4 where t_p.c1 = t_p4.c2 and t_p.c1 >= 5;
Query Plan
======================================================
|ID|OPERATOR                                |NAME    |
------------------------------------------------------
|0 |DISTRIBUTED DELETE                      |        |
|1 |└─PX COORDINATOR                        |        |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001|
|3 |    └─SHARED HASH JOIN                  |        |
|4 |      ├─PART JOIN FILTER CREATE         |:RF0000 |
|5 |      │ └─EXCHANGE IN DISTR             |        |
|6 |      │   └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000|
|7 |      │     └─PX BLOCK ITERATOR         |        |
|8 |      │       └─TABLE FULL SCAN         |t_p4    |
|9 |      └─PX BLOCK HASH JOIN-FILTER       |:RF0000 |
|10|        └─TABLE RANGE SCAN              |t_p     |
======================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)}), hash_distinct}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      equal_conds([t_p.c1 = t_p4.c2]), other_conds(nil)
  4 - output([t_p4.c2]), filter(nil), rowset=16
      RF_TYPE(bloom), RF_EXPR[calc_tablet_id(t_p4.c2)]
  5 - output([t_p4.c2]), filter(nil), rowset=16
  6 - output([t_p4.c2]), filter(nil), rowset=16
      dop=10
  7 - output([t_p4.c2]), filter(nil), rowset=16
  8 - output([t_p4.c2]), filter([t_p4.c2 >= 5]), rowset=16
      access([t_p4.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_p4.c1]), range(MIN ; MAX)always true
  9 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
 10 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; MAX), 
      range_cond([t_p.c1 >= 5])
explain basic delete /*+use_px, parallel(10)*/ t_p from t_p,t_p4 where t_p.c1 = t_p4.c2 and t_p.c1 >= 5;
Query Plan
======================================================
|ID|OPERATOR                                |NAME    |
------------------------------------------------------
|0 |DISTRIBUTED DELETE                      |        |
|1 |└─PX COORDINATOR                        |        |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001|
|3 |    └─SHARED HASH JOIN                  |        |
|4 |      ├─PART JOIN FILTER CREATE         |:RF0000 |
|5 |      │ └─EXCHANGE IN DISTR             |        |
|6 |      │   └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000|
|7 |      │     └─PX BLOCK ITERATOR         |        |
|8 |      │       └─TABLE FULL SCAN         |t_p4    |
|9 |      └─PX BLOCK HASH JOIN-FILTER       |:RF0000 |
|10|        └─TABLE RANGE SCAN              |t_p     |
======================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)}), hash_distinct}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      equal_conds([t_p.c1 = t_p4.c2]), other_conds(nil)
  4 - output([t_p4.c2]), filter(nil), rowset=16
      RF_TYPE(bloom), RF_EXPR[calc_tablet_id(t_p4.c2)]
  5 - output([t_p4.c2]), filter(nil), rowset=16
  6 - output([t_p4.c2]), filter(nil), rowset=16
      dop=10
  7 - output([t_p4.c2]), filter(nil), rowset=16
  8 - output([t_p4.c2]), filter([t_p4.c2 >= 5]), rowset=16
      access([t_p4.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_p4.c1]), range(MIN ; MAX)always true
  9 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
 10 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; MAX), 
      range_cond([t_p.c1 >= 5])
delete /*+use_px, parallel(10)*/ t_p from t_p,t_p4 where t_p.c1 = t_p4.c2 and t_p.c1 >= 5;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
+----+------+------+
delete from t_p;

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
insert into t_s(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
call dbms_stats.gather_table_stats('test','t_s');
explain basic delete /*+no_use_px,parallel(10) LEADING(t_s t_p) USE_NL(t_p) PQ_DISTRIBUTE(t_p NONE BROADCAST ) */ t_s,t_p from t_s,t_p;
Query Plan
========================================================
|ID|OPERATOR                                  |NAME    |
--------------------------------------------------------
|0 |DISTRIBUTED DELETE                        |        |
|1 |└─PX COORDINATOR                          |        |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001|
|3 |    └─NESTED-LOOP JOIN CARTESIAN          |        |
|4 |      ├─PX BLOCK ITERATOR                 |        |
|5 |      │ └─TABLE FULL SCAN                 |t_s     |
|6 |      └─MATERIAL                          |        |
|7 |        └─EXCHANGE IN DISTR               |        |
|8 |          └─EXCHANGE OUT DISTR (BROADCAST)|:EX10000|
|9 |            └─PX BLOCK ITERATOR           |        |
|10|              └─TABLE FULL SCAN           |t_p     |
========================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)}), hash_distinct}], [{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)}), hash_distinct}])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3], [t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3], [t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3], [t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  4 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  5 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range(MIN ; MAX)always true
  6 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  7 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  8 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  9 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
 10 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range(MIN ; MAX)always true
explain basic delete /*+use_px,parallel(10) LEADING(t_s t_p) USE_NL(t_p) PQ_DISTRIBUTE(t_p NONE BROADCAST ) */ t_s,t_p from t_s,t_p;
Query Plan
========================================================
|ID|OPERATOR                                  |NAME    |
--------------------------------------------------------
|0 |DISTRIBUTED DELETE                        |        |
|1 |└─PX COORDINATOR                          |        |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001|
|3 |    └─NESTED-LOOP JOIN CARTESIAN          |        |
|4 |      ├─PX BLOCK ITERATOR                 |        |
|5 |      │ └─TABLE FULL SCAN                 |t_s     |
|6 |      └─MATERIAL                          |        |
|7 |        └─EXCHANGE IN DISTR               |        |
|8 |          └─EXCHANGE OUT DISTR (BROADCAST)|:EX10000|
|9 |            └─PX BLOCK ITERATOR           |        |
|10|              └─TABLE FULL SCAN           |t_p     |
========================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)}), hash_distinct}], [{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)}), hash_distinct}])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3], [t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3], [t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3], [t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  4 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  5 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range(MIN ; MAX)always true
  6 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  7 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  8 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  9 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
 10 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range(MIN ; MAX)always true
delete /*+use_px,parallel(10)*/ t_s,t_p from t_s,t_p;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
+----+------+------+
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
+----+------+------+

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
insert into t_s(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
call dbms_stats.gather_table_stats('test','t_s');
explain basic delete /*+no_use_px, parallel(10)*/ t_s from t_s,t_p where t_p.c1 = t_s.c1;
Query Plan
====================================================
|ID|OPERATOR                              |NAME    |
----------------------------------------------------
|0 |DISTRIBUTED DELETE                    |        |
|1 |└─PX COORDINATOR                      |        |
|2 |  └─EXCHANGE OUT DISTR                |:EX10001|
|3 |    └─SHARED HASH JOIN                |        |
|4 |      ├─EXCHANGE IN DISTR             |        |
|5 |      │ └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000|
|6 |      │   └─PX BLOCK ITERATOR         |        |
|7 |      │     └─TABLE FULL SCAN         |t_p     |
|8 |      └─PX BLOCK ITERATOR             |        |
|9 |        └─TABLE FULL SCAN             |t_s     |
====================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      equal_conds([t_p.c1 = t_s.c1]), other_conds(nil)
  4 - output([t_p.c1]), filter(nil), rowset=16
  5 - output([t_p.c1]), filter(nil), rowset=16
      dop=10
  6 - output([t_p.c1]), filter(nil), rowset=16
  7 - output([t_p.c1]), filter(nil), rowset=16
      access([t_p.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range(MIN ; MAX)always true
  8 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  9 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range(MIN ; MAX)always true
explain basic delete /*+use_px, parallel(10),leading(t_s,t_p),pq_distribute(t_p,none,broadcast)*/ t_s from t_s,t_p where t_p.c1 = t_s.c1;
Query Plan
======================================================
|ID|OPERATOR                                |NAME    |
------------------------------------------------------
|0 |DISTRIBUTED DELETE                      |        |
|1 |└─PX COORDINATOR                        |        |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001|
|3 |    └─HASH JOIN                         |        |
|4 |      ├─PART JOIN FILTER CREATE         |:RF0000 |
|5 |      │ └─PX BLOCK ITERATOR             |        |
|6 |      │   └─TABLE FULL SCAN             |t_s     |
|7 |      └─EXCHANGE IN DISTR               |        |
|8 |        └─EXCHANGE OUT DISTR (BROADCAST)|:EX10000|
|9 |          └─PX BLOCK HASH JOIN-FILTER   |:RF0000 |
|10|            └─TABLE FULL SCAN           |t_p     |
======================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      equal_conds([t_p.c1 = t_s.c1]), other_conds(nil)
  4 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      RF_TYPE(bloom), RF_EXPR[calc_tablet_id(t_s.c1)]
  5 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  6 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range(MIN ; MAX)always true
  7 - output([t_p.c1]), filter(nil), rowset=16
  8 - output([t_p.c1]), filter(nil), rowset=16
      dop=10
  9 - output([t_p.c1]), filter(nil), rowset=16
 10 - output([t_p.c1]), filter(nil), rowset=16
      access([t_p.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range(MIN ; MAX)always true
delete /*+use_px, parallel(10),leading(t_s,t_p),pq_distribute(t_p,none,broadcast)*/ t_s from t_s,t_p where t_p.c1 = t_s.c1;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
+----+------+------+
insert into t_s(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_s');
explain basic delete /*+use_px, parallel(10)*/ t_s from t_s,t_p where t_p.c1 = t_s.c1;
Query Plan
====================================================
|ID|OPERATOR                              |NAME    |
----------------------------------------------------
|0 |DISTRIBUTED DELETE                    |        |
|1 |└─PX COORDINATOR                      |        |
|2 |  └─EXCHANGE OUT DISTR                |:EX10001|
|3 |    └─SHARED HASH JOIN                |        |
|4 |      ├─EXCHANGE IN DISTR             |        |
|5 |      │ └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000|
|6 |      │   └─PX BLOCK ITERATOR         |        |
|7 |      │     └─TABLE FULL SCAN         |t_p     |
|8 |      └─PX BLOCK ITERATOR             |        |
|9 |        └─TABLE FULL SCAN             |t_s     |
====================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      equal_conds([t_p.c1 = t_s.c1]), other_conds(nil)
  4 - output([t_p.c1]), filter(nil), rowset=16
  5 - output([t_p.c1]), filter(nil), rowset=16
      dop=10
  6 - output([t_p.c1]), filter(nil), rowset=16
  7 - output([t_p.c1]), filter(nil), rowset=16
      access([t_p.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range(MIN ; MAX)always true
  8 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  9 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range(MIN ; MAX)always true
delete /*+use_px, parallel(10)*/ t_s from t_s,t_p where t_p.c1 = t_s.c1;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
+----+------+------+

insert into t_s(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_s');
call dbms_stats.gather_table_stats('test','t_p');
explain basic delete /*+no_use_px, parallel(10)*/ t_p from t_s,t_p where t_p.c1 = t_s.c1 and t_p.c1 = 1;
Query Plan
========================================================
|ID|OPERATOR                                  |NAME    |
--------------------------------------------------------
|0 |DISTRIBUTED DELETE                        |        |
|1 |└─PX COORDINATOR                          |        |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001|
|3 |    └─NESTED-LOOP JOIN CARTESIAN          |        |
|4 |      ├─PX BLOCK ITERATOR                 |        |
|5 |      │ └─TABLE GET                       |t_p     |
|6 |      └─MATERIAL                          |        |
|7 |        └─EXCHANGE IN DISTR               |        |
|8 |          └─EXCHANGE OUT DISTR (BROADCAST)|:EX10000|
|9 |            └─PX BLOCK ITERATOR           |        |
|10|              └─TABLE GET                 |t_s     |
========================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  5 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p1)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[1 ; 1], 
      range_cond([t_p.c1 = 1])
  6 - output(nil), filter(nil), rowset=16
  7 - output(nil), filter(nil), rowset=16
  8 - output(nil), filter(nil), rowset=16
      dop=10
  9 - output(nil), filter(nil), rowset=16
 10 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range[1 ; 1], 
      range_cond([t_s.c1 = 1])
explain basic delete /*+use_px, parallel(1)*/ t_p from t_s,t_p where t_p.c1 = t_s.c1 and t_p.c1 = 1;
Query Plan
=======================================
|ID|OPERATOR                     |NAME|
---------------------------------------
|0 |DELETE                       |    |
|1 |└─NESTED-LOOP JOIN CARTESIAN |    |
|2 |  ├─TABLE GET                |t_s |
|3 |  └─TABLE GET                |t_p |
=======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range[1 ; 1], 
      range_cond([t_s.c1 = 1])
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p1)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[1 ; 1], 
      range_cond([t_p.c1 = 1])
explain basic delete /*+use_px, parallel(10)*/ t_p from t_s,t_p where t_p.c1 = t_s.c1 and t_p.c1 = 1;
Query Plan
========================================================
|ID|OPERATOR                                  |NAME    |
--------------------------------------------------------
|0 |DISTRIBUTED DELETE                        |        |
|1 |└─PX COORDINATOR                          |        |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001|
|3 |    └─NESTED-LOOP JOIN CARTESIAN          |        |
|4 |      ├─PX BLOCK ITERATOR                 |        |
|5 |      │ └─TABLE GET                       |t_p     |
|6 |      └─MATERIAL                          |        |
|7 |        └─EXCHANGE IN DISTR               |        |
|8 |          └─EXCHANGE OUT DISTR (BROADCAST)|:EX10000|
|9 |            └─PX BLOCK ITERATOR           |        |
|10|              └─TABLE GET                 |t_s     |
========================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  5 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p1)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[1 ; 1], 
      range_cond([t_p.c1 = 1])
  6 - output(nil), filter(nil), rowset=16
  7 - output(nil), filter(nil), rowset=16
  8 - output(nil), filter(nil), rowset=16
      dop=10
  9 - output(nil), filter(nil), rowset=16
 10 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range[1 ; 1], 
      range_cond([t_s.c1 = 1])
delete /*+use_px, parallel(10)*/ t_p from t_s,t_p where t_p.c1 = t_s.c1 and t_p.c1 = 1;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  5 |    5 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
+----+------+------+
delete from t_p;
delete from t_s;

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
call dbms_stats.gather_table_stats('test','t_s');
explain basic delete /*+no_use_px, parallel(10)*/ t_p from t_p4,t_p where t_p.c1 = t_p4.c2 and t_p4.c2 = 4;
Query Plan
========================================================
|ID|OPERATOR                                  |NAME    |
--------------------------------------------------------
|0 |DISTRIBUTED DELETE                        |        |
|1 |└─PX COORDINATOR                          |        |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001|
|3 |    └─NESTED-LOOP JOIN CARTESIAN          |        |
|4 |      ├─PX BLOCK ITERATOR                 |        |
|5 |      │ └─TABLE GET                       |t_p     |
|6 |      └─MATERIAL                          |        |
|7 |        └─EXCHANGE IN DISTR               |        |
|8 |          └─EXCHANGE OUT DISTR (BROADCAST)|:EX10000|
|9 |            └─PX BLOCK ITERATOR           |        |
|10|              └─TABLE FULL SCAN           |t_p4    |
========================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)}), hash_distinct}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  5 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[4 ; 4], 
      range_cond([t_p.c1 = 4])
  6 - output(nil), filter(nil), rowset=16
  7 - output(nil), filter(nil), rowset=16
  8 - output(nil), filter(nil), rowset=16
      dop=10
  9 - output(nil), filter(nil), rowset=16
 10 - output(nil), filter([t_p4.c2 = 4]), rowset=16
      access([t_p4.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_p4.c1]), range(MIN ; MAX)always true
explain basic delete /*+use_px, parallel(1)*/ t_p from t_p4,t_p where t_p.c1 = t_p4.c2 and t_p4.c2 = 4;
Query Plan
===========================================
|ID|OPERATOR                     |NAME    |
-------------------------------------------
|0 |DELETE                       |        |
|1 |└─NESTED-LOOP JOIN CARTESIAN |        |
|2 |  ├─TABLE GET                |t_p     |
|3 |  └─PX COORDINATOR           |        |
|4 |    └─EXCHANGE OUT DISTR     |:EX10000|
|5 |      └─PX PARTITION ITERATOR|        |
|6 |        └─TABLE FULL SCAN    |t_p4    |
===========================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)}), hash_distinct}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[4 ; 4], 
      range_cond([t_p.c1 = 4])
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      dop=1
  5 - output(nil), filter(nil), rowset=16
      force partition granule
  6 - output(nil), filter([t_p4.c2 = 4]), rowset=16
      access([t_p4.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_p4.c1]), range(MIN ; MAX)always true
delete /*+use_px, parallel(1)*/ t_p from t_p4,t_p where t_p.c1 = t_p4.c2 and t_p4.c2 = 4;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  5 |    5 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
+----+------+------+
delete from t_p;
insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
call dbms_stats.gather_table_stats('test','t_s');
explain basic delete /*+use_px, parallel(10)*/ t_p from t_p4,t_p where t_p.c1 = t_p4.c2 and t_p4.c2 = 4;
Query Plan
========================================================
|ID|OPERATOR                                  |NAME    |
--------------------------------------------------------
|0 |DISTRIBUTED DELETE                        |        |
|1 |└─PX COORDINATOR                          |        |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001|
|3 |    └─NESTED-LOOP JOIN CARTESIAN          |        |
|4 |      ├─PX BLOCK ITERATOR                 |        |
|5 |      │ └─TABLE GET                       |t_p     |
|6 |      └─MATERIAL                          |        |
|7 |        └─EXCHANGE IN DISTR               |        |
|8 |          └─EXCHANGE OUT DISTR (BROADCAST)|:EX10000|
|9 |            └─PX BLOCK ITERATOR           |        |
|10|              └─TABLE FULL SCAN           |t_p4    |
========================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)}), hash_distinct}])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  5 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[4 ; 4], 
      range_cond([t_p.c1 = 4])
  6 - output(nil), filter(nil), rowset=16
  7 - output(nil), filter(nil), rowset=16
  8 - output(nil), filter(nil), rowset=16
      dop=10
  9 - output(nil), filter(nil), rowset=16
 10 - output(nil), filter([t_p4.c2 = 4]), rowset=16
      access([t_p4.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_p4.c1]), range(MIN ; MAX)always true
delete /*+use_px, parallel(10)*/ t_p from t_p4,t_p where t_p.c1 = t_p4.c2 and t_p4.c2 = 4;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  5 |    5 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
+----+------+------+
delete from t_p;
delete from t_p4;

## update测试
insert into t_s(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_s');
call dbms_stats.gather_table_stats('test','t_p');
explain basic update /*+no_use_px, parallel(10)*/ t_s set t_s.c2 = 20 where t_s.c1 >= 5;
Query Plan
======================================
|ID|OPERATOR                |NAME    |
--------------------------------------
|0 |DISTRIBUTED UPDATE      |        |
|1 |└─PX COORDINATOR        |        |
|2 |  └─EXCHANGE OUT DISTR  |:EX10000|
|3 |    └─PX BLOCK ITERATOR |        |
|4 |      └─TABLE RANGE SCAN|t_s     |
======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]),
      update([t_s.c2=column_conv(INT,PS:(11,0),NULL,20)])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  4 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range[5 ; MAX), 
      range_cond([t_s.c1 >= 5])
explain basic update /*+use_px, parallel(10)*/ t_s set t_s.c2 = 20 where t_s.c1 >= 5;
Query Plan
======================================
|ID|OPERATOR                |NAME    |
--------------------------------------
|0 |DISTRIBUTED UPDATE      |        |
|1 |└─PX COORDINATOR        |        |
|2 |  └─EXCHANGE OUT DISTR  |:EX10000|
|3 |    └─PX BLOCK ITERATOR |        |
|4 |      └─TABLE RANGE SCAN|t_s     |
======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]),
      update([t_s.c2=column_conv(INT,PS:(11,0),NULL,20)])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  4 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_s.c1]), range[5 ; MAX), 
      range_cond([t_s.c1 >= 5])
update /*+use_px, parallel(10)*/ t_s set t_s.c2 = 20 where t_s.c1 >=5;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  5 |   20 | NULL |
|  6 |   20 | NULL |
|  7 |   20 | NULL |
|  8 |   20 | NULL |
|  9 |   20 | NULL |
| 10 |   20 | NULL |
+----+------+------+
delete from t_s;

insert into t_s(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_s');
explain basic update /*+no_use_px, parallel(10)*/ t_s set t_s.c1 = 20 where t_s.c2 = 5;
Query Plan
=====================================
|ID|OPERATOR               |NAME    |
-------------------------------------
|0 |DISTRIBUTED UPDATE     |        |
|1 |└─PX COORDINATOR       |        |
|2 |  └─EXCHANGE OUT DISTR |:EX10000|
|3 |    └─PX BLOCK ITERATOR|        |
|4 |      └─TABLE FULL SCAN|t_s     |
=====================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]),
      update([t_s.c1=column_conv(INT,PS:(11,0),NOT NULL,20)])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  4 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter([t_s.c2 = 5]), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_s.c1]), range(MIN ; MAX)always true
explain basic update /*+use_px, parallel(10)*/ t_s set t_s.c1 = 20 where t_s.c2 = 5;
Query Plan
=====================================
|ID|OPERATOR               |NAME    |
-------------------------------------
|0 |DISTRIBUTED UPDATE     |        |
|1 |└─PX COORDINATOR       |        |
|2 |  └─EXCHANGE OUT DISTR |:EX10000|
|3 |    └─PX BLOCK ITERATOR|        |
|4 |      └─TABLE FULL SCAN|t_s     |
=====================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]),
      update([t_s.c1=column_conv(INT,PS:(11,0),NOT NULL,20)])
  1 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  2 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter(nil), rowset=16
  4 - output([t_s.c1], [t_s.c2], [t_s.c3]), filter([t_s.c2 = 5]), rowset=16
      access([t_s.c1], [t_s.c2], [t_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_s.c1]), range(MIN ; MAX)always true
update /*+use_px, parallel(10)*/ t_s set t_s.c1 = 20 where t_s.c2 = 5;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
| 20 |    5 | NULL |
+----+------+------+
delete from t_s;

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
explain basic update /*+no_use_px, parallel(10)*/ t_p set t_p.c3 = 20 where t_p.c1 >= 5;
Query Plan
=======================================
|ID|OPERATOR                 |NAME    |
---------------------------------------
|0 |PX COORDINATOR           |        |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|
|2 |  └─PX PARTITION ITERATOR|        |
|3 |    └─UPDATE             |        |
|4 |      └─TABLE RANGE SCAN |t_p     |
=======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]),
      update([t_p.c3=column_conv(INT,PS:(11,0),NULL,20)])
  4 - output([t_p.c1], [t_p.c3], [t_p.c2]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c3], [t_p.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; MAX), 
      range_cond([t_p.c1 >= 5])
explain basic update /*+use_px, parallel(10)*/ t_p set t_p.c3 = 20 where t_p.c1 >= 5;
Query Plan
=======================================
|ID|OPERATOR                 |NAME    |
---------------------------------------
|0 |PX COORDINATOR           |        |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|
|2 |  └─PX PARTITION ITERATOR|        |
|3 |    └─UPDATE             |        |
|4 |      └─TABLE RANGE SCAN |t_p     |
=======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]),
      update([t_p.c3=column_conv(INT,PS:(11,0),NULL,20)])
  4 - output([t_p.c1], [t_p.c3], [t_p.c2]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c3], [t_p.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; MAX), 
      range_cond([t_p.c1 >= 5])
update /*+use_px, parallel(10)*/ t_p set t_p.c3 = 20 where t_p.c1 >= 5;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  5 |    5 |   20 |
|  6 |    6 |   20 |
|  7 |    7 |   20 |
|  8 |    8 |   20 |
|  9 |    9 |   20 |
| 10 |   10 |   20 |
+----+------+------+
delete from t_p;

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
explain basic update /*+no_use_px, parallel(10)*/ t_p set t_p.c1 = 20 where t_p.c1 = 5;
Query Plan
=====================================
|ID|OPERATOR               |NAME    |
-------------------------------------
|0 |DISTRIBUTED UPDATE     |        |
|1 |└─PX COORDINATOR       |        |
|2 |  └─EXCHANGE OUT DISTR |:EX10000|
|3 |    └─PX BLOCK ITERATOR|        |
|4 |      └─TABLE GET      |t_p     |
=====================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]),
      update([t_p.c1=column_conv(INT,PS:(11,0),NOT NULL,20)])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p1)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; 5], 
      range_cond([t_p.c1 = 5])
explain basic update /*+use_px, parallel(10)*/ t_p set t_p.c1 = 20 where t_p.c1 = 5;
Query Plan
=====================================
|ID|OPERATOR               |NAME    |
-------------------------------------
|0 |DISTRIBUTED UPDATE     |        |
|1 |└─PX COORDINATOR       |        |
|2 |  └─EXCHANGE OUT DISTR |:EX10000|
|3 |    └─PX BLOCK ITERATOR|        |
|4 |      └─TABLE GET      |t_p     |
=====================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]),
      update([t_p.c1=column_conv(INT,PS:(11,0),NOT NULL,20)])
  1 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  2 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
  4 - output([t_p.c1], [t_p.c2], [t_p.c3]), filter(nil), rowset=16
      access([t_p.c1], [t_p.c2], [t_p.c3]), partitions(p1)
      is_index_back=false, is_global_index=false, 
      range_key([t_p.c1]), range[5 ; 5], 
      range_cond([t_p.c1 = 5])
update /*+use_px, parallel(10)*/ t_p set t_p.c1 = 20 where t_p.c1 = 5;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
| 20 |    5 | NULL |
+----+------+------+
delete from t_p;

insert into t_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_p');
explain basic update /*+no_use_px, parallel(10)*/ t_p as pp set pp.c3 = 20 where pp.c1 >= 5;
Query Plan
=======================================
|ID|OPERATOR                 |NAME    |
---------------------------------------
|0 |PX COORDINATOR           |        |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|
|2 |  └─PX PARTITION ITERATOR|        |
|3 |    └─UPDATE             |        |
|4 |      └─TABLE RANGE SCAN |pp      |
=======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      table_columns([{pp: ({t_p: (pp.c1, pp.c2, pp.c3)})}]),
      update([pp.c3=column_conv(INT,PS:(11,0),NULL,20)])
  4 - output([pp.c1], [pp.c3], [pp.c2]), filter(nil), rowset=16
      access([pp.c1], [pp.c3], [pp.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([pp.c1]), range[5 ; MAX), 
      range_cond([pp.c1 >= 5])
explain basic update /*+use_px, parallel(10)*/ t_p as pp set pp.c3 = 20 where pp.c1 >= 5;
Query Plan
=======================================
|ID|OPERATOR                 |NAME    |
---------------------------------------
|0 |PX COORDINATOR           |        |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|
|2 |  └─PX PARTITION ITERATOR|        |
|3 |    └─UPDATE             |        |
|4 |      └─TABLE RANGE SCAN |pp      |
=======================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      table_columns([{pp: ({t_p: (pp.c1, pp.c2, pp.c3)})}]),
      update([pp.c3=column_conv(INT,PS:(11,0),NULL,20)])
  4 - output([pp.c1], [pp.c3], [pp.c2]), filter(nil), rowset=16
      access([pp.c1], [pp.c3], [pp.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([pp.c1]), range[5 ; MAX), 
      range_cond([pp.c1 >= 5])
update /*+use_px, parallel(10)*/ t_p as pp set pp.c3 = 20 where pp.c1 >= 5;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  5 |    5 |   20 |
|  6 |    6 |   20 |
|  7 |    7 |   20 |
|  8 |    8 |   20 |
|  9 |    9 |   20 |
| 10 |   10 |   20 |
+----+------+------+
delete from t_p;

insert into t_no_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
call dbms_stats.gather_table_stats('test','t_no_p');
explain basic update /*+no_use_px, parallel(10)*/ t_no_p set t_no_p.c1 = 20 where t_no_p.c1 >= 5;
Query Plan
=====================================
|ID|OPERATOR               |NAME    |
-------------------------------------
|0 |DISTRIBUTED UPDATE     |        |
|1 |└─PX COORDINATOR       |        |
|2 |  └─EXCHANGE OUT DISTR |:EX10000|
|3 |    └─PX BLOCK ITERATOR|        |
|4 |      └─TABLE FULL SCAN|t_no_p  |
=====================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_no_p: ({t_no_p: (t_no_p.__pk_increment, t_no_p.c1, t_no_p.c2, t_no_p.c3)})}]),
      update([t_no_p.c1=column_conv(INT,PS:(11,0),NULL,20)], [t_no_p.__pk_increment=T_HIDDEN_PK])
  1 - output([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), filter(nil), rowset=16
  2 - output([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), filter(nil), rowset=16
  4 - output([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), filter([t_no_p.c1 >= 5]), rowset=16
      access([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_no_p.__pk_increment]), range(MIN ; MAX)always true
explain basic update /*+use_px, parallel(10)*/ t_no_p set t_no_p.c1 = 20 where t_no_p.c1 >= 5;
Query Plan
=====================================
|ID|OPERATOR               |NAME    |
-------------------------------------
|0 |DISTRIBUTED UPDATE     |        |
|1 |└─PX COORDINATOR       |        |
|2 |  └─EXCHANGE OUT DISTR |:EX10000|
|3 |    └─PX BLOCK ITERATOR|        |
|4 |      └─TABLE FULL SCAN|t_no_p  |
=====================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t_no_p: ({t_no_p: (t_no_p.__pk_increment, t_no_p.c1, t_no_p.c2, t_no_p.c3)})}]),
      update([t_no_p.c1=column_conv(INT,PS:(11,0),NULL,20)], [t_no_p.__pk_increment=T_HIDDEN_PK])
  1 - output([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), filter(nil), rowset=16
  2 - output([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), filter(nil), rowset=16
      dop=10
  3 - output([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), filter(nil), rowset=16
  4 - output([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), filter([t_no_p.c1 >= 5]), rowset=16
      access([t_no_p.__pk_increment], [t_no_p.c1], [t_no_p.c2], [t_no_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_no_p.__pk_increment]), range(MIN ; MAX)always true
update /*+use_px, parallel(10)*/ t_no_p set t_no_p.c1 = 20 where t_no_p.c1 >= 5;
select * from t_no_p order by c2;
+------+------+------+
| c1   | c2   | c3   |
+------+------+------+
|    1 |    1 | NULL |
|    2 |    2 | NULL |
|    3 |    3 | NULL |
|    4 |    4 | NULL |
|   20 |    5 | NULL |
|   20 |    6 | NULL |
|   20 |    7 | NULL |
|   20 |    8 | NULL |
|   20 |    9 | NULL |
|   20 |   10 | NULL |
+------+------+------+
delete from t_no_p;

## insert测试：insert插入的表是local的非分区表/单分区的计划是非multi part，其他都是multi part计划
## insert不会出现GI算子在insert算子头上的计划
insert into t_temp_p(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
insert into t_temp_s(c1,c3) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
insert into t_temp_p4(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);
insert into t_temp_p5(c1,c2) values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10);

explain basic insert /*+no_use_px*/ into t_s select * from t_temp_s;
Query Plan
========================================
|ID|OPERATOR           |NAME           |
----------------------------------------
|0 |INSERT             |               |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|
|2 |  └─TABLE FULL SCAN|t_temp_s       |
========================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]), partitions(p0), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  2 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
explain basic insert /*+use_px*/ into t_s select * from t_temp_s;
Query Plan
========================================
|ID|OPERATOR           |NAME           |
----------------------------------------
|0 |INSERT             |               |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|
|2 |  └─TABLE FULL SCAN|t_temp_s       |
========================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]), partitions(p0), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  2 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px*/ into t_s select * from t_temp_s;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 | NULL |    1 |
|  2 | NULL |    2 |
|  3 | NULL |    3 |
|  4 | NULL |    4 |
|  5 | NULL |    5 |
|  6 | NULL |    6 |
|  7 | NULL |    7 |
|  8 | NULL |    8 |
|  9 | NULL |    9 |
| 10 | NULL |   10 |
+----+------+------+
delete from t_s;

call dbms_stats.gather_table_stats('test','t_temp_p');
call dbms_stats.gather_table_stats('test','t_temp_s');
call dbms_stats.gather_table_stats('test','t_temp_p4');
call dbms_stats.gather_table_stats('test','t_temp_p5');
explain basic insert /*+no_use_px,parallel(10)*/ into t_s select * from t_temp_s;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |INSERT                   |               |
|1 |└─PX COORDINATOR         |               |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000       |
|3 |    └─SUBPLAN SCAN       |ANONYMOUS_VIEW1|
|4 |      └─PX BLOCK ITERATOR|               |
|5 |        └─TABLE FULL SCAN|t_temp_s       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]), partitions(p0), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
  5 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
explain basic insert /*+use_px,parallel(10)*/ into t_s select * from t_temp_s;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |INSERT                   |               |
|1 |└─PX COORDINATOR         |               |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000       |
|3 |    └─SUBPLAN SCAN       |ANONYMOUS_VIEW1|
|4 |      └─PX BLOCK ITERATOR|               |
|5 |        └─TABLE FULL SCAN|t_temp_s       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]), partitions(p0), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
  5 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px,parallel(10)*/ into t_s select * from t_temp_s;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 | NULL |    1 |
|  2 | NULL |    2 |
|  3 | NULL |    3 |
|  4 | NULL |    4 |
|  5 | NULL |    5 |
|  6 | NULL |    6 |
|  7 | NULL |    7 |
|  8 | NULL |    8 |
|  9 | NULL |    9 |
| 10 | NULL |   10 |
+----+------+------+
delete from t_s;

call dbms_stats.gather_table_stats('test','t_temp_p');
call dbms_stats.gather_table_stats('test','t_temp_s');
call dbms_stats.gather_table_stats('test','t_temp_p4');
call dbms_stats.gather_table_stats('test','t_temp_p5');
call dbms_stats.gather_table_stats('test','t_s');
explain basic insert /*+no_use_px,parallel(10)*/ into t_s select * from t_temp_p where t_temp_p.c2 >= 5;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |INSERT                   |               |
|1 |└─PX COORDINATOR         |               |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000       |
|3 |    └─SUBPLAN SCAN       |ANONYMOUS_VIEW1|
|4 |      └─PX BLOCK ITERATOR|               |
|5 |        └─TABLE FULL SCAN|t_temp_p       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]), partitions(p0), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
  5 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter([t_temp_p.c2 >= 5]), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
explain basic insert /*+use_px,parallel(10)*/ into t_s select * from t_temp_p where t_temp_p.c2 >= 5;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |INSERT                   |               |
|1 |└─PX COORDINATOR         |               |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000       |
|3 |    └─SUBPLAN SCAN       |ANONYMOUS_VIEW1|
|4 |      └─PX BLOCK ITERATOR|               |
|5 |        └─TABLE FULL SCAN|t_temp_p       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]), partitions(p0), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
  5 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter([t_temp_p.c2 >= 5]), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px,parallel(10)*/ into t_s select * from t_temp_p where t_temp_p.c2 >= 5;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  5 |    5 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
+----+------+------+
delete from t_s;

call dbms_stats.gather_table_stats('test','t_s');
explain basic insert /*+no_use_px,parallel(10)*/ into t_s select t_temp_p.c1,t_temp_p.c2,t_temp_s.c3 from t_temp_p,t_temp_s where t_temp_p.c1 = t_temp_s.c1;
Query Plan
=============================================================
|ID|OPERATOR                                |NAME           |
-------------------------------------------------------------
|0 |INSERT                                  |               |
|1 |└─PX COORDINATOR                        |               |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001       |
|3 |    └─SUBPLAN SCAN                      |ANONYMOUS_VIEW1|
|4 |      └─SHARED HASH JOIN                |               |
|5 |        ├─EXCHANGE IN DISTR             |               |
|6 |        │ └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000       |
|7 |        │   └─PX BLOCK ITERATOR         |               |
|8 |        │     └─TABLE FULL SCAN         |t_temp_p       |
|9 |        └─PX BLOCK ITERATOR             |               |
|10|          └─TABLE FULL SCAN             |t_temp_s       |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]), partitions(p0), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_s.c3]), filter(nil), rowset=16
      equal_conds([t_temp_p.c1 = t_temp_s.c1]), other_conds(nil)
  5 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
  6 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
      dop=10
  7 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
  8 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
  9 - output([t_temp_s.c1], [t_temp_s.c3]), filter(nil), rowset=16
 10 - output([t_temp_s.c1], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
explain basic insert /*+use_px,parallel(10)*/ into t_s select t_temp_p.c1,t_temp_p.c2,t_temp_s.c3 from t_temp_p,t_temp_s where t_temp_p.c1 = t_temp_s.c1;
Query Plan
=============================================================
|ID|OPERATOR                                |NAME           |
-------------------------------------------------------------
|0 |INSERT                                  |               |
|1 |└─PX COORDINATOR                        |               |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001       |
|3 |    └─SUBPLAN SCAN                      |ANONYMOUS_VIEW1|
|4 |      └─SHARED HASH JOIN                |               |
|5 |        ├─EXCHANGE IN DISTR             |               |
|6 |        │ └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000       |
|7 |        │   └─PX BLOCK ITERATOR         |               |
|8 |        │     └─TABLE FULL SCAN         |t_temp_p       |
|9 |        └─PX BLOCK ITERATOR             |               |
|10|          └─TABLE FULL SCAN             |t_temp_s       |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_s: ({t_s: (t_s.c1, t_s.c2, t_s.c3)})}]), partitions(p0), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_s.c3]), filter(nil), rowset=16
      equal_conds([t_temp_p.c1 = t_temp_s.c1]), other_conds(nil)
  5 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
  6 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
      dop=10
  7 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
  8 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
  9 - output([t_temp_s.c1], [t_temp_s.c3]), filter(nil), rowset=16
 10 - output([t_temp_s.c1], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px,parallel(10)*/ into t_s select t_temp_p.c1,t_temp_p.c2,t_temp_s.c3 from t_temp_p,t_temp_s where t_temp_p.c1 = t_temp_s.c1;
select * from t_s order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 |    1 |
|  2 |    2 |    2 |
|  3 |    3 |    3 |
|  4 |    4 |    4 |
|  5 |    5 |    5 |
|  6 |    6 |    6 |
|  7 |    7 |    7 |
|  8 |    8 |    8 |
|  9 |    9 |    9 |
| 10 |   10 |   10 |
+----+------+------+
delete from t_s;

call dbms_stats.gather_table_stats('test','t_p');
explain basic insert /*+no_use_px,parallel(10)*/ into t_p select * from t_temp_s;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |DISTRIBUTED INSERT       |               |
|1 |└─PX COORDINATOR         |               |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000       |
|3 |    └─SUBPLAN SCAN       |ANONYMOUS_VIEW1|
|4 |      └─PX BLOCK ITERATOR|               |
|5 |        └─TABLE FULL SCAN|t_temp_s       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
  5 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
explain basic insert /*+use_px,parallel(10)*/ into t_p select * from t_temp_s;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |DISTRIBUTED INSERT       |               |
|1 |└─PX COORDINATOR         |               |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000       |
|3 |    └─SUBPLAN SCAN       |ANONYMOUS_VIEW1|
|4 |      └─PX BLOCK ITERATOR|               |
|5 |        └─TABLE FULL SCAN|t_temp_s       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
  5 - output([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c2], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px,parallel(10)*/ into t_p select * from t_temp_s;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 | NULL |    1 |
|  2 | NULL |    2 |
|  3 | NULL |    3 |
|  4 | NULL |    4 |
|  5 | NULL |    5 |
|  6 | NULL |    6 |
|  7 | NULL |    7 |
|  8 | NULL |    8 |
|  9 | NULL |    9 |
| 10 | NULL |   10 |
+----+------+------+
delete from t_p;

call dbms_stats.gather_table_stats('test','t_p');
explain basic insert /*+no_use_px,parallel(10)*/ into t_p select * from t_temp_p;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |PX COORDINATOR           |               |
|1 |└─EXCHANGE OUT DISTR     |:EX10000       |
|2 |  └─PX PARTITION ITERATOR|               |
|3 |    └─INSERT             |               |
|4 |      └─SUBPLAN SCAN     |ANONYMOUS_VIEW1|
|5 |        └─TABLE FULL SCAN|t_temp_p       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  4 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  5 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
explain basic insert /*+use_px,parallel(10)*/ into t_p select * from t_temp_p;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |PX COORDINATOR           |               |
|1 |└─EXCHANGE OUT DISTR     |:EX10000       |
|2 |  └─PX PARTITION ITERATOR|               |
|3 |    └─INSERT             |               |
|4 |      └─SUBPLAN SCAN     |ANONYMOUS_VIEW1|
|5 |        └─TABLE FULL SCAN|t_temp_p       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil), rowset=16
  1 - output(nil), filter(nil), rowset=16
      dop=10
  2 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  4 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  5 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px,parallel(10)*/ into t_p select * from t_temp_p;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  5 |    5 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
+----+------+------+
delete from t_p;

call dbms_stats.gather_table_stats('test','t_p');
explain basic insert /*+no_use_px, parallel(10)*/ into t_p select t_temp_p.c1,t_temp_p.c2,t_temp_p.c3 from t_temp_p,t_temp_p5 where t_temp_p.c1 = t_temp_p5.c1;
Query Plan
===============================================================
|ID|OPERATOR                                  |NAME           |
---------------------------------------------------------------
|0 |DISTRIBUTED INSERT                        |               |
|1 |└─PX COORDINATOR                          |               |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001       |
|3 |    └─SUBPLAN SCAN                        |ANONYMOUS_VIEW1|
|4 |      └─SHARED HASH JOIN                  |               |
|5 |        ├─PART JOIN FILTER CREATE         |:RF0000        |
|6 |        │ └─EXCHANGE IN DISTR             |               |
|7 |        │   └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000       |
|8 |        │     └─PX BLOCK ITERATOR         |               |
|9 |        │       └─TABLE FULL SCAN         |t_temp_p5      |
|10|        └─PX BLOCK HASH JOIN-FILTER       |:RF0000        |
|11|          └─TABLE FULL SCAN               |t_temp_p       |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      equal_conds([t_temp_p.c1 = t_temp_p5.c1]), other_conds(nil)
  5 - output([t_temp_p5.c1]), filter(nil), rowset=16
      RF_TYPE(bloom), RF_EXPR[calc_tablet_id(t_temp_p5.c1)]
  6 - output([t_temp_p5.c1]), filter(nil), rowset=16
  7 - output([t_temp_p5.c1]), filter(nil), rowset=16
      dop=10
  8 - output([t_temp_p5.c1]), filter(nil), rowset=16
  9 - output([t_temp_p5.c1]), filter(nil), rowset=16
      access([t_temp_p5.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p5.__pk_increment]), range(MIN ; MAX)always true
 10 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
 11 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
explain basic insert /*+use_px, parallel(10)*/ into t_p select t_temp_p.c1,t_temp_p.c2,t_temp_p.c3 from t_temp_p,t_temp_p5 where t_temp_p.c1 = t_temp_p5.c1;
Query Plan
===============================================================
|ID|OPERATOR                                  |NAME           |
---------------------------------------------------------------
|0 |DISTRIBUTED INSERT                        |               |
|1 |└─PX COORDINATOR                          |               |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001       |
|3 |    └─SUBPLAN SCAN                        |ANONYMOUS_VIEW1|
|4 |      └─SHARED HASH JOIN                  |               |
|5 |        ├─PART JOIN FILTER CREATE         |:RF0000        |
|6 |        │ └─EXCHANGE IN DISTR             |               |
|7 |        │   └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000       |
|8 |        │     └─PX BLOCK ITERATOR         |               |
|9 |        │       └─TABLE FULL SCAN         |t_temp_p5      |
|10|        └─PX BLOCK HASH JOIN-FILTER       |:RF0000        |
|11|          └─TABLE FULL SCAN               |t_temp_p       |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      equal_conds([t_temp_p.c1 = t_temp_p5.c1]), other_conds(nil)
  5 - output([t_temp_p5.c1]), filter(nil), rowset=16
      RF_TYPE(bloom), RF_EXPR[calc_tablet_id(t_temp_p5.c1)]
  6 - output([t_temp_p5.c1]), filter(nil), rowset=16
  7 - output([t_temp_p5.c1]), filter(nil), rowset=16
      dop=10
  8 - output([t_temp_p5.c1]), filter(nil), rowset=16
  9 - output([t_temp_p5.c1]), filter(nil), rowset=16
      access([t_temp_p5.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p5.__pk_increment]), range(MIN ; MAX)always true
 10 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
 11 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px, parallel(10)*/ into t_p select t_temp_p.c1,t_temp_p.c2,t_temp_p.c3 from t_temp_p,t_temp_p5 where t_temp_p.c1 = t_temp_p5.c1;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  5 |    5 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
+----+------+------+
delete from t_p;

call dbms_stats.gather_table_stats('test','t_p');
explain basic insert /*+use_px, parallel(10)*/ into t_p select t_temp_p.c1,t_temp_p.c2,t_temp_p.c3 from t_temp_p,t_temp_p5 where t_temp_p.c1 = t_temp_p5.c1 and t_temp_p.c1 = 3;
Query Plan
===============================================================
|ID|OPERATOR                                  |NAME           |
---------------------------------------------------------------
|0 |INSERT                                    |               |
|1 |└─PX COORDINATOR                          |               |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001       |
|3 |    └─SUBPLAN SCAN                        |ANONYMOUS_VIEW1|
|4 |      └─NESTED-LOOP JOIN CARTESIAN        |               |
|5 |        ├─EXCHANGE IN DISTR               |               |
|6 |        │ └─EXCHANGE OUT DISTR (BROADCAST)|:EX10000       |
|7 |        │   └─PX BLOCK ITERATOR           |               |
|8 |        │     └─TABLE FULL SCAN           |t_temp_p5      |
|9 |        └─MATERIAL                        |               |
|10|          └─PX BLOCK ITERATOR             |               |
|11|            └─TABLE FULL SCAN             |t_temp_p       |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p3), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  5 - output(nil), filter(nil), rowset=16
  6 - output(nil), filter(nil), rowset=16
      dop=10
  7 - output(nil), filter(nil), rowset=16
  8 - output(nil), filter([t_temp_p5.c1 = 3]), rowset=16
      access([t_temp_p5.c1]), partitions(p3)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_temp_p5.__pk_increment]), range(MIN ; MAX)always true
  9 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
 10 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
 11 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter([t_temp_p.c1 = 3]), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p3)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px, parallel(10)*/ into t_p select t_temp_p.c1,t_temp_p.c2,t_temp_p.c3 from t_temp_p,t_temp_p5 where t_temp_p.c1 = t_temp_p5.c1 and t_temp_p.c1 = 3;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  3 |    3 | NULL |
+----+------+------+
delete from t_p;

call dbms_stats.gather_table_stats('test','t_p');
explain basic insert /*+use_px, parallel(10)*/ into t_p select  t_temp_p.c1, t_temp_p.c2, t_temp_p.c3 from t_temp_p, t_temp_p4 where t_temp_p.c1 = t_temp_p4.c1;
Query Plan
===============================================================
|ID|OPERATOR                                  |NAME           |
---------------------------------------------------------------
|0 |DISTRIBUTED INSERT                        |               |
|1 |└─PX COORDINATOR                          |               |
|2 |  └─EXCHANGE OUT DISTR                    |:EX10001       |
|3 |    └─SUBPLAN SCAN                        |ANONYMOUS_VIEW1|
|4 |      └─SHARED HASH JOIN                  |               |
|5 |        ├─PART JOIN FILTER CREATE         |:RF0000        |
|6 |        │ └─EXCHANGE IN DISTR             |               |
|7 |        │   └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000       |
|8 |        │     └─PX BLOCK ITERATOR         |               |
|9 |        │       └─TABLE FULL SCAN         |t_temp_p4      |
|10|        └─PX BLOCK HASH JOIN-FILTER       |:RF0000        |
|11|          └─TABLE FULL SCAN               |t_temp_p       |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      equal_conds([t_temp_p.c1 = t_temp_p4.c1]), other_conds(nil)
  5 - output([t_temp_p4.c1]), filter(nil), rowset=16
      RF_TYPE(bloom), RF_EXPR[calc_tablet_id(t_temp_p4.c1)]
  6 - output([t_temp_p4.c1]), filter(nil), rowset=16
  7 - output([t_temp_p4.c1]), filter(nil), rowset=16
      dop=10
  8 - output([t_temp_p4.c1]), filter(nil), rowset=16
  9 - output([t_temp_p4.c1]), filter(nil), rowset=16
      access([t_temp_p4.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p4.__pk_increment]), range(MIN ; MAX)always true
 10 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
 11 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px, parallel(10)*/ into t_p select  t_temp_p.c1, t_temp_p.c2, t_temp_p.c3 from t_temp_p, t_temp_p4 where t_temp_p.c1 = t_temp_p4.c1;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    3 | NULL |
|  4 |    4 | NULL |
|  5 |    5 | NULL |
|  6 |    6 | NULL |
|  7 |    7 | NULL |
|  8 |    8 | NULL |
|  9 |    9 | NULL |
| 10 |   10 | NULL |
+----+------+------+
delete from t_p;

call dbms_stats.gather_table_stats('test','t_p');
explain basic insert /*+no_use_px,parallel(10)*/ into t_p select t_temp_p.c1,t_temp_p.c2,t_temp_s.c3 from t_temp_p,t_temp_s where t_temp_p.c1 = t_temp_s.c1;
Query Plan
=============================================================
|ID|OPERATOR                                |NAME           |
-------------------------------------------------------------
|0 |DISTRIBUTED INSERT                      |               |
|1 |└─PX COORDINATOR                        |               |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001       |
|3 |    └─SUBPLAN SCAN                      |ANONYMOUS_VIEW1|
|4 |      └─SHARED HASH JOIN                |               |
|5 |        ├─EXCHANGE IN DISTR             |               |
|6 |        │ └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000       |
|7 |        │   └─PX BLOCK ITERATOR         |               |
|8 |        │     └─TABLE FULL SCAN         |t_temp_p       |
|9 |        └─PX BLOCK ITERATOR             |               |
|10|          └─TABLE FULL SCAN             |t_temp_s       |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_s.c3]), filter(nil), rowset=16
      equal_conds([t_temp_p.c1 = t_temp_s.c1]), other_conds(nil)
  5 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
  6 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
      dop=10
  7 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
  8 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
  9 - output([t_temp_s.c1], [t_temp_s.c3]), filter(nil), rowset=16
 10 - output([t_temp_s.c1], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
explain basic insert /*+use_px,parallel(10)*/ into t_p select t_temp_p.c1,t_temp_p.c2,t_temp_s.c3 from t_temp_p,t_temp_s where t_temp_p.c1 = t_temp_s.c1;
Query Plan
=============================================================
|ID|OPERATOR                                |NAME           |
-------------------------------------------------------------
|0 |DISTRIBUTED INSERT                      |               |
|1 |└─PX COORDINATOR                        |               |
|2 |  └─EXCHANGE OUT DISTR                  |:EX10001       |
|3 |    └─SUBPLAN SCAN                      |ANONYMOUS_VIEW1|
|4 |      └─SHARED HASH JOIN                |               |
|5 |        ├─EXCHANGE IN DISTR             |               |
|6 |        │ └─EXCHANGE OUT DISTR (BC2HOST)|:EX10000       |
|7 |        │   └─PX BLOCK ITERATOR         |               |
|8 |        │     └─TABLE FULL SCAN         |t_temp_p       |
|9 |        └─PX BLOCK ITERATOR             |               |
|10|          └─TABLE FULL SCAN             |t_temp_s       |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_s.c3]), filter(nil), rowset=16
      equal_conds([t_temp_p.c1 = t_temp_s.c1]), other_conds(nil)
  5 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
  6 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
      dop=10
  7 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
  8 - output([t_temp_p.c1], [t_temp_p.c2]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
  9 - output([t_temp_s.c1], [t_temp_s.c3]), filter(nil), rowset=16
 10 - output([t_temp_s.c1], [t_temp_s.c3]), filter(nil), rowset=16
      access([t_temp_s.c1], [t_temp_s.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_s.__pk_increment]), range(MIN ; MAX)always true
insert /*+use_px,parallel(10)*/ into t_p select t_temp_p.c1,t_temp_p.c2,t_temp_s.c3 from t_temp_p,t_temp_s where t_temp_p.c1 = t_temp_s.c1;
select * from t_p order by c1;
+----+------+------+
| c1 | c2   | c3   |
+----+------+------+
|  1 |    1 |    1 |
|  2 |    2 |    2 |
|  3 |    3 |    3 |
|  4 |    4 |    4 |
|  5 |    5 |    5 |
|  6 |    6 |    6 |
|  7 |    7 |    7 |
|  8 |    8 |    8 |
|  9 |    9 |    9 |
| 10 |   10 |   10 |
+----+------+------+
delete from t_p;
call dbms_stats.gather_table_stats('test','t_p');

## replace / insert on duplicate 计划
## 目前replace / insert on duplicate计划是不支持PX
explain basic replace /*+use_px,parallel(10)*/ into t_p select * from t_temp_p;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |DISTRIBUTED REPLACE      |               |
|1 |└─PX COORDINATOR         |               |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000       |
|3 |    └─SUBPLAN SCAN       |ANONYMOUS_VIEW1|
|4 |      └─PX BLOCK ITERATOR|               |
|5 |        └─TABLE FULL SCAN|t_temp_p       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
  5 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true
explain basic insert /*+use_px,parallel(10)*/ into t_p select * from t_temp_p on duplicate key update c3 = 2;
Query Plan
==============================================
|ID|OPERATOR                 |NAME           |
----------------------------------------------
|0 |DISTRIBUTED INSERT_UP    |               |
|1 |└─PX COORDINATOR         |               |
|2 |  └─EXCHANGE OUT DISTR   |:EX10000       |
|3 |    └─SUBPLAN SCAN       |ANONYMOUS_VIEW1|
|4 |      └─PX BLOCK ITERATOR|               |
|5 |        └─TABLE FULL SCAN|t_temp_p       |
==============================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{t_p: ({t_p: (t_p.c1, t_p.c2, t_p.c3)})}]), partitions(p[0-3]), 
      column_values([column_conv(INT,PS:(11,0),NOT NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)], [column_conv(INT,PS:(11,
      0),NULL,ANONYMOUS_VIEW1.c3)]),
      update([t_p.c3=column_conv(INT,PS:(11,0),NULL,2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
  2 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      dop=10
  3 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2], [ANONYMOUS_VIEW1.c3])
  4 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
  5 - output([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), filter(nil), rowset=16
      access([t_temp_p.c1], [t_temp_p.c2], [t_temp_p.c3]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_temp_p.__pk_increment]), range(MIN ; MAX)always true

drop table if exists t_s,t_p,t_p4,t_no_p,t_temp_s,t_temp_p,t_temp_p4,t_temp_p5;
