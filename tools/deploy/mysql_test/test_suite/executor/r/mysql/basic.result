drop table if exists t_h3_01_20;
drop table if exists t_h3_05_24;
drop table if exists t_h3_09_28;
drop table if exists t_h5_01_20;
drop table if exists t_h5_05_24;
drop table if exists t_h5_09_28;
drop table if exists t_r4_01_20;
drop table if exists t_r4_05_24;
drop table if exists t_r4_09_28;
drop table if exists t_r5_01_20;
drop table if exists t_r5_05_24;
drop table if exists t_r5_09_28;
drop table if exists t_h3_r4_01_20;
drop table if exists t_h3_r5_09_28;
drop table if exists t_h5_r4_01_20;
drop table if exists t_h5_r5_09_28;
drop table if exists t_refered;
drop table if exists t_h5_int;
drop table if exists t_r4_int;
drop table if exists t_r4_date;
drop table if exists t_r4_datetime;
drop table if exists t_r4_timestamp;
drop table if exists t_h5_r4_int_int;
drop table if exists t_h5_r4_int_int_datetime;
drop table if exists t_r4_h2_date_int;
drop table if exists t_r4_h3_date_int;
drop table if exists t_r4_h3_date_bigint;
drop table if exists tt;
drop table if exists t_many_range_part;
create table t_h3_01_20(a int, b int, c datetime, primary key (a)) partition by hash(a) partitions 3;
create table t_h3_05_24(a int, b int, c datetime, primary key (a)) partition by hash(a) partitions 3;
create table t_h3_09_28(a int, b int, c datetime, primary key (a)) partition by hash(a) partitions 3;
create table t_h5_01_20(a int, b int, c datetime, primary key (a)) partition by hash(a) partitions 5;
create table t_h5_05_24(a int, b int, c datetime, primary key (a)) partition by hash(a) partitions 5;
create table t_h5_09_28(a int, b int, c datetime, primary key (a)) partition by hash(a) partitions 5;
create table t_r4_01_20(a int, b int, c datetime, primary key (a,b))
partition by range columns(a)
(
partition p6 values less than (6),
partition p11 values less than (11),
partition p16 values less than (16),
partition pm values less than (MAXVALUE)
);
create table t_r4_05_24(a int, b int, c datetime, primary key (a))
partition by range columns(a)
(
partition p10 values less than (10),
partition p15 values less than (15),
partition p20 values less than (20),
partition pm values less than (MAXVALUE)
);
create table t_r4_09_28(a int, b int, c datetime, primary key (a))
partition by range columns(a)
(
partition p14 values less than (14),
partition p19 values less than (19),
partition p24 values less than (24),
partition pm values less than (MAXVALUE)
);
create table t_r5_01_20(a int, b int, c datetime, primary key (a))
partition by range columns(a)
(
partition p5 values less than (5),
partition p9 values less than (9),
partition p13 values less than (13),
partition p17 values less than (17),
partition pm values less than (MAXVALUE)
);
create table t_r5_05_24(a int, b int, c datetime, primary key (a))
partition by range columns(a)
(
partition p9 values less than (9),
partition p13 values less than (13),
partition p17 values less than (17),
partition p21 values less than (21),
partition pm values less than (MAXVALUE)
);
create table t_r5_09_28(a int, b int, c datetime, primary key (a,b))
partition by range columns(a)
(
partition p13 values less than (13),
partition p17 values less than (17),
partition p21 values less than (21),
partition p25 values less than (25),
partition pm values less than (MAXVALUE)
);
create table t_h3_r4_01_20(a int, b int, c int, d int, e datetime, primary key (a, b, c))
partition by hash(a)
subpartition by range(b)
subpartition template (
subpartition p6 values less than (6),
subpartition p11 values less than (11),
subpartition p16 values less than (16),
subpartition pm values less than (MAXVALUE)
)
partitions 3;
create table t_h3_r5_09_28(a int, b int, c int, d int, e datetime, primary key (a, b))
partition by hash(a)
subpartition by range(b)
subpartition template (
subpartition p13 values less than (13),
subpartition p17 values less than (17),
subpartition p21 values less than (21),
subpartition p25 values less than (25),
subpartition pm values less than (MAXVALUE)
)
partitions 3;
create table t_h5_r4_01_20(a int, b int, c int, d int, e datetime, primary key (a, b))
partition by hash(a)
subpartition by range(b)
subpartition template (
subpartition p6 values less than (6),
subpartition p11 values less than (11),
subpartition p16 values less than (16),
subpartition pm values less than (MAXVALUE)
)
partitions 5;
create table t_h5_r5_09_28(a int, b int, c int, d int, e datetime, primary key (a, b, c))
partition by hash(a)
subpartition by range(b)
subpartition template (
subpartition p13 values less than (13),
subpartition p17 values less than (17),
subpartition p21 values less than (21),
subpartition p25 values less than (25),
subpartition pm values less than (MAXVALUE)
)
partitions 5;
create table t_refered(a int, aa bigint, b int unsigned, bb bigint unsigned, c datetime, d date, e timestamp,  primary key (a))  partition by hash(a) partitions 3;
create table t_h5_int(a int, b int, c datetime, primary key (a)) partition by hash(a) partitions 5;
create table t_r4_int(a int, b int, c date, primary key (a,b))
partition by range columns(a)
(
partition p6 values less than (6),
partition p11 values less than (11),
partition p16 values less than (16),
partition pm values less than (MAXVALUE)
);
create table t_r4_date(a int, b int, c date, primary key (b,c))
partition by range columns(c)
(
partition p11 values less than ("20161101"),
partition p12 values less than ("20161201"),
partition p171 values less than ("20170101"),
partition pm values less than (MAXVALUE)
);
create table t_r4_datetime(a int, b int, c datetime, primary key (b,c))
partition by range columns(c)
(
partition p11 values less than ("20161101"),
partition p12 values less than ("20161201"),
partition p171 values less than ("20170101"),
partition pm values less than (MAXVALUE)
);
create table t_r4_timestamp(a int, b int, c timestamp, primary key (a))
partition by range columns(a)
(
partition p11 values less than (10),
partition p12 values less than (100),
partition p171 values less than (1000),
partition pm values less than (MAXVALUE)
);
create table t_h5_r4_int_int(a int, b int, c datetime, primary key (a, b))
partition by hash(a)
subpartition by range columns(b)
subpartition template (
subpartition p6 values less than (6),
subpartition p11 values less than (11),
subpartition p16 values less than (16),
subpartition pm values less than (MAXVALUE)
);
create table t_r4_h3_date_int(a date, b int, c int, primary key (a, b))
partition by range columns(a) subpartition by hash(b) subpartitions 3
(
partition p11 values less than ("20161101"),
partition p12 values less than ("20161201"),
partition p171 values less than ("20170101"),
partition pm values less than (MAXVALUE)
);
create table t_r4_h2_date_int(a date, b int, c int, primary key (a, b))
partition by range columns(a) subpartition by hash(b) subpartitions 2
(
partition p11 values less than ("20161101"),
partition p12 values less than ("20161201"),
partition p171 values less than ("20170101"),
partition pm values less than (MAXVALUE)
);
create table t_r4_h3_date_bigint(a date, b bigint, c int, primary key (a, b))
partition by range columns(a) subpartition by hash(b) subpartitions 3
(
partition p11 values less than ("20161101"),
partition p12 values less than ("20161201"),
partition p171 values less than ("20170101"),
partition pm values less than (MAXVALUE)
);
create table t_h5_r4_int_int_datetime(a int, b int, c datetime, primary key (a, b, c))
partition by hash(a)
subpartition by range columns(b, c)
subpartition template (
subpartition p6 values less than (6, "20170510"),
subpartition p11 values less than (11, "20170510"),
subpartition p16 values less than (16, "20170510"),
subpartition pm values less than (MAXVALUE, MAXVALUE)
);
create table tt (a int, b int, c date, primary key(a, b));
insert into t_h3_01_20 values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104),
( 5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120);
insert into t_h3_05_24 values ( 5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124);
insert into t_h3_09_28 values ( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124),
(25, 25, 20161125), (26, 26, 20161126), (27, 27, 20161127), (28, 28, 20161128);
insert into t_h5_01_20 values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104),
( 5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120);
insert into t_h5_05_24 values ( 5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124);
insert into t_h5_09_28 values ( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124),
(25, 25, 20161125), (26, 26, 20161126), (27, 27, 20161127), (28, 28, 20161128);
insert into t_r4_01_20 values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104),
( 5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120);
insert into t_r4_05_24 values ( 5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124);
insert into t_r4_09_28 values ( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124),
(25, 25, 20161125), (26, 26, 20161126), (27, 27, 20161127), (28, 28, 20161128);
insert into t_r5_01_20 values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104),
( 5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120);
insert into t_r5_05_24 values ( 5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124);
insert into t_r5_09_28 values ( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124),
(25, 25, 20161125), (26, 26, 20161126), (27, 27, 20161127), (28, 28, 20161128);
insert into t_h3_r4_01_20 values ( 1,  1,  1,  1, 20161101), ( 2,  2,  2,  2, 20161102), ( 3,  3,  3,  3, 20161103), ( 4,  4,  4,  4, 20161104),
( 5,  5,  5,  5, 20161105), ( 6,  6,  6,  6, 20161106), ( 7,  7,  7,  7, 20161107), ( 8,  8,  8,  8, 20161108),
( 9,  9,  9,  9, 20161109), (10, 10, 10, 10, 20161110), (11, 11, 11, 11, 20161111), (12, 12, 12, 12, 20161112),
(13, 13, 13, 13, 20161113), (14, 14, 14, 14, 20161114), (15, 15, 15, 15, 20161115), (16, 16, 16, 16, 20161116),
(17, 17, 17, 17, 20161117), (18, 18, 18, 18, 20161118), (19, 19, 19, 19, 20161119), (20, 20, 20, 20, 20161120);
insert into t_h3_r5_09_28 values ( 9,  9,  9,  9, 20161109), (10, 10, 10, 10, 20161110), (11, 11, 11, 11, 20161111), (12, 12, 12, 12, 20161112),
(13, 13, 13, 13, 20161113), (14, 14, 14, 14, 20161114), (15, 15, 15, 15, 20161115), (16, 16, 16, 16, 20161116),
(17, 17, 17, 17, 20161117), (18, 18, 18, 18, 20161118), (19, 19, 19, 19, 20161119), (20, 20, 20, 20, 20161120),
(21, 21, 21, 21, 20161121), (22, 22, 22, 22, 20161122), (23, 23, 23, 23, 20161123), (24, 24, 24, 24, 20161124),
(25, 25, 25, 25, 20161125), (26, 26, 26, 26, 20161126), (27, 27, 27, 27, 20161127), (28, 28, 28, 28, 20161128);
insert into t_h5_r4_01_20 values ( 1,  1,  1,  1, 20161101), ( 2,  2,  2,  2, 20161102), ( 3,  3,  3,  3, 20161103), ( 4,  4,  4,  4, 20161104),
( 5,  5,  5,  5, 20161105), ( 6,  6,  6,  6, 20161106), ( 7,  7,  7,  7, 20161107), ( 8,  8,  8,  8, 20161108),
( 9,  9,  9,  9, 20161109), (10, 10, 10, 10, 20161110), (11, 11, 11, 11, 20161111), (12, 12, 12, 12, 20161112),
(13, 13, 13, 13, 20161113), (14, 14, 14, 14, 20161114), (15, 15, 15, 15, 20161115), (16, 16, 16, 16, 20161116),
(17, 17, 17, 17, 20161117), (18, 18, 18, 18, 20161118), (19, 19, 19, 19, 20161119), (20, 20, 20, 20, 20161120);
insert into t_h5_r5_09_28 values ( 9,  9,  9,  9, 20161109), (10, 10, 10, 10, 20161110), (11, 11, 11, 11, 20161111), (12, 12, 12, 12, 20161112),
(13, 13, 13, 13, 20161113), (14, 14, 14, 14, 20161114), (15, 15, 15, 15, 20161115), (16, 16, 16, 16, 20161116),
(17, 17, 17, 17, 20161117), (18, 18, 18, 18, 20161118), (19, 19, 19, 19, 20161119), (20, 20, 20, 20, 20161120),
(21, 21, 21, 21, 20161121), (22, 22, 22, 22, 20161122), (23, 23, 23, 23, 20161123), (24, 24, 24, 24, 20161124),
(25, 25, 25, 25, 20161125), (26, 26, 26, 26, 20161126), (27, 27, 27, 27, 20161127), (28, 28, 28, 28, 20161128);
insert into t_refered values ( 1,  1, 1, 1, 20161101, 20161101, 20161101), ( 2,  2, 2, 2, 20161101, 20161102, 20161102), ( 3,  3, 3, 3, 20161103, 20161101, 20161103), ( 4,  4, 4, 4, 20161104, 20161101, 20161104);
insert into t_h5_int values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104), ( 5,  5, 20161105);
insert into t_r4_int values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104),  ( 5,  5, 20161105);
insert into t_r4_date values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104);
insert into t_r4_datetime values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104);
insert into t_r4_timestamp values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104);
insert into t_h5_r4_int_int values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104);
insert into t_h5_r4_int_int_datetime values ( 1,  1, 20161101), ( 2,  2, 20161102), ( 3,  3, 20161103), ( 4,  4, 20161104);
insert into tt values ( 5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124),
(5, 6, 20161105), ( 6,  7, 20161106), ( 7,  8, 20161107), ( 8,  9, 20161108),
(9, 10, 20161109), (10, 11, 20161110), (11, 12, 20161111), (12, 13, 20161112),
(13, 14, 20161113), (14, 15, 20161114), (15, 16, 20161115), (16, 17, 20161116),
(17, 18, 20161117), (18, 19, 20161118), (19, 20, 20161119), (20, 21, 20161120),
(21, 22, 20161121), (22, 23, 20161122), (23, 24, 20161123), (24, 25, 20161124);
insert into t_r4_h2_date_int(b, c, a) values (5,  5, 20161105), ( 6,  6, 20161106), ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123), (24, 24, 20161124);
insert into t_r4_h3_date_int(b, c, a) values ( 7,  7, 20161107), ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122), (23, 23, 20161123);
insert into t_r4_h3_date_bigint(b, c, a) values  ( 8,  8, 20161108),
( 9,  9, 20161109), (10, 10, 20161110), (11, 11, 20161111), (12, 12, 20161112),
(13, 13, 20161113), (14, 14, 20161114), (15, 15, 20161115), (16, 16, 20161116),
(17, 17, 20161117), (18, 18, 20161118), (19, 19, 20161119), (20, 20, 20161120),
(21, 21, 20161121), (22, 22, 20161122);
create table t_many_range_part(a int, b int, primary key (a))
partition by range columns(a)
(
partition p05 values less than (5),
partition p10 values less than (10),
partition p15 values less than (15),
partition p20 values less than (20),
partition p25 values less than (25),
partition p30 values less than (30),
partition p35 values less than (35),
partition p40 values less than (40),
partition p45 values less than (45),
partition p50 values less than (50),
partition p55 values less than (55),
partition p60 values less than (60),
partition p65 values less than (65),
partition p70 values less than (70),
partition p75 values less than (75),
partition p80 values less than (80),
partition p85 values less than (85),
partition pm values less than (MAXVALUE)
);
insert into t_many_range_part values (01, 01), (02, 02), (03, 03), (04, 04), (05, 05), (06, 06), (07, 07), (08, 08), (09, 09), (10, 10),
(11, 11), (12, 12), (13, 13), (14, 14), (15, 15), (16, 16), (17, 17), (18, 18), (19, 19), (20, 20),
(21, 21), (22, 22), (23, 23), (24, 24), (25, 25), (26, 26), (27, 27), (28, 28), (29, 29), (30, 30),
(31, 31), (32, 32), (33, 33), (34, 34), (35, 35), (36, 36), (37, 37), (38, 38), (39, 39), (40, 40),
(41, 41), (42, 42), (43, 43), (44, 44), (45, 45), (46, 46), (47, 47), (48, 48), (49, 49), (50, 50);
result_format: 4
explain_protocol: 2
################################
EXPLAIN select b, sum(a) from t_h3_01_20 group by b having sum(a) between 5 and 16 order by b;
Query Plan
=========================================================================
|ID|OPERATOR                           |NAME      |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |          |1       |43          |
|1 |└─EXCHANGE OUT DISTR               |:EX10001  |1       |42          |
|2 |  └─MERGE GROUP BY                 |          |1       |41          |
|3 |    └─EXCHANGE IN MERGE SORT DISTR |          |20      |39          |
|4 |      └─EXCHANGE OUT DISTR (HASH)  |:EX10000  |20      |31          |
|5 |        └─MERGE GROUP BY           |          |20      |12          |
|6 |          └─SORT                   |          |20      |10          |
|7 |            └─PX PARTITION ITERATOR|          |20      |8           |
|8 |              └─TABLE FULL SCAN    |t_h3_01_20|20      |8           |
=========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h3_01_20.b, T_FUN_SUM(T_FUN_SUM(t_h3_01_20.a)))]), filter(nil), rowset=256
      sort_keys([t_h3_01_20.b, ASC])
  1 - output([t_h3_01_20.b], [INTERNAL_FUNCTION(t_h3_01_20.b, T_FUN_SUM(T_FUN_SUM(t_h3_01_20.a)))]), filter(nil), rowset=256
      dop=1
  2 - output([t_h3_01_20.b], [T_FUN_SUM(T_FUN_SUM(t_h3_01_20.a))]), filter([T_FUN_SUM(T_FUN_SUM(t_h3_01_20.a)) >= cast(5, DECIMAL_INT(33, 0))], [T_FUN_SUM(T_FUN_SUM(t_h3_01_20.a)) 
      <= cast(16, DECIMAL_INT(33, 0))]), rowset=256
      group([t_h3_01_20.b]), agg_func([T_FUN_SUM(T_FUN_SUM(t_h3_01_20.a))])
  3 - output([t_h3_01_20.b], [T_FUN_SUM(t_h3_01_20.a)]), filter(nil), rowset=256
      sort_keys([t_h3_01_20.b, ASC])
  4 - output([t_h3_01_20.b], [T_FUN_SUM(t_h3_01_20.a)]), filter(nil), rowset=256
      (#keys=1, [t_h3_01_20.b]), dop=1
  5 - output([t_h3_01_20.b], [T_FUN_SUM(t_h3_01_20.a)]), filter(nil), rowset=256
      group([t_h3_01_20.b]), agg_func([T_FUN_SUM(t_h3_01_20.a)])
  6 - output([t_h3_01_20.b], [t_h3_01_20.a]), filter(nil), rowset=256
      sort_keys([t_h3_01_20.b, ASC])
  7 - output([t_h3_01_20.a], [t_h3_01_20.b]), filter(nil), rowset=256
      force partition granule
  8 - output([t_h3_01_20.a], [t_h3_01_20.b]), filter(nil), rowset=256
      access([t_h3_01_20.a], [t_h3_01_20.b]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t_h3_01_20.a]), range(MIN ; MAX)always true
select b, sum(a) from t_h3_01_20 group by b having sum(a) between 5 and 16 order by b;
+------+--------+
| b    | sum(a) |
+------+--------+
|    5 |      5 |
|    6 |      6 |
|    7 |      7 |
|    8 |      8 |
|    9 |      9 |
|   10 |     10 |
|   11 |     11 |
|   12 |     12 |
|   13 |     13 |
|   14 |     14 |
|   15 |     15 |
|   16 |     16 |
+------+--------+
EXPLAIN select b, sum(a) from t_h5_09_28 group by b having sum(a) between 13 and 24 order by b desc;
Query Plan
=========================================================================
|ID|OPERATOR                           |NAME      |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |          |1       |47          |
|1 |└─EXCHANGE OUT DISTR               |:EX10001  |1       |46          |
|2 |  └─MERGE GROUP BY                 |          |1       |46          |
|3 |    └─EXCHANGE IN MERGE SORT DISTR |          |20      |43          |
|4 |      └─EXCHANGE OUT DISTR (HASH)  |:EX10000  |20      |35          |
|5 |        └─MERGE GROUP BY           |          |20      |16          |
|6 |          └─SORT                   |          |20      |14          |
|7 |            └─PX PARTITION ITERATOR|          |20      |12          |
|8 |              └─TABLE FULL SCAN    |t_h5_09_28|20      |12          |
=========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h5_09_28.b, T_FUN_SUM(T_FUN_SUM(t_h5_09_28.a)))]), filter(nil), rowset=256
      sort_keys([t_h5_09_28.b, DESC])
  1 - output([t_h5_09_28.b], [INTERNAL_FUNCTION(t_h5_09_28.b, T_FUN_SUM(T_FUN_SUM(t_h5_09_28.a)))]), filter(nil), rowset=256
      dop=1
  2 - output([t_h5_09_28.b], [T_FUN_SUM(T_FUN_SUM(t_h5_09_28.a))]), filter([T_FUN_SUM(T_FUN_SUM(t_h5_09_28.a)) >= cast(13, DECIMAL_INT(33, 0))], [T_FUN_SUM(T_FUN_SUM(t_h5_09_28.a)) 
      <= cast(24, DECIMAL_INT(33, 0))]), rowset=256
      group([t_h5_09_28.b]), agg_func([T_FUN_SUM(T_FUN_SUM(t_h5_09_28.a))])
  3 - output([t_h5_09_28.b], [T_FUN_SUM(t_h5_09_28.a)]), filter(nil), rowset=256
      sort_keys([t_h5_09_28.b, DESC])
  4 - output([t_h5_09_28.b], [T_FUN_SUM(t_h5_09_28.a)]), filter(nil), rowset=256
      (#keys=1, [t_h5_09_28.b]), dop=1
  5 - output([t_h5_09_28.b], [T_FUN_SUM(t_h5_09_28.a)]), filter(nil), rowset=256
      group([t_h5_09_28.b]), agg_func([T_FUN_SUM(t_h5_09_28.a)])
  6 - output([t_h5_09_28.b], [t_h5_09_28.a]), filter(nil), rowset=256
      sort_keys([t_h5_09_28.b, DESC])
  7 - output([t_h5_09_28.a], [t_h5_09_28.b]), filter(nil), rowset=256
      force partition granule
  8 - output([t_h5_09_28.a], [t_h5_09_28.b]), filter(nil), rowset=256
      access([t_h5_09_28.a], [t_h5_09_28.b]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_h5_09_28.a]), range(MIN ; MAX)always true
select b, sum(a) from t_h5_09_28 group by b having sum(a) between 13 and 24 order by b desc;
+------+--------+
| b    | sum(a) |
+------+--------+
|   24 |     24 |
|   23 |     23 |
|   22 |     22 |
|   21 |     21 |
|   20 |     20 |
|   19 |     19 |
|   18 |     18 |
|   17 |     17 |
|   16 |     16 |
|   15 |     15 |
|   14 |     14 |
|   13 |     13 |
+------+--------+
EXPLAIN select b, sum(a) from t_r4_01_20 group by b having sum(a) between 5 and 16 order by b;
Query Plan
=========================================================================
|ID|OPERATOR                           |NAME      |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |          |1       |45          |
|1 |└─EXCHANGE OUT DISTR               |:EX10001  |1       |44          |
|2 |  └─MERGE GROUP BY                 |          |1       |43          |
|3 |    └─EXCHANGE IN MERGE SORT DISTR |          |20      |41          |
|4 |      └─EXCHANGE OUT DISTR (HASH)  |:EX10000  |20      |33          |
|5 |        └─MERGE GROUP BY           |          |20      |14          |
|6 |          └─SORT                   |          |20      |12          |
|7 |            └─PX PARTITION ITERATOR|          |20      |10          |
|8 |              └─TABLE FULL SCAN    |t_r4_01_20|20      |10          |
=========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_r4_01_20.b, T_FUN_SUM(T_FUN_SUM(t_r4_01_20.a)))]), filter(nil), rowset=256
      sort_keys([t_r4_01_20.b, ASC])
  1 - output([t_r4_01_20.b], [INTERNAL_FUNCTION(t_r4_01_20.b, T_FUN_SUM(T_FUN_SUM(t_r4_01_20.a)))]), filter(nil), rowset=256
      dop=1
  2 - output([t_r4_01_20.b], [T_FUN_SUM(T_FUN_SUM(t_r4_01_20.a))]), filter([T_FUN_SUM(T_FUN_SUM(t_r4_01_20.a)) >= cast(5, DECIMAL_INT(33, 0))], [T_FUN_SUM(T_FUN_SUM(t_r4_01_20.a)) 
      <= cast(16, DECIMAL_INT(33, 0))]), rowset=256
      group([t_r4_01_20.b]), agg_func([T_FUN_SUM(T_FUN_SUM(t_r4_01_20.a))])
  3 - output([t_r4_01_20.b], [T_FUN_SUM(t_r4_01_20.a)]), filter(nil), rowset=256
      sort_keys([t_r4_01_20.b, ASC])
  4 - output([t_r4_01_20.b], [T_FUN_SUM(t_r4_01_20.a)]), filter(nil), rowset=256
      (#keys=1, [t_r4_01_20.b]), dop=1
  5 - output([t_r4_01_20.b], [T_FUN_SUM(t_r4_01_20.a)]), filter(nil), rowset=256
      group([t_r4_01_20.b]), agg_func([T_FUN_SUM(t_r4_01_20.a)])
  6 - output([t_r4_01_20.b], [t_r4_01_20.a]), filter(nil), rowset=256
      sort_keys([t_r4_01_20.b, ASC])
  7 - output([t_r4_01_20.a], [t_r4_01_20.b]), filter(nil), rowset=256
      force partition granule
  8 - output([t_r4_01_20.a], [t_r4_01_20.b]), filter(nil), rowset=256
      access([t_r4_01_20.a], [t_r4_01_20.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_r4_01_20.a], [t_r4_01_20.b]), range(MIN,MIN ; MAX,MAX)always true
select b, sum(a) from t_r4_01_20 group by b having sum(a) between 5 and 16 order by b;
+----+--------+
| b  | sum(a) |
+----+--------+
|  5 |      5 |
|  6 |      6 |
|  7 |      7 |
|  8 |      8 |
|  9 |      9 |
| 10 |     10 |
| 11 |     11 |
| 12 |     12 |
| 13 |     13 |
| 14 |     14 |
| 15 |     15 |
| 16 |     16 |
+----+--------+
EXPLAIN select b, sum(a) from t_r5_09_28 group by b having sum(a) between 13 and 24 order by b desc;
Query Plan
=========================================================================
|ID|OPERATOR                           |NAME      |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |          |1       |47          |
|1 |└─EXCHANGE OUT DISTR               |:EX10001  |1       |46          |
|2 |  └─MERGE GROUP BY                 |          |1       |46          |
|3 |    └─EXCHANGE IN MERGE SORT DISTR |          |20      |43          |
|4 |      └─EXCHANGE OUT DISTR (HASH)  |:EX10000  |20      |35          |
|5 |        └─MERGE GROUP BY           |          |20      |16          |
|6 |          └─SORT                   |          |20      |14          |
|7 |            └─PX PARTITION ITERATOR|          |20      |12          |
|8 |              └─TABLE FULL SCAN    |t_r5_09_28|20      |12          |
=========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_r5_09_28.b, T_FUN_SUM(T_FUN_SUM(t_r5_09_28.a)))]), filter(nil), rowset=256
      sort_keys([t_r5_09_28.b, DESC])
  1 - output([t_r5_09_28.b], [INTERNAL_FUNCTION(t_r5_09_28.b, T_FUN_SUM(T_FUN_SUM(t_r5_09_28.a)))]), filter(nil), rowset=256
      dop=1
  2 - output([t_r5_09_28.b], [T_FUN_SUM(T_FUN_SUM(t_r5_09_28.a))]), filter([T_FUN_SUM(T_FUN_SUM(t_r5_09_28.a)) >= cast(13, DECIMAL_INT(33, 0))], [T_FUN_SUM(T_FUN_SUM(t_r5_09_28.a)) 
      <= cast(24, DECIMAL_INT(33, 0))]), rowset=256
      group([t_r5_09_28.b]), agg_func([T_FUN_SUM(T_FUN_SUM(t_r5_09_28.a))])
  3 - output([t_r5_09_28.b], [T_FUN_SUM(t_r5_09_28.a)]), filter(nil), rowset=256
      sort_keys([t_r5_09_28.b, DESC])
  4 - output([t_r5_09_28.b], [T_FUN_SUM(t_r5_09_28.a)]), filter(nil), rowset=256
      (#keys=1, [t_r5_09_28.b]), dop=1
  5 - output([t_r5_09_28.b], [T_FUN_SUM(t_r5_09_28.a)]), filter(nil), rowset=256
      group([t_r5_09_28.b]), agg_func([T_FUN_SUM(t_r5_09_28.a)])
  6 - output([t_r5_09_28.b], [t_r5_09_28.a]), filter(nil), rowset=256
      sort_keys([t_r5_09_28.b, DESC])
  7 - output([t_r5_09_28.a], [t_r5_09_28.b]), filter(nil), rowset=256
      force partition granule
  8 - output([t_r5_09_28.a], [t_r5_09_28.b]), filter(nil), rowset=256
      access([t_r5_09_28.a], [t_r5_09_28.b]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_r5_09_28.a], [t_r5_09_28.b]), range(MIN,MIN ; MAX,MAX)always true
select b, sum(a) from t_r5_09_28 group by b having sum(a) between 13 and 24 order by b desc;
+----+--------+
| b  | sum(a) |
+----+--------+
| 24 |     24 |
| 23 |     23 |
| 22 |     22 |
| 21 |     21 |
| 20 |     20 |
| 19 |     19 |
| 18 |     18 |
| 17 |     17 |
| 16 |     16 |
| 15 |     15 |
| 14 |     14 |
| 13 |     13 |
+----+--------+
EXPLAIN select b, sum(a) from t_h3_r4_01_20 group by b having sum(a) between 5 and 16 order by b;
Query Plan
============================================================================
|ID|OPERATOR                           |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |             |1       |60          |
|1 |└─EXCHANGE OUT DISTR               |:EX10001     |1       |59          |
|2 |  └─MERGE GROUP BY                 |             |1       |59          |
|3 |    └─EXCHANGE IN MERGE SORT DISTR |             |19      |56          |
|4 |      └─EXCHANGE OUT DISTR (HASH)  |:EX10000     |19      |48          |
|5 |        └─MERGE GROUP BY           |             |19      |31          |
|6 |          └─SORT                   |             |20      |29          |
|7 |            └─PX PARTITION ITERATOR|             |20      |27          |
|8 |              └─TABLE FULL SCAN    |t_h3_r4_01_20|20      |27          |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h3_r4_01_20.b, T_FUN_SUM(T_FUN_SUM(t_h3_r4_01_20.a)))]), filter(nil), rowset=256
      sort_keys([t_h3_r4_01_20.b, ASC])
  1 - output([t_h3_r4_01_20.b], [INTERNAL_FUNCTION(t_h3_r4_01_20.b, T_FUN_SUM(T_FUN_SUM(t_h3_r4_01_20.a)))]), filter(nil), rowset=256
      dop=1
  2 - output([t_h3_r4_01_20.b], [T_FUN_SUM(T_FUN_SUM(t_h3_r4_01_20.a))]), filter([T_FUN_SUM(T_FUN_SUM(t_h3_r4_01_20.a)) >= cast(5, DECIMAL_INT(33, 0))],
       [T_FUN_SUM(T_FUN_SUM(t_h3_r4_01_20.a)) <= cast(16, DECIMAL_INT(33, 0))]), rowset=256
      group([t_h3_r4_01_20.b]), agg_func([T_FUN_SUM(T_FUN_SUM(t_h3_r4_01_20.a))])
  3 - output([t_h3_r4_01_20.b], [T_FUN_SUM(t_h3_r4_01_20.a)]), filter(nil), rowset=256
      sort_keys([t_h3_r4_01_20.b, ASC])
  4 - output([t_h3_r4_01_20.b], [T_FUN_SUM(t_h3_r4_01_20.a)]), filter(nil), rowset=256
      (#keys=1, [t_h3_r4_01_20.b]), dop=1
  5 - output([t_h3_r4_01_20.b], [T_FUN_SUM(t_h3_r4_01_20.a)]), filter(nil), rowset=256
      group([t_h3_r4_01_20.b]), agg_func([T_FUN_SUM(t_h3_r4_01_20.a)])
  6 - output([t_h3_r4_01_20.b], [t_h3_r4_01_20.a]), filter(nil), rowset=256
      sort_keys([t_h3_r4_01_20.b, ASC])
  7 - output([t_h3_r4_01_20.a], [t_h3_r4_01_20.b]), filter(nil), rowset=256
      force partition granule
  8 - output([t_h3_r4_01_20.a], [t_h3_r4_01_20.b]), filter(nil), rowset=256
      access([t_h3_r4_01_20.a], [t_h3_r4_01_20.b]), partitions(p0sp[0-3], p1sp[0-3], p2sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_h3_r4_01_20.a], [t_h3_r4_01_20.b], [t_h3_r4_01_20.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select b, sum(a) from t_h3_r4_01_20 group by b having sum(a) between 5 and 16 order by b;
+----+--------+
| b  | sum(a) |
+----+--------+
|  5 |      5 |
|  6 |      6 |
|  7 |      7 |
|  8 |      8 |
|  9 |      9 |
| 10 |     10 |
| 11 |     11 |
| 12 |     12 |
| 13 |     13 |
| 14 |     14 |
| 15 |     15 |
| 16 |     16 |
+----+--------+
EXPLAIN select b, sum(a) from t_h3_r5_09_28 group by b having sum(a) between 13 and 24 order by b desc;
Query Plan
============================================================================
|ID|OPERATOR                           |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |             |2       |70          |
|1 |└─EXCHANGE OUT DISTR               |:EX10001     |2       |69          |
|2 |  └─MERGE GROUP BY                 |             |2       |68          |
|3 |    └─EXCHANGE IN MERGE SORT DISTR |             |21      |66          |
|4 |      └─EXCHANGE OUT DISTR (HASH)  |:EX10000     |21      |57          |
|5 |        └─MERGE GROUP BY           |             |21      |37          |
|6 |          └─SORT                   |             |21      |35          |
|7 |            └─PX PARTITION ITERATOR|             |21      |33          |
|8 |              └─TABLE FULL SCAN    |t_h3_r5_09_28|21      |33          |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h3_r5_09_28.b, T_FUN_SUM(T_FUN_SUM(t_h3_r5_09_28.a)))]), filter(nil), rowset=256
      sort_keys([t_h3_r5_09_28.b, DESC])
  1 - output([t_h3_r5_09_28.b], [INTERNAL_FUNCTION(t_h3_r5_09_28.b, T_FUN_SUM(T_FUN_SUM(t_h3_r5_09_28.a)))]), filter(nil), rowset=256
      dop=1
  2 - output([t_h3_r5_09_28.b], [T_FUN_SUM(T_FUN_SUM(t_h3_r5_09_28.a))]), filter([T_FUN_SUM(T_FUN_SUM(t_h3_r5_09_28.a)) >= cast(13, DECIMAL_INT(33, 0))],
       [T_FUN_SUM(T_FUN_SUM(t_h3_r5_09_28.a)) <= cast(24, DECIMAL_INT(33, 0))]), rowset=256
      group([t_h3_r5_09_28.b]), agg_func([T_FUN_SUM(T_FUN_SUM(t_h3_r5_09_28.a))])
  3 - output([t_h3_r5_09_28.b], [T_FUN_SUM(t_h3_r5_09_28.a)]), filter(nil), rowset=256
      sort_keys([t_h3_r5_09_28.b, DESC])
  4 - output([t_h3_r5_09_28.b], [T_FUN_SUM(t_h3_r5_09_28.a)]), filter(nil), rowset=256
      (#keys=1, [t_h3_r5_09_28.b]), dop=1
  5 - output([t_h3_r5_09_28.b], [T_FUN_SUM(t_h3_r5_09_28.a)]), filter(nil), rowset=256
      group([t_h3_r5_09_28.b]), agg_func([T_FUN_SUM(t_h3_r5_09_28.a)])
  6 - output([t_h3_r5_09_28.b], [t_h3_r5_09_28.a]), filter(nil), rowset=256
      sort_keys([t_h3_r5_09_28.b, DESC])
  7 - output([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), filter(nil), rowset=256
      force partition granule
  8 - output([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), filter(nil), rowset=256
      access([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), partitions(p0sp[0-4], p1sp[0-4], p2sp[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), range(MIN,MIN ; MAX,MAX)always true
select b, sum(a) from t_h3_r5_09_28 group by b having sum(a) between 13 and 24 order by b desc;
+----+--------+
| b  | sum(a) |
+----+--------+
| 24 |     24 |
| 23 |     23 |
| 22 |     22 |
| 21 |     21 |
| 20 |     20 |
| 19 |     19 |
| 18 |     18 |
| 17 |     17 |
| 16 |     16 |
| 15 |     15 |
| 14 |     14 |
| 13 |     13 |
+----+--------+
EXPLAIN select b, sum(a) from t_h5_r4_01_20 group by b having sum(a) between 5 and 16 order by b;
Query Plan
============================================================================
|ID|OPERATOR                           |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |             |1       |78          |
|1 |└─EXCHANGE OUT DISTR               |:EX10001     |1       |78          |
|2 |  └─MERGE GROUP BY                 |             |1       |77          |
|3 |    └─EXCHANGE IN MERGE SORT DISTR |             |20      |75          |
|4 |      └─EXCHANGE OUT DISTR (HASH)  |:EX10000     |20      |66          |
|5 |        └─MERGE GROUP BY           |             |20      |48          |
|6 |          └─SORT                   |             |20      |46          |
|7 |            └─PX PARTITION ITERATOR|             |20      |43          |
|8 |              └─TABLE FULL SCAN    |t_h5_r4_01_20|20      |43          |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h5_r4_01_20.b, T_FUN_SUM(T_FUN_SUM(t_h5_r4_01_20.a)))]), filter(nil), rowset=256
      sort_keys([t_h5_r4_01_20.b, ASC])
  1 - output([t_h5_r4_01_20.b], [INTERNAL_FUNCTION(t_h5_r4_01_20.b, T_FUN_SUM(T_FUN_SUM(t_h5_r4_01_20.a)))]), filter(nil), rowset=256
      dop=1
  2 - output([t_h5_r4_01_20.b], [T_FUN_SUM(T_FUN_SUM(t_h5_r4_01_20.a))]), filter([T_FUN_SUM(T_FUN_SUM(t_h5_r4_01_20.a)) >= cast(5, DECIMAL_INT(33, 0))],
       [T_FUN_SUM(T_FUN_SUM(t_h5_r4_01_20.a)) <= cast(16, DECIMAL_INT(33, 0))]), rowset=256
      group([t_h5_r4_01_20.b]), agg_func([T_FUN_SUM(T_FUN_SUM(t_h5_r4_01_20.a))])
  3 - output([t_h5_r4_01_20.b], [T_FUN_SUM(t_h5_r4_01_20.a)]), filter(nil), rowset=256
      sort_keys([t_h5_r4_01_20.b, ASC])
  4 - output([t_h5_r4_01_20.b], [T_FUN_SUM(t_h5_r4_01_20.a)]), filter(nil), rowset=256
      (#keys=1, [t_h5_r4_01_20.b]), dop=1
  5 - output([t_h5_r4_01_20.b], [T_FUN_SUM(t_h5_r4_01_20.a)]), filter(nil), rowset=256
      group([t_h5_r4_01_20.b]), agg_func([T_FUN_SUM(t_h5_r4_01_20.a)])
  6 - output([t_h5_r4_01_20.b], [t_h5_r4_01_20.a]), filter(nil), rowset=256
      sort_keys([t_h5_r4_01_20.b, ASC])
  7 - output([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), filter(nil), rowset=256
      force partition granule
  8 - output([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), filter(nil), rowset=256
      access([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), partitions(p0sp[0-3], p1sp[0-3], p2sp[0-3], p3sp[0-3], p4sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), range(MIN,MIN ; MAX,MAX)always true
select b, sum(a) from t_h5_r4_01_20 group by b having sum(a) between 5 and 16 order by b;
+----+--------+
| b  | sum(a) |
+----+--------+
|  5 |      5 |
|  6 |      6 |
|  7 |      7 |
|  8 |      8 |
|  9 |      9 |
| 10 |     10 |
| 11 |     11 |
| 12 |     12 |
| 13 |     13 |
| 14 |     14 |
| 15 |     15 |
| 16 |     16 |
+----+--------+
EXPLAIN select b, sum(a) from t_h5_r5_09_28 group by b having sum(a) between 13 and 24 order by b desc;
Query Plan
============================================================================
|ID|OPERATOR                           |NAME         |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |             |2       |93          |
|1 |└─EXCHANGE OUT DISTR               |:EX10001     |2       |92          |
|2 |  └─MERGE GROUP BY                 |             |2       |91          |
|3 |    └─EXCHANGE IN MERGE SORT DISTR |             |22      |89          |
|4 |      └─EXCHANGE OUT DISTR (HASH)  |:EX10000     |22      |79          |
|5 |        └─MERGE GROUP BY           |             |22      |59          |
|6 |          └─SORT                   |             |23      |57          |
|7 |            └─PX PARTITION ITERATOR|             |23      |54          |
|8 |              └─TABLE FULL SCAN    |t_h5_r5_09_28|23      |54          |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h5_r5_09_28.b, T_FUN_SUM(T_FUN_SUM(t_h5_r5_09_28.a)))]), filter(nil), rowset=256
      sort_keys([t_h5_r5_09_28.b, DESC])
  1 - output([t_h5_r5_09_28.b], [INTERNAL_FUNCTION(t_h5_r5_09_28.b, T_FUN_SUM(T_FUN_SUM(t_h5_r5_09_28.a)))]), filter(nil), rowset=256
      dop=1
  2 - output([t_h5_r5_09_28.b], [T_FUN_SUM(T_FUN_SUM(t_h5_r5_09_28.a))]), filter([T_FUN_SUM(T_FUN_SUM(t_h5_r5_09_28.a)) >= cast(13, DECIMAL_INT(33, 0))],
       [T_FUN_SUM(T_FUN_SUM(t_h5_r5_09_28.a)) <= cast(24, DECIMAL_INT(33, 0))]), rowset=256
      group([t_h5_r5_09_28.b]), agg_func([T_FUN_SUM(T_FUN_SUM(t_h5_r5_09_28.a))])
  3 - output([t_h5_r5_09_28.b], [T_FUN_SUM(t_h5_r5_09_28.a)]), filter(nil), rowset=256
      sort_keys([t_h5_r5_09_28.b, DESC])
  4 - output([t_h5_r5_09_28.b], [T_FUN_SUM(t_h5_r5_09_28.a)]), filter(nil), rowset=256
      (#keys=1, [t_h5_r5_09_28.b]), dop=1
  5 - output([t_h5_r5_09_28.b], [T_FUN_SUM(t_h5_r5_09_28.a)]), filter(nil), rowset=256
      group([t_h5_r5_09_28.b]), agg_func([T_FUN_SUM(t_h5_r5_09_28.a)])
  6 - output([t_h5_r5_09_28.b], [t_h5_r5_09_28.a]), filter(nil), rowset=256
      sort_keys([t_h5_r5_09_28.b, DESC])
  7 - output([t_h5_r5_09_28.a], [t_h5_r5_09_28.b]), filter(nil), rowset=256
      force partition granule
  8 - output([t_h5_r5_09_28.a], [t_h5_r5_09_28.b]), filter(nil), rowset=256
      access([t_h5_r5_09_28.a], [t_h5_r5_09_28.b]), partitions(p0sp[0-4], p1sp[0-4], p2sp[0-4], p3sp[0-4], p4sp[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_h5_r5_09_28.a], [t_h5_r5_09_28.b], [t_h5_r5_09_28.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
select b, sum(a) from t_h5_r5_09_28 group by b having sum(a) between 13 and 24 order by b desc;
+----+--------+
| b  | sum(a) |
+----+--------+
| 24 |     24 |
| 23 |     23 |
| 22 |     22 |
| 21 |     21 |
| 20 |     20 |
| 19 |     19 |
| 18 |     18 |
| 17 |     17 |
| 16 |     16 |
| 15 |     15 |
| 14 |     14 |
| 13 |     13 |
+----+--------+
EXPLAIN select a, b from t_r4_01_20 where a between 5 and 16 order by a;
Query Plan
================================================================
|ID|OPERATOR                  |NAME      |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |          |12      |21          |
|1 |└─EXCHANGE OUT DISTR      |:EX10000  |12      |18          |
|2 |  └─PX PARTITION ITERATOR |          |12      |9           |
|3 |    └─TABLE RANGE SCAN    |t_r4_01_20|12      |9           |
================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_r4_01_20.a, t_r4_01_20.b)]), filter(nil), rowset=16
      sort_keys([t_r4_01_20.a, ASC])
  1 - output([t_r4_01_20.a], [INTERNAL_FUNCTION(t_r4_01_20.a, t_r4_01_20.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_r4_01_20.a], [t_r4_01_20.b]), filter(nil), rowset=16
      force partition granule, asc
  3 - output([t_r4_01_20.a], [t_r4_01_20.b]), filter(nil), rowset=16
      access([t_r4_01_20.a], [t_r4_01_20.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_r4_01_20.a], [t_r4_01_20.b]), range(5,MIN ; 16,MAX), 
      range_cond([t_r4_01_20.a >= 5], [t_r4_01_20.a <= 16])
select a, b from t_r4_01_20 where a between 5 and 16 order by a;
+----+----+
| a  | b  |
+----+----+
|  5 |  5 |
|  6 |  6 |
|  7 |  7 |
|  8 |  8 |
|  9 |  9 |
| 10 | 10 |
| 11 | 11 |
| 12 | 12 |
| 13 | 13 |
| 14 | 14 |
| 15 | 15 |
| 16 | 16 |
+----+----+
EXPLAIN select a, b from t_r4_09_28 where a between 13 and 24 order by a desc;
Query Plan
=========================================================================
|ID|OPERATOR                  |NAME               |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |                   |12      |21          |
|1 |└─EXCHANGE OUT DISTR      |:EX10000           |12      |18          |
|2 |  └─PX PARTITION ITERATOR |                   |12      |9           |
|3 |    └─TABLE RANGE SCAN    |t_r4_09_28(Reverse)|12      |9           |
=========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_r4_09_28.a, t_r4_09_28.b)]), filter(nil), rowset=16
      sort_keys([t_r4_09_28.a, DESC])
  1 - output([t_r4_09_28.a], [INTERNAL_FUNCTION(t_r4_09_28.a, t_r4_09_28.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_r4_09_28.a], [t_r4_09_28.b]), filter(nil), rowset=16
      force partition granule, desc
  3 - output([t_r4_09_28.a], [t_r4_09_28.b]), filter(nil), rowset=16
      access([t_r4_09_28.a], [t_r4_09_28.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_r4_09_28.a]), range[13 ; 24], 
      range_cond([t_r4_09_28.a >= 13], [t_r4_09_28.a <= 24])
select a, b from t_r4_09_28 where a between 13 and 24 order by a desc;
+----+------+
| a  | b    |
+----+------+
| 24 |   24 |
| 23 |   23 |
| 22 |   22 |
| 21 |   21 |
| 20 |   20 |
| 19 |   19 |
| 18 |   18 |
| 17 |   17 |
| 16 |   16 |
| 15 |   15 |
| 14 |   14 |
| 13 |   13 |
+----+------+
EXPLAIN select a, b from t_r5_01_20 where a between 5 and 16 order by a;
Query Plan
================================================================
|ID|OPERATOR                  |NAME      |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |          |12      |19          |
|1 |└─EXCHANGE OUT DISTR      |:EX10000  |12      |16          |
|2 |  └─PX PARTITION ITERATOR |          |12      |7           |
|3 |    └─TABLE RANGE SCAN    |t_r5_01_20|12      |7           |
================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_r5_01_20.a, t_r5_01_20.b)]), filter(nil), rowset=16
      sort_keys([t_r5_01_20.a, ASC])
  1 - output([t_r5_01_20.a], [INTERNAL_FUNCTION(t_r5_01_20.a, t_r5_01_20.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_r5_01_20.a], [t_r5_01_20.b]), filter(nil), rowset=16
      force partition granule, asc
  3 - output([t_r5_01_20.a], [t_r5_01_20.b]), filter(nil), rowset=16
      access([t_r5_01_20.a], [t_r5_01_20.b]), partitions(p[1-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_r5_01_20.a]), range[5 ; 16], 
      range_cond([t_r5_01_20.a >= 5], [t_r5_01_20.a <= 16])
select a, b from t_r5_01_20 where a between 5 and 16 order by a;
+----+------+
| a  | b    |
+----+------+
|  5 |    5 |
|  6 |    6 |
|  7 |    7 |
|  8 |    8 |
|  9 |    9 |
| 10 |   10 |
| 11 |   11 |
| 12 |   12 |
| 13 |   13 |
| 14 |   14 |
| 15 |   15 |
| 16 |   16 |
+----+------+
EXPLAIN select a, b from t_r5_09_28 where a between 13 and 24 order by a desc;
Query Plan
=========================================================================
|ID|OPERATOR                  |NAME               |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |                   |12      |19          |
|1 |└─EXCHANGE OUT DISTR      |:EX10000           |12      |16          |
|2 |  └─PX PARTITION ITERATOR |                   |12      |7           |
|3 |    └─TABLE RANGE SCAN    |t_r5_09_28(Reverse)|12      |7           |
=========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_r5_09_28.a, t_r5_09_28.b)]), filter(nil), rowset=16
      sort_keys([t_r5_09_28.a, DESC])
  1 - output([t_r5_09_28.a], [INTERNAL_FUNCTION(t_r5_09_28.a, t_r5_09_28.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_r5_09_28.a], [t_r5_09_28.b]), filter(nil), rowset=16
      force partition granule, desc
  3 - output([t_r5_09_28.a], [t_r5_09_28.b]), filter(nil), rowset=16
      access([t_r5_09_28.a], [t_r5_09_28.b]), partitions(p[1-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_r5_09_28.a], [t_r5_09_28.b]), range(13,MIN ; 24,MAX), 
      range_cond([t_r5_09_28.a >= 13], [t_r5_09_28.a <= 24])
select a, b from t_r5_09_28 where a between 13 and 24 order by a desc;
+----+----+
| a  | b  |
+----+----+
| 24 | 24 |
| 23 | 23 |
| 22 | 22 |
| 21 | 21 |
| 20 | 20 |
| 19 | 19 |
| 18 | 18 |
| 17 | 17 |
| 16 | 16 |
| 15 | 15 |
| 14 | 14 |
| 13 | 13 |
+----+----+
EXPLAIN select a, b from t_h3_r4_01_20 where a = 12 order by b;
Query Plan
===================================================================
|ID|OPERATOR                  |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |1       |10          |
|1 |└─EXCHANGE OUT DISTR      |:EX10000     |1       |10          |
|2 |  └─PX PARTITION ITERATOR |             |1       |9           |
|3 |    └─TABLE RANGE SCAN    |t_h3_r4_01_20|1       |9           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h3_r4_01_20.a, t_h3_r4_01_20.b)]), filter(nil), rowset=16
      sort_keys([t_h3_r4_01_20.b, ASC])
  1 - output([t_h3_r4_01_20.b], [INTERNAL_FUNCTION(t_h3_r4_01_20.a, t_h3_r4_01_20.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h3_r4_01_20.a], [t_h3_r4_01_20.b]), filter(nil), rowset=16
      force partition granule, asc
  3 - output([t_h3_r4_01_20.a], [t_h3_r4_01_20.b]), filter(nil), rowset=16
      access([t_h3_r4_01_20.a], [t_h3_r4_01_20.b]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_h3_r4_01_20.a], [t_h3_r4_01_20.b], [t_h3_r4_01_20.c]), range(12,MIN,MIN ; 12,MAX,MAX), 
      range_cond([t_h3_r4_01_20.a = 12])
select a, b from t_h3_r4_01_20 where a = 12 order by b;
+----+----+
| a  | b  |
+----+----+
| 12 | 12 |
+----+----+
EXPLAIN select a, b from t_h3_r5_09_28 where a = 12 order by b desc;
Query Plan
============================================================================
|ID|OPERATOR                  |NAME                  |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |                      |1       |12          |
|1 |└─EXCHANGE OUT DISTR      |:EX10000              |1       |12          |
|2 |  └─PX PARTITION ITERATOR |                      |1       |11          |
|3 |    └─TABLE RANGE SCAN    |t_h3_r5_09_28(Reverse)|1       |11          |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h3_r5_09_28.a, t_h3_r5_09_28.b)]), filter(nil), rowset=16
      sort_keys([t_h3_r5_09_28.b, DESC])
  1 - output([t_h3_r5_09_28.b], [INTERNAL_FUNCTION(t_h3_r5_09_28.a, t_h3_r5_09_28.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), filter(nil), rowset=16
      force partition granule, desc
  3 - output([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), filter(nil), rowset=16
      access([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), partitions(p0sp[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), range(12,MIN ; 12,MAX), 
      range_cond([t_h3_r5_09_28.a = 12])
select a, b from t_h3_r5_09_28 where a = 12 order by b desc;
+----+----+
| a  | b  |
+----+----+
| 12 | 12 |
+----+----+
EXPLAIN select a, b from t_h5_r4_01_20 where a = 12 order by b;
Query Plan
===================================================================
|ID|OPERATOR                  |NAME         |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |1       |10          |
|1 |└─EXCHANGE OUT DISTR      |:EX10000     |1       |10          |
|2 |  └─PX PARTITION ITERATOR |             |1       |9           |
|3 |    └─TABLE RANGE SCAN    |t_h5_r4_01_20|1       |9           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h5_r4_01_20.a, t_h5_r4_01_20.b)]), filter(nil), rowset=16
      sort_keys([t_h5_r4_01_20.b, ASC])
  1 - output([t_h5_r4_01_20.b], [INTERNAL_FUNCTION(t_h5_r4_01_20.a, t_h5_r4_01_20.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), filter(nil), rowset=16
      force partition granule, asc
  3 - output([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), filter(nil), rowset=16
      access([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), partitions(p2sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), range(12,MIN ; 12,MAX), 
      range_cond([t_h5_r4_01_20.a = 12])
select a, b from t_h5_r4_01_20 where a = 12 order by b;
+----+----+
| a  | b  |
+----+----+
| 12 | 12 |
+----+----+
EXPLAIN select a, b from t_h5_r5_09_28 where a = 12 order by b desc;
Query Plan
============================================================================
|ID|OPERATOR                  |NAME                  |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |                      |1       |12          |
|1 |└─EXCHANGE OUT DISTR      |:EX10000              |1       |12          |
|2 |  └─PX PARTITION ITERATOR |                      |1       |11          |
|3 |    └─TABLE RANGE SCAN    |t_h5_r5_09_28(Reverse)|1       |11          |
============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h5_r5_09_28.a, t_h5_r5_09_28.b)]), filter(nil), rowset=16
      sort_keys([t_h5_r5_09_28.b, DESC])
  1 - output([t_h5_r5_09_28.b], [INTERNAL_FUNCTION(t_h5_r5_09_28.a, t_h5_r5_09_28.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h5_r5_09_28.a], [t_h5_r5_09_28.b]), filter(nil), rowset=16
      force partition granule, desc
  3 - output([t_h5_r5_09_28.a], [t_h5_r5_09_28.b]), filter(nil), rowset=16
      access([t_h5_r5_09_28.a], [t_h5_r5_09_28.b]), partitions(p2sp[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_h5_r5_09_28.a], [t_h5_r5_09_28.b], [t_h5_r5_09_28.c]), range(12,MIN,MIN ; 12,MAX,MAX), 
      range_cond([t_h5_r5_09_28.a = 12])
select a, b from t_h5_r5_09_28 where a = 12 order by b desc;
+----+----+
| a  | b  |
+----+----+
| 12 | 12 |
+----+----+
EXPLAIN select a, b from t_h3_01_20 where a between 5 and 16 order by b;
Query Plan
=================================================================
|ID|OPERATOR                   |NAME      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |          |12      |21          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000  |12      |17          |
|2 |  └─SORT                   |          |12      |9           |
|3 |    └─PX PARTITION ITERATOR|          |12      |7           |
|4 |      └─TABLE RANGE SCAN   |t_h3_01_20|12      |7           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h3_01_20.a, t_h3_01_20.b)]), filter(nil), rowset=16
      sort_keys([t_h3_01_20.b, ASC])
  1 - output([t_h3_01_20.b], [INTERNAL_FUNCTION(t_h3_01_20.a, t_h3_01_20.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h3_01_20.b], [t_h3_01_20.a]), filter(nil), rowset=16
      sort_keys([t_h3_01_20.b, ASC])
  3 - output([t_h3_01_20.a], [t_h3_01_20.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t_h3_01_20.a], [t_h3_01_20.b]), filter(nil), rowset=16
      access([t_h3_01_20.a], [t_h3_01_20.b]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t_h3_01_20.a]), range[5 ; 16], 
      range_cond([t_h3_01_20.a >= 5], [t_h3_01_20.a <= 16])
select a, b from t_h3_01_20 where a between 5 and 16 order by b;
+----+------+
| a  | b    |
+----+------+
|  5 |    5 |
|  6 |    6 |
|  7 |    7 |
|  8 |    8 |
|  9 |    9 |
| 10 |   10 |
| 11 |   11 |
| 12 |   12 |
| 13 |   13 |
| 14 |   14 |
| 15 |   15 |
| 16 |   16 |
+----+------+
EXPLAIN select a, b from t_h5_09_28 where a between 13 and 24 order by b desc;
Query Plan
=================================================================
|ID|OPERATOR                   |NAME      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |          |12      |25          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000  |12      |21          |
|2 |  └─SORT                   |          |12      |13          |
|3 |    └─PX PARTITION ITERATOR|          |12      |12          |
|4 |      └─TABLE RANGE SCAN   |t_h5_09_28|12      |12          |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h5_09_28.a, t_h5_09_28.b)]), filter(nil), rowset=16
      sort_keys([t_h5_09_28.b, DESC])
  1 - output([t_h5_09_28.b], [INTERNAL_FUNCTION(t_h5_09_28.a, t_h5_09_28.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h5_09_28.b], [t_h5_09_28.a]), filter(nil), rowset=16
      sort_keys([t_h5_09_28.b, DESC])
  3 - output([t_h5_09_28.a], [t_h5_09_28.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t_h5_09_28.a], [t_h5_09_28.b]), filter(nil), rowset=16
      access([t_h5_09_28.a], [t_h5_09_28.b]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_h5_09_28.a]), range[13 ; 24], 
      range_cond([t_h5_09_28.a >= 13], [t_h5_09_28.a <= 24])
select a, b from t_h5_09_28 where a between 13 and 24 order by b desc;
+----+------+
| a  | b    |
+----+------+
| 24 |   24 |
| 23 |   23 |
| 22 |   22 |
| 21 |   21 |
| 20 |   20 |
| 19 |   19 |
| 18 |   18 |
| 17 |   17 |
| 16 |   16 |
| 15 |   15 |
| 14 |   14 |
| 13 |   13 |
+----+------+
EXPLAIN select a, b from t_r4_01_20 where a between 5 and 16 order by b;
Query Plan
=================================================================
|ID|OPERATOR                   |NAME      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |          |12      |23          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000  |12      |19          |
|2 |  └─SORT                   |          |12      |11          |
|3 |    └─PX PARTITION ITERATOR|          |12      |9           |
|4 |      └─TABLE RANGE SCAN   |t_r4_01_20|12      |9           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_r4_01_20.a, t_r4_01_20.b)]), filter(nil), rowset=16
      sort_keys([t_r4_01_20.b, ASC])
  1 - output([t_r4_01_20.b], [INTERNAL_FUNCTION(t_r4_01_20.a, t_r4_01_20.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_r4_01_20.b], [t_r4_01_20.a]), filter(nil), rowset=16
      sort_keys([t_r4_01_20.b, ASC])
  3 - output([t_r4_01_20.a], [t_r4_01_20.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t_r4_01_20.a], [t_r4_01_20.b]), filter(nil), rowset=16
      access([t_r4_01_20.a], [t_r4_01_20.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_r4_01_20.a], [t_r4_01_20.b]), range(5,MIN ; 16,MAX), 
      range_cond([t_r4_01_20.a >= 5], [t_r4_01_20.a <= 16])
select a, b from t_r4_01_20 where a between 5 and 16 order by b;
+----+----+
| a  | b  |
+----+----+
|  5 |  5 |
|  6 |  6 |
|  7 |  7 |
|  8 |  8 |
|  9 |  9 |
| 10 | 10 |
| 11 | 11 |
| 12 | 12 |
| 13 | 13 |
| 14 | 14 |
| 15 | 15 |
| 16 | 16 |
+----+----+
EXPLAIN select a, b from t_r4_09_28 where a between 13 and 24 order by b desc;
Query Plan
=================================================================
|ID|OPERATOR                   |NAME      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |          |12      |23          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000  |12      |19          |
|2 |  └─SORT                   |          |12      |11          |
|3 |    └─PX PARTITION ITERATOR|          |12      |9           |
|4 |      └─TABLE RANGE SCAN   |t_r4_09_28|12      |9           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_r4_09_28.a, t_r4_09_28.b)]), filter(nil), rowset=16
      sort_keys([t_r4_09_28.b, DESC])
  1 - output([t_r4_09_28.b], [INTERNAL_FUNCTION(t_r4_09_28.a, t_r4_09_28.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_r4_09_28.b], [t_r4_09_28.a]), filter(nil), rowset=16
      sort_keys([t_r4_09_28.b, DESC])
  3 - output([t_r4_09_28.a], [t_r4_09_28.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t_r4_09_28.a], [t_r4_09_28.b]), filter(nil), rowset=16
      access([t_r4_09_28.a], [t_r4_09_28.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_r4_09_28.a]), range[13 ; 24], 
      range_cond([t_r4_09_28.a >= 13], [t_r4_09_28.a <= 24])
select a, b from t_r4_09_28 where a between 13 and 24 order by b desc;
+----+------+
| a  | b    |
+----+------+
| 24 |   24 |
| 23 |   23 |
| 22 |   22 |
| 21 |   21 |
| 20 |   20 |
| 19 |   19 |
| 18 |   18 |
| 17 |   17 |
| 16 |   16 |
| 15 |   15 |
| 14 |   14 |
| 13 |   13 |
+----+------+
EXPLAIN select a, b from t_h3_r4_01_20 where a between 5 and 16 order by b;
Query Plan
====================================================================
|ID|OPERATOR                   |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |             |14      |41          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000     |14      |37          |
|2 |  └─SORT                   |             |14      |28          |
|3 |    └─PX PARTITION ITERATOR|             |14      |26          |
|4 |      └─TABLE RANGE SCAN   |t_h3_r4_01_20|14      |26          |
====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h3_r4_01_20.a, t_h3_r4_01_20.b)]), filter(nil), rowset=16
      sort_keys([t_h3_r4_01_20.b, ASC])
  1 - output([t_h3_r4_01_20.b], [INTERNAL_FUNCTION(t_h3_r4_01_20.a, t_h3_r4_01_20.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h3_r4_01_20.b], [t_h3_r4_01_20.a]), filter(nil), rowset=16
      sort_keys([t_h3_r4_01_20.b, ASC])
  3 - output([t_h3_r4_01_20.a], [t_h3_r4_01_20.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t_h3_r4_01_20.a], [t_h3_r4_01_20.b]), filter(nil), rowset=16
      access([t_h3_r4_01_20.a], [t_h3_r4_01_20.b]), partitions(p0sp[0-3], p1sp[0-3], p2sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_h3_r4_01_20.a], [t_h3_r4_01_20.b], [t_h3_r4_01_20.c]), range(5,MIN,MIN ; 16,MAX,MAX), 
      range_cond([t_h3_r4_01_20.a >= 5], [t_h3_r4_01_20.a <= 16])
select a, b from t_h3_r4_01_20 where a between 5 and 16 order by b;
+----+----+
| a  | b  |
+----+----+
|  5 |  5 |
|  6 |  6 |
|  7 |  7 |
|  8 |  8 |
|  9 |  9 |
| 10 | 10 |
| 11 | 11 |
| 12 | 12 |
| 13 | 13 |
| 14 | 14 |
| 15 | 15 |
| 16 | 16 |
+----+----+
EXPLAIN select a, b from t_h3_r5_09_28 where a between 13 and 24 order by b desc;
Query Plan
====================================================================
|ID|OPERATOR                   |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |             |11      |44          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000     |11      |41          |
|2 |  └─SORT                   |             |11      |34          |
|3 |    └─PX PARTITION ITERATOR|             |11      |33          |
|4 |      └─TABLE RANGE SCAN   |t_h3_r5_09_28|11      |33          |
====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h3_r5_09_28.a, t_h3_r5_09_28.b)]), filter(nil), rowset=16
      sort_keys([t_h3_r5_09_28.b, DESC])
  1 - output([t_h3_r5_09_28.b], [INTERNAL_FUNCTION(t_h3_r5_09_28.a, t_h3_r5_09_28.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h3_r5_09_28.b], [t_h3_r5_09_28.a]), filter(nil), rowset=16
      sort_keys([t_h3_r5_09_28.b, DESC])
  3 - output([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), filter(nil), rowset=16
      access([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), partitions(p0sp[0-4], p1sp[0-4], p2sp[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_h3_r5_09_28.a], [t_h3_r5_09_28.b]), range(13,MIN ; 24,MAX), 
      range_cond([t_h3_r5_09_28.a >= 13], [t_h3_r5_09_28.a <= 24])
select a, b from t_h3_r5_09_28 where a between 13 and 24 order by b desc;
+----+----+
| a  | b  |
+----+----+
| 24 | 24 |
| 23 | 23 |
| 22 | 22 |
| 21 | 21 |
| 20 | 20 |
| 19 | 19 |
| 18 | 18 |
| 17 | 17 |
| 16 | 16 |
| 15 | 15 |
| 14 | 14 |
| 13 | 13 |
+----+----+
EXPLAIN select a, b from t_h5_r4_01_20 where a between 5 and 16 order by b;
Query Plan
====================================================================
|ID|OPERATOR                   |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |             |14      |59          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000     |14      |54          |
|2 |  └─SORT                   |             |14      |45          |
|3 |    └─PX PARTITION ITERATOR|             |14      |43          |
|4 |      └─TABLE RANGE SCAN   |t_h5_r4_01_20|14      |43          |
====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h5_r4_01_20.a, t_h5_r4_01_20.b)]), filter(nil), rowset=16
      sort_keys([t_h5_r4_01_20.b, ASC])
  1 - output([t_h5_r4_01_20.b], [INTERNAL_FUNCTION(t_h5_r4_01_20.a, t_h5_r4_01_20.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h5_r4_01_20.b], [t_h5_r4_01_20.a]), filter(nil), rowset=16
      sort_keys([t_h5_r4_01_20.b, ASC])
  3 - output([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), filter(nil), rowset=16
      access([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), partitions(p0sp[0-3], p1sp[0-3], p2sp[0-3], p3sp[0-3], p4sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t_h5_r4_01_20.a], [t_h5_r4_01_20.b]), range(5,MIN ; 16,MAX), 
      range_cond([t_h5_r4_01_20.a >= 5], [t_h5_r4_01_20.a <= 16])
select a, b from t_h5_r4_01_20 where a between 5 and 16 order by b;
+----+----+
| a  | b  |
+----+----+
|  5 |  5 |
|  6 |  6 |
|  7 |  7 |
|  8 |  8 |
|  9 |  9 |
| 10 | 10 |
| 11 | 11 |
| 12 | 12 |
| 13 | 13 |
| 14 | 14 |
| 15 | 15 |
| 16 | 16 |
+----+----+
EXPLAIN select a, b from t_h5_r5_09_28 where a between 13 and 24 order by b desc;
Query Plan
====================================================================
|ID|OPERATOR                   |NAME         |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |             |10      |64          |
|1 |└─EXCHANGE OUT DISTR       |:EX10000     |10      |61          |
|2 |  └─SORT                   |             |10      |55          |
|3 |    └─PX PARTITION ITERATOR|             |10      |53          |
|4 |      └─TABLE RANGE SCAN   |t_h5_r5_09_28|10      |53          |
====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_h5_r5_09_28.a, t_h5_r5_09_28.b)]), filter(nil), rowset=16
      sort_keys([t_h5_r5_09_28.b, DESC])
  1 - output([t_h5_r5_09_28.b], [INTERNAL_FUNCTION(t_h5_r5_09_28.a, t_h5_r5_09_28.b)]), filter(nil), rowset=16
      dop=1
  2 - output([t_h5_r5_09_28.b], [t_h5_r5_09_28.a]), filter(nil), rowset=16
      sort_keys([t_h5_r5_09_28.b, DESC])
  3 - output([t_h5_r5_09_28.a], [t_h5_r5_09_28.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t_h5_r5_09_28.a], [t_h5_r5_09_28.b]), filter(nil), rowset=16
      access([t_h5_r5_09_28.a], [t_h5_r5_09_28.b]), partitions(p0sp[0-4], p1sp[0-4], p2sp[0-4], p3sp[0-4], p4sp[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t_h5_r5_09_28.a], [t_h5_r5_09_28.b], [t_h5_r5_09_28.c]), range(13,MIN,MIN ; 24,MAX,MAX), 
      range_cond([t_h5_r5_09_28.a >= 13], [t_h5_r5_09_28.a <= 24])
select a, b from t_h5_r5_09_28 where a between 13 and 24 order by b desc;
+----+----+
| a  | b  |
+----+----+
| 24 | 24 |
| 23 | 23 |
| 22 | 22 |
| 21 | 21 |
| 20 | 20 |
| 19 | 19 |
| 18 | 18 |
| 17 | 17 |
| 16 | 16 |
| 15 | 15 |
| 14 | 14 |
| 13 | 13 |
+----+----+

## check if result_type_classes of join_keys are the same when repart
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.aa;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |57          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |50          |
|2 |  └─HASH JOIN                    |        |4       |35          |
|3 |    ├─PX PARTITION ITERATOR      |        |5       |11          |
|4 |    │ └─TABLE FULL SCAN          |t1      |5       |11          |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.aa], [t1.b], [t1.c], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.aa]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.aa], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.aa], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [t2.aa]), dop=1
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.aa;
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b    | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 |    3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 |    1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 |    4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 |    2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |50          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |43          |
|2 |  └─HASH JOIN                    |        |4       |28          |
|3 |    ├─EXCHANGE IN DISTR          |        |5       |19          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |17          |
|5 |    │   └─PX PARTITION ITERATOR  |        |5       |11          |
|6 |    │     └─TABLE FULL SCAN      |t1      |5       |11          |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t1.c], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.a;
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b    | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 |    3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 |    1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 |    4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 |    2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.b;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |43          |
|1 |├─PX COORDINATOR           |        |5       |19          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |17          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |11          |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |11          |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.b]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.b;
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b    | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 |    3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 |    1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 |    4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 |    2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |43          |
|1 |├─PX COORDINATOR           |        |5       |19          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |17          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |11          |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |11          |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.c;
+---+------+------+---+------+------+------+------+------+------+
| a | b    | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+------+------+---+------+------+------+------+------+------+
+---+------+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.d;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |43          |
|1 |├─PX COORDINATOR           |        |5       |19          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |17          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |11          |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |11          |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATE(-1, -1)) = t2.d]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.d;
+---+------+------+---+------+------+------+------+------+------+
| a | b    | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+------+------+---+------+------+------+------+------+------+
+---+------+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.e;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |43          |
|1 |├─PX COORDINATOR           |        |5       |19          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |17          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |11          |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |11          |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, TIMESTAMP(-1, -1)) = t2.e]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.e;
+---+------+------+---+------+------+------+------+------+------+
| a | b    | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+------+------+---+------+------+------+------+------+------+
+---+------+------+---+------+------+------+------+------+------+

EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.aa;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |48          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |5       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |5       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.aa], [t1.b], [t1.c], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.aa]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.aa], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.aa], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [t2.aa]), dop=1
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.aa;
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |40          |
|2 |  └─HASH JOIN                    |        |4       |25          |
|3 |    ├─EXCHANGE IN DISTR          |        |5       |17          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |5       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |5       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t1.c], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.a;
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.b;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |41          |
|1 |├─PX COORDINATOR           |        |5       |17          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.b]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.b;
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |40          |
|1 |├─PX COORDINATOR           |        |5       |17          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.c;
+---+---+------+---+------+------+------+------+------+------+
| a | b | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+---+------+---+------+------+------+------+------+------+
+---+---+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.d;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |40          |
|1 |├─PX COORDINATOR           |        |5       |17          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATE(-1, -1)) = t2.d]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.d;
+---+---+------+---+------+------+------+------+------+------+
| a | b | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+---+------+---+------+------+------+------+------+------+
+---+---+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.e;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |40          |
|1 |├─PX COORDINATOR           |        |5       |17          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, TIMESTAMP(-1, -1)) = t2.e]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.e;
+---+---+------+---+------+------+------+------+------+------+
| a | b | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+---+------+---+------+------+------+------+------+------+
+---+---+------+---+------+------+------+------+------+------+

EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.a], [t1.b], [t1.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.a, MYSQL_DATE(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [cast(t2.a, MYSQL_DATE(-1, -1))], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [cast(t2.a, MYSQL_DATE(-1, -1))], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.a, MYSQL_DATE(-1, -1))]), dop=1
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.a;
+------+---+---+---+------+------+------+------+------+------+
| a    | b | c | a | aa   | b    | bb   | c    | d    | e    |
+------+---+---+---+------+------+------+------+------+------+
+------+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.b;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.b], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.b, MYSQL_DATE(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.b], [cast(t2.b, MYSQL_DATE(-1, -1))], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.b], [cast(t2.b, MYSQL_DATE(-1, -1))], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.b, MYSQL_DATE(-1, -1))]), dop=1
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.b;
+------+---+---+---+------+------+------+------+------+------+
| a    | b | c | a | aa   | b    | bb   | c    | d    | e    |
+------+---+---+---+------+------+------+------+------+------+
+------+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |39          |
|1 |├─PX COORDINATOR           |        |4       |15          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|4       |13          |
|3 |│   └─PX PARTITION ITERATOR|        |4       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |4       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.c, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.c;
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
|    1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    1 | 1 | 2016-11-01 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.d;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.d], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = t2.d]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.d], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
  6 - output([t2.d], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      (#keys=1, [t2.d]), dop=1
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.d;
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
|    1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    1 | 1 | 2016-11-01 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    1 | 1 | 2016-11-01 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
|    2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.e;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |39          |
|1 |├─PX COORDINATOR           |        |4       |15          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|4       |13          |
|3 |│   └─PX PARTITION ITERATOR|        |4       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |4       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.c, MYSQL_DATETIME(-1, -1)) = cast(t2.e, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.e;
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
|    3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
|    2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+

EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |48          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.a], [t1.b], [t1.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.a, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [cast(t2.a, MYSQL_DATETIME(-1, -1))], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [cast(t2.a, MYSQL_DATETIME(-1, -1))], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.a, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.a;
+------+---+---+---+------+------+------+------+------+------+
| a    | b | c | a | aa   | b    | bb   | c    | d    | e    |
+------+---+---+---+------+------+------+------+------+------+
+------+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.b;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |48          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.b], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.b, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.b], [cast(t2.b, MYSQL_DATETIME(-1, -1))], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.b], [cast(t2.b, MYSQL_DATETIME(-1, -1))], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.b, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.b;
+------+---+---+---+------+------+------+------+------+------+
| a    | b | c | a | aa   | b    | bb   | c    | d    | e    |
+------+---+---+---+------+------+------+------+------+------+
+------+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = t2.c]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [t2.c]), dop=1
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.c;
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
|    1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    1 | 1 | 2016-11-01 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.d;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.d], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.d, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.d], [cast(t2.d, MYSQL_DATETIME(-1, -1))], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
  6 - output([t2.d], [cast(t2.d, MYSQL_DATETIME(-1, -1))], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.d, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.d;
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
|    1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    1 | 1 | 2016-11-01 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    1 | 1 | 2016-11-01 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
|    2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.e;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |48          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.e], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.e, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.e], [cast(t2.e, MYSQL_DATETIME(19, 0))], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
  6 - output([t2.e], [cast(t2.e, MYSQL_DATETIME(19, 0))], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      (#keys=1, [cast(t2.e, MYSQL_DATETIME(19, 0))]), dop=1
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.e;
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
|    3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
|    2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+

EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t1.b], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.a, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.a;
+---+---+---+---+------+------+------+------+------+------+
| a | b | c | a | aa   | b    | bb   | c    | d    | e    |
+---+---+---+---+------+------+------+------+------+------+
+---+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.aa;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.aa], [t1.b], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.aa, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.aa;
+---+---+---+---+------+------+------+------+------+------+
| a | b | c | a | aa   | b    | bb   | c    | d    | e    |
+---+---+---+---+------+------+------+------+------+------+
+---+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.b;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.b], [t1.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.b, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.b;
+---+---+---+---+------+------+------+------+------+------+
| a | b | c | a | aa   | b    | bb   | c    | d    | e    |
+---+---+---+---+------+------+------+------+------+------+
+---+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.bb;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.bb], [t1.b], [t2.aa], [t2.b], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.bb, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.bb], [t2.aa], [t2.b], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.bb], [t2.aa], [t2.b], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.bb], [t2.aa], [t2.b], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.bb;
+---+---+---+---+------+------+------+------+------+------+
| a | b | c | a | aa   | b    | bb   | c    | d    | e    |
+---+---+---+---+------+------+------+------+------+------+
+---+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.c], [t1.b], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = t2.c]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.c;
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.d;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.d], [t1.b], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.d, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.d;
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.e;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.e], [t1.b], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.e, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.e;
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+

EXPLAIN select * from t_r4_int t1, t_r4_int as t2 where t1.a = t2.a;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |PX COORDINATOR           |        |5       |34          |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|5       |29          |
|2 |  └─PX PARTITION ITERATOR|        |5       |19          |
|3 |    └─MERGE JOIN         |        |5       |19          |
|4 |      ├─TABLE FULL SCAN  |t1      |5       |9           |
|5 |      └─TABLE FULL SCAN  |t2      |5       |9           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t1.c], [t2.b], [t2.c]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t1.a], [t2.a], [t1.b], [t1.c], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a]), other_conds(nil)
      merge_directions([ASC])
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a], [t2.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_int t1, t_r4_int as t2 where t1.a = t2.a;
+---+---+------------+---+---+------------+
| a | b | c          | a | b | c          |
+---+---+------------+---+---+------------+
| 1 | 1 | 2016-11-01 | 1 | 1 | 2016-11-01 |
| 2 | 2 | 2016-11-02 | 2 | 2 | 2016-11-02 |
| 3 | 3 | 2016-11-03 | 3 | 3 | 2016-11-03 |
| 4 | 4 | 2016-11-04 | 4 | 4 | 2016-11-04 |
| 5 | 5 | 2016-11-05 | 5 | 5 | 2016-11-05 |
+---+---+------------+---+---+------------+
EXPLAIN select * from t_r4_int t1, t_r4_date as t2 where t1.a = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |39          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |35          |
|2 |  └─HASH JOIN                    |        |4       |27          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t2      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |5       |17          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |5       |9           |
|8 |          └─TABLE FULL SCAN      |t1      |5       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.c], [t2.b], [t2.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATE(-1, -1)) = t2.c]), other_conds(nil)
  3 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t1.a], [cast(t1.a, MYSQL_DATE(-1, -1))], [t1.b], [t1.c]), filter(nil), rowset=16
  6 - output([t1.a], [cast(t1.a, MYSQL_DATE(-1, -1))], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [cast(t1.a, MYSQL_DATE(-1, -1))]), dop=1
  7 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_int t1, t_r4_date as t2 where t1.a = t2.c;
+---+---+------+------+---+---+
| a | b | c    | a    | b | c |
+---+---+------+------+---+---+
+---+---+------+------+---+---+
EXPLAIN select * from t_r4_int t1, t_r4_datetime as t2 where t1.a = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |40          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |36          |
|2 |  └─HASH JOIN                    |        |4       |27          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t2      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |5       |17          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |5       |9           |
|8 |          └─TABLE FULL SCAN      |t1      |5       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.c], [t2.b], [t2.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  3 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t1.a], [cast(t1.a, MYSQL_DATETIME(-1, -1))], [t1.b], [t1.c]), filter(nil), rowset=16
  6 - output([t1.a], [cast(t1.a, MYSQL_DATETIME(-1, -1))], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [cast(t1.a, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_int t1, t_r4_datetime as t2 where t1.a = t2.c;
+---+---+------+------+---+---+
| a | b | c    | a    | b | c |
+---+---+------+------+---+---+
+---+---+------+------+---+---+
EXPLAIN select * from t_r4_int t1, t_r4_timestamp as t2 where t1.a = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |33          |
|1 |├─PX COORDINATOR           |        |4       |16          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|4       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |4       |9           |
|4 |│     └─TABLE FULL SCAN    |t2      |4       |9           |
|5 |└─PX COORDINATOR           |        |5       |17          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|5       |14          |
|7 |    └─PX PARTITION ITERATOR|        |5       |9           |
|8 |      └─TABLE FULL SCAN    |t1      |5       |9           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([cast(t1.a, TIMESTAMP(-1, -1)) = t2.c]), other_conds(nil)
  1 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
  2 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      dop=1
  3 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  7 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_int t1, t_r4_timestamp as t2 where t1.a = t2.c;
+---+---+------+---+------+------+
| a | b | c    | a | b    | c    |
+---+---+------+---+------+------+
+---+---+------+---+------+------+

EXPLAIN select * from t_r4_date t1, t_r4_int as t2 where t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |39          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |35          |
|2 |  └─HASH JOIN                    |        |4       |27          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |5       |17          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |5       |9           |
|8 |          └─TABLE FULL SCAN      |t2      |5       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.a], [t1.b], [t1.a], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.a, MYSQL_DATE(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [cast(t2.a, MYSQL_DATE(-1, -1))], [t2.b], [t2.c]), filter(nil), rowset=16
  6 - output([t2.a], [cast(t2.a, MYSQL_DATE(-1, -1))], [t2.b], [t2.c]), filter(nil), rowset=16
      (#keys=1, [cast(t2.a, MYSQL_DATE(-1, -1))]), dop=1
  7 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a], [t2.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_date t1, t_r4_int as t2 where t1.c = t2.a;
+------+---+---+---+---+------+
| a    | b | c | a | b | c    |
+------+---+---+---+---+------+
+------+---+---+---+---+------+
EXPLAIN select * from t_r4_date t1, t_r4_date as t2 where t1.c = t2.c;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |PX COORDINATOR           |        |4       |31          |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|4       |28          |
|2 |  └─PX PARTITION ITERATOR|        |4       |19          |
|3 |    └─HASH JOIN          |        |4       |19          |
|4 |      ├─TABLE FULL SCAN  |t1      |4       |9           |
|5 |      └─TABLE FULL SCAN  |t2      |4       |9           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      equal_conds([t1.c = t2.c]), other_conds(nil)
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_date t1, t_r4_date as t2 where t1.c = t2.c;
+------+---+------------+------+---+------------+
| a    | b | c          | a    | b | c          |
+------+---+------------+------+---+------------+
|    1 | 1 | 2016-11-01 |    1 | 1 | 2016-11-01 |
|    2 | 2 | 2016-11-02 |    2 | 2 | 2016-11-02 |
|    3 | 3 | 2016-11-03 |    3 | 3 | 2016-11-03 |
|    4 | 4 | 2016-11-04 |    4 | 4 | 2016-11-04 |
+------+---+------------+------+---+------------+
EXPLAIN select * from t_r4_date t1, t_r4_datetime as t2 where t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |38          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |34          |
|2 |  └─HASH JOIN                    |        |4       |25          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |15          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |13          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |9           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      equal_conds([cast(t1.c, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  3 - output([t1.c], [cast(t1.c, MYSQL_DATETIME(-1, -1))], [t1.b], [t1.a]), filter(nil), rowset=16
  4 - output([t1.c], [cast(t1.c, MYSQL_DATETIME(-1, -1))], [t1.b], [t1.a]), filter(nil), rowset=16
      (#keys=1, [cast(t1.c, MYSQL_DATETIME(-1, -1))]), dop=1
  5 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_date t1, t_r4_datetime as t2 where t1.c = t2.c;
+------+---+------------+------+---+---------------------+
| a    | b | c          | a    | b | c                   |
+------+---+------------+------+---+---------------------+
|    1 | 1 | 2016-11-01 |    1 | 1 | 2016-11-01 00:00:00 |
|    2 | 2 | 2016-11-02 |    2 | 2 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 |    3 | 3 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 |    4 | 4 | 2016-11-04 00:00:00 |
+------+---+------------+------+---+---------------------+
EXPLAIN select * from t_r4_date t1, t_r4_timestamp as t2 where t1.c = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |32          |
|1 |├─PX COORDINATOR           |        |4       |15          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|4       |13          |
|3 |│   └─PX PARTITION ITERATOR|        |4       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |4       |9           |
|5 |└─PX COORDINATOR           |        |4       |16          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |14          |
|7 |    └─PX PARTITION ITERATOR|        |4       |9           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |9           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([cast(t1.c, MYSQL_DATETIME(-1, -1)) = cast(t2.c, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
  6 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_r4_timestamp as t2 where t1.c = t2.c;
+------+---+------------+---+------+---------------------+
| a    | b | c          | a | b    | c                   |
+------+---+------------+---+------+---------------------+
|    1 | 1 | 2016-11-01 | 1 |    1 | 2016-11-01 00:00:00 |
|    2 | 2 | 2016-11-02 | 2 |    2 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 | 3 |    3 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 | 4 |    4 | 2016-11-04 00:00:00 |
+------+---+------------+---+------+---------------------+

EXPLAIN select * from t_r4_datetime t1, t_r4_int as t2 where t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |40          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |36          |
|2 |  └─HASH JOIN                    |        |4       |27          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |5       |17          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |5       |9           |
|8 |          └─TABLE FULL SCAN      |t2      |5       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.a], [t1.b], [t1.a], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.a, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [cast(t2.a, MYSQL_DATETIME(-1, -1))], [t2.b], [t2.c]), filter(nil), rowset=16
  6 - output([t2.a], [cast(t2.a, MYSQL_DATETIME(-1, -1))], [t2.b], [t2.c]), filter(nil), rowset=16
      (#keys=1, [cast(t2.a, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a], [t2.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_datetime t1, t_r4_int as t2 where t1.c = t2.a;
+------+---+---+---+---+------+
| a    | b | c | a | b | c    |
+------+---+---+---+---+------+
+------+---+---+---+---+------+
EXPLAIN select * from t_r4_datetime t1, t_r4_date as t2 where t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |38          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |34          |
|2 |  └─HASH JOIN                    |        |4       |25          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |15          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |13          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t2      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |9           |
|8 |      └─TABLE FULL SCAN          |t1      |4       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t2.b], [t2.a], [t1.b], [t1.a]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.c, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t2.c], [cast(t2.c, MYSQL_DATETIME(-1, -1))], [t2.b], [t2.a]), filter(nil), rowset=16
  4 - output([t2.c], [cast(t2.c, MYSQL_DATETIME(-1, -1))], [t2.b], [t2.a]), filter(nil), rowset=16
      (#keys=1, [cast(t2.c, MYSQL_DATETIME(-1, -1))]), dop=1
  5 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      force partition granule
  6 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_datetime t1, t_r4_date as t2 where t1.c = t2.c;
+------+---+---------------------+------+---+------------+
| a    | b | c                   | a    | b | c          |
+------+---+---------------------+------+---+------------+
|    1 | 1 | 2016-11-01 00:00:00 |    1 | 1 | 2016-11-01 |
|    2 | 2 | 2016-11-02 00:00:00 |    2 | 2 | 2016-11-02 |
|    3 | 3 | 2016-11-03 00:00:00 |    3 | 3 | 2016-11-03 |
|    4 | 4 | 2016-11-04 00:00:00 |    4 | 4 | 2016-11-04 |
+------+---+---------------------+------+---+------------+
EXPLAIN select * from t_r4_datetime t1, t_r4_datetime as t2 where t1.c = t2.c;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |PX COORDINATOR           |        |4       |32          |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|4       |28          |
|2 |  └─PX PARTITION ITERATOR|        |4       |19          |
|3 |    └─HASH JOIN          |        |4       |19          |
|4 |      ├─TABLE FULL SCAN  |t1      |4       |9           |
|5 |      └─TABLE FULL SCAN  |t2      |4       |9           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      equal_conds([t1.c = t2.c]), other_conds(nil)
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_datetime t1, t_r4_datetime as t2 where t1.c = t2.c;
+------+---+---------------------+------+---+---------------------+
| a    | b | c                   | a    | b | c                   |
+------+---+---------------------+------+---+---------------------+
|    1 | 1 | 2016-11-01 00:00:00 |    1 | 1 | 2016-11-01 00:00:00 |
|    2 | 2 | 2016-11-02 00:00:00 |    2 | 2 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 00:00:00 |    3 | 3 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 00:00:00 |    4 | 4 | 2016-11-04 00:00:00 |
+------+---+---------------------+------+---+---------------------+
EXPLAIN select * from t_r4_datetime t1, t_r4_timestamp as t2 where t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |39          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |35          |
|2 |  └─HASH JOIN                    |        |4       |26          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |16          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |9           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.a], [t2.b]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.c, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c], [cast(t2.c, MYSQL_DATETIME(19, 0))], [t2.a], [t2.b]), filter(nil), rowset=16
  6 - output([t2.c], [cast(t2.c, MYSQL_DATETIME(19, 0))], [t2.a], [t2.b]), filter(nil), rowset=16
      (#keys=1, [cast(t2.c, MYSQL_DATETIME(19, 0))]), dop=1
  7 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_r4_timestamp as t2 where t1.c = t2.c;
+------+---+---------------------+---+------+---------------------+
| a    | b | c                   | a | b    | c                   |
+------+---+---------------------+---+------+---------------------+
|    1 | 1 | 2016-11-01 00:00:00 | 1 |    1 | 2016-11-01 00:00:00 |
|    2 | 2 | 2016-11-02 00:00:00 | 2 |    2 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 00:00:00 | 3 |    3 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 00:00:00 | 4 |    4 | 2016-11-04 00:00:00 |
+------+---+---------------------+---+------+---------------------+

EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.aa;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |57          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |50          |
|2 |  └─HASH JOIN                    |        |4       |35          |
|3 |    ├─PX PARTITION ITERATOR      |        |5       |11          |
|4 |    │ └─TABLE FULL SCAN          |t1      |5       |11          |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.aa], [t1.b], [t1.c], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.aa]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.aa], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.aa], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [t2.aa]), dop=1
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.aa;
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b    | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 |    3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 |    1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 |    4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 |    2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |50          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |43          |
|2 |  └─HASH JOIN                    |        |4       |28          |
|3 |    ├─EXCHANGE IN DISTR          |        |5       |19          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |17          |
|5 |    │   └─PX PARTITION ITERATOR  |        |5       |11          |
|6 |    │     └─TABLE FULL SCAN      |t1      |5       |11          |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t1.c], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.a;
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b    | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 |    3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 |    1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 |    4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 |    2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.b;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |43          |
|1 |├─PX COORDINATOR           |        |5       |19          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |17          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |11          |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |11          |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.b]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.b;
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b    | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 |    3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 |    1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 |    4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 |    2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+------+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |43          |
|1 |├─PX COORDINATOR           |        |5       |19          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |17          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |11          |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |11          |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.c;
+---+------+------+---+------+------+------+------+------+------+
| a | b    | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+------+------+---+------+------+------+------+------+------+
+---+------+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.d;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |43          |
|1 |├─PX COORDINATOR           |        |5       |19          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |17          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |11          |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |11          |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATE(-1, -1)) = t2.d]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.d;
+---+------+------+---+------+------+------+------+------+------+
| a | b    | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+------+------+---+------+------+------+------+------+------+
+---+------+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_int t1, t_refered as t2 where t1.a = t2.e;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |43          |
|1 |├─PX COORDINATOR           |        |5       |19          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |17          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |11          |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |11          |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, TIMESTAMP(-1, -1)) = t2.e]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_int t1, t_refered as t2 where t1.a = t2.e;
+---+------+------+---+------+------+------+------+------+------+
| a | b    | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+------+------+---+------+------+------+------+------+------+
+---+------+------+---+------+------+------+------+------+------+

EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.aa;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |48          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |5       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |5       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.aa], [t1.b], [t1.c], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.aa]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.aa], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.aa], [t2.a], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [t2.aa]), dop=1
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.aa;
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |40          |
|2 |  └─HASH JOIN                    |        |4       |25          |
|3 |    ├─EXCHANGE IN DISTR          |        |5       |17          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |5       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |5       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t1.c], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.a;
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.b;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |41          |
|1 |├─PX COORDINATOR           |        |5       |17          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.b]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.b;
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |40          |
|1 |├─PX COORDINATOR           |        |5       |17          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.c;
+---+---+------+---+------+------+------+------+------+------+
| a | b | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+---+------+---+------+------+------+------+------+------+
+---+---+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.d;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |40          |
|1 |├─PX COORDINATOR           |        |5       |17          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATE(-1, -1)) = t2.d]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.d;
+---+---+------+---+------+------+------+------+------+------+
| a | b | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+---+------+---+------+------+------+------+------+------+
+---+---+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_int t1, t_refered as t2 where t1.a = t2.e;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |40          |
|1 |├─PX COORDINATOR           |        |5       |17          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |5       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |5       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.a, TIMESTAMP(-1, -1)) = t2.e]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_int t1, t_refered as t2 where t1.a = t2.e;
+---+---+------+---+------+------+------+------+------+------+
| a | b | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+---+------+---+------+------+------+------+------+------+
+---+---+------+---+------+------+------+------+------+------+

EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.a], [t1.b], [t1.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.a, MYSQL_DATE(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [cast(t2.a, MYSQL_DATE(-1, -1))], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [cast(t2.a, MYSQL_DATE(-1, -1))], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.a, MYSQL_DATE(-1, -1))]), dop=1
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.a;
+------+---+---+---+------+------+------+------+------+------+
| a    | b | c | a | aa   | b    | bb   | c    | d    | e    |
+------+---+---+---+------+------+------+------+------+------+
+------+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.b;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.b], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.b, MYSQL_DATE(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.b], [cast(t2.b, MYSQL_DATE(-1, -1))], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.b], [cast(t2.b, MYSQL_DATE(-1, -1))], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.b, MYSQL_DATE(-1, -1))]), dop=1
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.b;
+------+---+---+---+------+------+------+------+------+------+
| a    | b | c | a | aa   | b    | bb   | c    | d    | e    |
+------+---+---+---+------+------+------+------+------+------+
+------+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |39          |
|1 |├─PX COORDINATOR           |        |4       |15          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|4       |13          |
|3 |│   └─PX PARTITION ITERATOR|        |4       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |4       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.c, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.c;
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
|    1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    1 | 1 | 2016-11-01 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.d;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.d], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = t2.d]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.d], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
  6 - output([t2.d], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      (#keys=1, [t2.d]), dop=1
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.d;
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
|    1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    1 | 1 | 2016-11-01 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    1 | 1 | 2016-11-01 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
|    2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_date t1, t_refered as t2 where t1.c = t2.e;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |39          |
|1 |├─PX COORDINATOR           |        |4       |15          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|4       |13          |
|3 |│   └─PX PARTITION ITERATOR|        |4       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |4       |9           |
|5 |└─PX COORDINATOR           |        |4       |23          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |18          |
|7 |    └─PX PARTITION ITERATOR|        |4       |7           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |7           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([cast(t1.c, MYSQL_DATETIME(-1, -1)) = cast(t2.e, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_refered as t2 where t1.c = t2.e;
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c          | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+
|    3 | 3 | 2016-11-03 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    1 | 1 | 2016-11-01 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    4 | 4 | 2016-11-04 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
|    2 | 2 | 2016-11-02 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+------+---+------------+---+------+------+------+---------------------+------------+---------------------+

EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |48          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.a], [t1.b], [t1.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.a, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [cast(t2.a, MYSQL_DATETIME(-1, -1))], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.a], [cast(t2.a, MYSQL_DATETIME(-1, -1))], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.a, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.a;
+------+---+---+---+------+------+------+------+------+------+
| a    | b | c | a | aa   | b    | bb   | c    | d    | e    |
+------+---+---+---+------+------+------+------+------+------+
+------+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.b;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |48          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.b], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.b, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.b], [cast(t2.b, MYSQL_DATETIME(-1, -1))], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.b], [cast(t2.b, MYSQL_DATETIME(-1, -1))], [t2.a], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.b, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.b;
+------+---+---+---+------+------+------+------+------+------+
| a    | b | c | a | aa   | b    | bb   | c    | d    | e    |
+------+---+---+---+------+------+------+------+------+------+
+------+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = t2.c]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
  6 - output([t2.c], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      (#keys=1, [t2.c]), dop=1
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.c;
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
|    1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    1 | 1 | 2016-11-01 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.d;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |47          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.d], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.d, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.d], [cast(t2.d, MYSQL_DATETIME(-1, -1))], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
  6 - output([t2.d], [cast(t2.d, MYSQL_DATETIME(-1, -1))], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      (#keys=1, [cast(t2.d, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.d;
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
|    1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    1 | 1 | 2016-11-01 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    1 | 1 | 2016-11-01 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
|    2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.e;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |54          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |48          |
|2 |  └─HASH JOIN                    |        |4       |33          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |23          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |18          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |7           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.e], [t1.b], [t1.a], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.e, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.e], [cast(t2.e, MYSQL_DATETIME(19, 0))], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
  6 - output([t2.e], [cast(t2.e, MYSQL_DATETIME(19, 0))], [t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      (#keys=1, [cast(t2.e, MYSQL_DATETIME(19, 0))]), dop=1
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_refered as t2 where t1.c = t2.e;
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a    | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
|    3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
|    1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
|    4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
|    2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+------+---+---------------------+---+------+------+------+---------------------+------------+---------------------+

EXPLAIN select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t1.c], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a;
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.aa;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t2.aa], [t1.c], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.b = t2.aa]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.aa;
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.b;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t2.b], [t1.c], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.b = t2.b]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.b;
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |45          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t2.c], [t1.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [cast(t1.b, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.c;
+---+---+------+---+------+------+------+------+------+------+
| a | b | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+---+------+---+------+------+------+------+------+------+
+---+---+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.d;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |45          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t2.d], [t1.c], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [cast(t1.b, MYSQL_DATE(-1, -1)) = t2.d]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.d;
+---+---+------+---+------+------+------+------+------+------+
| a | b | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+---+------+---+------+------+------+------+------+------+
+---+---+------+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.e;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t2.e], [t1.c], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [cast(t1.b, TIMESTAMP(-1, -1)) = t2.e]), other_conds(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.e;
+---+---+------+---+------+------+------+------+------+------+
| a | b | c    | a | aa   | b    | bb   | c    | d    | e    |
+---+---+------+---+------+------+------+------+------+------+
+---+---+------+---+------+------+------+------+------+------+

EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t1.b], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.a, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.a;
+---+---+---+---+------+------+------+------+------+------+
| a | b | c | a | aa   | b    | bb   | c    | d    | e    |
+---+---+---+---+------+------+------+------+------+------+
+---+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.aa;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.aa], [t1.b], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.aa, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.aa;
+---+---+---+---+------+------+------+------+------+------+
| a | b | c | a | aa   | b    | bb   | c    | d    | e    |
+---+---+---+---+------+------+------+------+------+------+
+---+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.b;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.b], [t1.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.b, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.aa], [t2.bb], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.b;
+---+---+---+---+------+------+------+------+------+------+
| a | b | c | a | aa   | b    | bb   | c    | d    | e    |
+---+---+---+---+------+------+------+------+------+------+
+---+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.bb;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.bb], [t1.b], [t2.aa], [t2.b], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.bb, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.bb], [t2.aa], [t2.b], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.bb], [t2.aa], [t2.b], [t2.c], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.bb], [t2.aa], [t2.b], [t2.c], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.bb;
+---+---+---+---+------+------+------+------+------+------+
| a | b | c | a | aa   | b    | bb   | c    | d    | e    |
+---+---+---+---+------+------+------+------+------+------+
+---+---+---+---+------+------+------+------+------+------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.c], [t1.b], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = t2.c]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.aa], [t2.b], [t2.bb], [t2.d], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.c;
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.d;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.d], [t1.b], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.d, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), filter(nil), rowset=16
      access([t2.a], [t2.d], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.e]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.d;
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
EXPLAIN select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.e;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |46          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |39          |
|2 |  └─HASH JOIN                    |        |4       |24          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |16          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |7           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |7           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.aa, t2.b, t2.bb, t2.c, t2.d, t2.e)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.c], [t2.e], [t1.b], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a], [t1.c = cast(t2.e, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  3 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
  4 - output([t1.a], [t1.c], [t1.b]), filter(nil), rowset=16
      (#keys=1, [t1.a]), dop=1
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.a], [t1.b], [t1.c]), filter([t1.a = t1.b]), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p0sp[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.a], [t1.b], [t1.c]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), filter(nil), rowset=16
      access([t2.a], [t2.e], [t2.aa], [t2.b], [t2.bb], [t2.c], [t2.d]), partitions(p[0-2])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_h5_r4_int_int_datetime t1, t_refered as t2 where t1.a = t2.a and t1.b=t2.a and t1.c = t2.e;
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| a | b | c                   | a | aa   | b    | bb   | c                   | d          | e                   |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+
| 3 | 3 | 2016-11-03 00:00:00 | 3 |    3 |    3 |    3 | 2016-11-03 00:00:00 | 2016-11-01 | 2016-11-03 00:00:00 |
| 1 | 1 | 2016-11-01 00:00:00 | 1 |    1 |    1 |    1 | 2016-11-01 00:00:00 | 2016-11-01 | 2016-11-01 00:00:00 |
| 4 | 4 | 2016-11-04 00:00:00 | 4 |    4 |    4 |    4 | 2016-11-04 00:00:00 | 2016-11-01 | 2016-11-04 00:00:00 |
| 2 | 2 | 2016-11-02 00:00:00 | 2 |    2 |    2 |    2 | 2016-11-01 00:00:00 | 2016-11-02 | 2016-11-02 00:00:00 |
+---+---+---------------------+---+------+------+------+---------------------+------------+---------------------+

EXPLAIN select * from t_r4_int t1, t_r4_int  as t2 where t1.a = t2.a;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |PX COORDINATOR           |        |5       |34          |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|5       |29          |
|2 |  └─PX PARTITION ITERATOR|        |5       |19          |
|3 |    └─MERGE JOIN         |        |5       |19          |
|4 |      ├─TABLE FULL SCAN  |t1      |5       |9           |
|5 |      └─TABLE FULL SCAN  |t2      |5       |9           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.a], [t1.b], [t1.c], [t2.b], [t2.c]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t1.a], [t2.a], [t1.b], [t1.c], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([t1.a = t2.a]), other_conds(nil)
      merge_directions([ASC])
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a], [t2.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_int t1, t_r4_int  as t2 where t1.a = t2.a;
+---+---+------------+---+---+------------+
| a | b | c          | a | b | c          |
+---+---+------------+---+---+------------+
| 1 | 1 | 2016-11-01 | 1 | 1 | 2016-11-01 |
| 2 | 2 | 2016-11-02 | 2 | 2 | 2016-11-02 |
| 3 | 3 | 2016-11-03 | 3 | 3 | 2016-11-03 |
| 4 | 4 | 2016-11-04 | 4 | 4 | 2016-11-04 |
| 5 | 5 | 2016-11-05 | 5 | 5 | 2016-11-05 |
+---+---+------------+---+---+------------+
EXPLAIN select * from t_r4_int t1, t_r4_date  as t2 where t1.a = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |39          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |35          |
|2 |  └─HASH JOIN                    |        |4       |27          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t2      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |5       |17          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |5       |9           |
|8 |          └─TABLE FULL SCAN      |t1      |5       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.c], [t2.b], [t2.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATE(-1, -1)) = t2.c]), other_conds(nil)
  3 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t1.a], [cast(t1.a, MYSQL_DATE(-1, -1))], [t1.b], [t1.c]), filter(nil), rowset=16
  6 - output([t1.a], [cast(t1.a, MYSQL_DATE(-1, -1))], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [cast(t1.a, MYSQL_DATE(-1, -1))]), dop=1
  7 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_int t1, t_r4_date  as t2 where t1.a = t2.c;
+---+---+------+------+---+---+
| a | b | c    | a    | b | c |
+---+---+------+------+---+---+
+---+---+------+------+---+---+
EXPLAIN select * from t_r4_int t1, t_r4_datetime  as t2 where t1.a = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |40          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |36          |
|2 |  └─HASH JOIN                    |        |4       |27          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t2      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |5       |17          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |5       |9           |
|8 |          └─TABLE FULL SCAN      |t1      |5       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.a], [t2.c], [t2.b], [t2.a], [t1.b], [t1.c]), filter(nil), rowset=16
      equal_conds([cast(t1.a, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  3 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t1.a], [cast(t1.a, MYSQL_DATETIME(-1, -1))], [t1.b], [t1.c]), filter(nil), rowset=16
  6 - output([t1.a], [cast(t1.a, MYSQL_DATETIME(-1, -1))], [t1.b], [t1.c]), filter(nil), rowset=16
      (#keys=1, [cast(t1.a, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_int t1, t_r4_datetime  as t2 where t1.a = t2.c;
+---+---+------+------+---+---+
| a | b | c    | a    | b | c |
+---+---+------+------+---+---+
+---+---+------+------+---+---+
EXPLAIN select * from t_r4_int t1, t_r4_timestamp  as t2 where t1.a = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |33          |
|1 |├─PX COORDINATOR           |        |4       |16          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|4       |14          |
|3 |│   └─PX PARTITION ITERATOR|        |4       |9           |
|4 |│     └─TABLE FULL SCAN    |t2      |4       |9           |
|5 |└─PX COORDINATOR           |        |5       |17          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|5       |14          |
|7 |    └─PX PARTITION ITERATOR|        |5       |9           |
|8 |      └─TABLE FULL SCAN    |t1      |5       |9           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([cast(t1.a, TIMESTAMP(-1, -1)) = t2.c]), other_conds(nil)
  1 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
  2 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      dop=1
  3 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      force partition granule
  4 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  7 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      access([t1.a], [t1.b], [t1.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.a], [t1.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_int t1, t_r4_timestamp  as t2 where t1.a = t2.c;
+---+---+------+---+------+------+
| a | b | c    | a | b    | c    |
+---+---+------+---+------+------+
+---+---+------+---+------+------+

EXPLAIN select * from t_r4_date t1, t_r4_int  as t2 where t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |39          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |35          |
|2 |  └─HASH JOIN                    |        |4       |27          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |5       |17          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |5       |9           |
|8 |          └─TABLE FULL SCAN      |t2      |5       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.a], [t1.b], [t1.a], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.a, MYSQL_DATE(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [cast(t2.a, MYSQL_DATE(-1, -1))], [t2.b], [t2.c]), filter(nil), rowset=16
  6 - output([t2.a], [cast(t2.a, MYSQL_DATE(-1, -1))], [t2.b], [t2.c]), filter(nil), rowset=16
      (#keys=1, [cast(t2.a, MYSQL_DATE(-1, -1))]), dop=1
  7 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a], [t2.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_date t1, t_r4_int  as t2 where t1.c = t2.a;
+------+---+---+---+---+------+
| a    | b | c | a | b | c    |
+------+---+---+---+---+------+
+------+---+---+---+---+------+
EXPLAIN select * from t_r4_date t1, t_r4_date  as t2 where t1.c = t2.c;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |PX COORDINATOR           |        |4       |31          |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|4       |28          |
|2 |  └─PX PARTITION ITERATOR|        |4       |19          |
|3 |    └─HASH JOIN          |        |4       |19          |
|4 |      ├─TABLE FULL SCAN  |t1      |4       |9           |
|5 |      └─TABLE FULL SCAN  |t2      |4       |9           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      equal_conds([t1.c = t2.c]), other_conds(nil)
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_date t1, t_r4_date  as t2 where t1.c = t2.c;
+------+---+------------+------+---+------------+
| a    | b | c          | a    | b | c          |
+------+---+------------+------+---+------------+
|    1 | 1 | 2016-11-01 |    1 | 1 | 2016-11-01 |
|    2 | 2 | 2016-11-02 |    2 | 2 | 2016-11-02 |
|    3 | 3 | 2016-11-03 |    3 | 3 | 2016-11-03 |
|    4 | 4 | 2016-11-04 |    4 | 4 | 2016-11-04 |
+------+---+------------+------+---+------------+
EXPLAIN select * from t_r4_date t1, t_r4_datetime  as t2 where t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |38          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |34          |
|2 |  └─HASH JOIN                    |        |4       |25          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |15          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |13          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t1      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |9           |
|8 |      └─TABLE FULL SCAN          |t2      |4       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      equal_conds([cast(t1.c, MYSQL_DATETIME(-1, -1)) = t2.c]), other_conds(nil)
  3 - output([t1.c], [cast(t1.c, MYSQL_DATETIME(-1, -1))], [t1.b], [t1.a]), filter(nil), rowset=16
  4 - output([t1.c], [cast(t1.c, MYSQL_DATETIME(-1, -1))], [t1.b], [t1.a]), filter(nil), rowset=16
      (#keys=1, [cast(t1.c, MYSQL_DATETIME(-1, -1))]), dop=1
  5 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      force partition granule
  6 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_date t1, t_r4_datetime  as t2 where t1.c = t2.c;
+------+---+------------+------+---+---------------------+
| a    | b | c          | a    | b | c                   |
+------+---+------------+------+---+---------------------+
|    1 | 1 | 2016-11-01 |    1 | 1 | 2016-11-01 00:00:00 |
|    2 | 2 | 2016-11-02 |    2 | 2 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 |    3 | 3 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 |    4 | 4 | 2016-11-04 00:00:00 |
+------+---+------------+------+---+---------------------+
EXPLAIN select * from t_r4_date t1, t_r4_timestamp  as t2 where t1.c = t2.c;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |HASH JOIN                  |        |4       |32          |
|1 |├─PX COORDINATOR           |        |4       |15          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|4       |13          |
|3 |│   └─PX PARTITION ITERATOR|        |4       |9           |
|4 |│     └─TABLE FULL SCAN    |t1      |4       |9           |
|5 |└─PX COORDINATOR           |        |4       |16          |
|6 |  └─EXCHANGE OUT DISTR     |:EX20000|4       |14          |
|7 |    └─PX PARTITION ITERATOR|        |4       |9           |
|8 |      └─TABLE FULL SCAN    |t2      |4       |9           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([cast(t1.c, MYSQL_DATETIME(-1, -1)) = cast(t2.c, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), rowset=16
      dop=1
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
  6 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      dop=1
  7 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_date t1, t_r4_timestamp  as t2 where t1.c = t2.c;
+------+---+------------+---+------+---------------------+
| a    | b | c          | a | b    | c                   |
+------+---+------------+---+------+---------------------+
|    1 | 1 | 2016-11-01 | 1 |    1 | 2016-11-01 00:00:00 |
|    2 | 2 | 2016-11-02 | 2 |    2 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 | 3 |    3 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 | 4 |    4 | 2016-11-04 00:00:00 |
+------+---+------------+---+------+---------------------+

EXPLAIN select * from t_r4_datetime t1, t_r4_int  as t2 where t1.c = t2.a;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |40          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |36          |
|2 |  └─HASH JOIN                    |        |4       |27          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |5       |17          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |5       |9           |
|8 |          └─TABLE FULL SCAN      |t2      |5       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.a], [t1.b], [t1.a], [t2.b], [t2.c]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.a, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.a], [cast(t2.a, MYSQL_DATETIME(-1, -1))], [t2.b], [t2.c]), filter(nil), rowset=16
  6 - output([t2.a], [cast(t2.a, MYSQL_DATETIME(-1, -1))], [t2.b], [t2.c]), filter(nil), rowset=16
      (#keys=1, [cast(t2.a, MYSQL_DATETIME(-1, -1))]), dop=1
  7 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.b], [t2.c]), filter(nil), rowset=16
      access([t2.a], [t2.b], [t2.c]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a], [t2.b]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_datetime t1, t_r4_int  as t2 where t1.c = t2.a;
+------+---+---+---+---+------+
| a    | b | c | a | b | c    |
+------+---+---+---+---+------+
+------+---+---+---+---+------+
EXPLAIN select * from t_r4_datetime t1, t_r4_date  as t2 where t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |38          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |34          |
|2 |  └─HASH JOIN                    |        |4       |25          |
|3 |    ├─EXCHANGE IN DISTR          |        |4       |15          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |13          |
|5 |    │   └─PX PARTITION ITERATOR  |        |4       |9           |
|6 |    │     └─TABLE FULL SCAN      |t2      |4       |9           |
|7 |    └─PX PARTITION ITERATOR      |        |4       |9           |
|8 |      └─TABLE FULL SCAN          |t1      |4       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t2.b], [t2.a], [t1.b], [t1.a]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.c, MYSQL_DATETIME(-1, -1))]), other_conds(nil)
  3 - output([t2.c], [cast(t2.c, MYSQL_DATETIME(-1, -1))], [t2.b], [t2.a]), filter(nil), rowset=16
  4 - output([t2.c], [cast(t2.c, MYSQL_DATETIME(-1, -1))], [t2.b], [t2.a]), filter(nil), rowset=16
      (#keys=1, [cast(t2.c, MYSQL_DATETIME(-1, -1))]), dop=1
  5 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      force partition granule
  6 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  8 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_datetime t1, t_r4_date  as t2 where t1.c = t2.c;
+------+---+---------------------+------+---+------------+
| a    | b | c                   | a    | b | c          |
+------+---+---------------------+------+---+------------+
|    1 | 1 | 2016-11-01 00:00:00 |    1 | 1 | 2016-11-01 |
|    2 | 2 | 2016-11-02 00:00:00 |    2 | 2 | 2016-11-02 |
|    3 | 3 | 2016-11-03 00:00:00 |    3 | 3 | 2016-11-03 |
|    4 | 4 | 2016-11-04 00:00:00 |    4 | 4 | 2016-11-04 |
+------+---+---------------------+------+---+------------+
EXPLAIN select * from t_r4_datetime t1, t_r4_datetime  as t2 where t1.c = t2.c;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |PX COORDINATOR           |        |4       |32          |
|1 |└─EXCHANGE OUT DISTR     |:EX10000|4       |28          |
|2 |  └─PX PARTITION ITERATOR|        |4       |19          |
|3 |    └─HASH JOIN          |        |4       |19          |
|4 |      ├─TABLE FULL SCAN  |t1      |4       |9           |
|5 |      └─TABLE FULL SCAN  |t2      |4       |9           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      partition wise, force partition granule
  3 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.b], [t2.a]), filter(nil), rowset=16
      equal_conds([t1.c = t2.c]), other_conds(nil)
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.b], [t2.c], [t2.a]), filter(nil), rowset=16
      access([t2.b], [t2.c], [t2.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.b], [t2.c]), range(MIN,MIN ; MAX,MAX)always true
select * from t_r4_datetime t1, t_r4_datetime  as t2 where t1.c = t2.c;
+------+---+---------------------+------+---+---------------------+
| a    | b | c                   | a    | b | c                   |
+------+---+---------------------+------+---+---------------------+
|    1 | 1 | 2016-11-01 00:00:00 |    1 | 1 | 2016-11-01 00:00:00 |
|    2 | 2 | 2016-11-02 00:00:00 |    2 | 2 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 00:00:00 |    3 | 3 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 00:00:00 |    4 | 4 | 2016-11-04 00:00:00 |
+------+---+---------------------+------+---+---------------------+
EXPLAIN select * from t_r4_datetime t1, t_r4_timestamp  as t2 where t1.c = t2.c;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |PX COORDINATOR                   |        |4       |39          |
|1 |└─EXCHANGE OUT DISTR             |:EX10001|4       |35          |
|2 |  └─HASH JOIN                    |        |4       |26          |
|3 |    ├─PX PARTITION ITERATOR      |        |4       |9           |
|4 |    │ └─TABLE FULL SCAN          |t1      |4       |9           |
|5 |    └─EXCHANGE IN DISTR          |        |4       |16          |
|6 |      └─EXCHANGE OUT DISTR (PKEY)|:EX10000|4       |14          |
|7 |        └─PX PARTITION ITERATOR  |        |4       |9           |
|8 |          └─TABLE FULL SCAN      |t2      |4       |9           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.a, t1.b, t1.c, t2.a, t2.b, t2.c)]), filter(nil), rowset=16
      dop=1
  2 - output([t1.c], [t2.c], [t1.b], [t1.a], [t2.a], [t2.b]), filter(nil), rowset=16
      equal_conds([t1.c = cast(t2.c, MYSQL_DATETIME(19, 0))]), other_conds(nil)
  3 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      affinitize, force partition granule
  4 - output([t1.b], [t1.c], [t1.a]), filter(nil), rowset=16
      access([t1.b], [t1.c], [t1.a]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t1.b], [t1.c]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c], [cast(t2.c, MYSQL_DATETIME(19, 0))], [t2.a], [t2.b]), filter(nil), rowset=16
  6 - output([t2.c], [cast(t2.c, MYSQL_DATETIME(19, 0))], [t2.a], [t2.b]), filter(nil), rowset=16
      (#keys=1, [cast(t2.c, MYSQL_DATETIME(19, 0))]), dop=1
  7 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      force partition granule
  8 - output([t2.a], [t2.c], [t2.b]), filter(nil), rowset=16
      access([t2.a], [t2.c], [t2.b]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t2.a]), range(MIN ; MAX)always true
select * from t_r4_datetime t1, t_r4_timestamp  as t2 where t1.c = t2.c;
+------+---+---------------------+---+------+---------------------+
| a    | b | c                   | a | b    | c                   |
+------+---+---------------------+---+------+---------------------+
|    1 | 1 | 2016-11-01 00:00:00 | 1 |    1 | 2016-11-01 00:00:00 |
|    2 | 2 | 2016-11-02 00:00:00 | 2 |    2 | 2016-11-02 00:00:00 |
|    3 | 3 | 2016-11-03 00:00:00 | 3 |    3 | 2016-11-03 00:00:00 |
|    4 | 4 | 2016-11-04 00:00:00 | 4 |    4 | 2016-11-04 00:00:00 |
+------+---+---------------------+---+------+---------------------+

EXPLAIN select min(a) from t_many_range_part where a >=  1;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |39          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |39          |
|2 |  └─LIMIT                        |                 |1       |39          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |39          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |39          |
|5 |        └─LIMIT                  |                 |1       |38          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |38          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |38          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[0-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[1 ; MAX), 
      range_cond([t_many_range_part.a >= 1])
select min(a) from t_many_range_part where a >=  1;
+--------+
| min(a) |
+--------+
|      1 |
+--------+
EXPLAIN select min(a) from t_many_range_part where a >=  6;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |37          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |37          |
|2 |  └─LIMIT                        |                 |1       |37          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |37          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |37          |
|5 |        └─LIMIT                  |                 |1       |36          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |36          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |36          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[1-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[6 ; MAX), 
      range_cond([t_many_range_part.a >= 6])
select min(a) from t_many_range_part where a >=  6;
+--------+
| min(a) |
+--------+
|      6 |
+--------+
EXPLAIN select min(a) from t_many_range_part where a >= 11;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |35          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |35          |
|2 |  └─LIMIT                        |                 |1       |35          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |35          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |34          |
|5 |        └─LIMIT                  |                 |1       |34          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |34          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |34          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[2-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[11 ; MAX), 
      range_cond([t_many_range_part.a >= 11])
select min(a) from t_many_range_part where a >= 11;
+--------+
| min(a) |
+--------+
|     11 |
+--------+
EXPLAIN select min(a) from t_many_range_part where a >= 16;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |33          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |33          |
|2 |  └─LIMIT                        |                 |1       |33          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |33          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |32          |
|5 |        └─LIMIT                  |                 |1       |32          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |32          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |32          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[3-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[16 ; MAX), 
      range_cond([t_many_range_part.a >= 16])
select min(a) from t_many_range_part where a >= 16;
+--------+
| min(a) |
+--------+
|     16 |
+--------+
EXPLAIN select min(a) from t_many_range_part where a >= 21;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |30          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |30          |
|2 |  └─LIMIT                        |                 |1       |30          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |30          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |30          |
|5 |        └─LIMIT                  |                 |1       |30          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |30          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |30          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[4-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[21 ; MAX), 
      range_cond([t_many_range_part.a >= 21])
select min(a) from t_many_range_part where a >= 21;
+--------+
| min(a) |
+--------+
|     21 |
+--------+
EXPLAIN select min(a) from t_many_range_part where a >= 26;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |28          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |28          |
|2 |  └─LIMIT                        |                 |1       |28          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |28          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |28          |
|5 |        └─LIMIT                  |                 |1       |28          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |28          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |28          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[5-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[26 ; MAX), 
      range_cond([t_many_range_part.a >= 26])
select min(a) from t_many_range_part where a >= 26;
+--------+
| min(a) |
+--------+
|     26 |
+--------+
EXPLAIN select min(a) from t_many_range_part where a >= 31;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |26          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |26          |
|2 |  └─LIMIT                        |                 |1       |26          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |26          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |26          |
|5 |        └─LIMIT                  |                 |1       |26          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |26          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |26          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[6-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[31 ; MAX), 
      range_cond([t_many_range_part.a >= 31])
select min(a) from t_many_range_part where a >= 31;
+--------+
| min(a) |
+--------+
|     31 |
+--------+
EXPLAIN select min(a) from t_many_range_part where a >= 36;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |24          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |24          |
|2 |  └─LIMIT                        |                 |1       |24          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |24          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |24          |
|5 |        └─LIMIT                  |                 |1       |24          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |24          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |24          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[7-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[36 ; MAX), 
      range_cond([t_many_range_part.a >= 36])
select min(a) from t_many_range_part where a >= 36;
+--------+
| min(a) |
+--------+
|     36 |
+--------+
EXPLAIN select min(a) from t_many_range_part where a >= 41;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |22          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |22          |
|2 |  └─LIMIT                        |                 |1       |22          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |22          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |22          |
|5 |        └─LIMIT                  |                 |1       |22          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |22          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |22          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[8-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[41 ; MAX), 
      range_cond([t_many_range_part.a >= 41])
select min(a) from t_many_range_part where a >= 41;
+--------+
| min(a) |
+--------+
|     41 |
+--------+
EXPLAIN select min(a) from t_many_range_part where a >= 46;
Query Plan
==============================================================================
|ID|OPERATOR                         |NAME             |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                 |1       |20          |
|1 |└─SUBPLAN SCAN                   |VIEW1            |1       |20          |
|2 |  └─LIMIT                        |                 |1       |20          |
|3 |    └─PX COORDINATOR MERGE SORT  |                 |1       |20          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000         |1       |20          |
|5 |        └─LIMIT                  |                 |1       |19          |
|6 |          └─PX PARTITION ITERATOR|                 |1       |19          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part|1       |19          |
==============================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MIN(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[9-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[46 ; MAX), 
      range_cond([t_many_range_part.a >= 46])
select min(a) from t_many_range_part where a >= 46;
+--------+
| min(a) |
+--------+
|     46 |
+--------+

EXPLAIN select max(a) from t_many_range_part where a >=  1;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |39          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |39          |
|2 |  └─LIMIT                        |                          |1       |39          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |39          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |39          |
|5 |        └─LIMIT                  |                          |1       |38          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |38          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |38          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[0-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[1 ; MAX), 
      range_cond([t_many_range_part.a >= 1])
select max(a) from t_many_range_part where a >=  1;
+--------+
| max(a) |
+--------+
|     50 |
+--------+
EXPLAIN select max(a) from t_many_range_part where a >=  6;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |37          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |37          |
|2 |  └─LIMIT                        |                          |1       |37          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |37          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |37          |
|5 |        └─LIMIT                  |                          |1       |36          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |36          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |36          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[1-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[6 ; MAX), 
      range_cond([t_many_range_part.a >= 6])
select max(a) from t_many_range_part where a >=  6;
+--------+
| max(a) |
+--------+
|     50 |
+--------+
EXPLAIN select max(a) from t_many_range_part where a >= 11;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |35          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |35          |
|2 |  └─LIMIT                        |                          |1       |35          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |35          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |34          |
|5 |        └─LIMIT                  |                          |1       |34          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |34          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |34          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[2-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[11 ; MAX), 
      range_cond([t_many_range_part.a >= 11])
select max(a) from t_many_range_part where a >= 11;
+--------+
| max(a) |
+--------+
|     50 |
+--------+
EXPLAIN select max(a) from t_many_range_part where a >= 16;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |33          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |33          |
|2 |  └─LIMIT                        |                          |1       |33          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |33          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |32          |
|5 |        └─LIMIT                  |                          |1       |32          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |32          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |32          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[3-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[16 ; MAX), 
      range_cond([t_many_range_part.a >= 16])
select max(a) from t_many_range_part where a >= 16;
+--------+
| max(a) |
+--------+
|     50 |
+--------+
EXPLAIN select max(a) from t_many_range_part where a >= 21;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |30          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |30          |
|2 |  └─LIMIT                        |                          |1       |30          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |30          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |30          |
|5 |        └─LIMIT                  |                          |1       |30          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |30          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |30          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[4-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[21 ; MAX), 
      range_cond([t_many_range_part.a >= 21])
select max(a) from t_many_range_part where a >= 21;
+--------+
| max(a) |
+--------+
|     50 |
+--------+
EXPLAIN select max(a) from t_many_range_part where a >= 26;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |28          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |28          |
|2 |  └─LIMIT                        |                          |1       |28          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |28          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |28          |
|5 |        └─LIMIT                  |                          |1       |28          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |28          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |28          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[5-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[26 ; MAX), 
      range_cond([t_many_range_part.a >= 26])
select max(a) from t_many_range_part where a >= 26;
+--------+
| max(a) |
+--------+
|     50 |
+--------+
EXPLAIN select max(a) from t_many_range_part where a >= 31;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |26          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |26          |
|2 |  └─LIMIT                        |                          |1       |26          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |26          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |26          |
|5 |        └─LIMIT                  |                          |1       |26          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |26          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |26          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[6-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[31 ; MAX), 
      range_cond([t_many_range_part.a >= 31])
select max(a) from t_many_range_part where a >= 31;
+--------+
| max(a) |
+--------+
|     50 |
+--------+
EXPLAIN select max(a) from t_many_range_part where a >= 36;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |24          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |24          |
|2 |  └─LIMIT                        |                          |1       |24          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |24          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |24          |
|5 |        └─LIMIT                  |                          |1       |24          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |24          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |24          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[7-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[36 ; MAX), 
      range_cond([t_many_range_part.a >= 36])
select max(a) from t_many_range_part where a >= 36;
+--------+
| max(a) |
+--------+
|     50 |
+--------+
EXPLAIN select max(a) from t_many_range_part where a >= 41;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |22          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |22          |
|2 |  └─LIMIT                        |                          |1       |22          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |22          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |22          |
|5 |        └─LIMIT                  |                          |1       |22          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |22          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |22          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[8-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[41 ; MAX), 
      range_cond([t_many_range_part.a >= 41])
select max(a) from t_many_range_part where a >= 41;
+--------+
| max(a) |
+--------+
|     50 |
+--------+
EXPLAIN select max(a) from t_many_range_part where a >= 46;
Query Plan
=======================================================================================
|ID|OPERATOR                         |NAME                      |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                  |                          |1       |20          |
|1 |└─SUBPLAN SCAN                   |VIEW1                     |1       |20          |
|2 |  └─LIMIT                        |                          |1       |20          |
|3 |    └─PX COORDINATOR MERGE SORT  |                          |1       |20          |
|4 |      └─EXCHANGE OUT DISTR       |:EX10000                  |1       |20          |
|5 |        └─LIMIT                  |                          |1       |19          |
|6 |          └─PX PARTITION ITERATOR|                          |1       |19          |
|7 |            └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|1       |19          |
=======================================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t_many_range_part.a)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_MAX(VIEW1.t_many_range_part.a)])
  1 - output([VIEW1.t_many_range_part.a]), filter(nil), rowset=16
      access([VIEW1.t_many_range_part.a])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  7 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[9-17])
      limit(1), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[46 ; MAX), 
      range_cond([t_many_range_part.a >= 46])
select max(a) from t_many_range_part where a >= 46;
+--------+
| max(a) |
+--------+
|     50 |
+--------+

EXPLAIN select a from t_many_range_part where a >=  1 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |10      |44          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |10      |44          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |10      |42          |
|3 |    └─LIMIT                  |                 |10      |39          |
|4 |      └─PX PARTITION ITERATOR|                 |10      |39          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|10      |39          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[0-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[1 ; MAX), 
      range_cond([t_many_range_part.a >= 1])
select a from t_many_range_part where a >=  1 order by a asc limit 10;
+----+
| a  |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
+----+
EXPLAIN select a from t_many_range_part where a >=  6 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |10      |41          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |10      |41          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |10      |40          |
|3 |    └─LIMIT                  |                 |10      |36          |
|4 |      └─PX PARTITION ITERATOR|                 |10      |36          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|10      |36          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[1-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[6 ; MAX), 
      range_cond([t_many_range_part.a >= 6])
select a from t_many_range_part where a >=  6 order by a asc limit 10;
+----+
| a  |
+----+
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
+----+
EXPLAIN select a from t_many_range_part where a >= 11 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |10      |39          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |10      |39          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |10      |38          |
|3 |    └─LIMIT                  |                 |10      |34          |
|4 |      └─PX PARTITION ITERATOR|                 |10      |34          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|10      |34          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[2-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[11 ; MAX), 
      range_cond([t_many_range_part.a >= 11])
select a from t_many_range_part where a >= 11 order by a asc limit 10;
+----+
| a  |
+----+
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |
+----+
EXPLAIN select a from t_many_range_part where a >= 16 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |10      |37          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |10      |37          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |10      |36          |
|3 |    └─LIMIT                  |                 |10      |32          |
|4 |      └─PX PARTITION ITERATOR|                 |10      |32          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|10      |32          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[3-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[16 ; MAX), 
      range_cond([t_many_range_part.a >= 16])
select a from t_many_range_part where a >= 16 order by a asc limit 10;
+----+
| a  |
+----+
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |
| 21 |
| 22 |
| 23 |
| 24 |
| 25 |
+----+
EXPLAIN select a from t_many_range_part where a >= 21 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |10      |35          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |10      |35          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |10      |34          |
|3 |    └─LIMIT                  |                 |10      |30          |
|4 |      └─PX PARTITION ITERATOR|                 |10      |30          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|10      |30          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[4-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[21 ; MAX), 
      range_cond([t_many_range_part.a >= 21])
select a from t_many_range_part where a >= 21 order by a asc limit 10;
+----+
| a  |
+----+
| 21 |
| 22 |
| 23 |
| 24 |
| 25 |
| 26 |
| 27 |
| 28 |
| 29 |
| 30 |
+----+
EXPLAIN select a from t_many_range_part where a >= 26 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |10      |33          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |10      |33          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |10      |32          |
|3 |    └─LIMIT                  |                 |10      |28          |
|4 |      └─PX PARTITION ITERATOR|                 |10      |28          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|10      |28          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[5-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[26 ; MAX), 
      range_cond([t_many_range_part.a >= 26])
select a from t_many_range_part where a >= 26 order by a asc limit 10;
+----+
| a  |
+----+
| 26 |
| 27 |
| 28 |
| 29 |
| 30 |
| 31 |
| 32 |
| 33 |
| 34 |
| 35 |
+----+
EXPLAIN select a from t_many_range_part where a >= 31 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |10      |31          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |10      |31          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |10      |29          |
|3 |    └─LIMIT                  |                 |10      |26          |
|4 |      └─PX PARTITION ITERATOR|                 |10      |26          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|10      |26          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[6-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[31 ; MAX), 
      range_cond([t_many_range_part.a >= 31])
select a from t_many_range_part where a >= 31 order by a asc limit 10;
+----+
| a  |
+----+
| 31 |
| 32 |
| 33 |
| 34 |
| 35 |
| 36 |
| 37 |
| 38 |
| 39 |
| 40 |
+----+
EXPLAIN select a from t_many_range_part where a >= 36 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |10      |29          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |10      |29          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |10      |27          |
|3 |    └─LIMIT                  |                 |10      |24          |
|4 |      └─PX PARTITION ITERATOR|                 |10      |24          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|10      |24          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[7-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[36 ; MAX), 
      range_cond([t_many_range_part.a >= 36])
select a from t_many_range_part where a >= 36 order by a asc limit 10;
+----+
| a  |
+----+
| 36 |
| 37 |
| 38 |
| 39 |
| 40 |
| 41 |
| 42 |
| 43 |
| 44 |
| 45 |
+----+
EXPLAIN select a from t_many_range_part where a >= 41 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |10      |27          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |10      |27          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |10      |25          |
|3 |    └─LIMIT                  |                 |10      |22          |
|4 |      └─PX PARTITION ITERATOR|                 |10      |22          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|10      |22          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[8-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[41 ; MAX), 
      range_cond([t_many_range_part.a >= 41])
select a from t_many_range_part where a >= 41 order by a asc limit 10;
+----+
| a  |
+----+
| 41 |
| 42 |
| 43 |
| 44 |
| 45 |
| 46 |
| 47 |
| 48 |
| 49 |
| 50 |
+----+
EXPLAIN select a from t_many_range_part where a >= 46 order by a asc limit 10;
Query Plan
==========================================================================
|ID|OPERATOR                     |NAME             |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |LIMIT                        |                 |5       |22          |
|1 |└─PX COORDINATOR MERGE SORT  |                 |5       |22          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000         |5       |21          |
|3 |    └─LIMIT                  |                 |5       |20          |
|4 |      └─PX PARTITION ITERATOR|                 |5       |20          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part|5       |20          |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, ASC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, asc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[9-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[46 ; MAX), 
      range_cond([t_many_range_part.a >= 46])
select a from t_many_range_part where a >= 46 order by a asc limit 10;
+----+
| a  |
+----+
| 46 |
| 47 |
| 48 |
| 49 |
| 50 |
+----+

EXPLAIN select a from t_many_range_part where a >=  1 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |10      |44          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |10      |44          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |10      |42          |
|3 |    └─LIMIT                  |                          |10      |39          |
|4 |      └─PX PARTITION ITERATOR|                          |10      |39          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|10      |39          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[0-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[1 ; MAX), 
      range_cond([t_many_range_part.a >= 1])
select a from t_many_range_part where a >=  1 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
| 45 |
| 44 |
| 43 |
| 42 |
| 41 |
+----+
EXPLAIN select a from t_many_range_part where a >=  6 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |10      |41          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |10      |41          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |10      |40          |
|3 |    └─LIMIT                  |                          |10      |36          |
|4 |      └─PX PARTITION ITERATOR|                          |10      |36          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|10      |36          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[1-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[6 ; MAX), 
      range_cond([t_many_range_part.a >= 6])
select a from t_many_range_part where a >=  6 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
| 45 |
| 44 |
| 43 |
| 42 |
| 41 |
+----+
EXPLAIN select a from t_many_range_part where a >= 11 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |10      |39          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |10      |39          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |10      |38          |
|3 |    └─LIMIT                  |                          |10      |34          |
|4 |      └─PX PARTITION ITERATOR|                          |10      |34          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|10      |34          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[2-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[11 ; MAX), 
      range_cond([t_many_range_part.a >= 11])
select a from t_many_range_part where a >= 11 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
| 45 |
| 44 |
| 43 |
| 42 |
| 41 |
+----+
EXPLAIN select a from t_many_range_part where a >= 16 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |10      |37          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |10      |37          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |10      |36          |
|3 |    └─LIMIT                  |                          |10      |32          |
|4 |      └─PX PARTITION ITERATOR|                          |10      |32          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|10      |32          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[3-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[16 ; MAX), 
      range_cond([t_many_range_part.a >= 16])
select a from t_many_range_part where a >= 16 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
| 45 |
| 44 |
| 43 |
| 42 |
| 41 |
+----+
EXPLAIN select a from t_many_range_part where a >= 21 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |10      |35          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |10      |35          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |10      |34          |
|3 |    └─LIMIT                  |                          |10      |30          |
|4 |      └─PX PARTITION ITERATOR|                          |10      |30          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|10      |30          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[4-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[21 ; MAX), 
      range_cond([t_many_range_part.a >= 21])
select a from t_many_range_part where a >= 21 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
| 45 |
| 44 |
| 43 |
| 42 |
| 41 |
+----+
EXPLAIN select a from t_many_range_part where a >= 26 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |10      |33          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |10      |33          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |10      |32          |
|3 |    └─LIMIT                  |                          |10      |28          |
|4 |      └─PX PARTITION ITERATOR|                          |10      |28          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|10      |28          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[5-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[26 ; MAX), 
      range_cond([t_many_range_part.a >= 26])
select a from t_many_range_part where a >= 26 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
| 45 |
| 44 |
| 43 |
| 42 |
| 41 |
+----+
EXPLAIN select a from t_many_range_part where a >= 31 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |10      |31          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |10      |31          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |10      |29          |
|3 |    └─LIMIT                  |                          |10      |26          |
|4 |      └─PX PARTITION ITERATOR|                          |10      |26          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|10      |26          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[6-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[31 ; MAX), 
      range_cond([t_many_range_part.a >= 31])
select a from t_many_range_part where a >= 31 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
| 45 |
| 44 |
| 43 |
| 42 |
| 41 |
+----+
EXPLAIN select a from t_many_range_part where a >= 36 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |10      |29          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |10      |29          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |10      |27          |
|3 |    └─LIMIT                  |                          |10      |24          |
|4 |      └─PX PARTITION ITERATOR|                          |10      |24          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|10      |24          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[7-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[36 ; MAX), 
      range_cond([t_many_range_part.a >= 36])
select a from t_many_range_part where a >= 36 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
| 45 |
| 44 |
| 43 |
| 42 |
| 41 |
+----+
EXPLAIN select a from t_many_range_part where a >= 41 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |10      |27          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |10      |27          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |10      |25          |
|3 |    └─LIMIT                  |                          |10      |22          |
|4 |      └─PX PARTITION ITERATOR|                          |10      |22          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|10      |22          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[8-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[41 ; MAX), 
      range_cond([t_many_range_part.a >= 41])
select a from t_many_range_part where a >= 41 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
| 45 |
| 44 |
| 43 |
| 42 |
| 41 |
+----+
EXPLAIN select a from t_many_range_part where a >= 46 order by a desc limit 10;
Query Plan
===================================================================================
|ID|OPERATOR                     |NAME                      |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------------------
|0 |LIMIT                        |                          |5       |22          |
|1 |└─PX COORDINATOR MERGE SORT  |                          |5       |22          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000                  |5       |21          |
|3 |    └─LIMIT                  |                          |5       |20          |
|4 |      └─PX PARTITION ITERATOR|                          |5       |20          |
|5 |        └─TABLE RANGE SCAN   |t_many_range_part(Reverse)|5       |20          |
===================================================================================
Outputs & filters:
-------------------------------------
  0 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  1 - output([t_many_range_part.a]), filter(nil), rowset=16
      sort_keys([t_many_range_part.a, DESC])
  2 - output([t_many_range_part.a]), filter(nil), rowset=16
      dop=1
  3 - output([t_many_range_part.a]), filter(nil), rowset=16
      limit(10), offset(nil)
  4 - output([t_many_range_part.a]), filter(nil), rowset=16
      force partition granule, desc
  5 - output([t_many_range_part.a]), filter(nil), rowset=16
      access([t_many_range_part.a]), partitions(p[9-17])
      limit(10), offset(nil), is_index_back=false, is_global_index=false, 
      range_key([t_many_range_part.a]), range[46 ; MAX), 
      range_cond([t_many_range_part.a >= 46])
select a from t_many_range_part where a >= 46 order by a desc limit 10;
+----+
| a  |
+----+
| 50 |
| 49 |
| 48 |
| 47 |
| 46 |
+----+

drop table if exists t_h3_01_20;
drop table if exists t_h3_05_24;
drop table if exists t_h3_09_28;
drop table if exists t_h5_01_20;
drop table if exists t_h5_05_24;
drop table if exists t_h5_09_28;
drop table if exists t_r4_01_20;
drop table if exists t_r4_05_24;
drop table if exists t_r4_09_28;
drop table if exists t_r5_01_20;
drop table if exists t_r5_05_24;
drop table if exists t_r5_09_28;
drop table if exists t_h3_r4_01_20;
drop table if exists t_h3_r5_09_28;
drop table if exists t_h5_r4_01_20;
drop table if exists t_h5_r5_09_28;

drop table if exists t_refered;
drop table if exists t_h5_int;
drop table if exists t_r4_int;
drop table if exists t_r4_date;
drop table if exists t_r4_datetime;
drop table if exists t_r4_timestamp;
drop table if exists t_h5_r4_int_int;
drop table if exists t_h5_r4_int_int_datetime;

drop table if exists t_r4_h2_date_int;
drop table if exists t_r4_h3_date_int;
drop table if exists t_r4_h3_date_bigint;
drop table if exists tt;

drop table if exists t_many_range_part;

