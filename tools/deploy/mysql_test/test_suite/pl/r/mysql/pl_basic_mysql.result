result_format: 4
drop table if exists a,b,t,t1;
drop procedure if exists p;
drop procedure if exists f;
drop procedure if exists pp;
drop procedure if exists gather_table_stats;

create table a(a1 int,a2 int,a3 int);
create procedure f(inout x int)
begin
set x = x+1;
end//
create procedure p(x int)
begin
declare i int;
set i=i+1;
if(1=1)
then
begin
declare j int;
select 1 from a where a1=i into x;
end;
end if;
while i>1 do
set i=i-1;
end while;
call f(x);
end//
call p(1);
drop table a;
drop procedure f;
drop procedure p;

create table a(a1 int,a2 int,a3 int);
drop procedure pro1;
create procedure pro1()
begin
declare i bigint default 0;
set i=i+1;
if(i=1)
then
select 1 from dual;
end if;
end//
call pro1()//
+---+
| 1 |
+---+
| 1 |
+---+
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
+------+------+------+
drop table a;

create table a(a1 int,a2 int,a3 int);
drop procedure pro1;
create procedure pro1()
begin
declare i bigint default 0;
set i=i+1;
if(i=1)
then
insert into a values(1,1,1);
end if;
end//
call pro1()//
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
drop table a;

create table a(a1 int,a2 int,a3 int);
create procedure p(x bigint)
begin
select x from dual;
end//
call p(1);
+------+
| x    |
+------+
|    1 |
+------+
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
+------+------+------+
drop table a;
drop procedure p;

create table a(a1 int,a2 int,a3 int);
create procedure p(x bigint)
begin
insert into a values(x,1,1);
end//
call p(1);
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
drop table a;
drop procedure p;

create table a(a1 int,a2 int,a3 int);
create procedure p()
begin
declare i bigint default 0;
set i=i+1;
if(i=1)
then
insert into a values(1,1,1);
end if;
end//
call p();
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
drop table a;
drop procedure p;

create table a(a1 int,a2 int,a3 int);
create procedure p(x bigint)
begin
declare i bigint default 0;
set i=i+1;
if(i>x)
then
insert into a values(0,0,0);
else
insert into a values(1,1,1);
end if;
end//
call p(1);
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
drop table a;
drop procedure p;

create table a(a1 int,a2 int,a3 int);
create procedure p(x bigint)
begin
declare i bigint default 1;
if(x<i)
then
insert into a values(0,0,0);
else
insert into a values(1,1,1);
end if;
end//
call p(1);
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
drop table a;
drop procedure p;

create table a(a1 int,a2 int,a3 int);
create procedure p(x bigint, y bigint)
begin
if(x<y)
then
insert into a values(0,0,0);
else
insert into a values(1,1,1);
end if;
end//
call p(1,2);
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
|    0 |    0 |    0 |
+------+------+------+
call p(2,1);
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
|    0 |    0 |    0 |
|    1 |    1 |    1 |
+------+------+------+
drop table a;
drop procedure p;

create table a(a1 int,a2 int,a3 int);
create procedure p(x bigint)
begin
declare i bigint default 1;
if(x>i)
then
insert into a values(x,x,x);
else
insert into a values(i,i,i);
end if;
end//
call p(1);
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
drop table a;
drop procedure p;

create table a(a1 char(5),a2 char(5),a3 char(5));
create procedure p(x char(5), y int)
begin
declare i bigint default 1;
if(y>i)
then
insert into a values(x,x,x);
else
insert into a values('i','i','i');
end if;
end//
call p('x', 1);
select * from a;
+------+------+------+
| a1   | a2   | a3   |
+------+------+------+
| i    | i    | i    |
+------+------+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p()
begin
select *,* from a;
end//
call p;
ERROR 42000: Duplicated star
select * from a;
+------+
| a1   |
+------+
+------+
drop table a;
drop procedure p;

create table a(a1 bigint);
create procedure p(x bigint)
begin
DECLARE cur Cursor FOR select * from a;
open cur;
fetch cur into x;
close cur;
end//
call p(1);
ERROR 02000: No data - zero rows fetched, selected, or processed
select * from a;
+------+
| a1   |
+------+
+------+
drop table a;
drop procedure p;

CREATE PROCEDURE p(a bigint)
BEGIN
label1: LOOP
SET a = a + 1;
IF a < 10 THEN
LEAVE label1;
END IF;
END LOOP label1;
END//
call p(1);
drop procedure p;

create table a(a1 bigint);
CREATE PROCEDURE p(a bigint)
BEGIN
label1: LOOP
SET a = a + 1;
IF a < 10 THEN
insert into a values(a);
else
LEAVE label1;
END IF;
END LOOP label1;
END//
call p(1);
select * from a;
+------+
| a1   |
+------+
|    2 |
|    3 |
|    4 |
|    5 |
|    6 |
|    7 |
|    8 |
|    9 |
+------+
drop table a;
drop procedure p;

create table a(a1 bigint);
CREATE PROCEDURE p(a bigint)
BEGIN
label1: LOOP
SET a = a + 1;
IF a < 10 THEN
iterate label1;
elseif a< 20 then
insert into a values(a);
else
LEAVE label1;
END IF;
END LOOP label1;
END//
call p(1);
select * from a;
+------+
| a1   |
+------+
|   10 |
|   11 |
|   12 |
|   13 |
|   14 |
|   15 |
|   16 |
|   17 |
|   18 |
|   19 |
+------+
drop table a;
drop procedure p;

CREATE PROCEDURE p(a bigint, sum bigint)
BEGIN
label1: LOOP
begin
declare b bigint;
set b=a+1;
IF a+b > sum THEN
LEAVE label1;
else
set a=b;
END IF;
end;
END LOOP label1;
END//
#### TODO: 执行时间过长导致farm失败, 暂时改小循环次数
## call p(1,1000000);
call p(1,10000);
drop procedure p;

CREATE PROCEDURE p(a bigint)
BEGIN
label1: Repeat
begin
declare b bigint;
SET b = a + 1;
end;
UNTIL a<10
END repeat label1;
END//
call p(1);
drop procedure p;

CREATE PROCEDURE p(a bigint)
BEGIN
label1: Repeat
begin
declare b int;
SET b = a + 1;
end;
UNTIL a<10
END repeat label1;
END//
call p(1);
drop procedure p;

CREATE PROCEDURE p(a bigint)
BEGIN
label1: Repeat
begin
declare b bigint;
SET b = a + 1;
end;
UNTIL b<10
END repeat label1;
END//
ERROR 42000: Undeclared variable: b

set @a=1;
drop procedure pro1;
create procedure pro1()
begin
if(@a=1)
then
select @a;
end if;
end//
call pro1()//
+------+
| @a   |
+------+
|    1 |
+------+

create table a(a1 int);
set @a=1;
drop procedure pro1;
create procedure pro1()
begin
if(@a=1)
then
insert into a values(1);
else
insert into a values(@a);
end if;
end//
call pro1()//
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
drop table a;

drop procedure pro1;
create procedure pro1()
begin
set @a=1;
end//
call pro1()//

drop procedure pro1;
create procedure pro1()
begin
set @b='b';
end//
call pro1()//

drop procedure pro1;
create procedure pro1()
begin
set @@session.a=1;
end//
ERROR 42000: Undeclared variable: a
call pro1()//
ERROR 42000: procedure test.pro1 does not exist

set @@session.ob_trx_timeout=100000000;
select @@session.ob_trx_timeout;
+--------------------------+
| @@session.ob_trx_timeout |
+--------------------------+
|                100000000 |
+--------------------------+
drop procedure pro1;
ERROR 42000: PROCEDURE test.pro1 does not exist
create procedure pro1()
begin
set @@session.ob_trx_timeout=100000001;
end//
call pro1()//
select @@session.ob_trx_timeout;
+--------------------------+
| @@session.ob_trx_timeout |
+--------------------------+
|                100000000 |
+--------------------------+
set @@session.ob_trx_timeout=100000000;

drop procedure pro1;
create procedure pro1()
begin
set @@global.a=1;
end//
ERROR 42000: Undeclared variable: a
call pro1()//
ERROR 42000: procedure test.pro1 does not exist

set @@global.ob_trx_timeout=100000000;
select @@global.ob_trx_timeout;
+-------------------------+
| @@global.ob_trx_timeout |
+-------------------------+
|               100000000 |
+-------------------------+
drop procedure pro1;
ERROR 42000: PROCEDURE test.pro1 does not exist
create procedure pro1()
begin
set @@global.ob_trx_timeout=100000001;
end//
call pro1()//
select @@global.ob_trx_timeout;
+-------------------------+
| @@global.ob_trx_timeout |
+-------------------------+
|               100000001 |
+-------------------------+
set @@global.ob_trx_timeout=100000000;

create table a(a1 int);
drop procedure pro1;
create procedure pro1()
begin
set @a=1+1;
if(@a=2) then
insert into a values(@a);
else
insert into a values(1);
end if;
end//
call pro1()//
select * from a;
+------+
| a1   |
+------+
|    2 |
+------+
drop table a;

create table a(a1 varchar(100));
create procedure p(x varchar(100))
begin
select * from a where a1=x;
end//
call p('fff');
+------+
| a1   |
+------+
+------+
drop procedure p;
drop table a;

create table a(a1 varchar(100));
create procedure p(x varchar(100))
begin
declare a1 varchar(100) default 'fff';
select * from a where a1=x;
end//
call p();
ERROR 42000: Incorrect number of arguments
call p('a');
+------+
| a1   |
+------+
+------+
drop procedure p;
drop table a;

create table a(a1 varchar(100));
create procedure p(x varchar(100))
begin
insert into a values(x);
end//
call p('fff');
select * from a;
+------+
| a1   |
+------+
| fff  |
+------+
drop procedure p;
drop table a;

create table a(a1 varchar(100));
create procedure p(inout x varchar(10))
begin
set x='bbb';
end//
create procedure pp()
begin
declare x varchar(10) default 'aaa';
call p(x);
insert into a values(x);
end//
call pp();
select * from a;
+------+
| a1   |
+------+
| bbb  |
+------+
drop table a;
drop procedure p;
drop procedure pp;

create table a(a1 varchar(100));
create table b(b1 int);
create procedure p(inout x varchar(10))
begin
insert into a values(x);
insert into b values(x);
end//
create procedure pp(inout x int)
begin
insert into a values(x);
insert into b values(x);
end//
set @px = 1;
call p(@px);
set @py = 1;
call pp(@py);
select * from a;
+------+
| a1   |
+------+
| 1    |
| 1    |
+------+
select * from b;
+------+
| b1   |
+------+
|    1 |
|    1 |
+------+
drop table a;
drop table b;
drop procedure p;

create table a(a1 varchar(100));
create procedure p(x varchar(4))
begin
insert into a values(x);
end//
call p('gggggggg');
ERROR 22001: Data too long for column
call p('gggg');
select * from a;
+------+
| a1   |
+------+
| gggg |
+------+
drop table a;
drop procedure p;
drop procedure pp;

create table a(a1 varchar(100));
insert into a values('a');
create table b(b1 varchar(100));
drop procedure pro1;
create procedure pro1()
BEGIN
DECLARE x varchar(100);
DECLARE c CURSOR FOR SELECT a1 FROM a;
OPEN c;
fetch c into x;
CLOSE c;
insert into b values(x);
END//
call pro1()//
select * from b;
+------+
| b1   |
+------+
| a    |
+------+
drop table a;
drop table b;

create table a(a1 varchar(10));
create procedure p(x varchar(100))
begin
case x
when 1 then insert into a values('1');
else insert into a values('0');
end case;
end//
call p(1);
select * from a;
+------+
| a1   |
+------+
| 1    |
+------+
call p(2);
select * from a;
+------+
| a1   |
+------+
| 0    |
| 1    |
+------+
call p(3);
select * from a;
+------+
| a1   |
+------+
| 0    |
| 0    |
| 1    |
+------+
drop table a;
drop procedure p;

create table a(a1 varchar(10));
create procedure p(x varchar(100))
begin
case x
when 1 then insert into a values('1');
when 2 then insert into a values('2');
else insert into a values('0');
end case;
end//
call p(1);
select * from a;
+------+
| a1   |
+------+
| 1    |
+------+
call p(2);
select * from a;
+------+
| a1   |
+------+
| 1    |
| 2    |
+------+
call p(3);
select * from a;
+------+
| a1   |
+------+
| 0    |
| 1    |
| 2    |
+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p(x int)
begin
case x
when 1 then insert into a values(1);
when 2 then insert into a values(2);
else insert into a values(0);
end case;
end//
call p(1);
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
call p(2);
select * from a;
+------+
| a1   |
+------+
|    1 |
|    2 |
+------+
call p(3);
select * from a;
+------+
| a1   |
+------+
|    0 |
|    1 |
|    2 |
+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p(x int)
begin
case x
when 1 then insert into a values(1);
when 2 then insert into a values(2);
else insert into a values(0);
if x > 1 then insert into a values(100);
else insert into a values(-100);
end if;
end case;
end//
call p(1);
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
call p(2);
select * from a;
+------+
| a1   |
+------+
|    1 |
|    2 |
+------+
call p(3);
select * from a;
+------+
| a1   |
+------+
|    0 |
|    1 |
|    2 |
|  100 |
+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p(x int)
begin
case x
when 1 then insert into a values(1);
when 2 then insert into a values(2);
else insert into a values(0);
end case;
if x > 1 then insert into a values(100);
else insert into a values(-100);
end if;
end//
call p(1);
select * from a;
+------+
| a1   |
+------+
|    1 |
| -100 |
+------+
call p(2);
select * from a;
+------+
| a1   |
+------+
|    1 |
|    2 |
|  100 |
| -100 |
+------+
call p(3);
select * from a;
+------+
| a1   |
+------+
|    0 |
|    1 |
|    2 |
|  100 |
|  100 |
| -100 |
+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p(x int)
begin
case
when x=1 then insert into a values(1);
when x=2 then insert into a values(2);
else insert into a values(0);
end case;
end//
call p(1);
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
call p(2);
select * from a;
+------+
| a1   |
+------+
|    1 |
|    2 |
+------+
call p(3);
select * from a;
+------+
| a1   |
+------+
|    0 |
|    1 |
|    2 |
+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p(x int)
begin
case
when x=1 then insert into a values(1);
when x=2 then insert into a values(2);
end case;
end//
call p(1);
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
call p(2);
select * from a;
+------+
| a1   |
+------+
|    1 |
|    2 |
+------+
call p(3);
ERROR 20000: Case not found for CASE statement
select * from a;
+------+
| a1   |
+------+
|    1 |
|    2 |
+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p(x int)
begin
case x
when 1 then insert into a values(1);
when 2 then insert into a values(2);
end case;
end//
call p(1);
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
call p(2);
select * from a;
+------+
| a1   |
+------+
|    1 |
|    2 |
+------+
call p(3);
ERROR 20000: Case not found for CASE statement
select * from a;
+------+
| a1   |
+------+
|    1 |
|    2 |
+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p(x int)
begin
declare exit handler for 1339
insert into a values(-1);
case x
when 1 then insert into a values(1);
end case;
end//
call p(3);
select * from a;
+------+
| a1   |
+------+
|   -1 |
+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p(x int)
begin
case x
when 1 then insert into a values(1);
end case;
end//
call p(1);
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
call p(3);
ERROR 20000: Case not found for CASE statement
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
drop table a;
drop procedure p;

create table b(b1 char(6));
create procedure p()
begin
declare x char(5) default 'a';
declare y char(6) default concat(x, 1);
insert into b values(y);
end//
call p();
select * from b;
+------+
| b1   |
+------+
| a1   |
+------+
drop table b;
drop procedure p;

set @@sql_mode=PAD_CHAR_TO_FULL_LENGTH;
create table b(b1 char(6));
create procedure p()
begin
declare x char(5) default 'a';
declare y char(6) default concat(x, 1);
insert into b values(y);
end//
call p();
select * from b;
+--------+
| b1     |
+--------+
| a    1 |
+--------+
drop table b;
drop procedure p;
set @@sql_mode=default;

set @@sql_mode=PAD_CHAR_TO_FULL_LENGTH;
create table b(b1 char(6));
create procedure p()
begin
declare x char(5) default 'a';
declare y char(6) default concat(x, 1);
insert into b values(y);
end//
set @@sql_mode=default;
call p();
select * from b;
+--------+
| b1     |
+--------+
| a    1 |
+--------+
drop table b;
drop procedure p;

create table a(a1 char(6));
create procedure p(a int)
begin
insert into a values(a);
end//
select route_sql from oceanbase.__all_routine where routine_name = 'p' and database_id = (select database_id from oceanbase.__all_database where database_name = database());
+--------------------------+
| route_sql                |
+--------------------------+
| insert into a values(:0) |
+--------------------------+
drop procedure p;
drop table a;

create table b(b1 char(6));
create procedure p(a int)
begin
declare x char(5) default 'a';
declare y char(6) default concat(x, 1);
insert into b values(y);
end//
select route_sql from oceanbase.__all_routine where routine_name = 'p' and database_id = (select database_id from oceanbase.__all_database where database_name = database());
+--------------------------+
| route_sql                |
+--------------------------+
| insert into b values(:2) |
+--------------------------+
drop procedure p;
drop table b;

set @@sql_mode=PAD_CHAR_TO_FULL_LENGTH;
create table b(b1 char(6));
create table a(a1 char(5));
insert into a values('a');
create procedure p()
begin
declare x char(5);
declare y char(6);
select a1 from a into x;
set y = concat(x, 1);
insert into b values(y);
end//
call p();
select * from b;
+--------+
| b1     |
+--------+
| a    1 |
+--------+
drop table a;
drop table b;
drop procedure p;
set @@sql_mode=default;

create table b(b1 char(6));
create table a(a1 char(5));
insert into a values('a');
create procedure p()
begin
declare x char(5);
select a1 from a into x;
insert into b values(x);
end//
call p();
select * from b;
+------+
| b1   |
+------+
| a    |
+------+
drop table b;
drop table a;
drop procedure p;

set @xxx = 'asd';
create table b(b1 char(6));
create table a(a1 char(5));
insert into a values('a');
insert into b values(@xxx);
create procedure p()
begin
select a1 from a into @xxx;
insert into b values(@xxx);
end//
call p();
select * from b;
+------+
| b1   |
+------+
| a    |
| asd  |
+------+
drop table b;
drop table a;
drop procedure p;

set @xxx = 'asd';
create table b(b1 char(6), b2 char(6));
create table a(a1 char(5), a2 char(5));
insert into a values('a', 'a');
insert into b values(@xxx, 'asd');
create procedure p()
begin
select a1 from a into @xxx;
insert into b values(@xxx,@xxx);
end//
call p();
select * from b;
+------+------+
| b1   | b2   |
+------+------+
| a    | a    |
| asd  | asd  |
+------+------+
drop table b;
drop table a;
drop procedure p;

set @xxx = 'asd';
create table b(b1 char(6), b2 char(6));
create table a(a1 char(5), a2 char(5));
insert into a values('a', 'a');
insert into b values(@xxx, 'asd');
create procedure p()
begin
declare x char(6);
select a1,a2 from a into @xxx, x;
insert into b values(@xxx, x);
end//
call p();
select * from b;
+------+------+
| b1   | b2   |
+------+------+
| a    | a    |
| asd  | asd  |
+------+------+
drop table b;
drop table a;
drop procedure p;

set @xxx = 'asd';
create table b(b1 char(6), b2 char(6));
create table a(a1 char(5), a2 char(5));
insert into a values('a', 'a');
insert into b values(@xxx, 'asd');
create procedure p()
begin
declare x char(6);
select a1,a2 from a into x, x;
insert into b values(@xxx, x);
end//
call p();
select * from b;
+------+------+
| b1   | b2   |
+------+------+
| asd  | a    |
| asd  | asd  |
+------+------+
drop table b;
drop table a;
drop procedure p;

set @xxx = 'asd';
create table b(b1 char(6), b2 char(6));
create table a(a1 char(5), a2 char(5));
insert into a values('a', 'a');
insert into b values(@xxx, 'asd');
create procedure p()
begin
declare x char(6);
declare y char(6);
select a1,a2 from a into @xxx, x;
set y = @xxx;
insert into b values(y, x);
end//
call p();
select * from b;
+------+------+
| b1   | b2   |
+------+------+
| a    | a    |
| asd  | asd  |
+------+------+
drop table b;
drop table a;
drop procedure p;

set @xxx = 'asd';
create table b(b1 char(6), b2 char(6));
insert into b values(@xxx, 'asd');
create procedure p()
begin
declare x char(6);
set x='a';
insert into b values(@xxx, x);
end//
call p();
select * from b;
+------+------+
| b1   | b2   |
+------+------+
| asd  | a    |
| asd  | asd  |
+------+------+
drop table b;
drop procedure p;

create table a(a1 int, a2 varchar(10));
drop procedure pro1;
create procedure pro1()
begin
declare x varchar(10) default 'x';
declare y varchar(10) default 'y';
declare xx int default 1;
declare yy int default 2;
set y = x;
set yy = xx;
set x = 'a';
set xx = 9;
insert into a values(yy, y);
end//
call pro1()//
select * from a;
+------+------+
| a1   | a2   |
+------+------+
|    1 | x    |
+------+------+
drop table a;

create procedure p()
begin
declare if int default 0;
end//
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your OceanBase version for the right syntax to use near 'if' at line 3

create procedure p()
begin
declare if1 int default 0;
end//
drop procedure p;

create procedure p()
begin
declare count int default 0;
end//
drop procedure p;

create procedure p()
begin
declare count1 int default 0;
end//
drop procedure p;

set autocommit=0;
create table a(a1 int);
drop procedure pro1;
create procedure pro1()
BEGIN
insert into a values(1);
commit;
END//
call pro1()//
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
drop procedure pro1;
create procedure pro1()
BEGIN
insert into a values(2);
rollback;
END//
call pro1()//
select * from a;
+------+
| a1   |
+------+
|    1 |
+------+
set autocommit=1;
drop table a;

create table fib(id int, value bigint);
create procedure p(x int, out y bigint)
begin
if x = 0 then set y = 0;
elseif x = 1 then set y = 1;
else
begin
declare a, b bigint default 0;
call p(x-1, a);
call p(x-2, b);
set y = a+b;
end;
end if;
end//
create procedure pp(x int)
begin
declare i int default 0;
declare result bigint default 0;
while i < x do
call p(i, result);
insert into fib values(i, result);
set i = i + 1;
end while;
end//
set @@max_sp_recursion_depth = 10;
call pp(10);
set @@max_sp_recursion_depth = 0;
select * from fib;
+------+-------+
| id   | value |
+------+-------+
|    0 |     0 |
|    1 |     1 |
|    2 |     1 |
|    3 |     2 |
|    4 |     3 |
|    5 |     5 |
|    6 |     8 |
|    7 |    13 |
|    8 |    21 |
|    9 |    34 |
+------+-------+
drop table fib;
drop procedure p;
drop procedure pp;

create procedure p()
begin
call p();
end//
call p();
ERROR HY000: Recursive limit 0 (as set by the max_sp_recursion_depth variable) was exceeded for routine
drop procedure p;

create table a(a1 bigint, a2 timestamp);
create procedure p()
begin
declare x bigint default 1;
update a set a2=CURRENT_TIMESTAMP where a1=x;
end //
call p();
drop table a;
drop procedure p;

create table a(a1 bigint, a2 timestamp);
create procedure p()
begin
declare x bigint default 1;
declare y timestamp;
set y = CURRENT_TIMESTAMP;
update a set a2=y where a1=x;
end //
call p();
drop table a;
drop procedure p;

create table a(a1 timestamp);
create table b(b1 timestamp);
insert into a values('2018-01-02 10:10:32.000000');
create procedure p()
begin
declare x timestamp;
select a1 from a into x;
insert into b values(x);
end //
call p;
select * from a;
+---------------------+
| a1                  |
+---------------------+
| 2018-01-02 10:10:32 |
+---------------------+
select * from b;
+---------------------+
| b1                  |
+---------------------+
| 2018-01-02 10:10:32 |
+---------------------+
drop table a;
drop table b;
drop procedure p;

create table a(a1 decimal(12,2),a2 timestamp);
create table b(b1 decimal(12,2),b2 timestamp);
insert into a values(1.1,'2018-01-02 10:10:32.000000');
create procedure p()
begin
declare x decimal(12,2);
declare y timestamp;
select a1,a2 from a into x,y;
insert into b values(x,y);
end //
call p;
select * from a;
+------+---------------------+
| a1   | a2                  |
+------+---------------------+
| 1.10 | 2018-01-02 10:10:32 |
+------+---------------------+
select * from b;
+------+---------------------+
| b1   | b2                  |
+------+---------------------+
| 1.10 | 2018-01-02 10:10:32 |
+------+---------------------+
drop table a;
drop table b;
drop procedure p;

create table a(a1 decimal(12,2),a2 timestamp);
create table b(b1 decimal(12,2),b2 timestamp);
insert into a values(1.1,'2018-01-02 10:10:32.000000');
create procedure p()
begin
declare x decimal(12,2);
declare y timestamp;
declare c1 cursor for select a1,a2 from a;
open c1;
fetch c1 into x,y;
close c1;
insert into b values(x,y);
end //
call p;
select * from a;
+------+---------------------+
| a1   | a2                  |
+------+---------------------+
| 1.10 | 2018-01-02 10:10:32 |
+------+---------------------+
select * from b;
+------+---------------------+
| b1   | b2                  |
+------+---------------------+
| 1.10 | 2018-01-02 10:10:32 |
+------+---------------------+
drop table a;
drop table b;
drop procedure p;

create table if not exists bmsql_customer (
  c_w_id         INTEGER        NOT NULL,
  c_d_id         INTEGER        NOT NULL,
  c_id           INTEGER        NOT NULL,
  c_data         VARCHAR(500),
  PRIMARY KEY (c_w_id, c_d_id, c_id)
);
insert into bmsql_customer values(1,1,1,'a');
create procedure p(IN in_w_id int,
                   IN in_d_id int,
                   IN in_c_id int,
                   IN in_c_d_id int,
                   IN in_c_w_id int,
                   IN in_h_amount DECIMAL(6,2)
                  )
begin
   UPDATE bmsql_customer
   SET c_data = SUBSTR(CONCAT('C_ID=', CAST(in_c_id AS CHAR),
                              ' C_D_ID=', CAST(in_c_d_id AS CHAR),
                              ' C_W_ID=', CAST(in_c_w_id AS CHAR),
                              ' D_ID=', CAST(in_d_id AS CHAR),
                              ' W_ID=', CAST(in_w_id AS CHAR),
                              ' H_AMOUNT=', ROUND(in_h_amount,2)), 1, 500)
   WHERE c_w_id = in_c_w_id AND c_d_id = in_c_d_id AND c_id = in_c_id;
end//
call p(1,1,1,1,1,1.1);
drop table bmsql_customer;
drop procedure p;

create table a(a1 varchar(20));
create procedure p(x int)
begin
update a set a1=cast(x as char) where a1=1;
end//
call p(1);
drop table a;
drop procedure p;

drop procedure pro1;
create procedure pro1()
begin
declare x int default 0;
set x=rand();
end//
call pro1()//
drop procedure pro1;

create table a(a1 int);
create procedure p(
arg1 int,
arg2 int,
arg3 int,
arg4 int,
arg5 int,
arg6 int,
arg7 int,
arg8 int,
arg9 int,
arg10 int
)
begin
declare x int default 1;
set x = arg10;
insert into a values(x);
end //
call p(1,2,3,4,5,6,7,8,9,10);
select * from a;
+------+
| a1   |
+------+
|   10 |
+------+
drop table a;
drop procedure p;

create table a(a1 int);
create procedure p1(
INOUT arg1 int,
INOUT arg2 int,
INOUT arg3 int,
INOUT arg4 int,
INOUT arg5 int,
INOUT arg6 int,
INOUT arg7 int,
INOUT arg8 int,
INOUT arg9 int,
INOUT arg10 int)
begin
set arg10 = 99;
end //
create procedure p()
begin
declare arg1 int default 1;
declare arg2 int default 2;
declare arg3 int default 3;
declare arg4 int default 4;
declare arg5 int default 5;
declare arg6 int default 6;
declare arg7 int default 7;
declare arg8 int default 8;
declare arg9 int default 9;
declare arg10 int default 10;
call p1(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
insert into a values(arg10);
end //
call p();
select * from a;
+------+
| a1   |
+------+
|   99 |
+------+
drop table a;
drop procedure p1;
drop procedure p;

create table a(a1 int);
create procedure p1(
INOUT arg1 int,
INOUT arg2 int,
INOUT arg3 int,
INOUT arg4 int,
INOUT arg5 int,
INOUT arg6 int,
INOUT arg7 int,
INOUT arg8 int,
INOUT arg9 int,
INOUT arg10 int,
INOUT arg11 int,
INOUT arg12 int,
INOUT arg13 int,
INOUT arg14 int,
INOUT arg15 int,
INOUT arg16 int,
INOUT arg17 int,
INOUT arg18 int,
INOUT arg19 int,
INOUT arg20 int)
begin
set arg20 = 99;
end //
create procedure p()
begin
declare arg1 int default 1;
declare arg2 int default 2;
declare arg3 int default 3;
declare arg4 int default 4;
declare arg5 int default 5;
declare arg6 int default 6;
declare arg7 int default 7;
declare arg8 int default 8;
declare arg9 int default 9;
declare arg10 int default 10;
declare arg11 int default 11;
declare arg12 int default 12;
declare arg13 int default 13;
declare arg14 int default 14;
declare arg15 int default 15;
declare arg16 int default 16;
declare arg17 int default 17;
declare arg18 int default 18;
declare arg19 int default 19;
declare arg20 int default 20;
call p1(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20);
insert into a values(arg20);
end //
call p();
select * from a;
+------+
| a1   |
+------+
|   99 |
+------+
drop table a;
drop procedure p1;
drop procedure p;

create table a(a1 timestamp);
create procedure p()
begin
declare x int default 1;
while x <=10 do
insert into a values(CURRENT_TIMESTAMP);
set x = x+1;
end while;
end //
call p;
select count(*) from a;
+----------+
| count(*) |
+----------+
|       10 |
+----------+
drop table a;
drop procedure p;

create table a(a1 timestamp);
create procedure p()
begin
declare x int default 1;
declare y timestamp;
while x <=10 do
set y = CURRENT_TIMESTAMP;
insert into a values(y);
set x = x+1;
end while;
end //
call p;
select count(*) from a;
+----------+
| count(*) |
+----------+
|       10 |
+----------+
drop table a;
drop procedure p;

create table a(a1 decimal(6,2));
insert into a values(1.11);
create table b(b1 decimal(6,2));
create procedure p()
begin
declare x decimal(6,2);
declare c cursor for select a1 from a;
open c;
fetch c into x;
close c;
insert into b values(x);
end //
call p;
select * from a;
+------+
| a1   |
+------+
| 1.11 |
+------+
select * from b;
+------+
| b1   |
+------+
| 1.11 |
+------+
drop table a;
drop table b;
drop procedure p;

create table a(a1 decimal(6,2));
insert into a values(1.11);
create table b(b1 int);
create procedure p()
begin
declare x int;
declare c cursor for select a1 from a;
open c;
fetch c into x;
close c;
insert into b values(x);
end //
call p;
select * from a;
+------+
| a1   |
+------+
| 1.11 |
+------+
select * from b;
+------+
| b1   |
+------+
|    1 |
+------+
drop table a;
drop table b;
drop procedure p;

create table a(a1 decimal(6,2));
create procedure p(x int)
begin
insert into a values(x);
select * from a where a1=x;
end //
select route_sql from oceanbase.__all_routine where routine_name = 'p' and database_id = (select database_id from oceanbase.__all_database where database_name = database());
+--------------------------+
| route_sql                |
+--------------------------+
| insert into a values(:0) |
+--------------------------+
drop table a;
drop procedure p;

create procedure p()
begin
insert into table_not_exist values(1);
end //
call p();
ERROR 42S02: Table 'test.table_not_exist' doesn't exist
drop procedure p;

create procedure p()
label1:
begin
end label1//
call p();
drop procedure p;

create procedure p()
begin
end//
call p();
drop procedure p;

create procedure p()
begin
declare i int default 3;
label1: begin
if i > 0 then
set i = i-1;
else leave label1;
end if;
end;
end//
call p();
drop procedure p;

create procedure p()
return 42;//
ERROR 42000: RETURN is only allowed in a FUNCTION

set @a=0;
select @a;
+------+
| @a   |
+------+
|    0 |
+------+
create procedure p(out x int)
begin
set x=1;
end//
call p(@a);
select @a;
+------+
| @a   |
+------+
|    1 |
+------+
drop procedure p;

create procedure gather_table_stats(tenant_name varchar(128), db_name varchar(128), table_name varchar(128))
begin
end//
drop procedure gather_table_stats;

create procedure gather_table_stats(tenant_name int, db_name int, table_name int)
begin
end//
drop procedure gather_table_stats;

create procedure gather_table_stats(tenant_name int, db_name int, t_name int)
begin
end//
call gather_table_stats(1,1,1);
drop procedure gather_table_stats;

drop function f;
create function f(x int) returns int
begin
  if x>1 then
    return x;
  else 
    signal SQLSTATE '01000';
  end if;
end//
select f(2);
+------+
| f(2) |
+------+
|    2 |
+------+
select f(1);
ERROR 2F005: FUNCTION ended without RETURN
drop function f;

create function f(x int) returns int
begin
  if x>1 then
    return x;
  else
    signal SQLSTATE '02000';
  end if;
end//
select f(2);
+------+
| f(2) |
+------+
|    2 |
+------+
select f(1);
ERROR 02000: Unhandled user-defined not found condition
drop function f;

create function f(x int) returns int
begin
  if x>1 then
    return NULL;
  else
    signal SQLSTATE '02000';
  end if;
end//
select f(2);
+------+
| f(2) |
+------+
| NULL |
+------+
select f(1);
ERROR 02000: Unhandled user-defined not found condition
drop function f;

### need has return in mysql function
### 
DROP FUNCTION IF EXISTS `fun6`//

CREATE FUNCTION fun6 ( p1 INT) RETURNS VARCHAR(20)
BEGIN
  SET p1 = p1 + 3;
  SET p1 = p1 * 2;
  SET @num = p1 * p1;
END//
ERROR 42000: No Return found in FUNCTION 'fun6'

SELECT fun6(5)//
ERROR 42000: FUNCTION fun6 does not exist
SELECT @num//
+------+
| @num |
+------+
| NULL |
+------+

CREATE FUNCTION fun6 ( p1 INT) RETURNS VARCHAR(20)
BEGIN
  SET @num = p1 * p1;
END//
ERROR 42000: No Return found in FUNCTION 'fun6'

SELECT fun6(5)//
ERROR 42000: FUNCTION fun6 does not exist
SELECT @num//
+------+
| @num |
+------+
| NULL |
+------+

DROP FUNCTION IF EXISTS `fun6`//

### label dup 
### 
DROP TABLE IF EXISTS result1//
CREATE TABLE result1(
id INT,
res1 VARCHAR(50),
res2 VARCHAR(50)
)//
DROP PROCEDURE IF EXISTS `pro_1`//

CREATE PROCEDURE pro_1()
BEGIN
  label1:BEGIN
    INSERT INTO result1 VALUES(1,'结果表：','标签label1');
    label2:BEGIN
      INSERT INTO result1 VALUES(2,'结果表：','标签label2');
    END label2;
  END label1;
END//

CALL pro_1()//

CREATE PROCEDURE pro_2()
BEGIN
  label1:BEGIN
    INSERT INTO result1 VALUES(3,'结果表：','标签label1');
  END label1;
  label1:BEGIN
    INSERT INTO result1 VALUES(4,'结果表：','标签label1');
  END label1;
END//

CALL pro_2()//

CREATE PROCEDURE pro_3()
BEGIN
  label1:BEGIN
    INSERT INTO result1 VALUES(5,'结果表：','标签label1');
    label1:BEGIN
      INSERT INTO result1 VALUES(6,'结果表：','标签label1');
    END label1;
  END label1;
END//
ERROR 42000: Redefining label '%.*s'

CALL pro_3()//
ERROR 42000: procedure test.pro_3 does not exist

SELECT * FROM result1//
+------+--------------+--------------+
| id   | res1         | res2         |
+------+--------------+--------------+
|    1 | 结果表：     | 标签label1   |
|    2 | 结果表：     | 标签label2   |
|    3 | 结果表：     | 标签label1   |
|    4 | 结果表：     | 标签label1   |
+------+--------------+--------------+
DROP TABLE IF EXISTS result1//
DROP PROCEDURE IF EXISTS `pro_1`//
DROP PROCEDURE IF EXISTS `pro_2`//
DROP PROCEDURE IF EXISTS `pro_3`//

###   ### varchar 
###   ### 
###   DROP TABLE IF EXISTS t2//
###   --error 1074
###   CREATE TABLE t2 ( 
###     id INT, 
###     res1 VARCHAR(128), 
###     d1 VARCHAR(16384) 
###   )// 
###   DROP TABLE IF EXISTS t3// 
###   --error 1074
###   CREATE TABLE t3 ( 
###     id INT, 
###     res1 VARCHAR(128), 
###     d1 VARCHAR(262145) 
###   )//
###   DROP FUNCTION IF EXISTS fun_l//
###   --error 1074
###   CREATE FUNCTION fun_l() RETURNS VARCHAR(262144)
###   BEGIN
###     DECLARE d1 VARCHAR(262144123456);  
###     SET d1='123456789012345678901234567890';
###     RETURN '定义长度262144123456的VARCHAR(262144123456)类型的变量';
###   END// 
###   --error 1305  
###   SELECT fun_l()// 
### char 
### 
DROP TABLE IF EXISTS t1//
DROP TABLE IF EXISTS t2//
CREATE TABLE t1 (
   id INT,
   res1 VARCHAR(128),
   d1 CHAR(255)
 )//
### --error 1074
### TODO: 
### CREATE TABLE t2 (
###   id INT,
###   res1 VARCHAR(128),
###   d1 CHAR(256)
### )//
DROP TABLE IF EXISTS t3//
CREATE TABLE t3 (
   id INT,
   res1 VARCHAR(128),
   d1 CHAR(257)
 )//
ERROR 42000: Column length too big for column 'd1' (max = 256)
DROP PROCEDURE IF EXISTS `pro_1`//
CREATE PROCEDURE pro_1()
 BEGIN
   DECLARE d1 CHAR(257);
   SET d1='CHAR[(M)] M表示以字符为单位的列长度, M范围是 0~255';
   INSERT INTO t1 VALUES(1,'变量形式插入CHAR(257)类型数据',d1);
 END//
ERROR 42000: Column length too big for column '(null)' (max = 256)
CALL pro_1()//
ERROR 42000: procedure test.pro_1 does not exist
SELECT * FROM t1//
+------+------+------+
| id   | res1 | d1   |
+------+------+------+
+------+------+------+

### varbinary
### 
DROP TABLE IF EXISTS t1//
CREATE TABLE t1 (
  d1 VARBINARY(65536)
)//
DROP TABLE IF EXISTS t2//
CREATE TABLE t2 (
  d1 VARBINARY(1048577)
)//
ERROR 42000: Column length too big for column 'd1' (max = 1048576)

DROP FUNCTION IF EXISTS `fun_l`//
CREATE FUNCTION fun_l() RETURNS VARBINARY(65535)
BEGIN 
  DECLARE d1 VARBINARY(65536);
  SET d1='123456789012345678901234567890';
  RETURN '定义长度65536的VARCHAR类型的变量'; 
END//
ERROR 42000: Column length too big for column '(null)' (max = 65535)

SELECT fun_l()//
ERROR 42000: FUNCTION fun_l does not exist

### number
### 
DROP FUNCTION IF EXISTS `fun_l`//
CREATE FUNCTION fun_l() RETURNS DEC(65,30)
BEGIN 
  DECLARE a DEC(66,30);  
  SET a=123450.1415;
  RETURN a; 
END//
ERROR 42000: Too big precision 66 specified for column '(null)'. Maximum is 65.
SELECT fun_l()//
ERROR 42000: FUNCTION fun_l does not exist
DROP FUNCTION IF EXISTS `fun_2`//
CREATE FUNCTION fun_2() RETURNS DEC(65,30)
BEGIN 
  DECLARE a DEC(65,31);  
  SET a=50.1;
  RETURN a; 
END//
ERROR 42000: Too big scale 31 specified for column '(null)'. Maximum is 30.
SELECT fun_2()//
ERROR 42000: FUNCTION fun_2 does not exist

### datetime
### 
DROP TABLE IF EXISTS t2//
CREATE TABLE t2 (
  id INT,
  res1 VARCHAR(128),
  d1 DATETIME(7)
)//
ERROR 42000: Too big precision 7 specified for column 'd1'. Maximum is 6.
DROP FUNCTION IF EXISTS `fun_l`//
CREATE FUNCTION fun_l() RETURNS DATETIME(6)
BEGIN
  DECLARE d2 DATETIME(7) DEFAULT '2021-07-02 23:59:59.999999';
  RETURN d2;
END//
ERROR 42000: Too big precision 7 specified for column '(null)'. Maximum is 6.
SELECT fun_l()//
ERROR 42000: FUNCTION fun_l does not exist

### datetime max value insert fail
### 
DROP TABLE IF EXISTS t2//
CREATE TABLE t2 (
  id INT,
  res1 VARCHAR(128),
  d1 DATETIME,
  d2 DATETIME(0),
  d3 DATETIME(6)
)//
INSERT INTO t2 VALUES(1,'插入DATETIME类型数据','1000-01-01 00:00:00.123','2000-01-01 00:00:00.123','9999-12-31 23:59:59.999999')//
DROP PROCEDURE IF EXISTS `pro_1`//
CREATE PROCEDURE pro_1()
BEGIN 
  DECLARE d1 DATETIME DEFAULT '1000-01-01 00:00:00.000000';
  DECLARE d2 DATETIME(0) DEFAULT '2021-07-02 23:59:59.999999';
  DECLARE d3 DATETIME(6) DEFAULT '9999-12-31 23:59:59.999999';
  INSERT INTO t2 VALUES(2,'变量形式插入DATETIME类型数据',d1,d2,d3);
  INSERT INTO t2 VALUES(3,'直接插入DATETIME类型数据','3000-01-01 00:00:00.123','4000-01-01 00:00:00.123','9999-12-31 23:59:59.999999');
END//
CALL pro_1()//
SELECT * FROM t2//
+------+----------------------------------------+---------------------+---------------------+----------------------------+
| id   | res1                                   | d1                  | d2                  | d3                         |
+------+----------------------------------------+---------------------+---------------------+----------------------------+
|    1 | 插入DATETIME类型数据                   | 1000-01-01 00:00:00 | 2000-01-01 00:00:00 | 9999-12-31 23:59:59.999999 |
|    2 | 变量形式插入DATETIME类型数据           | 1000-01-01 00:00:00 | 2021-07-03 00:00:00 | 9999-12-31 23:59:59.999999 |
|    3 | 直接插入DATETIME类型数据               | 3000-01-01 00:00:00 | 4000-01-01 00:00:00 | 9999-12-31 23:59:59.999999 |
+------+----------------------------------------+---------------------+---------------------+----------------------------+

### int
### 
DROP TABLE IF EXISTS t1//
CREATE TABLE t1 (
  id INT,
  res1 VARCHAR(128),
  a INT(255)
)//
DROP PROCEDURE IF EXISTS `pro_1`//
CREATE PROCEDURE pro_1()
BEGIN
  DECLARE a INT(256);
  SET a=4294967295;
  INSERT INTO t1 VALUES(1,'插入INT类型数据',a);
END//
ERROR 42000: Display width out of range for column '(null)' (max = 255)
CALL pro_1()//
ERROR 42000: procedure test.pro_1 does not exist
SELECT * FROM t1//
+------+------+------+
| id   | res1 | a    |
+------+------+------+
+------+------+------+

### commit
### rollback
### 
DROP TABLE IF EXISTS t1//
CREATE TABLE t1
( a INT
)//
DROP TABLE IF EXISTS t2//
CREATE TABLE t2
( a INT
)//

INSERT INTO t1 VALUES (1),(2),(3)//

DROP PROCEDURE IF EXISTS `pro`//
CREATE PROCEDURE pro()
BEGIN
  INSERT INTO t1 VALUES (4);
  COMMIT;
END//

call pro()//

select * from t1//
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
+------+

DROP PROCEDURE IF EXISTS `pro`//
CREATE PROCEDURE pro()
BEGIN
  INSERT INTO t1 VALUES (4);
  ROLLBACK;
END//

call pro()//

select * from t1//
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    4 |
+------+

DROP FUNCTION IF EXISTS `fun1`//
####mysql: ERROR 1422 (HY000): Explicit or implicit commit is not allowed in stored function or trigger.
CREATE FUNCTION fun1() RETURNS VARCHAR(128)
BEGIN
  INSERT INTO t1 VALUES (4);
  COMMIT;
  return '显示提交';
END//
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.

DROP FUNCTION IF EXISTS `fun2`//
CREATE FUNCTION fun2() RETURNS VARCHAR(128)
BEGIN
  INSERT INTO t1 VALUES (4);
  return '隐式提交';
END//

select fun2()//
+--------------+
| fun2()       |
+--------------+
| 隐式提交     |
+--------------+

select * from t1//
+------+
| a    |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    4 |
|    4 |
+------+

DROP FUNCTION IF EXISTS `fun3`//
CREATE FUNCTION fun3() RETURNS VARCHAR(128)
BEGIN
  INSERT INTO t1 VALUES (4);
  ROLLBACK;
  return '回滚';
END//
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.

### BIT
### 
DROP TABLE IF EXISTS t1;//
DROP PROCEDURE IF EXISTS `pro_2`;//
CREATE PROCEDURE pro_2()
BEGIN
  CREATE TABLE t1 (id INT,a BIT(65)); 
  INSERT INTO t1 VALUES(1,b'0'); 
END;
//
ERROR 42000: Display width out of range for column 'CREATE TABLE t1 (id INT,a BIT(65))' (max = 64)

### load data
### 
DROP TABLE IF EXISTS t1//
CREATE TABLE t1 (a INT)//
INSERT INTO t1 VALUES (1),(2),(3)//
DROP PROCEDURE IF EXISTS `pro_22`//

CREATE PROCEDURE pro_22()
BEGIN
  LOAD DATA INFILE 'data.txt' INTO TABLE t1;
END//
ERROR HY000: 'LOAD DATA' is not allowed in stored procedure.

### lock
### 
DROP TABLE IF EXISTS t1//
CREATE TABLE t1 (a INT)//
INSERT INTO t1 VALUES (1),(2),(3)//
DROP PROCEDURE IF EXISTS `pro_1`//
CREATE PROCEDURE pro_1()
BEGIN
  LOCK TABLES t1 READ;
END//
ERROR HY000: 'LOCK TABLE' is not allowed in stored procedure.

DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t2;
DROP TABLE IF EXISTS t3;
DROP PROCEDURE IF EXISTS `pro_1`;
DROP FUNCTION IF EXISTS `fun_l`;
DROP PROCEDURE IF EXISTS `pro_22`;
