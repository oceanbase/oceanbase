result_format: 4
explain_protocol: 2
DROP DATABASE IF EXISTS DB_SIMPLIFY;
CREATE DATABASE DB_SIMPLIFY;
USE DB_SIMPLIFY;

********************* test for basic transform *********
drop table if exists t1, t2, t3;
create table t1(c1 int primary key);
create table t2(c2 int primary key);
create table t3(c3 int primary key);
EXPLAIN insert into t1 values(1),(2),(3),(4),(5);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |5        |2   |
|1 | EXPRESSION|    |5        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)]), filter(nil), 
      columns([{t1: ({t1: (t1.c1)})}]), partitions(p0)
  1 - output([__values.c1]), filter(nil)
      values({1}, {2}, {3}, {4}, {5})

insert into t1 values(1),(2),(3),(4),(5);
EXPLAIN insert into t2 values(11),(12),(13),(14),(15);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |5        |2   |
|1 | EXPRESSION|    |5        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c2)]), filter(nil), 
      columns([{t2: ({t2: (t2.c2)})}]), partitions(p0)
  1 - output([__values.c2]), filter(nil)
      values({11}, {12}, {13}, {14}, {15})

insert into t2 values(11),(12),(13),(14),(15);
EXPLAIN insert into t3 values(111),(112),(113),(114),(115);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |5        |2   |
|1 | EXPRESSION|    |5        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c3)]), filter(nil), 
      columns([{t3: ({t3: (t3.c3)})}]), partitions(p0)
  1 - output([__values.c3]), filter(nil)
      values({111}, {112}, {113}, {114}, {115})

insert into t3 values(111),(112),(113),(114),(115);

drop table if exists is_c1, is_c2;
create table is_c1(c1 int);
create table is_c2(c1 int, c2 int);

set autocommit = 0;

EXPLAIN select /*+no_rewrite*/ max(c1) from t1 group by c1 desc;
Query Plan
==============================================
|ID|OPERATOR      |NAME       |EST. ROWS|COST|
----------------------------------------------
|0 |MERGE GROUP BY|           |5        |38  |
|1 | TABLE SCAN   |t1(Reverse)|5        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(t1.c1)]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MAX(t1.c1)])
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select /*+no_rewrite*/ max(c1) from t1 group by c1 desc;
+---------+
| max(c1) |
+---------+
|       5 |
|       4 |
|       3 |
|       2 |
|       1 |
+---------+
EXPLAIN select max(c1) from t1 group by c1 desc;
Query Plan
==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t1(Reverse)|5        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select max(c1) from t1 group by c1 desc;
+---------+
| max(c1) |
+---------+
|       5 |
|       4 |
|       3 |
|       2 |
|       1 |
+---------+

EXPLAIN select /*+no_rewrite*/ c1 from t1 order by c1,c1,c1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select /*+no_rewrite*/ c1 from t1 order by c1,c1,c1;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
+----+
EXPLAIN select c1 from t1 order by c1,c1,c1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select c1 from t1 order by c1,c1,c1;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
+----+
EXPLAIN insert into is_c1 select c1 from t1 order by c1,c1,c1;
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |5        |38  |
|1 | SUBPLAN SCAN|VIEW1|5        |38  |
|2 |  TABLE SCAN |t1   |5        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

insert into is_c1 select c1 from t1 order by c1,c1,c1;

## test for subquery transform  ###
EXPLAIN select /*+no_rewrite*/ * from (select max(c1) from t1 group by c1 desc) as tmp;
Query Plan
============================================
|ID|OPERATOR    |NAME       |EST. ROWS|COST|
--------------------------------------------
|0 |SUBPLAN SCAN|tmp        |5        |38  |
|1 | TABLE SCAN |t1(Reverse)|5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([tmp.max(c1)]), filter(nil), 
      access([tmp.max(c1)])
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select /*+no_rewrite*/ * from (select max(c1) from t1 group by c1 desc) as tmp;
+---------+
| max(c1) |
+---------+
|       5 |
|       4 |
|       3 |
|       2 |
|       1 |
+---------+
EXPLAIN select * from (select max(c1) from t1 group by c1 desc) as tmp;
Query Plan
==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t1(Reverse)|5        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from (select max(c1) from t1 group by c1 desc) as tmp;
+---------+
| max(c1) |
+---------+
|       5 |
|       4 |
|       3 |
|       2 |
|       1 |
+---------+
EXPLAIN update t2 set t2.c2 = t2.c2 + 1 where t2.c2 in (select max(c1) from t1 group by c1 desc);
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |UPDATE      |    |5        |83  |
|1 | MERGE JOIN |    |5        |78  |
|2 |  TABLE SCAN|t2  |5        |37  |
|3 |  TABLE SCAN|t1  |5        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2: ({t2: (t2.c2)})}]),
      update([t2.c2=column_conv(INT,PS:(11,0),NOT NULL,cast(t2.c2 + 1, INT(-1, 0)))])
  1 - output([t2.c2], [column_conv(INT,PS:(11,0),NOT NULL,cast(t2.c2 + 1, INT(-1, 0)))]), filter(nil), 
      equal_conds([t2.c2 = t1.c1]), other_conds(nil)
  2 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t2 set t2.c2 = t2.c2 + 1 where t2.c2 in (select max(c1) from t1 group by c1 desc);
EXPLAIN select * from t2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t2  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

select * from t2;
+----+
| c2 |
+----+
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
+----+
rollback;
EXPLAIN update /*+NO_REWRITE*/t2 set t2.c2 = t2.c2 + 1 where t2.c2 in (select /*+NO_REWRITE*/max(c1) from t1 group by c1 desc);
Query Plan
================================================
|ID|OPERATOR        |NAME       |EST. ROWS|COST|
------------------------------------------------
|0 |UPDATE          |           |3        |85  |
|1 | SUBPLAN FILTER |           |3        |82  |
|2 |  TABLE SCAN    |t2         |5        |37  |
|3 |  MERGE GROUP BY|           |5        |38  |
|4 |   TABLE SCAN   |t1(Reverse)|5        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2: ({t2: (t2.c2)})}]),
      update([t2.c2=column_conv(INT,PS:(11,0),NOT NULL,cast(t2.c2 + 1, INT(-1, 0)))])
  1 - output([t2.c2], [column_conv(INT,PS:(11,0),NOT NULL,cast(t2.c2 + 1, INT(-1, 0)))]), filter([t2.c2 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  3 - output([T_FUN_MAX(t1.c1)]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MAX(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update /*+NO_REWRITE*/t2 set t2.c2 = t2.c2 + 1 where t2.c2 in (select /*+NO_REWRITE*/max(c1) from t1 group by c1 desc);
EXPLAIN select * from t2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t2  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

select * from t2;
+----+
| c2 |
+----+
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
+----+
rollback;
EXPLAIN select /*+no_rewrite*/ c2 from t2 where c2 = (select max(c1) from t1 group by c1 desc limit 1);
Query Plan
==============================================
|ID|OPERATOR      |NAME       |EST. ROWS|COST|
----------------------------------------------
|0 |SUBPLAN FILTER|           |1        |72  |
|1 | TABLE GET    |t2         |1        |36  |
|2 | TABLE SCAN   |t1(Reverse)|1        |36  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

select /*+no_rewrite*/ c2 from t2 where c2 = (select max(c1) from t1 group by c1 desc limit 1);
+----+
| c2 |
+----+
+----+
EXPLAIN select c2 from t2 where c2 = (select max(c1) from t1 group by c1 desc limit 1);
Query Plan
==============================================
|ID|OPERATOR      |NAME       |EST. ROWS|COST|
----------------------------------------------
|0 |SUBPLAN FILTER|           |1        |72  |
|1 | TABLE GET    |t2         |1        |36  |
|2 | TABLE SCAN   |t1(Reverse)|1        |36  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

select c2 from t2 where c2 = (select max(c1) from t1 group by c1 desc limit 1);
+----+
| c2 |
+----+
+----+
EXPLAIN delete from t2 where c2 = (select max(c1) from t1 group by c1 desc limit 1);
Query Plan
===============================================
|ID|OPERATOR       |NAME       |EST. ROWS|COST|
-----------------------------------------------
|0 |DELETE         |           |1        |73  |
|1 | SUBPLAN FILTER|           |1        |72  |
|2 |  TABLE GET    |t2         |1        |36  |
|3 |  TABLE SCAN   |t1(Reverse)|1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2: ({t2: (t2.c2)})}])
  1 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t2 where c2 = (select max(c1) from t1 group by c1 desc limit 1);
EXPLAIN insert into is_c1 select c2 from t2 where c2 = (select max(c1) from t1 group by c1 desc limit 1);
Query Plan
================================================
|ID|OPERATOR        |NAME       |EST. ROWS|COST|
------------------------------------------------
|0 |INSERT          |           |1        |73  |
|1 | SUBPLAN SCAN   |VIEW1      |1        |73  |
|2 |  SUBPLAN FILTER|           |1        |72  |
|3 |   TABLE GET    |t2         |1        |36  |
|4 |   TABLE SCAN   |t1(Reverse)|1        |36  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0)
  1 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  2 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_c1 select c2 from t2 where c2 = (select max(c1) from t1 group by c1 desc limit 1);

EXPLAIN select /*+no_rewrite*/ * from (select c1 from t1 order by c1,c1,c1) as tmp;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |SUBPLAN SCAN|tmp |5        |38  |
|1 | TABLE SCAN |t1  |5        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tmp.c1]), filter(nil), 
      access([tmp.c1])
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select /*+no_rewrite*/ * from (select c1 from t1 order by c1,c1,c1) as tmp;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
+----+
EXPLAIN select * from (select c1 from t1 order by c1,c1,c1) as tmp;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from (select c1 from t1 order by c1,c1,c1) as tmp;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
+----+

EXPLAIN select /*+no_rewrite*/ c2 from t2 where c2 = (select c1 from t1 order by c1,c1,c1 limit 1);
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |72  |
|1 | TABLE GET    |t2  |1        |36  |
|2 | TABLE SCAN   |t1  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

select /*+no_rewrite*/ c2 from t2 where c2 = (select c1 from t1 order by c1,c1,c1 limit 1);
+----+
| c2 |
+----+
+----+
EXPLAIN select c2 from t2 where c2 = (select c1 from t1 order by c1,c1,c1 limit 1);
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |72  |
|1 | TABLE GET    |t2  |1        |36  |
|2 | TABLE SCAN   |t1  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

select c2 from t2 where c2 = (select c1 from t1 order by c1,c1,c1 limit 1);
+----+
| c2 |
+----+
+----+
EXPLAIN delete from t2 where c2 = (select c1 from t1 order by c1,c1,c1 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |73  |
|1 | SUBPLAN FILTER|    |1        |72  |
|2 |  TABLE GET    |t2  |1        |36  |
|3 |  TABLE SCAN   |t1  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2: ({t2: (t2.c2)})}])
  1 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t2 where c2 = (select c1 from t1 order by c1,c1,c1 limit 1);
EXPLAIN insert into is_c1 select c2 from t2 where c2 = (select c1 from t1 order by c1,c1,c1 limit 1);
Query Plan
==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |INSERT          |     |1        |73  |
|1 | SUBPLAN SCAN   |VIEW1|1        |73  |
|2 |  SUBPLAN FILTER|     |1        |72  |
|3 |   TABLE GET    |t2   |1        |36  |
|4 |   TABLE SCAN   |t1   |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0)
  1 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  2 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_c1 select c2 from t2 where c2 = (select c1 from t1 order by c1,c1,c1 limit 1);

EXPLAIN select /*+no_rewrite*/ * from ((select c1 from t1 order by c1) union (select c2 from t2)) as tmp;
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |SUBPLAN SCAN         |tmp |10       |78  |
|1 | MERGE UNION DISTINCT|    |10       |77  |
|2 |  TABLE SCAN         |t1  |5        |37  |
|3 |  TABLE SCAN         |t2  |5        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([tmp.c1]), filter(nil), 
      access([tmp.c1])
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

select /*+no_rewrite*/ * from ((select c1 from t1 order by c1) union (select c2 from t2)) as tmp;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
+----+
EXPLAIN select * from ((select c1 from t1 order by c1) union (select c2 from t2)) as tmp;
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |10       |77  |
|1 | TABLE SCAN         |t1  |5        |37  |
|2 | TABLE SCAN         |t2  |5        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

select * from ((select c1 from t1 order by c1) union (select c2 from t2)) as tmp;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
+----+
EXPLAIN select /*+no_rewrite*/ c3 from t3 where c3 in ((select c1 from t1 order by c1) union (select c2 from t2));
Query Plan
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |SUBPLAN FILTER       |    |3        |127 |
|1 | TABLE SCAN          |t3  |5        |37  |
|2 | MERGE UNION DISTINCT|    |10       |77  |
|3 |  TABLE SCAN         |t1  |5        |37  |
|4 |  TABLE SCAN         |t2  |5        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c3]), filter([t3.c3 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

select /*+no_rewrite*/ c3 from t3 where c3 in ((select c1 from t1 order by c1) union (select c2 from t2));
+----+
| c3 |
+----+
+----+
EXPLAIN select c3 from t3 where c3 in ((select c1 from t1 order by c1) union (select c2 from t2));
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE JOIN            |     |10       |123 |
|1 | TABLE SCAN           |t3   |5        |37  |
|2 | SUBPLAN SCAN         |VIEW1|10       |78  |
|3 |  MERGE UNION DISTINCT|     |10       |77  |
|4 |   TABLE SCAN         |t1   |5        |37  |
|5 |   TABLE SCAN         |t2   |5        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c3]), filter(nil), 
      equal_conds([t3.c3 = VIEW1.c1]), other_conds(nil)
  1 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([UNION([1])]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

select c3 from t3 where c3 in ((select c1 from t1 order by c1) union (select c2 from t2));
+----+
| c3 |
+----+
+----+
EXPLAIN delete from t3 where c3 in ((select c1 from t1 order by c1) union (select c2 from t2));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |DELETE                 |     |10       |133 |
|1 | MERGE JOIN            |     |10       |123 |
|2 |  TABLE SCAN           |t3   |5        |37  |
|3 |  SUBPLAN SCAN         |VIEW1|10       |78  |
|4 |   MERGE UNION DISTINCT|     |10       |77  |
|5 |    TABLE SCAN         |t1   |5        |37  |
|6 |    TABLE SCAN         |t2   |5        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t3: ({t3: (t3.c3)})}])
  1 - output([t3.c3]), filter(nil), 
      equal_conds([t3.c3 = VIEW1.c1]), other_conds(nil)
  2 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([UNION([1])]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

delete from t3 where c3 in ((select c1 from t1 order by c1) union (select c2 from t2));
EXPLAIN insert into is_c1 select c3 from t3 where c3 in ((select c1 from t1 order by c1) union (select c2 from t2));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |INSERT                  |     |10       |125 |
|1 | SUBPLAN SCAN           |VIEW1|10       |124 |
|2 |  MERGE JOIN            |     |10       |123 |
|3 |   TABLE SCAN           |t3   |5        |37  |
|4 |   SUBPLAN SCAN         |VIEW2|10       |78  |
|5 |    MERGE UNION DISTINCT|     |10       |77  |
|6 |     TABLE SCAN         |t1   |5        |37  |
|7 |     TABLE SCAN         |t2   |5        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c3)]), filter(nil), 
      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0)
  1 - output([VIEW1.c3]), filter(nil), 
      access([VIEW1.c3])
  2 - output([t3.c3]), filter(nil), 
      equal_conds([t3.c3 = VIEW2.c1]), other_conds(nil)
  3 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  4 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  5 - output([UNION([1])]), filter(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

insert into is_c1 select c3 from t3 where c3 in ((select c1 from t1 order by c1) union (select c2 from t2));

EXPLAIN select /*+no_rewrite*/ * from ((select c1 from t1) union all (select c2 from t2) limit 2) as tmp;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |SUBPLAN SCAN |tmp |2        |75  |
|1 | LIMIT       |    |2        |74  |
|2 |  UNION ALL  |    |2        |74  |
|3 |   TABLE SCAN|t1  |2        |37  |
|4 |   TABLE SCAN|t2  |2        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([tmp.c1]), filter(nil), 
      access([tmp.c1])
  1 - output([UNION([1])]), filter(nil), limit(2), offset(nil)
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(2), offset(nil)
  4 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0), 
      limit(2), offset(nil)

select /*+no_rewrite*/ * from ((select c1 from t1) union all (select c2 from t2) limit 2) as tmp;
+----+
| c1 |
+----+
|  1 |
|  2 |
+----+
EXPLAIN select * from ((select c1 from t1) union all (select c2 from t2) limit 2) as tmp;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |2        |74  |
|1 | UNION ALL  |    |2        |74  |
|2 |  TABLE SCAN|t1  |2        |37  |
|3 |  TABLE SCAN|t2  |2        |37  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), limit(2), offset(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(2), offset(nil)
  3 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0), 
      limit(2), offset(nil)

select * from ((select c1 from t1) union all (select c2 from t2) limit 2) as tmp;
+----+
| c1 |
+----+
|  1 |
|  2 |
+----+
EXPLAIN select /*+no_rewrite*/ c3 from t3 where c3 in ((select c1 from t1) union all (select c2 from t2) limit 2);
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |3        |114 |
|1 | TABLE SCAN   |t3  |5        |37  |
|2 | LIMIT        |    |2        |74  |
|3 |  UNION ALL   |    |2        |74  |
|4 |   TABLE SCAN |t1  |2        |37  |
|5 |   TABLE SCAN |t2  |2        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c3]), filter([t3.c3 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  2 - output([UNION([1])]), filter(nil), limit(2), offset(nil)
  3 - output([UNION([1])]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(2), offset(nil)
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0), 
      limit(2), offset(nil)

select /*+no_rewrite*/ c3 from t3 where c3 in ((select c1 from t1) union all (select c2 from t2) limit 2);
+----+
| c3 |
+----+
+----+
EXPLAIN select c3 from t3 where c3 in ((select c1 from t1) union all (select c2 from t2) limit 2);
Query Plan
=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |MERGE SEMI JOIN|     |2        |114 |
|1 | TABLE SCAN    |t3   |5        |37  |
|2 | SORT          |     |2        |76  |
|3 |  SUBPLAN SCAN |VIEW1|2        |75  |
|4 |   LIMIT       |     |2        |74  |
|5 |    UNION ALL  |     |2        |74  |
|6 |     TABLE SCAN|t1   |2        |37  |
|7 |     TABLE SCAN|t2   |2        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c3]), filter(nil), 
      equal_conds([t3.c3 = VIEW1.c1]), other_conds(nil)
  1 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil), sort_keys([VIEW1.c1, ASC])
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([UNION([1])]), filter(nil), limit(2), offset(nil)
  5 - output([UNION([1])]), filter(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(2), offset(nil)
  7 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0), 
      limit(2), offset(nil)

select c3 from t3 where c3 in ((select c1 from t1) union all (select c2 from t2) limit 2);
+----+
| c3 |
+----+
+----+
EXPLAIN delete from t3 where c3 in ((select c1 from t1) union all (select c2 from t2) limit 2);
Query Plan
==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |DELETE          |     |2        |116 |
|1 | MERGE SEMI JOIN|     |2        |114 |
|2 |  TABLE SCAN    |t3   |5        |37  |
|3 |  SORT          |     |2        |76  |
|4 |   SUBPLAN SCAN |VIEW1|2        |75  |
|5 |    LIMIT       |     |2        |74  |
|6 |     UNION ALL  |     |2        |74  |
|7 |      TABLE SCAN|t1   |2        |37  |
|8 |      TABLE SCAN|t2   |2        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t3: ({t3: (t3.c3)})}])
  1 - output([t3.c3]), filter(nil), 
      equal_conds([t3.c3 = VIEW1.c1]), other_conds(nil)
  2 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  3 - output([VIEW1.c1]), filter(nil), sort_keys([VIEW1.c1, ASC])
  4 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  5 - output([UNION([1])]), filter(nil), limit(2), offset(nil)
  6 - output([UNION([1])]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(2), offset(nil)
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0), 
      limit(2), offset(nil)

delete from t3 where c3 in ((select c1 from t1) union all (select c2 from t2) limit 2);
EXPLAIN insert into is_c1 select c3 from t3 where c3 in ((select c1 from t1) union all (select c2 from t2) limit 2);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |INSERT           |     |2        |115 |
|1 | SUBPLAN SCAN    |VIEW1|2        |114 |
|2 |  MERGE SEMI JOIN|     |2        |114 |
|3 |   TABLE SCAN    |t3   |5        |37  |
|4 |   SORT          |     |2        |76  |
|5 |    SUBPLAN SCAN |VIEW2|2        |75  |
|6 |     LIMIT       |     |2        |74  |
|7 |      UNION ALL  |     |2        |74  |
|8 |       TABLE SCAN|t1   |2        |37  |
|9 |       TABLE SCAN|t2   |2        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c3)]), filter(nil), 
      columns([{is_c1: ({is_c1: (is_c1.__pk_increment, is_c1.c1)})}]), partitions(p0)
  1 - output([VIEW1.c3]), filter(nil), 
      access([VIEW1.c3])
  2 - output([t3.c3]), filter(nil), 
      equal_conds([t3.c3 = VIEW2.c1]), other_conds(nil)
  3 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  4 - output([VIEW2.c1]), filter(nil), sort_keys([VIEW2.c1, ASC])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([UNION([1])]), filter(nil), limit(2), offset(nil)
  7 - output([UNION([1])]), filter(nil)
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(2), offset(nil)
  9 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0), 
      limit(2), offset(nil)

insert into is_c1 select c3 from t3 where c3 in ((select c1 from t1) union all (select c2 from t2) limit 2);

drop table is_c1, is_c2, t1,t2,t3;

set autocommit = 1;


*********************消除subquery中的order by子句 begin*****************

drop table if exists t1, t2;
create table t1(c1 int not null, c2 int, key idx_c1(c1));
create table t2(c1 int not null, c2 int, key idx_c2(c2));
create table is_t1(c1 int);
create table is_t2(c1 int, c2 int);
insert/*trace*/into t1 values(1,2),(2,3),(3,3), (4,3),(4,4),(6,5),(6,5),(10,20);

****** no limit, elimilate order by in subquery
EXPLAIN select /*+no_rewrite*/ sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c1, c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |102 |
|1 | SUBPLAN FILTER|    |4        |102 |
|2 |  TABLE SCAN   |t1  |8        |38  |
|3 |  SORT         |    |8        |46  |
|4 |   TABLE SCAN  |t1  |8        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  1 - output([t1.c1], [t1.c2]), filter([t1.c2 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+no_rewrite*/ sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c1, c2);
+---------+---------+
| sum(c1) | sum(c2) |
+---------+---------+
|      14 |      15 |
+---------+---------+
EXPLAIN select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c1, c2);
Query Plan
===============================================
|ID|OPERATOR        |NAME      |EST. ROWS|COST|
-----------------------------------------------
|0 |SCALAR GROUP BY |          |1        |92  |
|1 | MERGE SEMI JOIN|          |8        |90  |
|2 |  SORT          |          |8        |46  |
|3 |   TABLE SCAN   |t1        |8        |38  |
|4 |  TABLE SCAN    |t1(idx_c1)|8        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c1, c2);
+---------+---------+
| sum(c1) | sum(c2) |
+---------+---------+
|      14 |      15 |
+---------+---------+
EXPLAIN update t1 set c2 = c1+1 where c2 in (select c1 from t1 order by c1, c1, c2);
Query Plan
====================================================
|ID|OPERATOR             |NAME      |EST. ROWS|COST|
----------------------------------------------------
|0 |UPDATE               |          |8        |99  |
|1 | HASH RIGHT SEMI JOIN|          |8        |91  |
|2 |  TABLE SCAN         |t1(idx_c1)|8        |38  |
|3 |  TABLE SCAN         |t1        |8        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=column_conv(INT,PS:(11,0),NULL,cast(t1.c1 + 1, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NULL,cast(t1.c1 + 1, INT(-1, 0)))]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t1.c2], [t1.c1], [t1.__pk_increment]), filter(nil), 
      access([t1.c2], [t1.c1], [t1.__pk_increment]), partitions(p0)

update t1 set c2 = c1+1 where c2 in (select c1 from t1 order by c1, c1, c2);
EXPLAIN delete from t1 where c2 in (select c1 from t1 order by c1, c1, c2);
Query Plan
====================================================
|ID|OPERATOR             |NAME      |EST. ROWS|COST|
----------------------------------------------------
|0 |DELETE               |          |8        |99  |
|1 | HASH RIGHT SEMI JOIN|          |8        |91  |
|2 |  TABLE SCAN         |t1(idx_c1)|8        |38  |
|3 |  TABLE SCAN         |t1        |8        |38  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 in (select c1 from t1 order by c1, c1, c2);
EXPLAIN insert into is_t2 select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c1, c2);
Query Plan
=================================================
|ID|OPERATOR          |NAME      |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT            |          |1        |85  |
|1 | SUBPLAN SCAN     |VIEW1     |1        |85  |
|2 |  SCALAR GROUP BY |          |1        |85  |
|3 |   MERGE SEMI JOIN|          |5        |84  |
|4 |    SORT          |          |5        |42  |
|5 |     TABLE SCAN   |t1        |5        |38  |
|6 |    TABLE SCAN    |t1(idx_c1)|5        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.sum(c1), INT(-1, 0)))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.sum(c2), INT(-1, 0)))]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.sum(c1)], [VIEW1.sum(c2)]), filter(nil), 
      access([VIEW1.sum(c1)], [VIEW1.sum(c2)])
  2 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

insert into is_t2 select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c1, c2);


****** has limit, can't elimilate order by in subquery
EXPLAIN select /*+no_rewrite*/sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c2 limit 1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |80  |
|1 | SUBPLAN FILTER|    |3        |79  |
|2 |  TABLE SCAN   |t1  |5        |38  |
|3 |  LIMIT        |    |1        |40  |
|4 |   TOP-N SORT  |    |1        |40  |
|5 |    TABLE SCAN |t1  |5        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  1 - output([t1.c1], [t1.c2]), filter([t1.c2 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(1)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+no_rewrite*/sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c2 limit 1);
+---------+---------+
| sum(c1) | sum(c2) |
+---------+---------+
|    NULL |    NULL |
+---------+---------+
EXPLAIN select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c2 limit 1);
Query Plan
=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY|     |1        |81  |
|1 | HASH JOIN     |     |1        |81  |
|2 |  SUBPLAN SCAN |VIEW1|1        |40  |
|3 |   LIMIT       |     |1        |40  |
|4 |    TOP-N SORT |     |1        |40  |
|5 |     TABLE SCAN|t1   |5        |38  |
|6 |  TABLE SCAN   |t1   |5        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = VIEW1.c1]), other_conds(nil)
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(1)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)

select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c2 limit 1);
+---------+---------+
| sum(c1) | sum(c2) |
+---------+---------+
|    NULL |    NULL |
+---------+---------+
EXPLAIN update t1 set c2 = 1 where c2 in (select c1 from t1 order by c1, c2 limit 1);
Query Plan
=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |UPDATE         |     |1        |82  |
|1 | HASH JOIN     |     |1        |81  |
|2 |  SUBPLAN SCAN |VIEW1|1        |40  |
|3 |   LIMIT       |     |1        |40  |
|4 |    TOP-N SORT |     |1        |40  |
|5 |     TABLE SCAN|t1   |5        |38  |
|6 |  TABLE SCAN   |t1   |5        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=?])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [?]), filter(nil), 
      equal_conds([t1.c2 = VIEW1.c1]), other_conds(nil)
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(1)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)

update t1 set c2 = 1 where c2 in (select c1 from t1 order by c1, c2 limit 1);
EXPLAIN delete from t1 where c2 in (select c1 from t1 order by c1, c2 limit 1);
Query Plan
=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |DELETE         |     |1        |82  |
|1 | HASH JOIN     |     |1        |81  |
|2 |  SUBPLAN SCAN |VIEW1|1        |40  |
|3 |   LIMIT       |     |1        |40  |
|4 |    TOP-N SORT |     |1        |40  |
|5 |     TABLE SCAN|t1   |5        |38  |
|6 |  TABLE SCAN   |t1   |5        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = VIEW1.c1]), other_conds(nil)
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(1)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  6 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)

delete from t1 where c2 in (select c1 from t1 order by c1, c2 limit 1);
EXPLAIN insert into is_t2 select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c2 limit 1);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |INSERT           |     |1        |81  |
|1 | SUBPLAN SCAN    |VIEW1|1        |81  |
|2 |  SCALAR GROUP BY|     |1        |81  |
|3 |   HASH JOIN     |     |1        |81  |
|4 |    SUBPLAN SCAN |VIEW2|1        |40  |
|5 |     LIMIT       |     |1        |40  |
|6 |      TOP-N SORT |     |1        |40  |
|7 |       TABLE SCAN|t1   |5        |38  |
|8 |    TABLE SCAN   |t1   |5        |38  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.sum(c1), INT(-1, 0)))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.sum(c2), INT(-1, 0)))]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.sum(c1)], [VIEW1.sum(c2)]), filter(nil), 
      access([VIEW1.sum(c1)], [VIEW1.sum(c2)])
  2 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = VIEW2.c1]), other_conds(nil)
  4 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  5 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(1)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)

insert into is_t2 select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by c1, c2 limit 1);


****** order by subquery, can't elimilate order by in subquery
EXPLAIN select /*+no_rewrite*/ sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by (select 1));
Query Plan
==============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST|
----------------------------------------------
|0 |SCALAR GROUP BY|          |1        |83  |
|1 | SUBPLAN FILTER|          |3        |82  |
|2 |  TABLE SCAN   |t1        |5        |38  |
|3 |  TABLE SCAN   |t1(idx_c1)|5        |38  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  1 - output([t1.c1], [t1.c2]), filter([t1.c2 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select /*+no_rewrite*/ sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by (select 1));
+---------+---------+
| sum(c1) | sum(c2) |
+---------+---------+
|    NULL |    NULL |
+---------+---------+
EXPLAIN select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by (select 1));
Query Plan
===============================================
|ID|OPERATOR        |NAME      |EST. ROWS|COST|
-----------------------------------------------
|0 |SCALAR GROUP BY |          |1        |85  |
|1 | MERGE SEMI JOIN|          |5        |84  |
|2 |  SORT          |          |5        |42  |
|3 |   TABLE SCAN   |t1        |5        |38  |
|4 |  TABLE SCAN    |t1(idx_c1)|5        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by (select 1));
+---------+---------+
| sum(c1) | sum(c2) |
+---------+---------+
|    NULL |    NULL |
+---------+---------+
EXPLAIN update t1 set c2 = 1 where c2 in (select c1 from t1 order by (select 1));
Query Plan
===============================================
|ID|OPERATOR        |NAME      |EST. ROWS|COST|
-----------------------------------------------
|0 |UPDATE          |          |5        |90  |
|1 | MERGE SEMI JOIN|          |5        |85  |
|2 |  SORT          |          |5        |43  |
|3 |   TABLE SCAN   |t1        |5        |38  |
|4 |  TABLE SCAN    |t1(idx_c1)|5        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c2=?])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [?]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c2], [t1.__pk_increment], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.__pk_increment], [t1.c1]), partitions(p0)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

update t1 set c2 = 1 where c2 in (select c1 from t1 order by (select 1));
EXPLAIN delete from t1 where c2 in (select c1 from t1 order by (select 1));
Query Plan
===============================================
|ID|OPERATOR        |NAME      |EST. ROWS|COST|
-----------------------------------------------
|0 |DELETE          |          |5        |90  |
|1 | MERGE SEMI JOIN|          |5        |85  |
|2 |  SORT          |          |5        |43  |
|3 |   TABLE SCAN   |t1        |5        |38  |
|4 |  TABLE SCAN    |t1(idx_c1)|5        |38  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

delete from t1 where c2 in (select c1 from t1 order by (select 1));
EXPLAIN insert into is_t2 select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by (select 1));
Query Plan
=================================================
|ID|OPERATOR          |NAME      |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT            |          |1        |85  |
|1 | SUBPLAN SCAN     |VIEW1     |1        |85  |
|2 |  SCALAR GROUP BY |          |1        |85  |
|3 |   MERGE SEMI JOIN|          |5        |84  |
|4 |    SORT          |          |5        |42  |
|5 |     TABLE SCAN   |t1        |5        |38  |
|6 |    TABLE SCAN    |t1(idx_c1)|5        |38  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.sum(c1), INT(-1, 0)))], [column_conv(INT,PS:(11,0),NULL,cast(VIEW1.sum(c2), INT(-1, 0)))]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.sum(c1)], [VIEW1.sum(c2)]), filter(nil), 
      access([VIEW1.sum(c1)], [VIEW1.sum(c2)])
  2 - output([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  5 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

insert into is_t2 select sum(c1), sum(c2) from t1 where c2 in (select c1 from t1 order by (select 1));
drop table t1, t2;

*********************消除subquery中的order by子句 end*****************

*********************消除order by重复列begin*****************

drop table if exists t1;
create table t1(c1 int not null, c2 int);
EXPLAIN select /*+no_rewrite*/ c1 from t1 order by c1,c1 limit 10;
Query Plan
=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |LIMIT       |    |10       |112665|
|1 | TOP-N SORT |    |10       |112663|
|2 |  TABLE SCAN|t1  |100000   |61860 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(10), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(10)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select /*+no_rewrite*/ c1 from t1 order by c1,c1 limit 10;
+----+
| c1 |
+----+
+----+
EXPLAIN select c1 from t1 order by c1,c1 limit 10;
Query Plan
=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |LIMIT       |    |10       |112665|
|1 | TOP-N SORT |    |10       |112663|
|2 |  TABLE SCAN|t1  |100000   |61860 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(10), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(10)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select c1 from t1 order by c1,c1 limit 10;
+----+
| c1 |
+----+
+----+
EXPLAIN update t1 set c1 = c2 + 1  order by c1,c1 limit 10;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |UPDATE       |    |10       |133258|
|1 | LIMIT       |    |10       |133248|
|2 |  TOP-N SORT |    |10       |133246|
|3 |   TABLE SCAN|t1  |100000   |64066 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c1=column_conv(INT,PS:(11,0),NOT NULL,cast(t1.c2 + 1, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NOT NULL,cast(t1.c2 + 1, INT(-1, 0)))]), filter(nil), limit(10), offset(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), topn(10)
  3 - output([t1.c1], [t1.c2], [t1.__pk_increment]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.__pk_increment]), partitions(p0)

update t1 set c1 = c2 + 1  order by c1,c1 limit 10;
EXPLAIN delete from t1 order by c1,c1 limit 10;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |DELETE       |    |10       |133258|
|1 | LIMIT       |    |10       |133248|
|2 |  TOP-N SORT |    |10       |133246|
|3 |   TABLE SCAN|t1  |100000   |64066 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), limit(10), offset(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), topn(10)
  3 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)

delete from t1 order by c1,c1 limit 10;
EXPLAIN insert into is_t1 select c1 from t1 order by c1,c1 limit 10;
Query Plan
==========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST  |
------------------------------------------
|0 |INSERT        |     |10       |112668|
|1 | SUBPLAN SCAN |VIEW1|10       |112666|
|2 |  LIMIT       |     |10       |112665|
|3 |   TOP-N SORT |     |10       |112663|
|4 |    TABLE SCAN|t1   |100000   |61860 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{is_t1: ({is_t1: (is_t1.__pk_increment, is_t1.c1)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(10), offset(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(10)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

insert into is_t1 select c1 from t1 order by c1,c1 limit 10;



EXPLAIN select /*+no_rewrite*/c1 from t1 order by c1,c1,c2 limit 10;
Query Plan
=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |LIMIT       |    |10       |124337|
|1 | TOP-N SORT |    |10       |124336|
|2 |  TABLE SCAN|t1  |100000   |64066 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(10), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+no_rewrite*/c1 from t1 order by c1,c1,c2 limit 10;
+----+
| c1 |
+----+
+----+
EXPLAIN select c1 from t1 order by c1,c1,c2 limit 10;
Query Plan
=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |LIMIT       |    |10       |124337|
|1 | TOP-N SORT |    |10       |124336|
|2 |  TABLE SCAN|t1  |100000   |64066 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(10), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select c1 from t1 order by c1,c1,c2 limit 10;
+----+
| c1 |
+----+
+----+
EXPLAIN update t1 set c1 = c2 + 1 order by c1,c1,c2 limit 10;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |UPDATE       |    |10       |133536|
|1 | LIMIT       |    |10       |133526|
|2 |  TOP-N SORT |    |10       |133525|
|3 |   TABLE SCAN|t1  |100000   |64066 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c1=column_conv(INT,PS:(11,0),NOT NULL,cast(t1.c2 + 1, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NOT NULL,cast(t1.c2 + 1, INT(-1, 0)))]), filter(nil), limit(10), offset(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  3 - output([t1.c1], [t1.c2], [t1.__pk_increment]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.__pk_increment]), partitions(p0)

update t1 set c1 = c2 + 1 order by c1,c1,c2 limit 10;
EXPLAIN delete from t1 order by c1,c1,c2 limit 10;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |DELETE       |    |10       |133536|
|1 | LIMIT       |    |10       |133526|
|2 |  TOP-N SORT |    |10       |133525|
|3 |   TABLE SCAN|t1  |100000   |64066 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), limit(10), offset(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  3 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)

delete from t1 order by c1,c1,c2 limit 10;
EXPLAIN insert into is_t1 select c1 from t1 order by c1,c1,c2 limit 10;
Query Plan
==========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST  |
------------------------------------------
|0 |INSERT        |     |10       |124340|
|1 | SUBPLAN SCAN |VIEW1|10       |124339|
|2 |  LIMIT       |     |10       |124337|
|3 |   TOP-N SORT |     |10       |124336|
|4 |    TABLE SCAN|t1   |100000   |64066 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{is_t1: ({is_t1: (is_t1.__pk_increment, is_t1.c1)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(10), offset(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into is_t1 select c1 from t1 order by c1,c1,c2 limit 10;



EXPLAIN select /*+no_rewrite*/c1 from t1 order by c1,c2,c1 limit 10;
Query Plan
=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |LIMIT       |    |10       |124337|
|1 | TOP-N SORT |    |10       |124336|
|2 |  TABLE SCAN|t1  |100000   |64066 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(10), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+no_rewrite*/c1 from t1 order by c1,c2,c1 limit 10;
+----+
| c1 |
+----+
+----+
EXPLAIN select c1 from t1 order by c1,c2,c1 limit 10;
Query Plan
=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |LIMIT       |    |10       |124337|
|1 | TOP-N SORT |    |10       |124336|
|2 |  TABLE SCAN|t1  |100000   |64066 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(10), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select c1 from t1 order by c1,c2,c1 limit 10;
+----+
| c1 |
+----+
+----+
EXPLAIN update t1 set c1 = c2 + 1 order by c1,c2,c1 limit 10;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |UPDATE       |    |10       |133536|
|1 | LIMIT       |    |10       |133526|
|2 |  TOP-N SORT |    |10       |133525|
|3 |   TABLE SCAN|t1  |100000   |64066 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}]),
      update([t1.c1=column_conv(INT,PS:(11,0),NOT NULL,cast(t1.c2 + 1, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2], [column_conv(INT,PS:(11,0),NOT NULL,cast(t1.c2 + 1, INT(-1, 0)))]), filter(nil), limit(10), offset(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  3 - output([t1.c1], [t1.c2], [t1.__pk_increment]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.__pk_increment]), partitions(p0)

update t1 set c1 = c2 + 1 order by c1,c2,c1 limit 10;
EXPLAIN delete from t1 order by c1,c2,c1 limit 10;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |DELETE       |    |10       |133536|
|1 | LIMIT       |    |10       |133526|
|2 |  TOP-N SORT |    |10       |133525|
|3 |   TABLE SCAN|t1  |100000   |64066 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.c1, t1.c2)})}])
  1 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), limit(10), offset(nil)
  2 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  3 - output([t1.__pk_increment], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.__pk_increment], [t1.c1], [t1.c2]), partitions(p0)

delete from t1 order by c1,c2,c1 limit 10;
EXPLAIN insert into is_t1 select c1 from t1 order by c1,c2,c1 limit 10;
Query Plan
==========================================
|ID|OPERATOR      |NAME |EST. ROWS|COST  |
------------------------------------------
|0 |INSERT        |     |10       |124340|
|1 | SUBPLAN SCAN |VIEW1|10       |124339|
|2 |  LIMIT       |     |10       |124337|
|3 |   TOP-N SORT |     |10       |124336|
|4 |    TABLE SCAN|t1   |100000   |64066 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)]), filter(nil), 
      columns([{is_t1: ({is_t1: (is_t1.__pk_increment, is_t1.c1)})}]), partitions(p0)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t1.c1]), filter(nil), limit(10), offset(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC]), topn(10)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

insert into is_t1 select c1 from t1 order by c1,c2,c1 limit 10;

drop table t1;


*********************消除order by重复列end*****************

************************* replace is null condition, begin *********

drop table if exists t1_null, t2_null, t3_null;
create table t1_null(c1 int primary key, c2 int);
create table t2_null(c1 int, c2 int not NULL);
create table t3_null(c1 int primary key, c6 int);
insert/*trace*/ into t1_null values(1, 1),(2, 2),(3, 3);
insert/*trace*/ into t2_null values(4, 4),(5, 5),(6, 6);


******  pk is null ==> false
EXPLAIN select /*+no_rewrite*/ * from t1_null where c1 is NULL;
Query Plan
=====================================
|ID|OPERATOR |NAME   |EST. ROWS|COST|
-------------------------------------
|0 |TABLE GET|t1_null|1        |52  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

select /*+no_rewrite*/ * from t1_null where c1 is NULL;
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN select * from t1_null where c1 is NULL;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t1_null|3        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter(nil), startup_filter([0]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

select * from t1_null where c1 is NULL;
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN update t1_null set c2 = 0 where c1 is NULL;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |UPDATE     |       |3        |40  |
|1 | TABLE SCAN|t1_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}]),
      update([t1_null.c2=?])
  1 - output([t1_null.c1], [t1_null.c2], [?]), filter(nil), startup_filter([0]), 
      access([t1_null.c2], [t1_null.c1]), partitions(p0)

update t1_null set c2 = 0 where c1 is NULL;
EXPLAIN delete from t1_null where c1 is NULL;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |DELETE     |       |3        |40  |
|1 | TABLE SCAN|t1_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}])
  1 - output([t1_null.c1], [t1_null.c2]), filter(nil), startup_filter([0]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

delete from t1_null where c1 is NULL;
EXPLAIN insert into is_t2 select * from t1_null where c1 is NULL;
Query Plan
=========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST|
-----------------------------------------
|0 |INSERT       |       |3        |38  |
|1 | SUBPLAN SCAN|VIEW1  |3        |37  |
|2 |  TABLE SCAN |t1_null|3        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

insert into is_t2 select * from t1_null where c1 is NULL;


****** 多个表达式,pk is null ==> false
EXPLAIN select /*+no_rewrite*/* from t1_null where c1 is NULL and c2 = 1;
Query Plan
=====================================
|ID|OPERATOR |NAME   |EST. ROWS|COST|
-------------------------------------
|0 |TABLE GET|t1_null|1        |53  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter([t1_null.c2 = 1]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

select /*+no_rewrite*/* from t1_null where c1 is NULL and c2 = 1;
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN select * from t1_null where c1 is NULL and c2 = 1;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t1_null|3        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter(nil), startup_filter([0]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

select * from t1_null where c1 is NULL and c2 = 1;
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN update t1_null set c2 = 0 where c1 is NULL and c2 = 1;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |UPDATE     |       |3        |40  |
|1 | TABLE SCAN|t1_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}]),
      update([t1_null.c2=?])
  1 - output([t1_null.c1], [t1_null.c2], [?]), filter(nil), startup_filter([0]), 
      access([t1_null.c2], [t1_null.c1]), partitions(p0)

update t1_null set c2 = 0 where c1 is NULL and c2 = 1;
EXPLAIN delete from t1_null where c1 is NULL and c2 = 1;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |DELETE     |       |3        |40  |
|1 | TABLE SCAN|t1_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}])
  1 - output([t1_null.c1], [t1_null.c2]), filter(nil), startup_filter([0]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

delete from t1_null where c1 is NULL and c2 = 1;
EXPLAIN insert into is_t2 select * from t1_null where c1 is NULL and c2 = 1;
Query Plan
=========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST|
-----------------------------------------
|0 |INSERT       |       |3        |38  |
|1 | SUBPLAN SCAN|VIEW1  |3        |37  |
|2 |  TABLE SCAN |t1_null|3        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

insert into is_t2 select * from t1_null where c1 is NULL and c2 = 1;


****** column(not NULL) is NULL ==> false
EXPLAIN select /*+no_rewrite*/* from t2_null where c2 is NULL;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t2_null|0        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_null.c1], [t2_null.c2]), filter([(T_OP_IS, t2_null.c2, NULL, 0)]), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

select /*+no_rewrite*/* from t2_null where c2 is NULL;
+------+----+
| c1   | c2 |
+------+----+
+------+----+
EXPLAIN select * from t2_null where c2 is NULL;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t2_null|3        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_null.c1], [t2_null.c2]), filter(nil), startup_filter([0]), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

select * from t2_null where c2 is NULL;
+------+----+
| c1   | c2 |
+------+----+
+------+----+
EXPLAIN update t2_null set c2 = c1 + 1 where c2 is NULL;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |UPDATE     |       |3        |40  |
|1 | TABLE SCAN|t2_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_null: ({t2_null: (t2_null.__pk_increment, t2_null.c1, t2_null.c2)})}]),
      update([t2_null.c2=column_conv(INT,PS:(11,0),NOT NULL,cast(t2_null.c1 + 1, INT(-1, 0)))])
  1 - output([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2], [column_conv(INT,PS:(11,0),NOT NULL,cast(t2_null.c1 + 1, INT(-1, 0)))]), filter(nil), startup_filter([0]), 
      access([t2_null.c2], [t2_null.c1], [t2_null.__pk_increment]), partitions(p0)

update t2_null set c2 = c1 + 1 where c2 is NULL;
EXPLAIN delete from t2_null where c2 is NULL;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |DELETE     |       |3        |40  |
|1 | TABLE SCAN|t2_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_null: ({t2_null: (t2_null.__pk_increment, t2_null.c1, t2_null.c2)})}])
  1 - output([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2]), filter(nil), startup_filter([0]), 
      access([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2]), partitions(p0)

delete from t2_null where c2 is NULL;
EXPLAIN insert into is_t2 select * from t2_null where c2 is NULL;
Query Plan
=========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST|
-----------------------------------------
|0 |INSERT       |       |3        |38  |
|1 | SUBPLAN SCAN|VIEW1  |3        |37  |
|2 |  TABLE SCAN |t2_null|3        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t2_null.c1], [t2_null.c2]), filter(nil), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

insert into is_t2 select * from t2_null where c2 is NULL;


****** 多个表达式, column(not NULL) is NULL ==> false
EXPLAIN select /*+no_rewrite*/* from t2_null where c2 is NULL and c1 = 1;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t2_null|0        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_null.c1], [t2_null.c2]), filter([(T_OP_IS, t2_null.c2, NULL, 0)], [t2_null.c1 = 1]), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

select /*+no_rewrite*/* from t2_null where c2 is NULL and c1 = 1;
+------+----+
| c1   | c2 |
+------+----+
+------+----+
EXPLAIN select * from t2_null where c2 is NULL and c1 = 1;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t2_null|3        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_null.c1], [t2_null.c2]), filter(nil), startup_filter([0]), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

select * from t2_null where c2 is NULL and c1 = 1;
+------+----+
| c1   | c2 |
+------+----+
+------+----+
EXPLAIN update t2_null set c2 = c1 + 1 where c2 is NULL and c1 = 1;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |UPDATE     |       |3        |40  |
|1 | TABLE SCAN|t2_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_null: ({t2_null: (t2_null.__pk_increment, t2_null.c1, t2_null.c2)})}]),
      update([t2_null.c2=column_conv(INT,PS:(11,0),NOT NULL,cast(t2_null.c1 + 1, INT(-1, 0)))])
  1 - output([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2], [column_conv(INT,PS:(11,0),NOT NULL,cast(t2_null.c1 + 1, INT(-1, 0)))]), filter(nil), startup_filter([0]), 
      access([t2_null.c2], [t2_null.c1], [t2_null.__pk_increment]), partitions(p0)

update t2_null set c2 = c1 + 1 where c2 is NULL and c1 = 1;
EXPLAIN delete from t2_null where c2 is NULL and c1 = 1;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |DELETE     |       |3        |40  |
|1 | TABLE SCAN|t2_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_null: ({t2_null: (t2_null.__pk_increment, t2_null.c1, t2_null.c2)})}])
  1 - output([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2]), filter(nil), startup_filter([0]), 
      access([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2]), partitions(p0)

delete from t2_null where c2 is NULL and c1 = 1;
EXPLAIN insert into is_t2 select * from t2_null where c2 is NULL and c1 = 1;
Query Plan
=========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST|
-----------------------------------------
|0 |INSERT       |       |3        |38  |
|1 | SUBPLAN SCAN|VIEW1  |3        |37  |
|2 |  TABLE SCAN |t2_null|3        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t2_null.c1], [t2_null.c2]), filter(nil), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

insert into is_t2 select * from t2_null where c2 is NULL and c1 = 1;


******  pk is not NULL ==> true
EXPLAIN select /*+no_rewrite*/* from t1_null where c1 is not NULL;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t1_null|3        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter([(T_OP_IS_NOT, t1_null.c1, NULL, 0)]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

select /*+no_rewrite*/* from t1_null where c1 is not NULL;
+----+------+
| c1 | c2   |
+----+------+
|  1 |    1 |
|  2 |    2 |
|  3 |    3 |
+----+------+
EXPLAIN select * from t1_null where c1 is not NULL;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t1_null|3        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter(nil), startup_filter([1]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

select * from t1_null where c1 is not NULL;
+----+------+
| c1 | c2   |
+----+------+
|  1 |    1 |
|  2 |    2 |
|  3 |    3 |
+----+------+
EXPLAIN update t1_null set c2 = 0 where c1 is not NULL;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |UPDATE     |       |3        |40  |
|1 | TABLE SCAN|t1_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}]),
      update([t1_null.c2=?])
  1 - output([t1_null.c1], [t1_null.c2], [?]), filter(nil), startup_filter([1]), 
      access([t1_null.c2], [t1_null.c1]), partitions(p0)

update t1_null set c2 = 0 where c1 is not NULL;
EXPLAIN delete from t1_null where c1 is not NULL;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |DELETE     |       |3        |40  |
|1 | TABLE SCAN|t1_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}])
  1 - output([t1_null.c1], [t1_null.c2]), filter(nil), startup_filter([1]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

delete from t1_null where c1 is not NULL;
EXPLAIN insert into is_t2 select * from t1_null where c1 is not NULL;
Query Plan
==========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST |
------------------------------------------
|0 |INSERT       |       |100000   |89464|
|1 | SUBPLAN SCAN|VIEW1  |100000   |75662|
|2 |  TABLE SCAN |t1_null|100000   |61860|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([1]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

insert into is_t2 select * from t1_null where c1 is not NULL;


******  多个表达式，pk is not NULL ==> true
EXPLAIN select /*+no_rewrite*/* from t1_null where c1 is not NULL and c2 = 1;
Query Plan
=======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST |
---------------------------------------
|0 |TABLE SCAN|t1_null|990      |86977|
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter([t1_null.c2 = 1], [(T_OP_IS_NOT, t1_null.c1, NULL, 0)]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

select /*+no_rewrite*/* from t1_null where c1 is not NULL and c2 = 1;
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN select * from t1_null where c1 is not NULL and c2 = 1;
Query Plan
=======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST |
---------------------------------------
|0 |TABLE SCAN|t1_null|990      |78605|
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter([t1_null.c2 = 1]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

select * from t1_null where c1 is not NULL and c2 = 1;
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN update t1_null set c2 = 0 where c1 is not NULL and c2 = 1;
Query Plan
========================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST |
----------------------------------------
|0 |UPDATE     |       |990      |79595|
|1 | TABLE SCAN|t1_null|990      |78605|
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}]),
      update([t1_null.c2=?])
  1 - output([t1_null.c1], [t1_null.c2], [?]), filter([t1_null.c2 = 1]), 
      access([t1_null.c2], [t1_null.c1]), partitions(p0)

update t1_null set c2 = 0 where c1 is not NULL and c2 = 1;
EXPLAIN delete from t1_null where c1 is not NULL and c2 = 1;
Query Plan
========================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST |
----------------------------------------
|0 |DELETE     |       |990      |79595|
|1 | TABLE SCAN|t1_null|990      |78605|
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}])
  1 - output([t1_null.c1], [t1_null.c2]), filter([t1_null.c2 = 1]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

delete from t1_null where c1 is not NULL and c2 = 1;
EXPLAIN insert into is_t2 select * from t1_null where c1 is not NULL and c2 = 1;
Query Plan
==========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST |
------------------------------------------
|0 |INSERT       |       |990      |78878|
|1 | SUBPLAN SCAN|VIEW1  |990      |78742|
|2 |  TABLE SCAN |t1_null|990      |78605|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_null.c1], [t1_null.c2]), filter([t1_null.c2 = 1]), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)

insert into is_t2 select * from t1_null where c1 is not NULL and c2 = 1;


****** column(not NULL) is not NULL ==> true
EXPLAIN select /*+no_rewrite*/* from t2_null where c2 is not NULL;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t2_null|3        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_null.c1], [t2_null.c2]), filter([(T_OP_IS_NOT, t2_null.c2, NULL, 0)]), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

select /*+no_rewrite*/* from t2_null where c2 is not NULL;
+------+----+
| c1   | c2 |
+------+----+
|    4 |  4 |
|    5 |  5 |
|    6 |  6 |
+------+----+
EXPLAIN select * from t2_null where c2 is not NULL;
Query Plan
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|t2_null|3        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_null.c1], [t2_null.c2]), filter(nil), startup_filter([1]), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

select * from t2_null where c2 is not NULL;
+------+----+
| c1   | c2 |
+------+----+
|    4 |  4 |
|    5 |  5 |
|    6 |  6 |
+------+----+
EXPLAIN update t2_null set c2 = c1 + 1 where c2 is not NULL;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |UPDATE     |       |3        |40  |
|1 | TABLE SCAN|t2_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_null: ({t2_null: (t2_null.__pk_increment, t2_null.c1, t2_null.c2)})}]),
      update([t2_null.c2=column_conv(INT,PS:(11,0),NOT NULL,cast(t2_null.c1 + 1, INT(-1, 0)))])
  1 - output([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2], [column_conv(INT,PS:(11,0),NOT NULL,cast(t2_null.c1 + 1, INT(-1, 0)))]), filter(nil), startup_filter([1]), 
      access([t2_null.c2], [t2_null.c1], [t2_null.__pk_increment]), partitions(p0)

update t2_null set c2 = c1 + 1 where c2 is not NULL;
EXPLAIN delete from t2_null where c2 is not NULL;
Query Plan
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |DELETE     |       |3        |40  |
|1 | TABLE SCAN|t2_null|3        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_null: ({t2_null: (t2_null.__pk_increment, t2_null.c1, t2_null.c2)})}])
  1 - output([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2]), filter(nil), startup_filter([1]), 
      access([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2]), partitions(p0)

delete from t2_null where c2 is not NULL;
EXPLAIN insert into is_t2 select * from t2_null where c2 is not NULL;
Query Plan
==========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST |
------------------------------------------
|0 |INSERT       |       |100000   |91670|
|1 | SUBPLAN SCAN|VIEW1  |100000   |77868|
|2 |  TABLE SCAN |t2_null|100000   |64066|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([1]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t2_null.c1], [t2_null.c2]), filter(nil), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

insert into is_t2 select * from t2_null where c2 is not NULL;


****** 多个表达式, column(not NULL) is not NULL ==> true
EXPLAIN select /*+no_rewrite*/* from t2_null where c2 is not NULL and c1 = 1;
Query Plan
=======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST |
---------------------------------------
|0 |TABLE SCAN|t2_null|981      |89183|
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_null.c1], [t2_null.c2]), filter([t2_null.c1 = 1], [(T_OP_IS_NOT, t2_null.c2, NULL, 0)]), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

select /*+no_rewrite*/* from t2_null where c2 is not NULL and c1 = 1;
+------+----+
| c1   | c2 |
+------+----+
+------+----+
EXPLAIN select * from t2_null where c2 is not NULL and c1 = 1;
Query Plan
=======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST |
---------------------------------------
|0 |TABLE SCAN|t2_null|990      |80811|
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_null.c1], [t2_null.c2]), filter([t2_null.c1 = 1]), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

select * from t2_null where c2 is not NULL and c1 = 1;
+------+----+
| c1   | c2 |
+------+----+
+------+----+
EXPLAIN update t2_null set c2 = c1 + 1 where c2 is not NULL and c1 = 1;
Query Plan
========================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST |
----------------------------------------
|0 |UPDATE     |       |990      |81801|
|1 | TABLE SCAN|t2_null|990      |80811|
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_null: ({t2_null: (t2_null.__pk_increment, t2_null.c1, t2_null.c2)})}]),
      update([t2_null.c2=column_conv(INT,PS:(11,0),NOT NULL,cast(t2_null.c1 + 1, INT(-1, 0)))])
  1 - output([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2], [column_conv(INT,PS:(11,0),NOT NULL,cast(t2_null.c1 + 1, INT(-1, 0)))]), filter([t2_null.c1 = 1]), 
      access([t2_null.c2], [t2_null.c1], [t2_null.__pk_increment]), partitions(p0)

update t2_null set c2 = c1 + 1 where c2 is not NULL and c1 = 1;
EXPLAIN delete from t2_null where c2 is not NULL and c1 = 1;
Query Plan
========================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST |
----------------------------------------
|0 |DELETE     |       |990      |81801|
|1 | TABLE SCAN|t2_null|990      |80811|
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_null: ({t2_null: (t2_null.__pk_increment, t2_null.c1, t2_null.c2)})}])
  1 - output([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2]), filter([t2_null.c1 = 1]), 
      access([t2_null.__pk_increment], [t2_null.c1], [t2_null.c2]), partitions(p0)

delete from t2_null where c2 is not NULL and c1 = 1;
EXPLAIN insert into is_t2 select * from t2_null where c2 is not NULL and c1 = 1;
Query Plan
==========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST |
------------------------------------------
|0 |INSERT       |       |990      |81084|
|1 | SUBPLAN SCAN|VIEW1  |990      |80947|
|2 |  TABLE SCAN |t2_null|990      |80811|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t2_null.c1], [t2_null.c2]), filter([t2_null.c1 = 1]), 
      access([t2_null.c2], [t2_null.c1]), partitions(p0)

insert into is_t2 select * from t2_null where c2 is not NULL and c1 = 1;

****** 子查询中 pk is null ==> false
EXPLAIN select /*+no_rewrite*/* from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);
Query Plan
===========================================
|ID|OPERATOR      |NAME   |EST. ROWS|COST |
-------------------------------------------
|0 |SUBPLAN FILTER|       |1        |95527|
|1 | TABLE SCAN   |t1_null|100000   |61860|
|2 | TABLE SCAN   |t2_null|1        |36   |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter([t1_null.c1 = subquery(1)]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)
  2 - output([t2_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

select /*+no_rewrite*/* from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN select * from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);
Query Plan
==========================================
|ID|OPERATOR      |NAME   |EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER|       |1        |72  |
|1 | TABLE GET    |t1_null|1        |36  |
|2 | TABLE SCAN   |t2_null|1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)
  2 - output([t2_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN update t1_null set c2 = c1 + 1  where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);
Query Plan
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE         |       |1        |73  |
|1 | SUBPLAN FILTER|       |1        |72  |
|2 |  TABLE GET    |t1_null|1        |36  |
|3 |  TABLE SCAN   |t2_null|1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}]),
      update([t1_null.c2=column_conv(INT,PS:(11,0),NULL,cast(t1_null.c1 + 1, INT(-1, 0)))])
  1 - output([t1_null.c1], [t1_null.c2], [column_conv(INT,PS:(11,0),NULL,cast(t1_null.c1 + 1, INT(-1, 0)))]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1_null.c2], [t1_null.c1]), filter(nil), 
      access([t1_null.c2], [t1_null.c1]), partitions(p0)
  3 - output([t2_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1_null set c2 = c1 + 1  where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);
EXPLAIN delete from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);
Query Plan
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |DELETE         |       |1        |73  |
|1 | SUBPLAN FILTER|       |1        |72  |
|2 |  TABLE GET    |t1_null|1        |36  |
|3 |  TABLE SCAN   |t2_null|1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}])
  1 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)
  3 - output([t2_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);
EXPLAIN insert into is_t2 select * from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);
Query Plan
============================================
|ID|OPERATOR        |NAME   |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT          |       |1        |73  |
|1 | SUBPLAN SCAN   |VIEW1  |1        |73  |
|2 |  SUBPLAN FILTER|       |1        |72  |
|3 |   TABLE GET    |t1_null|1        |36  |
|4 |   TABLE SCAN   |t2_null|1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)
  4 - output([t2_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NULL limit 1);

****** 子查询中 pk is not null ==> true
EXPLAIN select /*+no_rewrite*/* from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
Query Plan
===========================================
|ID|OPERATOR      |NAME   |EST. ROWS|COST |
-------------------------------------------
|0 |SUBPLAN FILTER|       |1        |95527|
|1 | TABLE SCAN   |t1_null|100000   |61860|
|2 | TABLE SCAN   |t2_null|1        |36   |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter([t1_null.c1 = subquery(1)]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)
  2 - output([t2_null.c1]), filter(nil), startup_filter([1]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

select /*+no_rewrite*/* from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN select * from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
Query Plan
==========================================
|ID|OPERATOR      |NAME   |EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER|       |1        |72  |
|1 | TABLE GET    |t1_null|1        |36  |
|2 | TABLE SCAN   |t2_null|1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)
  2 - output([t2_null.c1]), filter(nil), startup_filter([1]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
+----+------+
| c1 | c2   |
+----+------+
+----+------+
EXPLAIN update t1_null set c2 = c1 + 1 where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
Query Plan
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |UPDATE         |       |1        |73  |
|1 | SUBPLAN FILTER|       |1        |72  |
|2 |  TABLE GET    |t1_null|1        |36  |
|3 |  TABLE SCAN   |t2_null|1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}]),
      update([t1_null.c2=column_conv(INT,PS:(11,0),NULL,cast(t1_null.c1 + 1, INT(-1, 0)))])
  1 - output([t1_null.c1], [t1_null.c2], [column_conv(INT,PS:(11,0),NULL,cast(t1_null.c1 + 1, INT(-1, 0)))]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1_null.c2], [t1_null.c1]), filter(nil), 
      access([t1_null.c2], [t1_null.c1]), partitions(p0)
  3 - output([t2_null.c1]), filter(nil), startup_filter([1]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1_null set c2 = c1 + 1 where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
EXPLAIN delete from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
Query Plan
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |DELETE         |       |1        |73  |
|1 | SUBPLAN FILTER|       |1        |72  |
|2 |  TABLE GET    |t1_null|1        |36  |
|3 |  TABLE SCAN   |t2_null|1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_null: ({t1_null: (t1_null.c1, t1_null.c2)})}])
  1 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)
  3 - output([t2_null.c1]), filter(nil), startup_filter([1]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
EXPLAIN insert into is_t2 select * from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
Query Plan
============================================
|ID|OPERATOR        |NAME   |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT          |       |1        |73  |
|1 | SUBPLAN SCAN   |VIEW1  |1        |73  |
|2 |  SUBPLAN FILTER|       |1        |72  |
|3 |   TABLE GET    |t1_null|1        |36  |
|4 |   TABLE SCAN   |t2_null|1        |36  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1_null.c1], [t1_null.c2]), filter(nil), 
      access([t1_null.c1], [t1_null.c2]), partitions(p0)
  4 - output([t2_null.c1]), filter(nil), startup_filter([1]), 
      access([t2_null.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1_null where t1_null.c1 = (select t2_null.c1 from t2_null where t1_null.c1 is NOT NULL limit 1);
drop table t1_null, t2_null;

************************* replace is null condition, end*********

************************* replace op null condition, begin *********

drop table if exists t1_op_null, t2_op_null;
create table t1_op_null(c1 int , c2 int);
create table t2_op_null(c1 int , c2 int );
insert/*trace*/ into t1_op_null values (1,1),(2,null),(3,3);
insert/*trace*/ into t2_op_null values (null,4),(5,5),(null,6);


******  compare null ==> false
EXPLAIN select /*+no_rewrite*/ * from t1_op_null where c1 = NULL;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t1_op_null|0        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c1 = NULL]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select /*+no_rewrite*/ * from t1_op_null where c1 = NULL;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1_op_null where c1 = NULL;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t1_op_null|3        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), startup_filter([0]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select * from t1_op_null where c1 = NULL;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN update t1_op_null set c2 = 0 where c1 != NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |UPDATE     |          |3        |40  |
|1 | TABLE SCAN|t1_op_null|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}]),
      update([t1_op_null.c2=?])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2], [?]), filter(nil), startup_filter([0]), 
      access([t1_op_null.c2], [t1_op_null.__pk_increment], [t1_op_null.c1]), partitions(p0)

update t1_op_null set c2 = 0 where c1 != NULL;
EXPLAIN delete from t1_op_null where c1 > NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |DELETE     |          |3        |40  |
|1 | TABLE SCAN|t1_op_null|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), filter(nil), startup_filter([0]), 
      access([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

delete from t1_op_null where c1 > NULL;
EXPLAIN insert into is_t2 select * from t1_op_null where c1 < NULL;
Query Plan
============================================
|ID|OPERATOR     |NAME      |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT       |          |3        |38  |
|1 | SUBPLAN SCAN|VIEW1     |3        |37  |
|2 |  TABLE SCAN |t1_op_null|3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

insert into is_t2 select * from t1_op_null where c1 < NULL;
EXPLAIN select * from t1_op_null where c1 <> NULL;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t1_op_null|3        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), startup_filter([0]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select * from t1_op_null where c1 <> NULL;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN update t1_op_null set c2 = 0 where c1 >= NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |UPDATE     |          |3        |40  |
|1 | TABLE SCAN|t1_op_null|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}]),
      update([t1_op_null.c2=?])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2], [?]), filter(nil), startup_filter([0]), 
      access([t1_op_null.c2], [t1_op_null.__pk_increment], [t1_op_null.c1]), partitions(p0)

update t1_op_null set c2 = 0 where c1 >= NULL;
EXPLAIN delete from t1_op_null where c1 <= NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |DELETE     |          |3        |40  |
|1 | TABLE SCAN|t1_op_null|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), filter(nil), startup_filter([0]), 
      access([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

delete from t1_op_null where c1 <= NULL;


****** 多个表达式, compare null ==> false
EXPLAIN select /*+no_rewrite*/* from t1_op_null where c1 = NULL and c2 = 1;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t1_op_null|0        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c1 = NULL], [t1_op_null.c2 = 1]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select /*+no_rewrite*/* from t1_op_null where c1 = NULL and c2 = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1_op_null where c1 <> NULL or c2 = 1;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t1_op_null|1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c2 = 1]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select * from t1_op_null where c1 <> NULL or c2 = 1;
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
+------+------+
EXPLAIN update t1_op_null set c2 = 0 where c1 != NULL and c2 = 1;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |UPDATE     |          |3        |40  |
|1 | TABLE SCAN|t1_op_null|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}]),
      update([t1_op_null.c2=?])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2], [?]), filter(nil), startup_filter([0]), 
      access([t1_op_null.c2], [t1_op_null.__pk_increment], [t1_op_null.c1]), partitions(p0)

update t1_op_null set c2 = 0 where c1 != NULL and c2 = 1;
EXPLAIN delete from t1_op_null where c1 >= NULL or c2 = 1;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |DELETE     |          |1        |38  |
|1 | TABLE SCAN|t1_op_null|1        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c2 = 1]), 
      access([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

delete from t1_op_null where c1 >= NULL or c2 = 1;
EXPLAIN insert into is_t2 select * from t1_op_null where c1 <= NULL and c2 = 1;
Query Plan
============================================
|ID|OPERATOR     |NAME      |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT       |          |2        |37  |
|1 | SUBPLAN SCAN|VIEW1     |2        |37  |
|2 |  TABLE SCAN |t1_op_null|2        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

insert into is_t2 select * from t1_op_null where c1 <= NULL and c2 = 1;
EXPLAIN select * from t1_op_null where c1 <> NULL or c2=1;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t1_op_null|1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c2 = 1]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select * from t1_op_null where c1 <> NULL or c2=1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN update t1_op_null set c2 = 0 where c1 =1 and c2 < NULL or c1=NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |UPDATE     |          |2        |39  |
|1 | TABLE SCAN|t1_op_null|2        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}]),
      update([t1_op_null.c2=?])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2], [?]), filter(nil), startup_filter([0]), 
      access([t1_op_null.c2], [t1_op_null.__pk_increment], [t1_op_null.c1]), partitions(p0)

update t1_op_null set c2 = 0 where c1 =1 and c2 < NULL or c1=NULL;
EXPLAIN delete from t1_op_null where c1 >= NULL or c2 = 1 and c1=3 and c2=1 and c2=NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |DELETE     |          |2        |39  |
|1 | TABLE SCAN|t1_op_null|2        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), filter(nil), startup_filter([0]), 
      access([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

delete from t1_op_null where c1 >= NULL or c2 = 1 and c1=3 and c2=1 and c2=NULL;
EXPLAIN insert into is_t2 select * from t1_op_null where c1 <= NULL or c2 != NULL or c1=NULL or c2=1;
Query Plan
============================================
|ID|OPERATOR     |NAME      |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT       |          |1        |38  |
|1 | SUBPLAN SCAN|VIEW1     |1        |37  |
|2 |  TABLE SCAN |t1_op_null|1        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c2 = 1]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

insert into is_t2 select * from t1_op_null where c1 <= NULL or c2 != NULL or c1=NULL or c2=1;


****** operator with NULL ==> false
EXPLAIN select /*+no_rewrite*/* from t2_op_null where c2 = NULL+c1;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t2_op_null|1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_op_null.c1], [t2_op_null.c2]), filter([cast(t2_op_null.c2, DOUBLE(-1, -1)) = NULL + cast(t2_op_null.c1, DOUBLE(-1, -1))]), 
      access([t2_op_null.c2], [t2_op_null.c1]), partitions(p0)

select /*+no_rewrite*/* from t2_op_null where c2 = NULL+c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2_op_null where c2 = NULL+c1;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t2_op_null|3        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_op_null.c1], [t2_op_null.c2]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c2], [t2_op_null.c1]), partitions(p0)

select * from t2_op_null where c2 = NULL+c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN update t2_op_null set c1 = c2 + 1 where c2 = c1-NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |UPDATE     |          |3        |40  |
|1 | TABLE SCAN|t2_op_null|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_op_null: ({t2_op_null: (t2_op_null.__pk_increment, t2_op_null.c1, t2_op_null.c2)})}]),
      update([t2_op_null.c1=column_conv(INT,PS:(11,0),NULL,cast(t2_op_null.c2 + 1, INT(-1, 0)))])
  1 - output([t2_op_null.__pk_increment], [t2_op_null.c1], [t2_op_null.c2], [column_conv(INT,PS:(11,0),NULL,cast(t2_op_null.c2 + 1, INT(-1, 0)))]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1], [t2_op_null.c2], [t2_op_null.__pk_increment]), partitions(p0)

update t2_op_null set c1 = c2 + 1 where c2 = c1-NULL;
EXPLAIN delete from t2_op_null where c2 =c1*NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |DELETE     |          |3        |40  |
|1 | TABLE SCAN|t2_op_null|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_op_null: ({t2_op_null: (t2_op_null.__pk_increment, t2_op_null.c1, t2_op_null.c2)})}])
  1 - output([t2_op_null.__pk_increment], [t2_op_null.c1], [t2_op_null.c2]), filter(nil), startup_filter([0]), 
      access([t2_op_null.__pk_increment], [t2_op_null.c1], [t2_op_null.c2]), partitions(p0)

delete from t2_op_null where c2 =c1*NULL;
EXPLAIN insert into is_t2 select * from t2_op_null where c2 = c1/NULL;
Query Plan
============================================
|ID|OPERATOR     |NAME      |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT       |          |3        |38  |
|1 | SUBPLAN SCAN|VIEW1     |3        |37  |
|2 |  TABLE SCAN |t2_op_null|3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t2_op_null.c1], [t2_op_null.c2]), filter(nil), 
      access([t2_op_null.c2], [t2_op_null.c1]), partitions(p0)

insert into is_t2 select * from t2_op_null where c2 = c1/NULL;
EXPLAIN update t2_op_null set c1 = c2 + 1 where c2 = c1 | NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |UPDATE     |          |1        |37  |
|1 | TABLE SCAN|t2_op_null|1        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_op_null: ({t2_op_null: (t2_op_null.__pk_increment, t2_op_null.c1, t2_op_null.c2)})}]),
      update([t2_op_null.c1=column_conv(INT,PS:(11,0),NULL,cast(t2_op_null.c2 + 1, INT(-1, 0)))])
  1 - output([t2_op_null.__pk_increment], [t2_op_null.c1], [t2_op_null.c2], [column_conv(INT,PS:(11,0),NULL,cast(t2_op_null.c2 + 1, INT(-1, 0)))]), filter([t2_op_null.c2 = (T_OP_BIT_OR, cast(t2_op_null.c1, BIGINT UNSIGNED(-1, 0)), ?)]), 
      access([t2_op_null.c1], [t2_op_null.c2], [t2_op_null.__pk_increment]), partitions(p0)

update t2_op_null set c1 = c2 + 1 where c2 = c1 | NULL;
EXPLAIN delete from t2_op_null where c2 =c1 & NULL;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |DELETE     |          |1        |37  |
|1 | TABLE SCAN|t2_op_null|1        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_op_null: ({t2_op_null: (t2_op_null.__pk_increment, t2_op_null.c1, t2_op_null.c2)})}])
  1 - output([t2_op_null.__pk_increment], [t2_op_null.c1], [t2_op_null.c2]), filter([t2_op_null.c2 = (T_OP_BIT_AND, cast(t2_op_null.c1, BIGINT UNSIGNED(-1, 0)), ?)]), 
      access([t2_op_null.__pk_increment], [t2_op_null.c1], [t2_op_null.c2]), partitions(p0)

delete from t2_op_null where c2 =c1 & NULL;
EXPLAIN insert into is_t2 select * from t2_op_null where c2 = c1 mod NULL;
Query Plan
============================================
|ID|OPERATOR     |NAME      |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT       |          |3        |38  |
|1 | SUBPLAN SCAN|VIEW1     |3        |37  |
|2 |  TABLE SCAN |t2_op_null|3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t2_op_null.c1], [t2_op_null.c2]), filter(nil), 
      access([t2_op_null.c2], [t2_op_null.c1]), partitions(p0)

insert into is_t2 select * from t2_op_null where c2 = c1 mod NULL;


****** 多个表达式, operator NULL ==> false
EXPLAIN select /*+no_rewrite*/* from t2_op_null where c2 = c1+NULL and c1 = 1;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t2_op_null|1        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_op_null.c1], [t2_op_null.c2]), filter([cast(t2_op_null.c2, DOUBLE(-1, -1)) = cast(t2_op_null.c1, DOUBLE(-1, -1)) + NULL], [t2_op_null.c1 = 1]), 
      access([t2_op_null.c2], [t2_op_null.c1]), partitions(p0)

select /*+no_rewrite*/* from t2_op_null where c2 = c1+NULL and c1 = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2_op_null where c2 = NULL-c1 or c1 = 1;
Query Plan
=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t2_op_null|1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_op_null.c1], [t2_op_null.c2]), filter([t2_op_null.c1 = 1]), 
      access([t2_op_null.c2], [t2_op_null.c1]), partitions(p0)

select * from t2_op_null where c2 = NULL-c1 or c1 = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN update t2_op_null set c2 = c1 + 1 where c2 = c1/NULL or c2 = c1*NULL and c2=c1 & NULL ;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |UPDATE     |          |3        |40  |
|1 | TABLE SCAN|t2_op_null|3        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_op_null: ({t2_op_null: (t2_op_null.__pk_increment, t2_op_null.c1, t2_op_null.c2)})}]),
      update([t2_op_null.c2=column_conv(INT,PS:(11,0),NULL,cast(t2_op_null.c1 + 1, INT(-1, 0)))])
  1 - output([t2_op_null.__pk_increment], [t2_op_null.c1], [t2_op_null.c2], [column_conv(INT,PS:(11,0),NULL,cast(t2_op_null.c1 + 1, INT(-1, 0)))]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c2], [t2_op_null.c1], [t2_op_null.__pk_increment]), partitions(p0)

update t2_op_null set c2 = c1 + 1 where c2 = c1/NULL or c2 = c1*NULL and c2=c1 & NULL ;
EXPLAIN delete from t2_op_null where c2 = c1 mod NULL  or c1 = NULL or c2=c1 | NULL or c1=1;
Query Plan
==========================================
|ID|OPERATOR   |NAME      |EST. ROWS|COST|
------------------------------------------
|0 |DELETE     |          |2        |38  |
|1 | TABLE SCAN|t2_op_null|2        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2_op_null: ({t2_op_null: (t2_op_null.__pk_increment, t2_op_null.c1, t2_op_null.c2)})}])
  1 - output([t2_op_null.__pk_increment], [t2_op_null.c1], [t2_op_null.c2]), filter([t2_op_null.c2 = (T_OP_BIT_OR, cast(t2_op_null.c1, BIGINT UNSIGNED(-1, 0)), ?) OR t2_op_null.c1 = 1]), 
      access([t2_op_null.__pk_increment], [t2_op_null.c1], [t2_op_null.c2]), partitions(p0)

delete from t2_op_null where c2 = c1 mod NULL  or c1 = NULL or c2=c1 | NULL or c1=1;
EXPLAIN insert into is_t2 select * from t2_op_null where c2 = NULL and c1 =c2 >> NULL and c1=c2 << NULL ;
Query Plan
============================================
|ID|OPERATOR     |NAME      |EST. ROWS|COST|
--------------------------------------------
|0 |INSERT       |          |3        |38  |
|1 | SUBPLAN SCAN|VIEW1     |3        |37  |
|2 |  TABLE SCAN |t2_op_null|3        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t2_op_null.c1], [t2_op_null.c2]), filter(nil), 
      access([t2_op_null.c2], [t2_op_null.c1]), partitions(p0)

insert into is_t2 select * from t2_op_null where c2 = NULL and c1 =c2 >> NULL and c1=c2 << NULL ;

****** 子查询中 has null ==> false
EXPLAIN select /*+no_rewrite*/* from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = NULL limit 1);
Query Plan
=============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST|
---------------------------------------------
|0 |SUBPLAN FILTER|          |1        |74  |
|1 | TABLE SCAN   |t1_op_null|2        |37  |
|2 | TABLE SCAN   |t2_op_null|1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c1 = subquery(1)]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)
  2 - output([t2_op_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1]), partitions(p0), 
      limit(1), offset(nil)

select /*+no_rewrite*/* from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = NULL limit 1);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = NULL limit 1);
Query Plan
=============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST|
---------------------------------------------
|0 |SUBPLAN FILTER|          |1        |73  |
|1 | TABLE SCAN   |t1_op_null|1        |37  |
|2 | TABLE SCAN   |t2_op_null|1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c1 = ?]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)
  2 - output([t2_op_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = NULL limit 1);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN update t1_op_null set c2 = c1 + 1  where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 != NULL limit 1);
Query Plan
==============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST|
----------------------------------------------
|0 |UPDATE         |          |1        |74  |
|1 | SUBPLAN FILTER|          |1        |73  |
|2 |  TABLE SCAN   |t1_op_null|1        |37  |
|3 |  TABLE SCAN   |t2_op_null|1        |36  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}]),
      update([t1_op_null.c2=column_conv(INT,PS:(11,0),NULL,cast(t1_op_null.c1 + 1, INT(-1, 0)))])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2], [column_conv(INT,PS:(11,0),NULL,cast(t1_op_null.c1 + 1, INT(-1, 0)))]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1_op_null.c2], [t1_op_null.c1], [t1_op_null.__pk_increment]), filter([t1_op_null.c1 = ?]), 
      access([t1_op_null.c2], [t1_op_null.c1], [t1_op_null.__pk_increment]), partitions(p0)
  3 - output([t2_op_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1_op_null set c2 = c1 + 1  where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 != NULL limit 1);
EXPLAIN delete from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 >= NULL limit 1);
Query Plan
==============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST|
----------------------------------------------
|0 |DELETE         |          |1        |74  |
|1 | SUBPLAN FILTER|          |1        |73  |
|2 |  TABLE SCAN   |t1_op_null|1        |37  |
|3 |  TABLE SCAN   |t2_op_null|1        |36  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c1 = ?]), 
      access([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), partitions(p0)
  3 - output([t2_op_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 >= NULL limit 1);
EXPLAIN insert into is_t2 select * from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 <= NULL limit 1);
Query Plan
===============================================
|ID|OPERATOR        |NAME      |EST. ROWS|COST|
-----------------------------------------------
|0 |INSERT          |          |1        |73  |
|1 | SUBPLAN SCAN   |VIEW1     |1        |73  |
|2 |  SUBPLAN FILTER|          |1        |73  |
|3 |   TABLE SCAN   |t1_op_null|1        |37  |
|4 |   TABLE SCAN   |t2_op_null|1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c1 = ?]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)
  4 - output([t2_op_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 <= NULL limit 1);
EXPLAIN select * from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = t1_op_null.c2+NULL limit 1);
Query Plan
=============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST|
---------------------------------------------
|0 |SUBPLAN FILTER|          |1        |73  |
|1 | TABLE SCAN   |t1_op_null|1        |37  |
|2 | TABLE SCAN   |t2_op_null|1        |36  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c1 = ?]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)
  2 - output([t2_op_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = t1_op_null.c2+NULL limit 1);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN update t1_op_null set c2 = c1 + 1  where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = t1_op_null.c2-NULL limit 1);
Query Plan
==============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST|
----------------------------------------------
|0 |UPDATE         |          |1        |74  |
|1 | SUBPLAN FILTER|          |1        |73  |
|2 |  TABLE SCAN   |t1_op_null|1        |37  |
|3 |  TABLE SCAN   |t2_op_null|1        |36  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}]),
      update([t1_op_null.c2=column_conv(INT,PS:(11,0),NULL,cast(t1_op_null.c1 + 1, INT(-1, 0)))])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2], [column_conv(INT,PS:(11,0),NULL,cast(t1_op_null.c1 + 1, INT(-1, 0)))]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1_op_null.c2], [t1_op_null.c1], [t1_op_null.__pk_increment]), filter([t1_op_null.c1 = ?]), 
      access([t1_op_null.c2], [t1_op_null.c1], [t1_op_null.__pk_increment]), partitions(p0)
  3 - output([t2_op_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1_op_null set c2 = c1 + 1  where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = t1_op_null.c2-NULL limit 1);
EXPLAIN delete from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = t1_op_null.c2*NULL limit 1);
Query Plan
==============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST|
----------------------------------------------
|0 |DELETE         |          |1        |74  |
|1 | SUBPLAN FILTER|          |1        |73  |
|2 |  TABLE SCAN   |t1_op_null|1        |37  |
|3 |  TABLE SCAN   |t2_op_null|1        |36  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1_op_null: ({t1_op_null: (t1_op_null.__pk_increment, t1_op_null.c1, t1_op_null.c2)})}])
  1 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c1 = ?]), 
      access([t1_op_null.__pk_increment], [t1_op_null.c1], [t1_op_null.c2]), partitions(p0)
  3 - output([t2_op_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 = t1_op_null.c2*NULL limit 1);
EXPLAIN insert into is_t2 select * from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 =t1_op_null.c2/NULL limit 1);
Query Plan
===============================================
|ID|OPERATOR        |NAME      |EST. ROWS|COST|
-----------------------------------------------
|0 |INSERT          |          |1        |73  |
|1 | SUBPLAN SCAN   |VIEW1     |1        |73  |
|2 |  SUBPLAN FILTER|          |1        |73  |
|3 |   TABLE SCAN   |t1_op_null|1        |37  |
|4 |   TABLE SCAN   |t2_op_null|1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c2)]), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0)
  1 - output([VIEW1.c1], [VIEW1.c2]), filter(nil), 
      access([VIEW1.c1], [VIEW1.c2])
  2 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1_op_null.c1], [t1_op_null.c2]), filter([t1_op_null.c1 = ?]), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)
  4 - output([t2_op_null.c1]), filter(nil), startup_filter([0]), 
      access([t2_op_null.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1_op_null where t1_op_null.c1 = (select t2_op_null.c1 from t2_op_null where t1_op_null.c1 =t1_op_null.c2/NULL limit 1);

*****group by having 条件为null ==> false
EXPLAIN select * from t1_op_null group by c1 having count(*) = NULL;
Query Plan
=============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE GROUP BY|          |2        |39  |
|1 | SORT         |          |2        |38  |
|2 |  TABLE SCAN  |t1_op_null|2        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), startup_filter([0]), 
      group([t1_op_null.c1]), agg_func(nil)
  1 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), sort_keys([t1_op_null.c1, ASC])
  2 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select * from t1_op_null group by c1 having count(*) = NULL;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1_op_null group by c1 having count(*) != NULL;
Query Plan
=============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE GROUP BY|          |2        |39  |
|1 | SORT         |          |2        |38  |
|2 |  TABLE SCAN  |t1_op_null|2        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), startup_filter([0]), 
      group([t1_op_null.c1]), agg_func(nil)
  1 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), sort_keys([t1_op_null.c1, ASC])
  2 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select * from t1_op_null group by c1 having count(*) != NULL;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1_op_null where c1 like '%1' group by c1 having count(*) = NULL;
Query Plan
=============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE GROUP BY|          |2        |39  |
|1 | SORT         |          |2        |38  |
|2 |  TABLE SCAN  |t1_op_null|2        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), startup_filter([0]), 
      group([t1_op_null.c1]), agg_func(nil)
  1 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), sort_keys([t1_op_null.c1, ASC])
  2 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select * from t1_op_null where c1 like '%1' group by c1 having count(*) = NULL;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1_op_null where c1 like '%1' group by c1 having count(*) != NULL;
Query Plan
=============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE GROUP BY|          |2        |39  |
|1 | SORT         |          |2        |38  |
|2 |  TABLE SCAN  |t1_op_null|2        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), startup_filter([0]), 
      group([t1_op_null.c1]), agg_func(nil)
  1 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), sort_keys([t1_op_null.c1, ASC])
  2 - output([t1_op_null.c1], [t1_op_null.c2]), filter(nil), 
      access([t1_op_null.c1], [t1_op_null.c2]), partitions(p0)

select * from t1_op_null where c1 like '%1' group by c1 having count(*) != NULL;
+------+------+
| c1   | c2   |
+------+------+
+------+------+


************************* replace op null condition, end*********

************************改写向量等值条件 begin**********

drop table if exists t1, t2;
create table t1 (id int, a int, b int, c varchar(10), d decimal);
create table is_t4 (id int, a int, b int, c varchar(10), d decimal);
insert/*trace*/ into t1 values (0 , 0, 0, '0', 0);
insert/*trace*/ into t1 values (1 , 1, 0, '0', 0);
insert/*trace*/ into t1 values (2 , 0, 1, '0', 0);
insert/*trace*/ into t1 values (3 , 1, 1, '0', 0);
insert/*trace*/ into t1 values (4 , 0, 0, '1', 0);
insert/*trace*/ into t1 values (5 , 1, 0, '1', 0);
insert/*trace*/ into t1 values (6 , 0, 1, '1', 0);
insert/*trace*/ into t1 values (7 , 1, 1, '1', 0);
insert/*trace*/ into t1 values (8 , 0, 0, '0', 1);
insert/*trace*/ into t1 values (9 , 1, 0, '0', 1);
insert/*trace*/ into t1 values (10, 0, 1, '0', 1);
insert/*trace*/ into t1 values (11, 1, 1, '0', 1);
insert/*trace*/ into t1 values (12, 0, 0, '1', 1);
insert/*trace*/ into t1 values (13, 1, 0, '1', 1);
insert/*trace*/ into t1 values (14, 0, 1, '1', 1);
insert/*trace*/ into t1 values (15, 1, 1, '1', 1);


****** convert_preds_vector_to_scalar: case 1
EXPLAIN select /*+no_rewrite*/* from t1 where (a, b) = (1, 1);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |42  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([(t1.a, t1.b) = (1, 1)]), 
      access([t1.a], [t1.b], [t1.id], [t1.c], [t1.d]), partitions(p0)

select /*+no_rewrite*/* from t1 where (a, b) = (1, 1);
+------+------+------+------+------+
| id   | a    | b    | c    | d    |
+------+------+------+------+------+
|    3 |    1 |    1 | 0    |    0 |
|    7 |    1 |    1 | 1    |    0 |
|   11 |    1 |    1 | 0    |    1 |
|   15 |    1 |    1 | 1    |    1 |
+------+------+------+------+------+
EXPLAIN select * from t1 where (a, b) = (1, 1);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([t1.a = 1], [t1.b = 1]), 
      access([t1.a], [t1.b], [t1.id], [t1.c], [t1.d]), partitions(p0)

select * from t1 where (a, b) = (1, 1);
+------+------+------+------+------+
| id   | a    | b    | c    | d    |
+------+------+------+------+------+
|    3 |    1 |    1 | 0    |    0 |
|    7 |    1 |    1 | 1    |    0 |
|   11 |    1 |    1 | 0    |    1 |
|   15 |    1 |    1 | 1    |    1 |
+------+------+------+------+------+
EXPLAIN update t1 set a = b + 1 where (a, b) = (1, 1);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |46  |
|1 | TABLE SCAN|t1  |1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.id, t1.a, t1.b, t1.c, t1.d)})}]),
      update([t1.a=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 1, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 1, INT(-1, 0)))]), filter([t1.a = 1], [t1.b = 1]), 
      access([t1.a], [t1.b], [t1.__pk_increment], [t1.id], [t1.c], [t1.d]), partitions(p0)

update t1 set a = b + 1 where (a, b) = (1, 1);
EXPLAIN delete from t1 where (a, b) = (1, 1);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |46  |
|1 | TABLE SCAN|t1  |1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.id, t1.a, t1.b, t1.c, t1.d)})}])
  1 - output([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([t1.a = 1], [t1.b = 1]), 
      access([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), partitions(p0)

delete from t1 where (a, b) = (1, 1);
EXPLAIN insert into is_t4 select * from t1 where (a, b) = (1, 1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |1        |46  |
|1 | SUBPLAN SCAN|VIEW1|1        |46  |
|2 |  TABLE SCAN |t1   |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.id)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(VARCHAR,utf8mb4_general_ci,length:10,NULL,VIEW1.c)], [column_conv(DECIMAL,PS:(10,0),NULL,VIEW1.d)]), filter(nil), 
      columns([{is_t4: ({is_t4: (is_t4.__pk_increment, is_t4.id, is_t4.a, is_t4.b, is_t4.c, is_t4.d)})}]), partitions(p0)
  1 - output([VIEW1.id], [VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.d]), filter(nil), 
      access([VIEW1.id], [VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.d])
  2 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([t1.a = 1], [t1.b = 1]), 
      access([t1.a], [t1.b], [t1.id], [t1.c], [t1.d]), partitions(p0)

insert into is_t4 select * from t1 where (a, b) = (1, 1);


****** convert_preds_vector_to_scalar: case 2
EXPLAIN select /*+no_rewrite*/* from t1 where (a, c) = (1, 1);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |42  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([(t1.a, cast(t1.c, DECIMAL(-1, -1))) = (1, ?)]), 
      access([t1.a], [t1.c], [t1.id], [t1.b], [t1.d]), partitions(p0)

select /*+no_rewrite*/* from t1 where (a, c) = (1, 1);
+------+------+------+------+------+
| id   | a    | b    | c    | d    |
+------+------+------+------+------+
|    5 |    1 |    0 | 1    |    0 |
|   13 |    1 |    0 | 1    |    1 |
+------+------+------+------+------+
EXPLAIN select * from t1 where (a, c) = (1, 1);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([cast(t1.c, DECIMAL(-1, -1)) = ?], [t1.a = 1]), 
      access([t1.a], [t1.c], [t1.id], [t1.b], [t1.d]), partitions(p0)

select * from t1 where (a, c) = (1, 1);
+------+------+------+------+------+
| id   | a    | b    | c    | d    |
+------+------+------+------+------+
|    5 |    1 |    0 | 1    |    0 |
|   13 |    1 |    0 | 1    |    1 |
+------+------+------+------+------+
EXPLAIN update t1 set a = b + 1 where (a, c) = (1, 1);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |46  |
|1 | TABLE SCAN|t1  |1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.id, t1.a, t1.b, t1.c, t1.d)})}]),
      update([t1.a=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 1, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 1, INT(-1, 0)))]), filter([cast(t1.c, DECIMAL(-1, -1)) = ?], [t1.a = 1]), 
      access([t1.a], [t1.b], [t1.__pk_increment], [t1.id], [t1.c], [t1.d]), partitions(p0)

update t1 set a = b + 1 where (a, c) = (1, 1);
EXPLAIN delete from t1 where (a, c) = (1, 1);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |46  |
|1 | TABLE SCAN|t1  |1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.id, t1.a, t1.b, t1.c, t1.d)})}])
  1 - output([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([cast(t1.c, DECIMAL(-1, -1)) = ?], [t1.a = 1]), 
      access([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), partitions(p0)

delete from t1 where (a, c) = (1, 1);
EXPLAIN insert into is_t4 select * from t1 where (a, c) = (1, 1);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |1        |46  |
|1 | SUBPLAN SCAN|VIEW1|1        |46  |
|2 |  TABLE SCAN |t1   |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.id)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(VARCHAR,utf8mb4_general_ci,length:10,NULL,VIEW1.c)], [column_conv(DECIMAL,PS:(10,0),NULL,VIEW1.d)]), filter(nil), 
      columns([{is_t4: ({is_t4: (is_t4.__pk_increment, is_t4.id, is_t4.a, is_t4.b, is_t4.c, is_t4.d)})}]), partitions(p0)
  1 - output([VIEW1.id], [VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.d]), filter(nil), 
      access([VIEW1.id], [VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.d])
  2 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([cast(t1.c, DECIMAL(-1, -1)) = ?], [t1.a = 1]), 
      access([t1.a], [t1.c], [t1.id], [t1.b], [t1.d]), partitions(p0)

insert into is_t4 select * from t1 where (a, c) = (1, 1);


******convert_preds_vector_to_scalar: case 3
EXPLAIN select /*+no_rewrite*/* from t1 where (a, b) = (c, d);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |42  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([(cast(t1.a, DECIMAL(11, 0)), cast(t1.b, DECIMAL(11, 0))) = (cast(t1.c, DECIMAL(-1, -1)), t1.d)]), 
      access([t1.a], [t1.b], [t1.c], [t1.d], [t1.id]), partitions(p0)

select /*+no_rewrite*/* from t1 where (a, b) = (c, d);
+------+------+------+------+------+
| id   | a    | b    | c    | d    |
+------+------+------+------+------+
|    0 |    0 |    0 | 0    |    0 |
|   10 |    0 |    1 | 0    |    1 |
+------+------+------+------+------+
EXPLAIN select * from t1 where (a, b) = (c, d);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([cast(t1.a, DECIMAL(11, 0)) = cast(t1.c, DECIMAL(-1, -1))], [cast(t1.b, DECIMAL(11, 0)) = t1.d]), 
      access([t1.a], [t1.b], [t1.c], [t1.d], [t1.id]), partitions(p0)

select * from t1 where (a, b) = (c, d);
+------+------+------+------+------+
| id   | a    | b    | c    | d    |
+------+------+------+------+------+
|    0 |    0 |    0 | 0    |    0 |
|   10 |    0 |    1 | 0    |    1 |
+------+------+------+------+------+
EXPLAIN update t1 set a = b + 1 where (a, b) = (c, d);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |46  |
|1 | TABLE SCAN|t1  |1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.id, t1.a, t1.b, t1.c, t1.d)})}]),
      update([t1.a=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 1, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 1, INT(-1, 0)))]), filter([cast(t1.a, DECIMAL(11, 0)) = cast(t1.c, DECIMAL(-1, -1))], [cast(t1.b, DECIMAL(11, 0)) = t1.d]), 
      access([t1.a], [t1.b], [t1.__pk_increment], [t1.id], [t1.c], [t1.d]), partitions(p0)

update t1 set a = b + 1 where (a, b) = (c, d);
EXPLAIN delete from t1 where (a, b) = (c, d);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |46  |
|1 | TABLE SCAN|t1  |1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.id, t1.a, t1.b, t1.c, t1.d)})}])
  1 - output([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([cast(t1.a, DECIMAL(11, 0)) = cast(t1.c, DECIMAL(-1, -1))], [cast(t1.b, DECIMAL(11, 0)) = t1.d]), 
      access([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), partitions(p0)

delete from t1 where (a, b) = (c, d);
EXPLAIN insert into is_t4 select * from t1 where (a, b) = (c, d);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |1        |46  |
|1 | SUBPLAN SCAN|VIEW1|1        |46  |
|2 |  TABLE SCAN |t1   |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.id)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(VARCHAR,utf8mb4_general_ci,length:10,NULL,VIEW1.c)], [column_conv(DECIMAL,PS:(10,0),NULL,VIEW1.d)]), filter(nil), 
      columns([{is_t4: ({is_t4: (is_t4.__pk_increment, is_t4.id, is_t4.a, is_t4.b, is_t4.c, is_t4.d)})}]), partitions(p0)
  1 - output([VIEW1.id], [VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.d]), filter(nil), 
      access([VIEW1.id], [VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.d])
  2 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([cast(t1.a, DECIMAL(11, 0)) = cast(t1.c, DECIMAL(-1, -1))], [cast(t1.b, DECIMAL(11, 0)) = t1.d]), 
      access([t1.a], [t1.b], [t1.c], [t1.d], [t1.id]), partitions(p0)

insert into is_t4 select * from t1 where (a, b) = (c, d);


******convert_preds_vector_to_scalar: case 4
EXPLAIN select /*+no_rewrite*/* from t1 where (a, c, d) = (c, d, a);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |42  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([(cast(t1.a, DECIMAL(11, 0)), cast(t1.c, DECIMAL(-1, -1)), t1.d) = (cast(t1.c, DECIMAL(-1, -1)), t1.d, cast(t1.a, DECIMAL(11, 0)))]), 
      access([t1.a], [t1.c], [t1.d], [t1.id], [t1.b]), partitions(p0)

select /*+no_rewrite*/* from t1 where (a, c, d) = (c, d, a);
+------+------+------+------+------+
| id   | a    | b    | c    | d    |
+------+------+------+------+------+
|    2 |    0 |    1 | 0    |    0 |
+------+------+------+------+------+
EXPLAIN select * from t1 where (a, c, d) = (c, d, a);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([cast(t1.a, DECIMAL(11, 0)) = cast(t1.c, DECIMAL(-1, -1))], [t1.d = cast(t1.a, DECIMAL(11, 0))]), 
      access([t1.a], [t1.c], [t1.d], [t1.id], [t1.b]), partitions(p0)

select * from t1 where (a, c, d) = (c, d, a);
+------+------+------+------+------+
| id   | a    | b    | c    | d    |
+------+------+------+------+------+
|    2 |    0 |    1 | 0    |    0 |
+------+------+------+------+------+
EXPLAIN update t1 set a = b + 1 where (a, c, d) = (c, d, a);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |46  |
|1 | TABLE SCAN|t1  |1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.id, t1.a, t1.b, t1.c, t1.d)})}]),
      update([t1.a=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 1, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 1, INT(-1, 0)))]), filter([cast(t1.a, DECIMAL(11, 0)) = cast(t1.c, DECIMAL(-1, -1))], [t1.d = cast(t1.a, DECIMAL(11, 0))]), 
      access([t1.a], [t1.b], [t1.__pk_increment], [t1.id], [t1.c], [t1.d]), partitions(p0)

update t1 set a = b + 1 where (a, c, d) = (c, d, a);
EXPLAIN delete from t1 where (a, c, d) = (c, d, a);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |46  |
|1 | TABLE SCAN|t1  |1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.id, t1.a, t1.b, t1.c, t1.d)})}])
  1 - output([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([cast(t1.a, DECIMAL(11, 0)) = cast(t1.c, DECIMAL(-1, -1))], [t1.d = cast(t1.a, DECIMAL(11, 0))]), 
      access([t1.__pk_increment], [t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), partitions(p0)

delete from t1 where (a, c, d) = (c, d, a);
EXPLAIN insert into is_t4 select * from t1 where (a, c, d) = (c, d, a);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |1        |46  |
|1 | SUBPLAN SCAN|VIEW1|1        |46  |
|2 |  TABLE SCAN |t1   |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.id)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(VARCHAR,utf8mb4_general_ci,length:10,NULL,VIEW1.c)], [column_conv(DECIMAL,PS:(10,0),NULL,VIEW1.d)]), filter(nil), 
      columns([{is_t4: ({is_t4: (is_t4.__pk_increment, is_t4.id, is_t4.a, is_t4.b, is_t4.c, is_t4.d)})}]), partitions(p0)
  1 - output([VIEW1.id], [VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.d]), filter(nil), 
      access([VIEW1.id], [VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.d])
  2 - output([t1.id], [t1.a], [t1.b], [t1.c], [t1.d]), filter([cast(t1.a, DECIMAL(11, 0)) = cast(t1.c, DECIMAL(-1, -1))], [t1.d = cast(t1.a, DECIMAL(11, 0))]), 
      access([t1.a], [t1.c], [t1.d], [t1.id], [t1.b]), partitions(p0)

insert into is_t4 select * from t1 where (a, c, d) = (c, d, a);

drop table t1;


************************改写向量等值条件 end**********

********************remove dummy exprs begin************************

drop table if exists t1;
create table t1(a int, b int, c int);
create table t_temp(a int, b int, c int);
insert/*trace*/ into t1 values (1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);
set autocommit = 0;

******false or filter-> filter**********
EXPLAIN select * from t1 where false or t1.a < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |38  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where false or t1.a < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
|    1 |    1 |    1 |
|    2 |    2 |    2 |
+------+------+------+
EXPLAIN insert into t_temp select * from t1 where false or t1.a < 3;
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |1        |38  |
|1 | SUBPLAN SCAN|VIEW1|1        |38  |
|2 |  TABLE SCAN |t1   |1        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

insert into t_temp select * from t1 where false or t1.a < 3;
EXPLAIN insert /*+NO_REWRITE*/into t_temp select * from t1 where false or t1.a < 3;
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |1        |38  |
|1 | SUBPLAN SCAN|VIEW1|1        |38  |
|2 |  TABLE SCAN |t1   |1        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

insert /*+NO_REWRITE*/into t_temp select * from t1 where false or t1.a < 3;
EXPLAIN update t1 set t1.b = t1.b + 100 where false or t1.a < 3;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |39  |
|1 | TABLE SCAN|t1  |1        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}]),
      update([t1.b=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))]), filter([t1.a < 3]), 
      access([t1.b], [t1.__pk_increment], [t1.a], [t1.c]), partitions(p0)

update t1 set t1.b = t1.b + 100 where false or t1.a < 3;
EXPLAIN update /*+NO_REWRITE*/t1 set t1.b = t1.b + 100 where false or t1.a < 3;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |38  |
|1 | TABLE SCAN|t1  |1        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}]),
      update([t1.b=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))]), filter([0 OR t1.a < 3]), 
      access([t1.b], [t1.__pk_increment], [t1.a], [t1.c]), partitions(p0)

update /*+NO_REWRITE*/t1 set t1.b = t1.b + 100 where false or t1.a < 3;
EXPLAIN delete from t1 where false or t1.a < 3;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |39  |
|1 | TABLE SCAN|t1  |1        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), filter([t1.a < 3]), 
      access([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), partitions(p0)

delete from t1 where false or t1.a < 3;
EXPLAIN delete /*+NO_REWRITE*/from t1 where false or t1.a < 3;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |38  |
|1 | TABLE SCAN|t1  |1        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), filter([0 OR t1.a < 3]), 
      access([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), partitions(p0)

delete /*+NO_REWRITE*/from t1 where false or t1.a < 3;
EXPLAIN select * from t1 where t1.a < 3 or 1 > 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |38  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 or 1 > 2;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where false or t1.a < 3 or t1.b < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |38  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3 OR t1.b < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where false or t1.a < 3 or t1.b < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where t1.a < 3 or 1 > 2 or t1.b < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |38  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3 OR t1.b < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 or 1 > 2 or t1.b < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where false or false or t1.a < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |38  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where false or false or t1.a < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where t1.a < 3 or false or false;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |38  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 or false or false;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where false or (t1.a < 3 and t1.b < 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |39  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3], [t1.b < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where false or (t1.a < 3 and t1.b < 3);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+


******true or filter-> true**********
EXPLAIN select * from t1 where t1.a < 3 or true;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 or true;
+------+------+------+
| a    | b    | c    |
+------+------+------+
|    3 |    3 |    3 |
|    4 |    4 |    4 |
|    5 |    5 |    5 |
+------+------+------+
EXPLAIN insert into t_temp as select * from t1 where t1.a < 3 or true;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your OceanBase version for the right syntax to use near 'as select * from t1 where t1.a < 3 or true' at line 1
insert into t_temp as select * from t1 where t1.a < 3 or true;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your OceanBase version for the right syntax to use near 'as select * from t1 where t1.a < 3 or true' at line 1
EXPLAIN insert /*+NO_REWRITE*/into t_temp as select * from t1 where t1.a < 3 or true;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your OceanBase version for the right syntax to use near 'as select * from t1 where t1.a < 3 or true' at line 1
insert /*+NO_REWRITE*/into t_temp as select * from t1 where t1.a < 3 or true;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your OceanBase version for the right syntax to use near 'as select * from t1 where t1.a < 3 or true' at line 1
EXPLAIN update t1 set t1.b = t1.b + 100 where t1.a < 3 or true;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |5        |42  |
|1 | TABLE SCAN|t1  |5        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}]),
      update([t1.b=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))]), filter(nil), startup_filter([1]), 
      access([t1.b], [t1.__pk_increment], [t1.a], [t1.c]), partitions(p0)

update t1 set t1.b = t1.b + 100 where t1.a < 3 or true;
EXPLAIN update /*+NO_REWRITE*/t1 set t1.b = t1.b + 100 where t1.a < 3 or true;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |5        |43  |
|1 | TABLE SCAN|t1  |5        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}]),
      update([t1.b=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))]), filter([t1.a < 3 OR 1]), 
      access([t1.b], [t1.__pk_increment], [t1.a], [t1.c]), partitions(p0)

update /*+NO_REWRITE*/t1 set t1.b = t1.b + 100 where t1.a < 3 or true;
EXPLAIN delete from t1 where t1.a < 3 or true;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |5        |42  |
|1 | TABLE SCAN|t1  |5        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([1]), 
      access([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), partitions(p0)

delete from t1 where t1.a < 3 or true;
EXPLAIN delete /*+NO_REWRITE*/from t1 where t1.a < 3 or true;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |5        |43  |
|1 | TABLE SCAN|t1  |5        |38  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), filter([t1.a < 3 OR 1]), 
      access([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), partitions(p0)

delete /*+NO_REWRITE*/from t1 where t1.a < 3 or true;
EXPLAIN select * from t1 where t1.a < 3 or 1 < 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 or 1 < 2;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where true or t1.a < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where true or t1.a < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where 1 < 2 or t1.a < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where 1 < 2 or t1.a < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where t1.a < 3 or t1.b < 3 or true;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 or t1.b < 3 or true;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where t1.a < 3 or t1.b < 3 or 1 < 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 or t1.b < 3 or 1 < 2;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where true or (t1.a < 3 and t1.b < 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where true or (t1.a < 3 and t1.b < 3);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+


******false and filter-> false**********
EXPLAIN select * from t1 where false and t1.a < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([0]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where false and t1.a < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where t1.a < 3 and 1 > 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([0]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 and 1 > 2;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where t1.a < 3 and false and t1. b < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([0]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 and false and t1. b < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where t1.a < 3 and t1.b < 3 and 1 > 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([0]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 and t1.b < 3 and 1 > 2;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where false and (t1.a < 3 and t1.b < 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([0]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where false and (t1.a < 3 and t1.b < 3);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN insert into t_temp select * from t1 where false and (t1.a < 3 and t1.b < 3);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |5        |39  |
|1 | SUBPLAN SCAN|VIEW1|5        |38  |
|2 |  TABLE SCAN |t1   |5        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), startup_filter([0]), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

insert into t_temp select * from t1 where false and (t1.a < 3 and t1.b < 3);
EXPLAIN insert /*+NO_REWRITE*/into t_temp select * from t1 where false and (t1.a < 3 and t1.b < 3);
Query Plan
=======================================
|ID|OPERATOR     |NAME |EST. ROWS|COST|
---------------------------------------
|0 |INSERT       |     |5        |39  |
|1 | SUBPLAN SCAN|VIEW1|5        |38  |
|2 |  TABLE SCAN |t1   |5        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), startup_filter([0]), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

insert /*+NO_REWRITE*/into t_temp select * from t1 where false and (t1.a < 3 and t1.b < 3);
EXPLAIN update t1 set t1.b = t1.b + 100 where false and (t1.a < 3 and t1.b < 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |5        |42  |
|1 | TABLE SCAN|t1  |5        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}]),
      update([t1.b=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))]), filter(nil), startup_filter([0]), 
      access([t1.b], [t1.__pk_increment], [t1.a], [t1.c]), partitions(p0)

update t1 set t1.b = t1.b + 100 where false and (t1.a < 3 and t1.b < 3);
EXPLAIN update /*+NO_REWRITE*/t1 set t1.b = t1.b + 100 where false and (t1.a < 3 and t1.b < 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |39  |
|1 | TABLE SCAN|t1  |1        |39  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}]),
      update([t1.b=column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c], [column_conv(INT,PS:(11,0),NULL,cast(t1.b + 100, INT(-1, 0)))]), filter([t1.a < 3], [t1.b < 3]), startup_filter([0]), 
      access([t1.b], [t1.__pk_increment], [t1.a], [t1.c]), partitions(p0)

update /*+NO_REWRITE*/t1 set t1.b = t1.b + 100 where false and (t1.a < 3 and t1.b < 3);
EXPLAIN delete from t1 where false and (t1.a < 3 and t1.b < 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |5        |42  |
|1 | TABLE SCAN|t1  |5        |37  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([0]), 
      access([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), partitions(p0)

delete from t1 where false and (t1.a < 3 and t1.b < 3);
EXPLAIN delete /*+NO_REWRITE*/from t1 where false and (t1.a < 3 and t1.b < 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |39  |
|1 | TABLE SCAN|t1  |1        |39  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b, t1.c)})}])
  1 - output([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), filter([t1.a < 3], [t1.b < 3]), startup_filter([0]), 
      access([t1.__pk_increment], [t1.a], [t1.b], [t1.c]), partitions(p0)

delete /*+NO_REWRITE*/from t1 where false and (t1.a < 3 and t1.b < 3);


******true and filter-> filter**********
EXPLAIN select * from t1 where true and t1.a < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |38  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where true and t1.a < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where t1.a < 3 and true and 1 < 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |38  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 and true and 1 < 2;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where t1.a < 3 and 1 < 2 and t1.b < 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |39  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3], [t1.b < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where t1.a < 3 and 1 < 2 and t1.b < 3;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where true and (t1.a < 3 and t1.b < 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |39  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter([t1.a < 3], [t1.b < 3]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where true and (t1.a < 3 and t1.b < 3);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+


**********test cases where we can not remove dummy exprs**********
EXPLAIN select * from t1 where 1 + true >= 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where 1 + true >= 2;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select * from t1 where 1 + false >= 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |5        |37  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), startup_filter([0]), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from t1 where 1 + false >= 2;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

drop table t1;
drop table t_temp;


drop table if exists cache, resource_assigned;
CREATE TABLE `cache` ( `id` varchar(20) NOT NULL, `name` varchar(200) DEFAULT NULL, `description` varchar(200) DEFAULT NULL, `iaas_id` varchar(200) DEFAULT NULL, `provider_id` varchar(20) DEFAULT NULL, `region_id` varchar(20) DEFAULT NULL, `zone_id` varchar(20) DEFAULT NULL, `tenant_id` varchar(20) DEFAULT NULL, `workspace_id` varchar(20) DEFAULT NULL, `iaas_type` varchar(100) DEFAULT NULL, `status` varchar(50) NOT NULL, `network_type` varchar(50) DEFAULT NULL, `vpc_id` varchar(20) DEFAULT NULL, `v_switch_iaas_id` varchar(200) DEFAULT NULL, `spec_iaas_id` varchar(200) DEFAULT NULL, `capacity` bigint(20) DEFAULT NULL, `qps` bigint(20) DEFAULT NULL, `bandwidth` bigint(20) DEFAULT NULL, `max_connections` bigint(20) DEFAULT NULL, `connection_domain` varchar(200) DEFAULT NULL, `port` bigint(20) DEFAULT NULL, `user_name` varchar(200) DEFAULT NULL, `password` varchar(200) DEFAULT NULL, `utc_create` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `utc_modified` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP, `utc_deleted` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`), KEY `workspace_id` (`workspace_id`) BLOCK_SIZE 16384, KEY `zone_id` (`zone_id`) BLOCK_SIZE 16384, KEY `iaas_id` (`iaas_id`) BLOCK_SIZE 16384, KEY `region_id` (`region_id`) BLOCK_SIZE 16384, KEY `status` (`status`) BLOCK_SIZE 16384 );
CREATE TABLE `resource_assigned` ( `id` varchar(20) NOT NULL, `resource_id` varchar(20) NOT NULL, `resource_type` varchar(20) NOT NULL, `workspace_id` varchar(20) NOT NULL, `app_id` varchar(20) NOT NULL, `utc_create` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `utc_modified` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `assignedResource_UNIQUE` (`resource_id`, `resource_type`, `workspace_id`, `app_id`) BLOCK_SIZE 16384, KEY `resource_id` (`resource_id`) BLOCK_SIZE 16384, KEY `workspace_id` (`workspace_id`) BLOCK_SIZE 16384, KEY `app_id` (`app_id`) BLOCK_SIZE 16384 );
EXPLAIN SELECT COUNT(cache.id) FROM cache WHERE false OR cache.workspace_id IN ('0077508610') AND EXISTS ( SELECT resource_assigned.resource_id FROM resource_assigned WHERE resource_assigned.resource_id = cache.id AND resource_assigned.resource_type = 'CACHE' AND resource_assigned.workspace_id IN ('0077508610') AND resource_assigned.app_id IN ('0080452727') ) AND cache.status != 'DELETED';
Query Plan
=====================================================================
|ID|OPERATOR         |NAME                           |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |SCALAR GROUP BY  |                               |1        |6680|
|1 | NESTED-LOOP JOIN|                               |1        |6680|
|2 |  TABLE SCAN     |resource_assigned(workspace_id)|1        |6677|
|3 |  TABLE GET      |cache                          |1        |37  |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(cache.id)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(cache.id)])
  1 - output([cache.id]), filter(nil), 
      conds(nil), nl_params_([resource_assigned.resource_id])
  2 - output([resource_assigned.resource_id]), filter([resource_assigned.resource_type = 'CACHE'], [resource_assigned.app_id = '0080452727']), 
      access([resource_assigned.resource_id], [resource_assigned.resource_type], [resource_assigned.app_id]), partitions(p0)
  3 - output([cache.id]), filter([cache.workspace_id = '0077508610'], [cache.status != 'DELETED']), 
      access([cache.id], [cache.workspace_id], [cache.status]), partitions(p0)

SELECT COUNT(cache.id) FROM cache WHERE false OR cache.workspace_id IN ('0077508610') AND EXISTS ( SELECT resource_assigned.resource_id FROM resource_assigned WHERE resource_assigned.resource_id = cache.id AND resource_assigned.resource_type = 'CACHE' AND resource_assigned.workspace_id IN ('0077508610') AND resource_assigned.app_id IN ('0080452727') ) AND cache.status != 'DELETED';
+-----------------+
| COUNT(cache.id) |
+-----------------+
|               0 |
+-----------------+
drop table cache, resource_assigned;

*********************remove dummy exprs end************************

drop table if exists t1, t2;
create table t1 (c1 int);
create table t2 (c1 int primary key);

EXPLAIN insert into t1 values (1);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1)})}]), partitions(p0)
  1 - output([__values.c1]), filter(nil)
      values({1})

insert into t1 values (1);
EXPLAIN insert into t1 values (2);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,__values.c1)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.c1)})}]), partitions(p0)
  1 - output([__values.c1]), filter(nil)
      values({2})

insert into t1 values (2);
EXPLAIN insert into t2 values (1);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)]), filter(nil), 
      columns([{t2: ({t2: (t2.c1)})}]), partitions(p0)
  1 - output([__values.c1]), filter(nil)
      values({1})

insert into t2 values (1);
EXPLAIN insert into t2 values (2);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |INSERT     |    |1        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(INT,PS:(11,0),NOT NULL,__values.c1)]), filter(nil), 
      columns([{t2: ({t2: (t2.c1)})}]), partitions(p0)
  1 - output([__values.c1]), filter(nil)
      values({2})

insert into t2 values (2);

EXPLAIN select * from t1 where c1 between coalesce( ( SELECT 1 ), -10 )AND 10;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |78605|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([(T_OP_BTW, cast(t1.c1, DECIMAL(11, 0)), ?, ?)]), 
      access([t1.c1]), partitions(p0)

select * from t1 where c1 between coalesce( ( SELECT 1 ), -10 )AND 10;
+------+
| c1   |
+------+
|    1 |
|    2 |
+------+

EXPLAIN select * from t2 where c1 = 1 + (select 1);
Query Plan
==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t2  |1        |52  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select * from t2 where c1 = 1 + (select 1);
+----+
| c1 |
+----+
|  2 |
+----+

EXPLAIN select * from t2 where c1 = 1 + (select 1);
Query Plan
==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t2  |1        |52  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select * from t2 where c1 = 1 + (select 1);
+----+
| c1 |
+----+
|  2 |
+----+

drop table t1;
drop table t2;


*********************remove dummy exprs end************************
drop table if exists t1;
create table t1 (c1 int primary key, c2 int);

EXPLAIN select c1, max(c2) from t1 group by c1;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |100000   |61860|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select c1, max(c2) from t1 group by c1;
+----+---------+
| c1 | max(c2) |
+----+---------+
+----+---------+
EXPLAIN select c1, max(c2) from t1 group by c1 with rollup;
Query Plan
========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |MERGE GROUP BY|    |100000   |89334|
|1 | TABLE SCAN   |t1  |100000   |61860|
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [T_FUN_MAX(t1.c2)]), filter(nil), 
      group(nil), rollup([t1.c1]), agg_func([T_FUN_MAX(t1.c2)])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select c1, max(c2) from t1 group by c1 with rollup;
+----+---------+
| c1 | max(c2) |
+----+---------+
+----+---------+

drop table t1;

DROP TABLE IF EXISTS `b`, `cc`;
CREATE TABLE `b` (
  `col_int` int(11) DEFAULT NULL,
  `col_varchar` varchar(1) DEFAULT NULL,
  `col_varchar_10` varchar(10) DEFAULT NULL,
  `col_int_key` int(11) DEFAULT NULL,
  `col_varchar_20` varchar(20) DEFAULT NULL,
  `pk` int(11) NOT NULL,
  `col_varchar_key` varchar(1) DEFAULT NULL,
  `col_varchar_10_key` varchar(10) DEFAULT NULL,
  `col_varchar_20_key` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`pk`),
  KEY `idx1` (`pk`, `col_int_key`)  ,
  KEY `idx3` (`pk`, `col_varchar_key`)  ,
  KEY `idx5` (`pk`, `col_varchar_10_key`)  ,
  KEY `idx7` (`pk`, `col_varchar_20_key`)
) ;
CREATE TABLE `cc` (
  `col_int` int(11) DEFAULT NULL,
  `col_varchar_10` varchar(10) DEFAULT NULL,
  `col_varchar` varchar(1) DEFAULT NULL,
  `col_varchar_20_key` varchar(20) DEFAULT NULL,
  `col_varchar_key` varchar(1) DEFAULT NULL,
  `col_varchar_20` varchar(20) DEFAULT NULL,
  `col_int_key` int(11) DEFAULT NULL,
  `col_varchar_10_key` varchar(10) DEFAULT NULL,
  `pk` int(11) NOT NULL,
  PRIMARY KEY (`pk`),
  KEY `idx7` (`pk`, `col_varchar_20_key`)  ,
  KEY `idx3` (`pk`, `col_varchar_key`)  ,
  KEY `idx1` (`pk`, `col_int_key`)  ,
  KEY `idx5` (`pk`, `col_varchar_10_key`)
) ;
EXPLAIN SELECT table1 . col_varchar_key AS field1,
       CONCAT (table2 . `col_varchar_20`, table1 . `col_varchar_20_key`) AS field2,
       ((table2 . `col_int`) + (table1 . `col_int_key`)) AS field3,
       table2 . `col_varchar` AS field4,
       (SELECT SUM(SUBQUERY1_t2 . `pk`) AS SUBQUERY1_field1
        FROM (CC AS SUBQUERY1_t1 INNER JOIN B AS SUBQUERY1_t2 ON (SUBQUERY1_t2 . `col_int` = SUBQUERY1_t1 . `pk`))
        WHERE SUBQUERY1_t1 . `col_varchar_10` <> table1 . `col_varchar_20`
          AND SUBQUERY1_t1 . `col_int_key` = table1 . `col_int_key` ) AS field5,
        table1 . `pk` AS field6,
        table2 . col_varchar_20_key AS field7,
        CONCAT (table1 . `col_varchar_10_key`, table1 . `col_varchar_10_key`) AS field8,
        table2 . `col_int_key` AS field9,
        SUM(table2 . `pk`) AS field10,
        CONCAT (table1 . `col_varchar_10_key`, table1 . `col_varchar_10_key`) AS field11,
        SUM(table2 . `col_int_key`) AS field12,
        table1 . col_varchar_20_key AS field13,
        CONCAT (table1 . `col_varchar_20`, table2 . `col_varchar`) AS field14,
        ((table1 . `pk`) + (table2 . `col_int_key`)) AS field15
FROM (CC AS table1
      INNER JOIN CC AS table2 ON (table2 . `pk` = table1 . `pk`))
WHERE (NOT EXISTS ((SELECT 6 FROM DUAL)))
  AND table1 . `col_varchar_key` = table1 . `col_varchar_key`
GROUP BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field11,
         field13,
         field14,
         field15
HAVING ((field2 >= 'r'
         AND field1 < 'qr')
        AND field10 < 'pq')
ORDER BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field12,
         field13,
         field14,
         field15
LIMIT 100
OFFSET 2;
Query Plan
======================================================
|ID|OPERATOR           |NAME        |EST. ROWS|COST  |
------------------------------------------------------
|0 |LIMIT              |            |100      |711695|
|1 | TOP-N SORT        |            |102      |711681|
|2 |  HASH GROUP BY    |            |334      |710002|
|3 |   SUBPLAN FILTER  |            |80859    |678937|
|4 |    HASH OUTER JOIN|            |161717   |656616|
|5 |     TABLE SCAN    |table1      |334      |16909 |
|6 |     HASH JOIN     |            |99000    |345403|
|7 |      TABLE SCAN   |SUBQUERY1_t2|100000   |61860 |
|8 |      TABLE SCAN   |SUBQUERY1_t1|100000   |64066 |
|9 |    LIMIT          |            |1        |1     |
|10|     EXPRESSION    |            |1        |1     |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([table1.col_varchar_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)], [table1.col_int + table1.col_int_key], [table1.col_varchar], [T_FUN_SUM(SUBQUERY1_t2.pk)], [table1.pk], [table1.col_varchar_20_key], [CONCAT(table1.col_varchar_10_key, table1.col_varchar_10_key)], [table1.col_int_key], [cast(table1.pk, DECIMAL(11, 0))], [CONCAT(table1.col_varchar_10_key, table1.col_varchar_10_key)], [cast(table1.col_int_key, DECIMAL(11, 0))], [table1.col_varchar_20_key], [CONCAT(table1.col_varchar_20, table1.col_varchar)], [table1.pk + table1.col_int_key]), filter(nil), limit(100), offset(2)
  1 - output([table1.col_varchar_key], [table1.col_varchar_20], [table1.col_varchar_20_key], [table1.col_int_key], [table1.col_varchar], [T_FUN_SUM(SUBQUERY1_t2.pk)], [table1.pk], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)], [table1.col_int + table1.col_int_key]), filter(nil), sort_keys([table1.col_varchar_key, ASC], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key), ASC], [table1.col_int + table1.col_int_key, ASC], [table1.col_varchar, ASC], [T_FUN_SUM(SUBQUERY1_t2.pk), ASC], [table1.pk, ASC]), topn(100 + 2)
  2 - output([table1.col_varchar_key], [table1.col_varchar_20], [table1.col_varchar_20_key], [table1.col_int_key], [table1.col_varchar], [T_FUN_SUM(SUBQUERY1_t2.pk)], [table1.pk], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)], [table1.col_int + table1.col_int_key]), filter(nil), 
      group([table1.pk]), agg_func([T_FUN_SUM(SUBQUERY1_t2.pk)])
  3 - output([table1.col_varchar_key], [table1.col_varchar_20], [table1.col_varchar_20_key], [table1.col_int], [table1.col_int_key], [table1.col_varchar], [SUBQUERY1_t2.pk], [table1.pk], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  4 - output([table1.col_varchar_key], [table1.col_varchar_20], [table1.col_varchar_20_key], [table1.col_int], [table1.col_int_key], [table1.col_varchar], [SUBQUERY1_t2.pk], [table1.pk], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter(nil), 
      equal_conds([SUBQUERY1_t1.col_int_key = table1.col_int_key]), other_conds([SUBQUERY1_t1.col_varchar_10 != table1.col_varchar_20])
  5 - output([table1.pk], [table1.col_varchar_key], [table1.col_varchar_20_key], [table1.col_int], [table1.col_int_key], [table1.col_varchar], [table1.col_varchar_20], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter([table1.col_varchar_key < 'qr'], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key) >= 'r']), 
      access([table1.pk], [table1.col_varchar_key], [table1.col_varchar_20_key], [table1.col_int], [table1.col_int_key], [table1.col_varchar], [table1.col_varchar_20], [table1.col_varchar_10_key]), partitions(p0)
  6 - output([SUBQUERY1_t2.pk], [SUBQUERY1_t1.col_varchar_10], [SUBQUERY1_t1.col_int_key]), filter(nil), 
      equal_conds([SUBQUERY1_t2.col_int = SUBQUERY1_t1.pk]), other_conds(nil)
  7 - output([SUBQUERY1_t2.col_int], [SUBQUERY1_t2.pk]), filter(nil), 
      access([SUBQUERY1_t2.col_int], [SUBQUERY1_t2.pk]), partitions(p0)
  8 - output([SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_10], [SUBQUERY1_t1.col_int_key]), filter(nil), 
      access([SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_10], [SUBQUERY1_t1.col_int_key]), partitions(p0)
  9 - output([6]), filter(nil), limit(1), offset(nil)
  10 - output([1]), filter(nil)
      values({1})

SELECT table1 . col_varchar_key AS field1,
       CONCAT (table2 . `col_varchar_20`, table1 . `col_varchar_20_key`) AS field2,
       ((table2 . `col_int`) + (table1 . `col_int_key`)) AS field3,
       table2 . `col_varchar` AS field4,
       (SELECT SUM(SUBQUERY1_t2 . `pk`) AS SUBQUERY1_field1
        FROM (CC AS SUBQUERY1_t1 INNER JOIN B AS SUBQUERY1_t2 ON (SUBQUERY1_t2 . `col_int` = SUBQUERY1_t1 . `pk`))
        WHERE SUBQUERY1_t1 . `col_varchar_10` <> table1 . `col_varchar_20`
          AND SUBQUERY1_t1 . `col_int_key` = table1 . `col_int_key` ) AS field5,
        table1 . `pk` AS field6,
        table2 . col_varchar_20_key AS field7,
        CONCAT (table1 . `col_varchar_10_key`, table1 . `col_varchar_10_key`) AS field8,
        table2 . `col_int_key` AS field9,
        SUM(table2 . `pk`) AS field10,
        CONCAT (table1 . `col_varchar_10_key`, table1 . `col_varchar_10_key`) AS field11,
        SUM(table2 . `col_int_key`) AS field12,
        table1 . col_varchar_20_key AS field13,
        CONCAT (table1 . `col_varchar_20`, table2 . `col_varchar`) AS field14,
        ((table1 . `pk`) + (table2 . `col_int_key`)) AS field15
FROM (CC AS table1
      INNER JOIN CC AS table2 ON (table2 . `pk` = table1 . `pk`))
WHERE (NOT EXISTS ((SELECT 6 FROM DUAL)))
  AND table1 . `col_varchar_key` = table1 . `col_varchar_key`
GROUP BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field11,
         field13,
         field14,
         field15
HAVING ((field2 >= 'r'
         AND field1 < 'qr')
        AND field10 < 'pq')
ORDER BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field12,
         field13,
         field14,
         field15
LIMIT 100
OFFSET 2;
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+---------+---------+
| field1 | field2 | field3 | field4 | field5 | field6 | field7 | field8 | field9 | field10 | field11 | field12 | field13 | field14 | field15 |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+---------+---------+
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+---------+---------+

EXPLAIN SELECT /*+no_rewrite*/ table1 . col_varchar_key AS field1,
       CONCAT (table2 . `col_varchar_20`, table1 . `col_varchar_20_key`) AS field2,
       ((table2 . `col_int`) + (table1 . `col_int_key`)) AS field3,
       table2 . `col_varchar` AS field4,
       (SELECT SUM(SUBQUERY1_t2 . `pk`) AS SUBQUERY1_field1
        FROM (CC AS SUBQUERY1_t1 INNER JOIN B AS SUBQUERY1_t2 ON (SUBQUERY1_t2 . `col_int` = SUBQUERY1_t1 . `pk`))
        WHERE SUBQUERY1_t1 . `col_varchar_10` <> table1 . `col_varchar_20`
          AND SUBQUERY1_t1 . `col_int_key` = table1 . `col_int_key` ) AS field5,
        table1 . `pk` AS field6,
        table2 . col_varchar_20_key AS field7,
        CONCAT (table1 . `col_varchar_10_key`, table1 . `col_varchar_10_key`) AS field8,
        table2 . `col_int_key` AS field9,
        SUM(table2 . `pk`) AS field10,
        CONCAT (table1 . `col_varchar_10_key`, table1 . `col_varchar_10_key`) AS field11,
        SUM(table2 . `col_int_key`) AS field12,
        table1 . col_varchar_20_key AS field13,
        CONCAT (table1 . `col_varchar_20`, table2 . `col_varchar`) AS field14,
        ((table1 . `pk`) + (table2 . `col_int_key`)) AS field15
FROM (CC AS table1
      INNER JOIN CC AS table2 ON (table2 . `pk` = table1 . `pk`))
WHERE (NOT EXISTS ((SELECT 6 FROM DUAL)))
  AND table1 . `col_varchar_key` = table1 . `col_varchar_key`
GROUP BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field11,
         field13,
         field14,
         field15
HAVING ((field2 >= 'r'
         AND field1 < 'qr')
        AND field10 < 'pq')
ORDER BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field12,
         field13,
         field14,
         field15
LIMIT 100
OFFSET 2;
Query Plan
===========================================================
|ID|OPERATOR           |NAME        |EST. ROWS|COST       |
-----------------------------------------------------------
|0 |LIMIT              |            |81       |14506246305|
|1 | TOP-N SORT        |            |83       |14506246293|
|2 |  MERGE GROUP BY   |            |83       |14506245758|
|3 |   SUBPLAN FILTER  |            |49501    |14506229535|
|4 |    SUBPLAN FILTER |            |49501    |288049     |
|5 |     MERGE JOIN    |            |99001    |274384     |
|6 |      TABLE SCAN   |table1      |99000    |117520     |
|7 |      TABLE SCAN   |table2      |100000   |70683      |
|8 |     EXPRESSION    |            |1        |1          |
|9 |    SCALAR GROUP BY|            |1        |293050     |
|10|     HASH JOIN     |            |99000    |274139     |
|11|      TABLE SCAN   |SUBQUERY1_t1|971      |119275     |
|12|      TABLE SCAN   |SUBQUERY1_t2|100000   |61860      |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([table1.col_varchar_key], [CONCAT(table2.col_varchar_20, table1.col_varchar_20_key)], [table2.col_int + table1.col_int_key], [table2.col_varchar], [subquery(1)], [table1.pk], [table2.col_varchar_20_key], [CONCAT(table1.col_varchar_10_key, table1.col_varchar_10_key)], [table2.col_int_key], [T_FUN_SUM(table2.pk)], [CONCAT(table1.col_varchar_10_key, table1.col_varchar_10_key)], [T_FUN_SUM(table2.col_int_key)], [table1.col_varchar_20_key], [CONCAT(table1.col_varchar_20, table2.col_varchar)], [table1.pk + table2.col_int_key]), filter(nil), limit(100), offset(2)
  1 - output([table1.col_varchar_key], [table1.col_varchar_20_key], [table2.col_varchar], [subquery(1)], [table1.pk], [table2.col_varchar_20_key], [table1.col_varchar_10_key], [table2.col_int_key], [T_FUN_SUM(table2.pk)], [T_FUN_SUM(table2.col_int_key)], [table1.col_varchar_20], [CONCAT(table2.col_varchar_20, table1.col_varchar_20_key)], [table2.col_int + table1.col_int_key]), filter(nil), sort_keys([table1.col_varchar_key, ASC], [CONCAT(table2.col_varchar_20, table1.col_varchar_20_key), ASC], [table2.col_int + table1.col_int_key, ASC], [table2.col_varchar, ASC], [subquery(1), ASC], [table1.pk, ASC], [T_FUN_SUM(table2.pk), ASC], [T_FUN_SUM(table2.col_int_key), ASC]), topn(100 + 2)
  2 - output([table1.col_varchar_key], [table1.col_varchar_20_key], [table2.col_varchar], [subquery(1)], [table1.pk], [table2.col_varchar_20_key], [table1.col_varchar_10_key], [table2.col_int_key], [T_FUN_SUM(table2.pk)], [T_FUN_SUM(table2.col_int_key)], [table1.col_varchar_20], [CONCAT(table2.col_varchar_20, table1.col_varchar_20_key)], [table2.col_int + table1.col_int_key]), filter([T_FUN_SUM(table2.pk) < ?], [table1.col_varchar_key < 'qr'], [CONCAT(table2.col_varchar_20, table1.col_varchar_20_key) >= 'r']), 
      group([table1.pk]), agg_func([T_FUN_SUM(table2.pk)], [T_FUN_SUM(table2.col_int_key)])
  3 - output([table1.col_varchar_key], [table2.col_varchar_20], [table1.col_varchar_20_key], [table2.col_int], [table1.col_int_key], [table2.col_varchar], [subquery(1)], [table1.pk], [table2.col_varchar_20_key], [table1.col_varchar_10_key], [table2.col_int_key], [table2.pk], [table1.col_varchar_20]), filter(nil), 
      exec_params_([table1.col_int_key], [table1.col_varchar_20]), onetime_exprs_(nil), init_plan_idxs_(nil)
  4 - output([table1.col_varchar_key], [table2.col_varchar_20], [table1.col_varchar_20_key], [table2.col_int], [table1.col_int_key], [table2.col_varchar], [table1.pk], [table2.col_varchar_20_key], [table1.col_varchar_10_key], [table2.col_int_key], [table2.pk], [table1.col_varchar_20]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  5 - output([table1.col_varchar_key], [table2.col_varchar_20], [table1.col_varchar_20_key], [table2.col_int], [table1.col_int_key], [table2.col_varchar], [table1.pk], [table2.col_varchar_20_key], [table1.col_varchar_10_key], [table2.col_int_key], [table2.pk], [table1.col_varchar_20]), filter(nil), 
      equal_conds([table2.pk = table1.pk]), other_conds(nil)
  6 - output([table1.pk], [table1.col_varchar_key], [table1.col_varchar_20_key], [table1.col_int_key], [table1.col_varchar_20], [table1.col_varchar_10_key]), filter([table1.col_varchar_key = table1.col_varchar_key]), 
      access([table1.pk], [table1.col_varchar_key], [table1.col_varchar_20_key], [table1.col_int_key], [table1.col_varchar_20], [table1.col_varchar_10_key]), partitions(p0)
  7 - output([table2.pk], [table2.col_varchar_20], [table2.col_int], [table2.col_varchar], [table2.col_varchar_20_key], [table2.col_int_key]), filter(nil), 
      access([table2.pk], [table2.col_varchar_20], [table2.col_int], [table2.col_varchar], [table2.col_varchar_20_key], [table2.col_int_key]), partitions(p0)
  8 - output([6]), filter(nil)
      values({6})
  9 - output([T_FUN_SUM(SUBQUERY1_t2.pk)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(SUBQUERY1_t2.pk)])
  10 - output([SUBQUERY1_t2.pk]), filter(nil), 
      equal_conds([SUBQUERY1_t2.col_int = SUBQUERY1_t1.pk]), other_conds(nil)
  11 - output([SUBQUERY1_t1.pk]), filter([SUBQUERY1_t1.col_int_key = ?], [SUBQUERY1_t1.col_varchar_10 != ?]), 
      access([SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_10], [SUBQUERY1_t1.col_int_key]), partitions(p0)
  12 - output([SUBQUERY1_t2.col_int], [SUBQUERY1_t2.pk]), filter(nil), 
      access([SUBQUERY1_t2.col_int], [SUBQUERY1_t2.pk]), partitions(p0)

SELECT /*+no_rewrite*/ table1 . col_varchar_key AS field1,
       CONCAT (table2 . `col_varchar_20`, table1 . `col_varchar_20_key`) AS field2,
       ((table2 . `col_int`) + (table1 . `col_int_key`)) AS field3,
       table2 . `col_varchar` AS field4,
       (SELECT SUM(SUBQUERY1_t2 . `pk`) AS SUBQUERY1_field1
        FROM (CC AS SUBQUERY1_t1 INNER JOIN B AS SUBQUERY1_t2 ON (SUBQUERY1_t2 . `col_int` = SUBQUERY1_t1 . `pk`))
        WHERE SUBQUERY1_t1 . `col_varchar_10` <> table1 . `col_varchar_20`
          AND SUBQUERY1_t1 . `col_int_key` = table1 . `col_int_key` ) AS field5,
        table1 . `pk` AS field6,
        table2 . col_varchar_20_key AS field7,
        CONCAT (table1 . `col_varchar_10_key`, table1 . `col_varchar_10_key`) AS field8,
        table2 . `col_int_key` AS field9,
        SUM(table2 . `pk`) AS field10,
        CONCAT (table1 . `col_varchar_10_key`, table1 . `col_varchar_10_key`) AS field11,
        SUM(table2 . `col_int_key`) AS field12,
        table1 . col_varchar_20_key AS field13,
        CONCAT (table1 . `col_varchar_20`, table2 . `col_varchar`) AS field14,
        ((table1 . `pk`) + (table2 . `col_int_key`)) AS field15
FROM (CC AS table1
      INNER JOIN CC AS table2 ON (table2 . `pk` = table1 . `pk`))
WHERE (NOT EXISTS ((SELECT 6 FROM DUAL)))
  AND table1 . `col_varchar_key` = table1 . `col_varchar_key`
GROUP BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field11,
         field13,
         field14,
         field15
HAVING ((field2 >= 'r'
         AND field1 < 'qr')
        AND field10 < 'pq')
ORDER BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field12,
         field13,
         field14,
         field15
LIMIT 100
OFFSET 2;
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+---------+---------+
| field1 | field2 | field3 | field4 | field5 | field6 | field7 | field8 | field9 | field10 | field11 | field12 | field13 | field14 | field15 |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+---------+---------+
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+---------+---------+


************************消除冗余select begin**********

drop table if exists t1,t2,t3;
create table t1 (c1 int, c2 int);
create table t2 (c1 int, c2 int);
create table t3 (c1 int, c2 int);
EXPLAIN select (select 123 from dual) from dual;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([123]), filter(nil)
      values({123})

select (select 123 from dual) from dual;
+------------------------+
| (select 123 from dual) |
+------------------------+
|                    123 |
+------------------------+
EXPLAIN select /*+no_rewrite*/ (select 123 from dual) from dual;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([123]), filter(nil)
      values({123})

select /*+no_rewrite*/ (select 123 from dual) from dual;
+------------------------+
| (select 123 from dual) |
+------------------------+
|                    123 |
+------------------------+
EXPLAIN select (select sum(c1) from t1) from dual;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |80961|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select (select sum(c1) from t1) from dual;
+--------------------------+
| (select sum(c1) from t1) |
+--------------------------+
|                       15 |
+--------------------------+
EXPLAIN select /*+no_rewrite*/ (select sum(c1) from t1) from dual;
Query Plan
==========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST |
------------------------------------------
|0 |SUBPLAN FILTER  |    |1        |80962|
|1 | EXPRESSION     |    |1        |1    |
|2 | SCALAR GROUP BY|    |1        |80961|
|3 |  TABLE SCAN    |t1  |100000   |61860|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select /*+no_rewrite*/ (select sum(c1) from t1) from dual;
+--------------------------+
| (select sum(c1) from t1) |
+--------------------------+
|                       15 |
+--------------------------+
EXPLAIN select (select c1 from t1 limit 1) from dual;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |37  |
|1 | EXPRESSION   |    |1        |1   |
|2 | TABLE SCAN   |t1  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

select (select c1 from t1 limit 1) from dual;
+-----------------------------+
| (select c1 from t1 limit 1) |
+-----------------------------+
|                           1 |
+-----------------------------+
EXPLAIN select /*+no_rewrite*/ (select c1 from t1 limit 1) from dual;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |37  |
|1 | EXPRESSION   |    |1        |1   |
|2 | TABLE SCAN   |t1  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil)

select /*+no_rewrite*/ (select c1 from t1 limit 1) from dual;
+-----------------------------+
| (select c1 from t1 limit 1) |
+-----------------------------+
|                           1 |
+-----------------------------+
EXPLAIN select (select c1 from t1 limit 0) from dual;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | TABLE SCAN   |t1  |0        |0   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(0), offset(nil)

select (select c1 from t1 limit 0) from dual;
+-----------------------------+
| (select c1 from t1 limit 0) |
+-----------------------------+
|                        NULL |
+-----------------------------+
EXPLAIN select /*+no_rewrite*/ (select c1 from t1 limit 0) from dual;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | TABLE SCAN   |t1  |0        |0   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(0), offset(nil)

select /*+no_rewrite*/ (select c1 from t1 limit 0) from dual;
+-----------------------------+
| (select c1 from t1 limit 0) |
+-----------------------------+
|                        NULL |
+-----------------------------+
EXPLAIN select (select 'x' from dual where 1>2) from dual;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output(['x']), filter([0])
      values({'x'})

select (select 'x' from dual where 1>2) from dual;
+----------------------------------+
| (select 'x' from dual where 1>2) |
+----------------------------------+
| NULL                             |
+----------------------------------+
EXPLAIN select /*+no_rewrite*/ (select 'x' from dual where 1>2) from dual;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output(['x']), filter([0])
      values({'x'})

select /*+no_rewrite*/ (select 'x' from dual where 1>2) from dual;
+----------------------------------+
| (select 'x' from dual where 1>2) |
+----------------------------------+
| NULL                             |
+----------------------------------+
select (select sum(c1) over() from t1) from dual;
ERROR 21000: Subquery returns more than 1 row
EXPLAIN select * from (select (select 123 from dual) from dual);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([123]), filter(nil)
      values({123})

select * from (select (select 123 from dual) from dual);
+------------------------+
| (select 123 from dual) |
+------------------------+
|                    123 |
+------------------------+
EXPLAIN select * from (select /*+no_rewrite*/ (select 123 from dual) from dual);
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([123]), filter(nil)
      values({123})

select * from (select /*+no_rewrite*/ (select 123 from dual) from dual);
+------------------------+
| (select 123 from dual) |
+------------------------+
|                    123 |
+------------------------+
EXPLAIN select * from (select (select sum(c1) from t1) from dual);
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |80961|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from (select (select sum(c1) from t1) from dual);
+--------------------------+
| (select sum(c1) from t1) |
+--------------------------+
|                       15 |
+--------------------------+
EXPLAIN select * from (select /*+no_rewrite*/ (select sum(c1) from t1) from dual);
Query Plan
==========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST |
------------------------------------------
|0 |SUBPLAN FILTER  |    |1        |80962|
|1 | EXPRESSION     |    |1        |1    |
|2 | SCALAR GROUP BY|    |1        |80961|
|3 |  TABLE SCAN    |t1  |100000   |61860|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from (select /*+no_rewrite*/ (select sum(c1) from t1) from dual);
+--------------------------+
| (select sum(c1) from t1) |
+--------------------------+
|                       15 |
+--------------------------+
EXPLAIN select * from t2,(select (select 123 from dual) as c1 from dual) V where t2.c1 = V.c1;
Query Plan
==========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST |
------------------------------------------
|0 |NESTED-LOOP JOIN|    |990      |95118|
|1 | SUBPLAN SCAN   |V   |1        |1    |
|2 |  EXPRESSION    |    |1        |1    |
|3 | TABLE SCAN     |t2  |100000   |64066|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [V.c1]), filter(nil), 
      conds([t2.c1 = V.c1]), nl_params_(nil)
  1 - output([V.c1]), filter(nil), 
      access([V.c1])
  2 - output([123]), filter(nil)
      values({123})
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2,(select (select 123 from dual) as c1 from dual) V where t2.c1 = V.c1;
+------+------+----+
| c1   | c2   | c1 |
+------+------+----+
+------+------+----+
EXPLAIN select * from t2,(select /*+no_rewrite*/ (select 123 from dual) as c1 from dual) V where t2.c1 = V.c1;
Query Plan
==========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST |
------------------------------------------
|0 |NESTED-LOOP JOIN|    |990      |95118|
|1 | SUBPLAN SCAN   |V   |1        |1    |
|2 |  SUBPLAN FILTER|    |1        |1    |
|3 |   EXPRESSION   |    |1        |1    |
|4 |   EXPRESSION   |    |1        |1    |
|5 | TABLE SCAN     |t2  |100000   |64066|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [V.c1]), filter(nil), 
      conds([t2.c1 = V.c1]), nl_params_(nil)
  1 - output([V.c1]), filter(nil), 
      access([V.c1])
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([123]), filter(nil)
      values({123})
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2,(select /*+no_rewrite*/ (select 123 from dual) as c1 from dual) V where t2.c1 = V.c1;
+------+------+----+
| c1   | c2   | c1 |
+------+------+----+
+------+------+----+
EXPLAIN select * from t2,(select (select sum(c1) from t1) as c1 from dual) V where t2.c1 = V.c1;
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |NESTED-LOOP JOIN |    |500      |175829|
|1 | SUBPLAN SCAN    |V   |1        |80961 |
|2 |  SCALAR GROUP BY|    |1        |80961 |
|3 |   TABLE SCAN    |t1  |100000   |61860 |
|4 | TABLE SCAN      |t2  |100000   |64066 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [V.c1]), filter(nil), 
      conds([cast(t2.c1, DECIMAL(11, 0)) = V.c1]), nl_params_(nil)
  1 - output([V.c1]), filter(nil), 
      access([V.c1])
  2 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2,(select (select sum(c1) from t1) as c1 from dual) V where t2.c1 = V.c1;
+------+------+------+
| c1   | c2   | c1   |
+------+------+------+
+------+------+------+
EXPLAIN select * from t2,(select /*+no_rewrite*/ (select sum(c1) from t1) as c1 from dual) V where t2.c1 = V.c1;
Query Plan
=============================================
|ID|OPERATOR          |NAME|EST. ROWS|COST  |
---------------------------------------------
|0 |NESTED-LOOP JOIN  |    |500      |175829|
|1 | SUBPLAN SCAN     |V   |1        |80962 |
|2 |  SUBPLAN FILTER  |    |1        |80962 |
|3 |   EXPRESSION     |    |1        |1     |
|4 |   SCALAR GROUP BY|    |1        |80961 |
|5 |    TABLE SCAN    |t1  |100000   |61860 |
|6 | TABLE SCAN       |t2  |100000   |64066 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [V.c1]), filter(nil), 
      conds([cast(t2.c1, DECIMAL(11, 0)) = V.c1]), nl_params_(nil)
  1 - output([V.c1]), filter(nil), 
      access([V.c1])
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2,(select /*+no_rewrite*/ (select sum(c1) from t1) as c1 from dual) V where t2.c1 = V.c1;
+------+------+------+
| c1   | c2   | c1   |
+------+------+------+
+------+------+------+
EXPLAIN select * from t2 where t2.c1 = (select (select 123 from dual) from dual);
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t2  |990      |80811|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 = 123]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where t2.c1 = (select (select 123 from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 = (select /*+no_rewrite*/ (select 123 from dual) from dual);
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |990      |80948|
|1 | TABLE SCAN    |t2  |990      |80811|
|2 | SUBPLAN FILTER|    |1        |1    |
|3 |  EXPRESSION   |    |1        |1    |
|4 |  EXPRESSION   |    |1        |1    |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1], [t2.c2]), filter([t2.c1 = ?]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([123]), filter(nil)
      values({123})

select * from t2 where t2.c1 = (select /*+no_rewrite*/ (select 123 from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 = (select (select count(c1) from t1) from dual);
Query Plan
=============================================
|ID|OPERATOR         |NAME |EST. ROWS|COST  |
---------------------------------------------
|0 |NESTED-LOOP JOIN |     |990      |176078|
|1 | SUBPLAN SCAN    |VIEW1|1        |80961 |
|2 |  SCALAR GROUP BY|     |1        |80961 |
|3 |   TABLE SCAN    |t1   |100000   |61860 |
|4 | TABLE SCAN      |t2   |100000   |64066 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 = VIEW1.count(c1)]), nl_params_(nil)
  1 - output([VIEW1.count(c1)]), filter(nil), 
      access([VIEW1.count(c1)])
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where t2.c1 = (select (select count(c1) from t1) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where t2.c1 = (select /*+no_rewrite*/ (select count(c1) from t1) from dual);
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |SUBPLAN FILTER   |    |990      |161908|
|1 | TABLE SCAN      |t2  |990      |80811 |
|2 | SUBPLAN FILTER  |    |1        |80962 |
|3 |  EXPRESSION     |    |1        |1     |
|4 |  SCALAR GROUP BY|    |1        |80961 |
|5 |   TABLE SCAN    |t1  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1], [t2.c2]), filter([t2.c1 = ?]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from t2 where t2.c1 = (select /*+no_rewrite*/ (select count(c1) from t1) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where t2.c1 in (select (select 123 from dual) from dual);
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t2  |990      |80811|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 = 123]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where t2.c1 in (select (select 123 from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 in (select /*+no_rewrite*/ (select 123 from dual) from dual);
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |50000    |96652|
|1 | TABLE SCAN    |t2  |100000   |64066|
|2 | SUBPLAN FILTER|    |1        |1    |
|3 |  EXPRESSION   |    |1        |1    |
|4 |  EXPRESSION   |    |1        |1    |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([123]), filter(nil)
      values({123})

select * from t2 where t2.c1 in (select /*+no_rewrite*/ (select 123 from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 in (select (select count(c1) from t1) from dual);
Query Plan
=============================================
|ID|OPERATOR         |NAME |EST. ROWS|COST  |
---------------------------------------------
|0 |NESTED-LOOP JOIN |     |990      |176078|
|1 | SUBPLAN SCAN    |VIEW1|1        |80961 |
|2 |  SCALAR GROUP BY|     |1        |80961 |
|3 |   TABLE SCAN    |t1   |100000   |61860 |
|4 | TABLE SCAN      |t2   |100000   |64066 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 = VIEW1.count(c1)]), nl_params_(nil)
  1 - output([VIEW1.count(c1)]), filter(nil), 
      access([VIEW1.count(c1)])
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where t2.c1 in (select (select count(c1) from t1) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where t2.c1 in (select /*+no_rewrite*/ (select count(c1) from t1) from dual);
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |SUBPLAN FILTER   |    |50000    |177613|
|1 | TABLE SCAN      |t2  |100000   |64066 |
|2 | SUBPLAN FILTER  |    |1        |80962 |
|3 |  EXPRESSION     |    |1        |1     |
|4 |  SCALAR GROUP BY|    |1        |80961 |
|5 |   TABLE SCAN    |t1  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from t2 where t2.c1 in (select /*+no_rewrite*/ (select count(c1) from t1) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where exists (select (select 123 from dual) from dual);
Query Plan
========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |SUBPLAN FILTER|    |50000    |77868|
|1 | TABLE SCAN   |t2  |100000   |64066|
|2 | LIMIT        |    |1        |1    |
|3 |  EXPRESSION  |    |1        |1    |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([123]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
      values({1})

select * from t2 where exists (select (select 123 from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
|    4 |    4 |
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where exists (select /*+no_rewrite*/ (select 123 from dual) from dual);
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |50000    |77869|
|1 | TABLE SCAN    |t2  |100000   |64066|
|2 | SUBPLAN FILTER|    |1        |1    |
|3 |  LIMIT        |    |1        |1    |
|4 |   EXPRESSION  |    |1        |1    |
|5 |  EXPRESSION   |    |1        |1    |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil), limit(1), offset(nil)
  4 - output([1]), filter(nil)
      values({1})
  5 - output([123]), filter(nil)
      values({123})

select * from t2 where exists (select /*+no_rewrite*/ (select 123 from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
|    4 |    4 |
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where exists (select (select count(c1) from t1) from dual);
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t2  |100000   |64066|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), startup_filter([1]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where exists (select (select count(c1) from t1) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
|    4 |    4 |
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where exists (select /*+no_rewrite*/ (select count(c1) from t1) from dual);
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |SUBPLAN FILTER   |    |50000    |158829|
|1 | TABLE SCAN      |t2  |100000   |64066 |
|2 | SUBPLAN FILTER  |    |1        |80962 |
|3 |  LIMIT          |    |1        |1     |
|4 |   EXPRESSION    |    |1        |1     |
|5 |  SCALAR GROUP BY|    |1        |80961 |
|6 |   TABLE SCAN    |t1  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil), limit(1), offset(nil)
  4 - output([1]), filter(nil)
      values({1})
  5 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from t2 where exists (select /*+no_rewrite*/ (select count(c1) from t1) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
|    4 |    4 |
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where t2.c1 > all (select (select 123 from dual) from dual);
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t2  |10000    |80811|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 > 123]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where t2.c1 > all (select (select 123 from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 > all (select /*+no_rewrite*/ (select 123 from dual) from dual);
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |50000    |96652|
|1 | TABLE SCAN    |t2  |100000   |64066|
|2 | SUBPLAN FILTER|    |1        |1    |
|3 |  EXPRESSION   |    |1        |1    |
|4 |  EXPRESSION   |    |1        |1    |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([123]), filter(nil)
      values({123})

select * from t2 where t2.c1 > all (select /*+no_rewrite*/ (select 123 from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 > all (select (select count(c1) from t1) from dual);
Query Plan
=================================================
|ID|OPERATOR             |NAME |EST. ROWS|COST  |
-------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |66000    |190546|
|1 | TABLE SCAN          |t2   |100000   |64066 |
|2 | MATERIAL            |     |1        |80962 |
|3 |  SUBPLAN SCAN       |VIEW1|1        |80961 |
|4 |   SCALAR GROUP BY   |     |1        |80961 |
|5 |    TABLE SCAN       |t1   |100000   |61860 |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 <= VIEW1.count(c1) OR (T_OP_IS, t2.c1, NULL, 0)]), nl_params_(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([VIEW1.count(c1)]), filter(nil)
  3 - output([VIEW1.count(c1)]), filter(nil), 
      access([VIEW1.count(c1)])
  4 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from t2 where t2.c1 > all (select (select count(c1) from t1) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 > all (select /*+no_rewrite*/ (select count(c1) from t1) from dual);
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |SUBPLAN FILTER   |    |50000    |177613|
|1 | TABLE SCAN      |t2  |100000   |64066 |
|2 | SUBPLAN FILTER  |    |1        |80962 |
|3 |  EXPRESSION     |    |1        |1     |
|4 |  SCALAR GROUP BY|    |1        |80961 |
|5 |   TABLE SCAN    |t1  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 > ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from t2 where t2.c1 > all (select /*+no_rewrite*/ (select count(c1) from t1) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select t2.c1, (select (select 123 from dual) from dual) as s1 from t2 order by s1;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t2  |100000   |61860|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [123]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t2.c1, (select (select 123 from dual) from dual) as s1 from t2 order by s1;
+------+-----+
| c1   | s1  |
+------+-----+
|    1 | 123 |
|    2 | 123 |
|    3 | 123 |
|    4 | 123 |
|    5 | 123 |
+------+-----+
EXPLAIN select t2.c1, (select /*+no_rewrite*/ (select 123 from dual) from dual) as s1 from t2 order by s1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |100000   |75663|
|1 | TABLE SCAN    |t2  |100000   |61860|
|2 | SUBPLAN FILTER|    |1        |1    |
|3 |  EXPRESSION   |    |1        |1    |
|4 |  EXPRESSION   |    |1        |1    |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([123]), filter(nil)
      values({123})

select t2.c1, (select /*+no_rewrite*/ (select 123 from dual) from dual) as s1 from t2 order by s1;
+------+-----+
| c1   | s1  |
+------+-----+
|    1 | 123 |
|    2 | 123 |
|    3 | 123 |
|    4 | 123 |
|    5 | 123 |
+------+-----+
EXPLAIN select t2.c1, (select (select sum(c1) from t1) from dual) as s1 from t2 order by s1;
Query Plan
=======================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST  |
-------------------------------------------------------
|0 |SORT                       |     |100000   |561967|
|1 | NESTED-LOOP JOIN CARTESIAN|     |100000   |207559|
|2 |  SUBPLAN SCAN             |VIEW1|1        |80961 |
|3 |   SCALAR GROUP BY         |     |1        |80961 |
|4 |    TABLE SCAN             |t1   |100000   |61860 |
|5 |  TABLE SCAN               |t2   |100000   |61860 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [VIEW1.sum(c1)]), filter(nil), sort_keys([VIEW1.sum(c1), ASC])
  1 - output([t2.c1], [VIEW1.sum(c1)]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([VIEW1.sum(c1)]), filter(nil), 
      access([VIEW1.sum(c1)])
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t2.c1, (select (select sum(c1) from t1) from dual) as s1 from t2 order by s1;
+------+------+
| c1   | s1   |
+------+------+
|    1 |   15 |
|    2 |   15 |
|    3 |   15 |
|    4 |   15 |
|    5 |   15 |
+------+------+
EXPLAIN select t2.c1, (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) as s1 from t2 order by s1;
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |SUBPLAN FILTER   |    |100000   |156623|
|1 | TABLE SCAN      |t2  |100000   |61860 |
|2 | SUBPLAN FILTER  |    |1        |80962 |
|3 |  EXPRESSION     |    |1        |1     |
|4 |  SCALAR GROUP BY|    |1        |80961 |
|5 |   TABLE SCAN    |t1  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select t2.c1, (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) as s1 from t2 order by s1;
+------+------+
| c1   | s1   |
+------+------+
|    1 |   15 |
|    2 |   15 |
|    3 |   15 |
|    4 |   15 |
|    5 |   15 |
+------+------+
EXPLAIN select t2.c1, (select (select 123 from dual) from dual) as s1 from t2 having s1 > 5;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t2  |100000   |61860|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [123]), filter(nil), startup_filter([?]), 
      access([t2.c1]), partitions(p0)

select t2.c1, (select (select 123 from dual) from dual) as s1 from t2 having s1 > 5;
+------+-----+
| c1   | s1  |
+------+-----+
|    1 | 123 |
|    2 | 123 |
|    3 | 123 |
|    4 | 123 |
|    5 | 123 |
+------+-----+
EXPLAIN select t2.c1, (select /*+no_rewrite*/ (select 123 from dual) from dual) as s1 from t2 having s1 > 5;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |33334    |75663|
|1 | TABLE SCAN    |t2  |100000   |61860|
|2 | SUBPLAN FILTER|    |1        |1    |
|3 |  EXPRESSION   |    |1        |1    |
|4 |  EXPRESSION   |    |1        |1    |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [?]), filter([? > 5]), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([123]), filter(nil)
      values({123})

select t2.c1, (select /*+no_rewrite*/ (select 123 from dual) from dual) as s1 from t2 having s1 > 5;
+------+-----+
| c1   | s1  |
+------+-----+
|    1 | 123 |
|    2 | 123 |
|    3 | 123 |
|    4 | 123 |
|    5 | 123 |
+------+-----+
EXPLAIN select t2.c1, (select (select sum(c1) from t1) from dual) as s1 from t2 having s1 > 5;
Query Plan
=====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST |
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |5000     |87291|
|1 | SUBPLAN SCAN             |VIEW1|1        |80961|
|2 |  SCALAR GROUP BY         |     |1        |80961|
|3 |   TABLE SCAN             |t1   |100000   |61860|
|4 | TABLE SCAN               |t2   |100000   |61860|
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [VIEW1.sum(c1)]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([VIEW1.sum(c1)]), filter(nil), 
      access([VIEW1.sum(c1)])
  2 - output([T_FUN_SUM(t1.c1)]), filter([T_FUN_SUM(t1.c1) > ?]), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t2.c1, (select (select sum(c1) from t1) from dual) as s1 from t2 having s1 > 5;
+------+------+
| c1   | s1   |
+------+------+
|    1 |   15 |
|    2 |   15 |
|    3 |   15 |
|    4 |   15 |
|    5 |   15 |
+------+------+
EXPLAIN select t2.c1, (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) as s1 from t2 having s1 > 5;
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |SUBPLAN FILTER   |    |33334    |156623|
|1 | TABLE SCAN      |t2  |100000   |61860 |
|2 | SUBPLAN FILTER  |    |1        |80962 |
|3 |  EXPRESSION     |    |1        |1     |
|4 |  SCALAR GROUP BY|    |1        |80961 |
|5 |   TABLE SCAN    |t1  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [?]), filter([? > ?]), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select t2.c1, (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) as s1 from t2 having s1 > 5;
+------+------+
| c1   | s1   |
+------+------+
|    1 |   15 |
|    2 |   15 |
|    3 |   15 |
|    4 |   15 |
|    5 |   15 |
+------+------+
EXPLAIN select (select (select 123 from dual) from dual) from dual;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([123]), filter(nil)
      values({123})

select (select (select 123 from dual) from dual) from dual;
+-------------------------------------------+
| (select (select 123 from dual) from dual) |
+-------------------------------------------+
|                                       123 |
+-------------------------------------------+
EXPLAIN select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |1        |1   |
|1 | EXPRESSION    |    |1        |1   |
|2 | SUBPLAN FILTER|    |1        |1   |
|3 |  EXPRESSION   |    |1        |1   |
|4 |  EXPRESSION   |    |1        |1   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([123]), filter(nil)
      values({123})

select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual;
+-----------------------------------------------------------+
| (select /*+no_rewrite*/ (select 123 from dual) from dual) |
+-----------------------------------------------------------+
|                                                       123 |
+-----------------------------------------------------------+
EXPLAIN select (select (select sum(c1) from t1) from dual) from dual;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |80961|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select (select (select sum(c1) from t1) from dual) from dual;
+---------------------------------------------+
| (select (select sum(c1) from t1) from dual) |
+---------------------------------------------+
|                                          15 |
+---------------------------------------------+
EXPLAIN select /*+no_rewrite*/ (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) from dual;
Query Plan
===========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST |
-------------------------------------------
|0 |SUBPLAN FILTER   |    |1        |80962|
|1 | EXPRESSION      |    |1        |1    |
|2 | SUBPLAN FILTER  |    |1        |80962|
|3 |  EXPRESSION     |    |1        |1    |
|4 |  SCALAR GROUP BY|    |1        |80961|
|5 |   TABLE SCAN    |t1  |100000   |61860|
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select /*+no_rewrite*/ (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) from dual;
+-------------------------------------------------------------+
| (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) |
+-------------------------------------------------------------+
|                                                          15 |
+-------------------------------------------------------------+
EXPLAIN select * from (select (select (select 123 from dual) from dual) from dual);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([123]), filter(nil)
      values({123})

select * from (select (select (select 123 from dual) from dual) from dual);
+-------------------------------------------+
| (select (select 123 from dual) from dual) |
+-------------------------------------------+
|                                       123 |
+-------------------------------------------+
EXPLAIN select * from (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |1        |1   |
|1 | EXPRESSION    |    |1        |1   |
|2 | SUBPLAN FILTER|    |1        |1   |
|3 |  EXPRESSION   |    |1        |1   |
|4 |  EXPRESSION   |    |1        |1   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([123]), filter(nil)
      values({123})

select * from (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual);
+-----------------------------------------------------------+
| (select /*+no_rewrite*/ (select 123 from dual) from dual) |
+-----------------------------------------------------------+
|                                                       123 |
+-----------------------------------------------------------+
EXPLAIN select * from (select (select (select sum(c1) from t1) from dual) from dual);
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |80961|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from (select (select (select sum(c1) from t1) from dual) from dual);
+---------------------------------------------+
| (select (select sum(c1) from t1) from dual) |
+---------------------------------------------+
|                                          15 |
+---------------------------------------------+
EXPLAIN select * from (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) from dual);
Query Plan
===========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST |
-------------------------------------------
|0 |SUBPLAN FILTER   |    |1        |80962|
|1 | EXPRESSION      |    |1        |1    |
|2 | SUBPLAN FILTER  |    |1        |80962|
|3 |  EXPRESSION     |    |1        |1    |
|4 |  SCALAR GROUP BY|    |1        |80961|
|5 |   TABLE SCAN    |t1  |100000   |61860|
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) from dual);
+-------------------------------------------------------------+
| (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) |
+-------------------------------------------------------------+
|                                                          15 |
+-------------------------------------------------------------+
EXPLAIN select * from t2,(select (select (select 123 from dual) from dual) as c1 from dual) V where t2.c1 = V.c1;
Query Plan
==========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST |
------------------------------------------
|0 |NESTED-LOOP JOIN|    |990      |95118|
|1 | SUBPLAN SCAN   |V   |1        |1    |
|2 |  EXPRESSION    |    |1        |1    |
|3 | TABLE SCAN     |t2  |100000   |64066|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [V.c1]), filter(nil), 
      conds([t2.c1 = V.c1]), nl_params_(nil)
  1 - output([V.c1]), filter(nil), 
      access([V.c1])
  2 - output([123]), filter(nil)
      values({123})
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2,(select (select (select 123 from dual) from dual) as c1 from dual) V where t2.c1 = V.c1;
+------+------+----+
| c1   | c2   | c1 |
+------+------+----+
+------+------+----+
EXPLAIN select * from t2,(select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) as c1 from dual) V where t2.c1 = V.c1;
Query Plan
===========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST |
-------------------------------------------
|0 |NESTED-LOOP JOIN |    |990      |95118|
|1 | SUBPLAN SCAN    |V   |1        |1    |
|2 |  SUBPLAN FILTER |    |1        |1    |
|3 |   EXPRESSION    |    |1        |1    |
|4 |   SUBPLAN FILTER|    |1        |1    |
|5 |    EXPRESSION   |    |1        |1    |
|6 |    EXPRESSION   |    |1        |1    |
|7 | TABLE SCAN      |t2  |100000   |64066|
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [V.c1]), filter(nil), 
      conds([t2.c1 = V.c1]), nl_params_(nil)
  1 - output([V.c1]), filter(nil), 
      access([V.c1])
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil)
      values({1})
  6 - output([123]), filter(nil)
      values({123})
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2,(select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) as c1 from dual) V where t2.c1 = V.c1;
+------+------+----+
| c1   | c2   | c1 |
+------+------+----+
+------+------+----+
EXPLAIN select * from t2,(select (select (select sum(c1) from t1) from dual) as c1 from dual) V where t2.c1 = V.c1;
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |NESTED-LOOP JOIN |    |500      |175829|
|1 | SUBPLAN SCAN    |V   |1        |80961 |
|2 |  SCALAR GROUP BY|    |1        |80961 |
|3 |   TABLE SCAN    |t1  |100000   |61860 |
|4 | TABLE SCAN      |t2  |100000   |64066 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [V.c1]), filter(nil), 
      conds([cast(t2.c1, DECIMAL(11, 0)) = V.c1]), nl_params_(nil)
  1 - output([V.c1]), filter(nil), 
      access([V.c1])
  2 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2,(select (select (select sum(c1) from t1) from dual) as c1 from dual) V where t2.c1 = V.c1;
+------+------+------+
| c1   | c2   | c1   |
+------+------+------+
+------+------+------+
EXPLAIN select * from t2,(select /*+no_rewrite*/ (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) as c1 from dual) V where t2.c1 = V.c1;
Query Plan
==============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST  |
----------------------------------------------
|0 |NESTED-LOOP JOIN   |    |500      |175829|
|1 | SUBPLAN SCAN      |V   |1        |80962 |
|2 |  SUBPLAN FILTER   |    |1        |80962 |
|3 |   EXPRESSION      |    |1        |1     |
|4 |   SUBPLAN FILTER  |    |1        |80962 |
|5 |    EXPRESSION     |    |1        |1     |
|6 |    SCALAR GROUP BY|    |1        |80961 |
|7 |     TABLE SCAN    |t1  |100000   |61860 |
|8 | TABLE SCAN        |t2  |100000   |64066 |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [V.c1]), filter(nil), 
      conds([cast(t2.c1, DECIMAL(11, 0)) = V.c1]), nl_params_(nil)
  1 - output([V.c1]), filter(nil), 
      access([V.c1])
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil)
      values({1})
  6 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2,(select /*+no_rewrite*/ (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) as c1 from dual) V where t2.c1 = V.c1;
+------+------+------+
| c1   | c2   | c1   |
+------+------+------+
+------+------+------+
EXPLAIN select * from t2 where t2.c1 = (select (select (select 123 from dual) from dual) from dual);
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t2  |990      |80811|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 = 123]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where t2.c1 = (select (select (select 123 from dual) from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 = (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual);
Query Plan
==========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST |
------------------------------------------
|0 |SUBPLAN FILTER  |    |990      |80948|
|1 | TABLE SCAN     |t2  |990      |80811|
|2 | SUBPLAN FILTER |    |1        |1    |
|3 |  EXPRESSION    |    |1        |1    |
|4 |  SUBPLAN FILTER|    |1        |1    |
|5 |   EXPRESSION   |    |1        |1    |
|6 |   EXPRESSION   |    |1        |1    |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1], [t2.c2]), filter([t2.c1 = ?]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil)
      values({1})
  6 - output([123]), filter(nil)
      values({123})

select * from t2 where t2.c1 = (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 = (select (select (select count(c1) from t1) from dual) from dual);
Query Plan
=============================================
|ID|OPERATOR         |NAME |EST. ROWS|COST  |
---------------------------------------------
|0 |NESTED-LOOP JOIN |     |990      |176078|
|1 | SUBPLAN SCAN    |VIEW1|1        |80961 |
|2 |  SCALAR GROUP BY|     |1        |80961 |
|3 |   TABLE SCAN    |t1   |100000   |61860 |
|4 | TABLE SCAN      |t2   |100000   |64066 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 = VIEW1.count(c1)]), nl_params_(nil)
  1 - output([VIEW1.count(c1)]), filter(nil), 
      access([VIEW1.count(c1)])
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where t2.c1 = (select (select (select count(c1) from t1) from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where t2.c1 = (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select count(c1) from t1) from dual) from dual);
Query Plan
=============================================
|ID|OPERATOR          |NAME|EST. ROWS|COST  |
---------------------------------------------
|0 |SUBPLAN FILTER    |    |990      |161909|
|1 | TABLE SCAN       |t2  |990      |80811 |
|2 | SUBPLAN FILTER   |    |1        |80962 |
|3 |  EXPRESSION      |    |1        |1     |
|4 |  SUBPLAN FILTER  |    |1        |80962 |
|5 |   EXPRESSION     |    |1        |1     |
|6 |   SCALAR GROUP BY|    |1        |80961 |
|7 |    TABLE SCAN    |t1  |100000   |61860 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1], [t2.c2]), filter([t2.c1 = ?]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil)
      values({1})
  6 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from t2 where t2.c1 = (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select count(c1) from t1) from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where t2.c1 in (select (select (select 123 from dual) from dual) from dual);
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t2  |990      |80811|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 = 123]), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where t2.c1 in (select (select (select 123 from dual) from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 in (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual);
Query Plan
==========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST |
------------------------------------------
|0 |SUBPLAN FILTER  |    |50000    |96653|
|1 | TABLE SCAN     |t2  |100000   |64066|
|2 | SUBPLAN FILTER |    |1        |1    |
|3 |  EXPRESSION    |    |1        |1    |
|4 |  SUBPLAN FILTER|    |1        |1    |
|5 |   EXPRESSION   |    |1        |1    |
|6 |   EXPRESSION   |    |1        |1    |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil)
      values({1})
  6 - output([123]), filter(nil)
      values({123})

select * from t2 where t2.c1 in (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t2 where t2.c1 in (select (select (select count(c1) from t1) from dual) from dual);
Query Plan
=============================================
|ID|OPERATOR         |NAME |EST. ROWS|COST  |
---------------------------------------------
|0 |NESTED-LOOP JOIN |     |990      |176078|
|1 | SUBPLAN SCAN    |VIEW1|1        |80961 |
|2 |  SCALAR GROUP BY|     |1        |80961 |
|3 |   TABLE SCAN    |t1   |100000   |61860 |
|4 | TABLE SCAN      |t2   |100000   |64066 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter(nil), 
      conds([t2.c1 = VIEW1.count(c1)]), nl_params_(nil)
  1 - output([VIEW1.count(c1)]), filter(nil), 
      access([VIEW1.count(c1)])
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t2 where t2.c1 in (select (select (select count(c1) from t1) from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
+------+------+
EXPLAIN select * from t2 where t2.c1 in (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select count(c1) from t1) from dual) from dual);
Query Plan
=============================================
|ID|OPERATOR          |NAME|EST. ROWS|COST  |
---------------------------------------------
|0 |SUBPLAN FILTER    |    |50000    |177613|
|1 | TABLE SCAN       |t2  |100000   |64066 |
|2 | SUBPLAN FILTER   |    |1        |80962 |
|3 |  EXPRESSION      |    |1        |1     |
|4 |  SUBPLAN FILTER  |    |1        |80962 |
|5 |   EXPRESSION     |    |1        |1     |
|6 |   SCALAR GROUP BY|    |1        |80961 |
|7 |    TABLE SCAN    |t1  |100000   |61860 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2]), filter([t2.c1 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil)
      values({1})
  6 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select * from t2 where t2.c1 in (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select count(c1) from t1) from dual) from dual);
+------+------+
| c1   | c2   |
+------+------+
|    5 |    5 |
+------+------+
EXPLAIN select t2.c1, (select (select (select 123 from dual) from dual) from dual) as s1 from t2 order by s1;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t2  |100000   |61860|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [123]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t2.c1, (select (select (select 123 from dual) from dual) from dual) as s1 from t2 order by s1;
+------+-----+
| c1   | s1  |
+------+-----+
|    1 | 123 |
|    2 | 123 |
|    3 | 123 |
|    4 | 123 |
|    5 | 123 |
+------+-----+
EXPLAIN select t2.c1, (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual) as s1 from t2 order by s1;
Query Plan
==========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST |
------------------------------------------
|0 |SUBPLAN FILTER  |    |100000   |75663|
|1 | TABLE SCAN     |t2  |100000   |61860|
|2 | SUBPLAN FILTER |    |1        |1    |
|3 |  EXPRESSION    |    |1        |1    |
|4 |  SUBPLAN FILTER|    |1        |1    |
|5 |   EXPRESSION   |    |1        |1    |
|6 |   EXPRESSION   |    |1        |1    |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil)
      values({1})
  6 - output([123]), filter(nil)
      values({123})

select t2.c1, (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select 123 from dual) from dual) from dual) as s1 from t2 order by s1;
+------+-----+
| c1   | s1  |
+------+-----+
|    1 | 123 |
|    2 | 123 |
|    3 | 123 |
|    4 | 123 |
|    5 | 123 |
+------+-----+
EXPLAIN select t2.c1, (select (select (select sum(c1) from t1) from dual) from dual) as s1 from t2 order by s1;
Query Plan
=======================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST  |
-------------------------------------------------------
|0 |SORT                       |     |100000   |561967|
|1 | NESTED-LOOP JOIN CARTESIAN|     |100000   |207559|
|2 |  SUBPLAN SCAN             |VIEW1|1        |80961 |
|3 |   SCALAR GROUP BY         |     |1        |80961 |
|4 |    TABLE SCAN             |t1   |100000   |61860 |
|5 |  TABLE SCAN               |t2   |100000   |61860 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [VIEW1.sum(c1)]), filter(nil), sort_keys([VIEW1.sum(c1), ASC])
  1 - output([t2.c1], [VIEW1.sum(c1)]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([VIEW1.sum(c1)]), filter(nil), 
      access([VIEW1.sum(c1)])
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select t2.c1, (select (select (select sum(c1) from t1) from dual) from dual) as s1 from t2 order by s1;
+------+------+
| c1   | s1   |
+------+------+
|    1 |   15 |
|    2 |   15 |
|    3 |   15 |
|    4 |   15 |
|    5 |   15 |
+------+------+
EXPLAIN select t2.c1, (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) from dual) as s1 from t2 order by s1;
Query Plan
=============================================
|ID|OPERATOR          |NAME|EST. ROWS|COST  |
---------------------------------------------
|0 |SUBPLAN FILTER    |    |100000   |156624|
|1 | TABLE SCAN       |t2  |100000   |61860 |
|2 | SUBPLAN FILTER   |    |1        |80962 |
|3 |  EXPRESSION      |    |1        |1     |
|4 |  SUBPLAN FILTER  |    |1        |80962 |
|5 |   EXPRESSION     |    |1        |1     |
|6 |   SCALAR GROUP BY|    |1        |80961 |
|7 |    TABLE SCAN    |t1  |100000   |61860 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil)
      values({1})
  6 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select t2.c1, (select /*+no_rewrite*/ (select /*+no_rewrite*/ (select sum(c1) from t1) from dual) from dual) as s1 from t2 order by s1;
+------+------+
| c1   | s1   |
+------+------+
|    1 |   15 |
|    2 |   15 |
|    3 |   15 |
|    4 |   15 |
|    5 |   15 |
+------+------+

drop table t1,t2,t3;

*********************remove dummy exprs end************************

************************消除冗余group by/distinct**********

drop table if exists t1, t2, t3, tpart1, tpart2, t4, t5, t6;
create table t1 (c1 int, c2 int, c3 int, c4 int);
create table t2 (c1 int, c2 int, c3 int, c4 int);
create table t3 (c1 int, c2 int, c3 int, c4 int);
create table tpart1 (c1 int, c2 int, c3 int, c4 int) partition by hash(c1) partitions 3;
create table tpart2 (c1 int, c2 int, c3 int, c4 int) partition by hash(c1) partitions 3;
create table t4 (c1 int, c2 int, c3 int, c4 int);
create table t5 (c1 int, c2 int, c3 int, c4 int);
create table t6 (c1 int, c2 float, c3 decimal, c4 varchar(20), c5 date);
set autocommit = 1;

##basic test
EXPLAIN select c1, c2, min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2) group by c1,c2;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |7        |46  |
|1 | TABLE SCAN  |t1  |7        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, c2, min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2) group by c1,c2;
+------+------+------------+
| c1   | c2   | min(minc3) |
+------+------+------------+
|    1 |    1 |          3 |
|    1 |    2 |          1 |
|    2 |    1 |          2 |
| NULL | NULL |       NULL |
+------+------+------------+
EXPLAIN select /*+no_rewrite*/ c1, c2, min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2) group by c1,c2;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |52  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [.c2], [T_FUN_MIN(.minc3)]), filter(nil), 
      group([.c1], [.c2]), agg_func([T_FUN_MIN(.minc3)])
  1 - output([.c1], [.c2], [.minc3]), filter(nil), 
      access([.c1], [.c2], [.minc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, c2, min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2) group by c1,c2;
+------+------+------------+
| c1   | c2   | min(minc3) |
+------+------+------------+
| NULL | NULL |       NULL |
|    1 |    1 |          3 |
|    1 |    2 |          1 |
|    2 |    1 |          2 |
+------+------+------------+
EXPLAIN select c1, min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2) group by c1;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |7        |45  |
|1 | TABLE SCAN  |t1  |7        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MIN(t1.c3)])
  1 - output([t1.c1], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c3]), partitions(p0)

select c1, min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2) group by c1;
+------+------------+
| c1   | min(minc3) |
+------+------------+
|    1 |          1 |
|    2 |          2 |
| NULL |       NULL |
+------+------------+
EXPLAIN select /*+no_rewrite*/ c1, min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_MIN(.minc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_MIN(.minc3)])
  1 - output([.c1], [.minc3]), filter(nil), 
      access([.c1], [.minc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2) group by c1;
+------+------------+
| c1   | min(minc3) |
+------+------------+
| NULL |       NULL |
|    1 |          1 |
|    2 |          2 |
+------+------------+
EXPLAIN select min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(t1.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(t1.c3)])
  1 - output([t1.c3]), filter(nil), 
      access([t1.c3]), partitions(p0)

select min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2);
+------------+
| min(minc3) |
+------------+
|          1 |
+------------+
EXPLAIN select /*+no_rewrite*/ min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |48  |
|1 | SUBPLAN SCAN  |    |7        |47  |
|2 |  HASH GROUP BY|    |7        |46  |
|3 |   TABLE SCAN  |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.minc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.minc3)])
  1 - output([.minc3]), filter(nil), 
      access([.minc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ min(minc3) from (select c1, c2, min(c3) minc3 from t1 group by c1,c2);
+------------+
| min(minc3) |
+------------+
|          1 |
+------------+
EXPLAIN select min(minc3) from (select min(c3) minc3 from t1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(t1.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(t1.c3)])
  1 - output([t1.c3]), filter(nil), 
      access([t1.c3]), partitions(p0)

select min(minc3) from (select min(c3) minc3 from t1);
+------------+
| min(minc3) |
+------------+
|          1 |
+------------+
EXPLAIN select /*+no_rewrite*/ min(minc3) from (select min(c3) minc3 from t1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SCALAR GROUP BY  |    |1        |39  |
|1 | SUBPLAN SCAN    |    |1        |39  |
|2 |  SCALAR GROUP BY|    |1        |39  |
|3 |   TABLE SCAN    |t1  |7        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.minc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.minc3)])
  1 - output([.minc3]), filter(nil), 
      access([.minc3])
  2 - output([T_FUN_MIN(t1.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c3]), filter(nil), 
      access([t1.c3]), partitions(p0)

select /*+no_rewrite*/ min(minc3) from (select min(c3) minc3 from t1);
+------------+
| min(minc3) |
+------------+
|          1 |
+------------+

EXPLAIN select c1, c2, max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2) group by c1,c2;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |7        |46  |
|1 | TABLE SCAN  |t1  |7        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, c2, max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2) group by c1,c2;
+------+------+------------+
| c1   | c2   | max(maxc3) |
+------+------+------------+
|    1 |    1 |          5 |
|    1 |    2 |          4 |
|    2 |    1 |          2 |
| NULL | NULL |       NULL |
+------+------+------------+
EXPLAIN select /*+no_rewrite*/ c1, c2, max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2) group by c1,c2;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |52  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [.c2], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group([.c1], [.c2]), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.c1], [.c2], [.maxc3]), filter(nil), 
      access([.c1], [.c2], [.maxc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, c2, max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2) group by c1,c2;
+------+------+------------+
| c1   | c2   | max(maxc3) |
+------+------+------------+
| NULL | NULL |       NULL |
|    1 |    1 |          5 |
|    1 |    2 |          4 |
|    2 |    1 |          2 |
+------+------+------------+
EXPLAIN select c1, max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2) group by c1;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |7        |45  |
|1 | TABLE SCAN  |t1  |7        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MAX(t1.c3)])
  1 - output([t1.c1], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c3]), partitions(p0)

select c1, max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2) group by c1;
+------+------------+
| c1   | max(maxc3) |
+------+------------+
|    1 |          5 |
|    2 |          2 |
| NULL |       NULL |
+------+------------+
EXPLAIN select /*+no_rewrite*/ c1, max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.c1], [.maxc3]), filter(nil), 
      access([.c1], [.maxc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2) group by c1;
+------+------------+
| c1   | max(maxc3) |
+------+------------+
| NULL |       NULL |
|    1 |          5 |
|    2 |          2 |
+------+------------+
EXPLAIN select max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(t1.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t1.c3)])
  1 - output([t1.c3]), filter(nil), 
      access([t1.c3]), partitions(p0)

select max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2);
+------------+
| max(maxc3) |
+------------+
|          5 |
+------------+
EXPLAIN select /*+no_rewrite*/ max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |48  |
|1 | SUBPLAN SCAN  |    |7        |47  |
|2 |  HASH GROUP BY|    |7        |46  |
|3 |   TABLE SCAN  |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.maxc3]), filter(nil), 
      access([.maxc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ max(maxc3) from (select c1, c2, max(c3) maxc3 from t1 group by c1,c2);
+------------+
| max(maxc3) |
+------------+
|          5 |
+------------+
EXPLAIN select max(maxc3) from (select max(c3) maxc3 from t1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(t1.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t1.c3)])
  1 - output([t1.c3]), filter(nil), 
      access([t1.c3]), partitions(p0)

select max(maxc3) from (select max(c3) maxc3 from t1);
+------------+
| max(maxc3) |
+------------+
|          5 |
+------------+
EXPLAIN select /*+no_rewrite*/ max(maxc3) from (select max(c3) maxc3 from t1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SCALAR GROUP BY  |    |1        |39  |
|1 | SUBPLAN SCAN    |    |1        |39  |
|2 |  SCALAR GROUP BY|    |1        |39  |
|3 |   TABLE SCAN    |t1  |7        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.maxc3]), filter(nil), 
      access([.maxc3])
  2 - output([T_FUN_MAX(t1.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c3]), filter(nil), 
      access([t1.c3]), partitions(p0)

select /*+no_rewrite*/ max(maxc3) from (select max(c3) maxc3 from t1);
+------------+
| max(maxc3) |
+------------+
|          5 |
+------------+

EXPLAIN select c1, c2, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2) group by c1,c2;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |7        |46  |
|1 | TABLE SCAN  |t1  |7        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, c2, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2) group by c1,c2;
+------+------+----------+
| c1   | c2   | sum(sc3) |
+------+------+----------+
|    1 |    1 |        8 |
|    1 |    2 |        5 |
|    2 |    1 |        2 |
| NULL | NULL |     NULL |
+------+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, c2, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2) group by c1,c2;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |52  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [.c2], [T_FUN_SUM(.sc3)]), filter(nil), 
      group([.c1], [.c2]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.c2], [.sc3]), filter(nil), 
      access([.c1], [.c2], [.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, c2, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2) group by c1,c2;
+------+------+----------+
| c1   | c2   | sum(sc3) |
+------+------+----------+
| NULL | NULL |     NULL |
|    1 |    1 |        8 |
|    1 |    2 |        5 |
|    2 |    1 |        2 |
+------+------+----------+
EXPLAIN select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2) group by c1;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |7        |45  |
|1 | TABLE SCAN  |t1  |7        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))])
  1 - output([t1.c1], [cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c1], [t1.c3]), partitions(p0)

select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2) group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
|    1 |       13 |
|    2 |        2 |
| NULL |     NULL |
+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2) group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
| NULL |     NULL |
|    1 |       13 |
|    2 |        2 |
+------+----------+
EXPLAIN select sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))])
  1 - output([cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c3]), partitions(p0)

select sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |48  |
|1 | SUBPLAN SCAN  |    |7        |47  |
|2 |  HASH GROUP BY|    |7        |46  |
|3 |   TABLE SCAN  |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+
EXPLAIN select sum(sc3) from (select sum(c3) sc3 from t1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))])
  1 - output([cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c3]), partitions(p0)

select sum(sc3) from (select sum(c3) sc3 from t1);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3) from (select sum(c3) sc3 from t1);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SCALAR GROUP BY  |    |1        |39  |
|1 | SUBPLAN SCAN    |    |1        |39  |
|2 |  SCALAR GROUP BY|    |1        |39  |
|3 |   TABLE SCAN    |t1  |7        |38  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([T_FUN_SUM(t1.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c3]), filter(nil), 
      access([t1.c3]), partitions(p0)

select /*+no_rewrite*/ sum(sc3) from (select sum(c3) sc3 from t1);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+

EXPLAIN select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |41  |
|1 | TABLE SCAN    |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(t1.c1)], [T_FUN_MAX(t1.c2)], [T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t1.c3)], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(t1.c1)], [T_FUN_MAX(t1.c2)], [T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t1.c3)], [T_FUN_MAX(t1.c3)])
  1 - output([t1.c1], [t1.c2], [t1.c3], [cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t1 group by c1,c2);
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|       1 |       2 |       15 |          1 |          5 |
+---------+---------+----------+------------+------------+
EXPLAIN select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |50  |
|1 | SUBPLAN SCAN  |    |7        |48  |
|2 |  HASH GROUP BY|    |7        |47  |
|3 |   TABLE SCAN  |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)])
  1 - output([.c1], [.c2], [.sc3], [.minc3], [.maxc3]), filter(nil), 
      access([.c1], [.c2], [.sc3], [.minc3], [.maxc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)], [T_FUN_MIN(t1.c3)], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)], [T_FUN_MIN(t1.c3)], [T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t1 group by c1,c2);
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|       1 |       2 |       15 |          1 |          5 |
+---------+---------+----------+------------+------------+
EXPLAIN select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from tpart1 group by c1,c2);
Query Plan
======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |39  |
|1 | PX COORDINATOR          |        |1        |38  |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |38  |
|3 |   MERGE GROUP BY        |        |1        |38  |
|4 |    PX PARTITION ITERATOR|        |3        |37  |
|5 |     TABLE SCAN          |tpart1  |3        |37  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(T_FUN_MIN(tpart1.c1))], [T_FUN_MAX(T_FUN_MAX(tpart1.c2))], [T_FUN_SUM(T_FUN_SUM(cast(tpart1.c3, DECIMAL(11, 0))))], [T_FUN_MIN(T_FUN_MIN(tpart1.c3))], [T_FUN_MAX(T_FUN_MAX(tpart1.c3))]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(T_FUN_MIN(tpart1.c1))], [T_FUN_MAX(T_FUN_MAX(tpart1.c2))], [T_FUN_SUM(T_FUN_SUM(cast(tpart1.c3, DECIMAL(11, 0))))], [T_FUN_MIN(T_FUN_MIN(tpart1.c3))], [T_FUN_MAX(T_FUN_MAX(tpart1.c3))])
  1 - output([T_FUN_MIN(tpart1.c1)], [T_FUN_MAX(tpart1.c2)], [T_FUN_SUM(cast(tpart1.c3, DECIMAL(11, 0)))], [T_FUN_MIN(tpart1.c3)], [T_FUN_MAX(tpart1.c3)]), filter(nil)
  2 - output([T_FUN_MIN(tpart1.c1)], [T_FUN_MAX(tpart1.c2)], [T_FUN_SUM(cast(tpart1.c3, DECIMAL(11, 0)))], [T_FUN_MIN(tpart1.c3)], [T_FUN_MAX(tpart1.c3)]), filter(nil), dop=1
  3 - output([T_FUN_MIN(tpart1.c1)], [T_FUN_MAX(tpart1.c2)], [T_FUN_SUM(cast(tpart1.c3, DECIMAL(11, 0)))], [T_FUN_MIN(tpart1.c3)], [T_FUN_MAX(tpart1.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(tpart1.c1)], [T_FUN_MAX(tpart1.c2)], [T_FUN_SUM(cast(tpart1.c3, DECIMAL(11, 0)))], [T_FUN_MIN(tpart1.c3)], [T_FUN_MAX(tpart1.c3)])
  4 - output([tpart1.c1], [tpart1.c2], [tpart1.c3], [cast(tpart1.c3, DECIMAL(11, 0))]), filter(nil)
  5 - output([tpart1.c1], [tpart1.c2], [tpart1.c3], [cast(tpart1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([tpart1.c1], [tpart1.c2], [tpart1.c3]), partitions(p[0-2])

select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from tpart1 group by c1,c2);
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|       1 |       2 |       13 |          1 |          3 |
+---------+---------+----------+------------+------------+
EXPLAIN select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from tpart1 group by c1,c2);
Query Plan
=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |44  |
|1 | PX COORDINATOR           |        |1        |43  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |42  |
|3 |   MERGE GROUP BY         |        |1        |42  |
|4 |    SUBPLAN SCAN          |        |3        |41  |
|5 |     PX PARTITION ITERATOR|        |3        |41  |
|6 |      HASH GROUP BY       |        |3        |41  |
|7 |       TABLE SCAN         |tpart1  |3        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(T_FUN_MIN(.c1))], [T_FUN_MAX(T_FUN_MAX(.c2))], [T_FUN_SUM(T_FUN_SUM(.sc3))], [T_FUN_MIN(T_FUN_MIN(.minc3))], [T_FUN_MAX(T_FUN_MAX(.maxc3))]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(T_FUN_MIN(.c1))], [T_FUN_MAX(T_FUN_MAX(.c2))], [T_FUN_SUM(T_FUN_SUM(.sc3))], [T_FUN_MIN(T_FUN_MIN(.minc3))], [T_FUN_MAX(T_FUN_MAX(.maxc3))])
  1 - output([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil)
  2 - output([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil), dop=1
  3 - output([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)])
  4 - output([.c1], [.c2], [.sc3], [.minc3], [.maxc3]), filter(nil), 
      access([.c1], [.c2], [.sc3], [.minc3], [.maxc3])
  5 - output([tpart1.c1], [tpart1.c2], [T_FUN_SUM(tpart1.c3)], [T_FUN_MIN(tpart1.c3)], [T_FUN_MAX(tpart1.c3)]), filter(nil)
  6 - output([tpart1.c1], [tpart1.c2], [T_FUN_SUM(tpart1.c3)], [T_FUN_MIN(tpart1.c3)], [T_FUN_MAX(tpart1.c3)]), filter(nil), 
      group([tpart1.c1], [tpart1.c2]), agg_func([T_FUN_SUM(tpart1.c3)], [T_FUN_MIN(tpart1.c3)], [T_FUN_MAX(tpart1.c3)])
  7 - output([tpart1.c1], [tpart1.c2], [tpart1.c3]), filter(nil), 
      access([tpart1.c1], [tpart1.c2], [tpart1.c3]), partitions(p[0-2])

select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from tpart1 group by c1,c2);
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|       1 |       2 |       13 |          1 |          3 |
+---------+---------+----------+------------+------------+

EXPLAIN select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4 group by c1,c2) group by c1;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |1        |38  |
|1 | TABLE SCAN  |t4  |1        |36  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(t4.c1)], [T_FUN_MAX(t4.c2)], [T_FUN_SUM(cast(t4.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)]), filter(nil), 
      group([t4.c1]), agg_func([T_FUN_MIN(t4.c1)], [T_FUN_MAX(t4.c2)], [T_FUN_SUM(cast(t4.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)])
  1 - output([t4.c1], [t4.c2], [t4.c3], [cast(t4.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4 group by c1,c2) group by c1;
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|    NULL |    NULL |     NULL |       NULL |       NULL |
+---------+---------+----------+------------+------------+
EXPLAIN select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |38  |
|1 | SUBPLAN SCAN   |    |1        |38  |
|2 |  MERGE GROUP BY|    |1        |38  |
|3 |   SORT         |    |1        |37  |
|4 |    TABLE SCAN  |t4  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)])
  1 - output([.c1], [.c2], [.sc3], [.minc3], [.maxc3]), filter(nil), 
      access([.c1], [.c2], [.sc3], [.minc3], [.maxc3])
  2 - output([t4.c1], [t4.c2], [T_FUN_SUM(t4.c3)], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)]), filter(nil), 
      group([t4.c1], [t4.c2]), agg_func([T_FUN_SUM(t4.c3)], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)])
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC], [t4.c2, ASC])
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4 group by c1,c2) group by c1;
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|    NULL |    NULL |     NULL |       NULL |       NULL |
+---------+---------+----------+------------+------------+
EXPLAIN select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |37  |
|1 | TABLE SCAN    |t4  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(t4.c1)], [T_FUN_MAX(t4.c2)], [T_FUN_SUM(cast(t4.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(t4.c1)], [T_FUN_MAX(t4.c2)], [T_FUN_SUM(cast(t4.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)])
  1 - output([t4.c1], [t4.c2], [t4.c3], [cast(t4.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4 group by c1,c2);
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|    NULL |    NULL |     NULL |       NULL |       NULL |
+---------+---------+----------+------------+------------+
EXPLAIN select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |38  |
|1 | SUBPLAN SCAN  |    |1        |38  |
|2 |  HASH GROUP BY|    |1        |38  |
|3 |   TABLE SCAN  |t4  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)])
  1 - output([.c1], [.c2], [.sc3], [.minc3], [.maxc3]), filter(nil), 
      access([.c1], [.c2], [.sc3], [.minc3], [.maxc3])
  2 - output([t4.c1], [t4.c2], [T_FUN_SUM(t4.c3)], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)]), filter(nil), 
      group([t4.c1], [t4.c2]), agg_func([T_FUN_SUM(t4.c3)], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)])
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4 group by c1,c2);
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|    NULL |    NULL |     NULL |       NULL |       NULL |
+---------+---------+----------+------------+------------+
EXPLAIN select sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |37  |
|1 | TABLE SCAN    |t4  |1        |36  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(cast(t4.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(cast(t4.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)])
  1 - output([t4.c3], [cast(t4.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t4.c3]), partitions(p0)

select sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4);
+----------+------------+------------+
| sum(sc3) | min(minc3) | max(maxc3) |
+----------+------------+------------+
|     NULL |       NULL |       NULL |
+----------+------------+------------+
EXPLAIN select /*+no_rewrite*/ sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4);
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SCALAR GROUP BY  |    |1        |37  |
|1 | SUBPLAN SCAN    |    |1        |37  |
|2 |  SCALAR GROUP BY|    |1        |37  |
|3 |   TABLE SCAN    |t4  |1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)])
  1 - output([.sc3], [.minc3], [.maxc3]), filter(nil), 
      access([.sc3], [.minc3], [.maxc3])
  2 - output([t4.c1], [t4.c2], [T_FUN_SUM(t4.c3)], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t4.c3)], [T_FUN_MIN(t4.c3)], [T_FUN_MAX(t4.c3)])
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

select /*+no_rewrite*/ sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t4);
+----------+------------+------------+
| sum(sc3) | min(minc3) | max(maxc3) |
+----------+------------+------------+
|     NULL |       NULL |       NULL |
+----------+------------+------------+

EXPLAIN select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5 group by c1,c2) group by c1;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |HASH GROUP BY|    |101      |125664|
|1 | TABLE SCAN  |t5  |100000   |66272 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(t5.c1)], [T_FUN_MAX(t5.c2)], [T_FUN_SUM(cast(t5.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)]), filter(nil), 
      group([t5.c1]), agg_func([T_FUN_MIN(t5.c1)], [T_FUN_MAX(t5.c2)], [T_FUN_SUM(cast(t5.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [cast(t5.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0)

select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5 group by c1,c2) group by c1;
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
+---------+---------+----------+------------+------------+
EXPLAIN select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5 group by c1,c2) group by c1;
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |HASH GROUP BY  |    |101      |135349|
|1 | SUBPLAN SCAN  |    |10001    |129345|
|2 |  HASH GROUP BY|    |10001    |127965|
|3 |   TABLE SCAN  |t5  |100000   |66272 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)])
  1 - output([.c1], [.c2], [.sc3], [.minc3], [.maxc3]), filter(nil), 
      access([.c1], [.c2], [.sc3], [.minc3], [.maxc3])
  2 - output([t5.c1], [t5.c2], [T_FUN_SUM(t5.c3)], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)]), filter(nil), 
      group([t5.c1], [t5.c2]), agg_func([T_FUN_SUM(t5.c3)], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)])
  3 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0)

select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5 group by c1,c2) group by c1;
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
+---------+---------+----------+------------+------------+
EXPLAIN select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5 group by c1,c2);
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |SCALAR GROUP BY|    |1        |106569|
|1 | TABLE SCAN    |t5  |100000   |66272 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(t5.c1)], [T_FUN_MAX(t5.c2)], [T_FUN_SUM(cast(t5.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(t5.c1)], [T_FUN_MAX(t5.c2)], [T_FUN_SUM(cast(t5.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)])
  1 - output([t5.c1], [t5.c2], [t5.c3], [cast(t5.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0)

select min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5 group by c1,c2);
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|    NULL |    NULL |     NULL |       NULL |       NULL |
+---------+---------+----------+------------+------------+
EXPLAIN select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5 group by c1,c2);
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |SCALAR GROUP BY|    |1        |133375|
|1 | SUBPLAN SCAN  |    |10001    |129345|
|2 |  HASH GROUP BY|    |10001    |127965|
|3 |   TABLE SCAN  |t5  |100000   |66272 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.c1)], [T_FUN_MAX(.c2)], [T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)])
  1 - output([.c1], [.c2], [.sc3], [.minc3], [.maxc3]), filter(nil), 
      access([.c1], [.c2], [.sc3], [.minc3], [.maxc3])
  2 - output([t5.c1], [t5.c2], [T_FUN_SUM(t5.c3)], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)]), filter(nil), 
      group([t5.c1], [t5.c2]), agg_func([T_FUN_SUM(t5.c3)], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)])
  3 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0)

select /*+no_rewrite*/ min(c1), max(c2), sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5 group by c1,c2);
+---------+---------+----------+------------+------------+
| min(c1) | max(c2) | sum(sc3) | min(minc3) | max(maxc3) |
+---------+---------+----------+------------+------------+
|    NULL |    NULL |     NULL |       NULL |       NULL |
+---------+---------+----------+------------+------------+
EXPLAIN select sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5);
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |91559|
|1 | TABLE SCAN    |t5  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(cast(t5.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(cast(t5.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)])
  1 - output([t5.c3], [cast(t5.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t5.c3]), partitions(p0)

select sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5);
+----------+------------+------------+
| sum(sc3) | min(minc3) | max(maxc3) |
+----------+------------+------------+
|     NULL |       NULL |       NULL |
+----------+------------+------------+
EXPLAIN select /*+no_rewrite*/ sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5);
Query Plan
===========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST |
-------------------------------------------
|0 |SCALAR GROUP BY  |    |1        |95971|
|1 | SUBPLAN SCAN    |    |1        |95971|
|2 |  SCALAR GROUP BY|    |1        |95971|
|3 |   TABLE SCAN    |t5  |100000   |66272|
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)], [T_FUN_MIN(.minc3)], [T_FUN_MAX(.maxc3)])
  1 - output([.sc3], [.minc3], [.maxc3]), filter(nil), 
      access([.sc3], [.minc3], [.maxc3])
  2 - output([t5.c1], [t5.c2], [T_FUN_SUM(t5.c3)], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t5.c3)], [T_FUN_MIN(t5.c3)], [T_FUN_MAX(t5.c3)])
  3 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0)

select /*+no_rewrite*/ sum(sc3), min(minc3), max(maxc3) from (select c1, c2, sum(c3) sc3, min(c3) minc3, max(c3) maxc3 from t5);
+----------+------------+------------+
| sum(sc3) | min(minc3) | max(maxc3) |
+----------+------------+------------+
|     NULL |       NULL |       NULL |
+----------+------------+------------+

##union all test
EXPLAIN select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from t2 group by c1,c2));
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |84  |
|1 | SUBPLAN SCAN  |    |14       |81  |
|2 |  UNION ALL    |    |14       |79  |
|3 |   TABLE SCAN  |t1  |7        |38  |
|4 |   TABLE SCAN  |t2  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c3]), partitions(p0)
  4 - output([cast(t2.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t2.c3]), partitions(p0)

select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from t2 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       34 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from t2 group by c1,c2));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |101 |
|1 | SUBPLAN SCAN   |    |14       |98  |
|2 |  UNION ALL     |    |14       |96  |
|3 |   HASH GROUP BY|    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |7        |46  |
|6 |    TABLE SCAN  |t2  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.c3], [t1.c1], [t1.c2]), partitions(p0)
  5 - output([T_FUN_SUM(t2.c3)]), filter(nil), 
      group([t2.c1], [t2.c2]), agg_func([T_FUN_SUM(t2.c3)])
  6 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from t2 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       34 |
+----------+

EXPLAIN select max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1,c2)
      union all
      (select c1 from t2));
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |84  |
|1 | SUBPLAN SCAN  |    |14       |81  |
|2 |  UNION ALL    |    |14       |79  |
|3 |   TABLE SCAN  |t1  |7        |38  |
|4 |   TABLE SCAN  |t2  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.maxc3]), filter(nil), 
      access([.maxc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c3]), filter(nil), 
      access([t1.c3]), partitions(p0)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1,c2)
      union all
      (select c1 from t2));
+------------+
| max(maxc3) |
+------------+
|          5 |
+------------+
EXPLAIN select /*+no_rewrite*/ max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1,c2)
      union all
      (select c1 from t2));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |92  |
|1 | SUBPLAN SCAN   |    |14       |89  |
|2 |  UNION ALL     |    |14       |88  |
|3 |   HASH GROUP BY|    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   TABLE SCAN   |t2  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.maxc3]), filter(nil), 
      access([.maxc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  4 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.c3], [t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select /*+no_rewrite*/ max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1,c2)
      union all
      (select c1 from t2));
+------------+
| max(maxc3) |
+------------+
|          5 |
+------------+

EXPLAIN select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1)
      union all
      (select min(c3) sc3 from t2 group by c1,c2));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |92  |
|1 | SUBPLAN SCAN   |    |14       |89  |
|2 |  UNION ALL     |    |14       |88  |
|3 |   TABLE SCAN   |t1  |7        |38  |
|4 |   HASH GROUP BY|    |7        |46  |
|5 |    TABLE SCAN  |t2  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c3]), partitions(p0)
  4 - output([cast(T_FUN_MIN(t2.c3), DECIMAL(11, 0))]), filter(nil), 
      group([t2.c1], [t2.c2]), agg_func([T_FUN_MIN(t2.c3)])
  5 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1)
      union all
      (select min(c3) sc3 from t2 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       19 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1)
      union all
      (select min(c3) sc3 from t2 group by c1,c2));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |100 |
|1 | SUBPLAN SCAN   |    |14       |97  |
|2 |  UNION ALL     |    |14       |95  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |7        |46  |
|6 |    TABLE SCAN  |t2  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([cast(T_FUN_MIN(t2.c3), DECIMAL(11, 0))]), filter(nil), 
      group([t2.c1], [t2.c2]), agg_func([T_FUN_MIN(t2.c3)])
  6 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1)
      union all
      (select min(c3) sc3 from t2 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       19 |
+----------+

EXPLAIN select sum(sc3)
from ((select sum(c3) sc3 from tpart1 group by c1,c2)
      union all
      (select sum(c3) sc3 from tpart2 group by c1,c2));
Query Plan
=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |78  |
|1 | PX COORDINATOR           |        |1        |77  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |77  |
|3 |   MERGE GROUP BY         |        |1        |77  |
|4 |    SUBPLAN SCAN          |        |6        |76  |
|5 |     PX PARTITION ITERATOR|        |6        |75  |
|6 |      UNION ALL           |        |6        |75  |
|7 |       TABLE SCAN         |tpart1  |3        |37  |
|8 |       TABLE SCAN         |tpart2  |3        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(.sc3))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(.sc3))])
  1 - output([T_FUN_SUM(.sc3)]), filter(nil)
  2 - output([T_FUN_SUM(.sc3)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  4 - output([.sc3]), filter(nil), 
      access([.sc3])
  5 - output([UNION([1])]), filter(nil)
  6 - output([UNION([1])]), filter(nil)
  7 - output([cast(tpart1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([tpart1.c3]), partitions(p[0-2])
  8 - output([cast(tpart2.c3, DECIMAL(11, 0))]), filter(nil), 
      access([tpart2.c3]), partitions(p[0-2])

select sum(sc3)
from ((select sum(c3) sc3 from tpart1 group by c1,c2)
      union all
      (select sum(c3) sc3 from tpart2 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       44 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from tpart1 group by c1,c2)
      union all
      (select sum(c3) sc3 from tpart2 group by c1,c2));
Query Plan
=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |85  |
|1 | PX COORDINATOR           |        |1        |84  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |84  |
|3 |   MERGE GROUP BY         |        |1        |84  |
|4 |    SUBPLAN SCAN          |        |6        |83  |
|5 |     PX PARTITION ITERATOR|        |6        |82  |
|6 |      UNION ALL           |        |6        |82  |
|7 |       HASH GROUP BY      |        |3        |40  |
|8 |        TABLE SCAN        |tpart1  |3        |37  |
|9 |       HASH GROUP BY      |        |3        |40  |
|10|        TABLE SCAN        |tpart2  |3        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(.sc3))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(.sc3))])
  1 - output([T_FUN_SUM(.sc3)]), filter(nil)
  2 - output([T_FUN_SUM(.sc3)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  4 - output([.sc3]), filter(nil), 
      access([.sc3])
  5 - output([UNION([1])]), filter(nil)
  6 - output([UNION([1])]), filter(nil)
  7 - output([T_FUN_SUM(tpart1.c3)]), filter(nil), 
      group([tpart1.c1], [tpart1.c2]), agg_func([T_FUN_SUM(tpart1.c3)])
  8 - output([tpart1.c1], [tpart1.c3], [tpart1.c2]), filter(nil), 
      access([tpart1.c1], [tpart1.c3], [tpart1.c2]), partitions(p[0-2])
  9 - output([T_FUN_SUM(tpart2.c3)]), filter(nil), 
      group([tpart2.c1], [tpart2.c2]), agg_func([T_FUN_SUM(tpart2.c3)])
  10 - output([tpart2.c1], [tpart2.c3], [tpart2.c2]), filter(nil), 
      access([tpart2.c1], [tpart2.c3], [tpart2.c2]), partitions(p[0-2])

select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from tpart1 group by c1,c2)
      union all
      (select sum(c3) sc3 from tpart2 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       44 |
+----------+

EXPLAIN select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from tpart2 group by c1,c2));
Query Plan
=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |81  |
|1 | SUBPLAN SCAN             |        |10       |79  |
|2 |  UNION ALL               |        |10       |77  |
|3 |   TABLE SCAN             |t1      |7        |38  |
|4 |   PX COORDINATOR         |        |3        |37  |
|5 |    EXCHANGE OUT DISTR    |:EX10000|3        |37  |
|6 |     PX PARTITION ITERATOR|        |3        |37  |
|7 |      TABLE SCAN          |tpart2  |3        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c3]), partitions(p0)
  4 - output([cast(tpart2.c3, DECIMAL(11, 0))]), filter(nil)
  5 - output([cast(tpart2.c3, DECIMAL(11, 0))]), filter(nil), dop=1
  6 - output([cast(tpart2.c3, DECIMAL(11, 0))]), filter(nil)
  7 - output([cast(tpart2.c3, DECIMAL(11, 0))]), filter(nil), 
      access([tpart2.c3]), partitions(p[0-2])

select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from tpart2 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       46 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from tpart2 group by c1,c2));
Query Plan
=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |93  |
|1 | SUBPLAN SCAN             |        |10       |91  |
|2 |  UNION ALL               |        |10       |90  |
|3 |   HASH GROUP BY          |        |7        |46  |
|4 |    TABLE SCAN            |t1      |7        |38  |
|5 |   PX COORDINATOR         |        |3        |41  |
|6 |    EXCHANGE OUT DISTR    |:EX10000|3        |40  |
|7 |     PX PARTITION ITERATOR|        |3        |40  |
|8 |      HASH GROUP BY       |        |3        |40  |
|9 |       TABLE SCAN         |tpart2  |3        |37  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.c3], [t1.c1], [t1.c2]), partitions(p0)
  5 - output([T_FUN_SUM(tpart2.c3)]), filter(nil)
  6 - output([T_FUN_SUM(tpart2.c3)]), filter(nil), dop=1
  7 - output([T_FUN_SUM(tpart2.c3)]), filter(nil)
  8 - output([T_FUN_SUM(tpart2.c3)]), filter(nil), 
      group([tpart2.c1], [tpart2.c2]), agg_func([T_FUN_SUM(tpart2.c3)])
  9 - output([tpart2.c1], [tpart2.c3], [tpart2.c2]), filter(nil), 
      access([tpart2.c1], [tpart2.c3], [tpart2.c2]), partitions(p[0-2])

select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from tpart2 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       46 |
+----------+

EXPLAIN select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from t2 group by c1,c2)
      union all
      (select sum(c3) sc3 from t3 group by c1,c2));
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |124 |
|1 | SUBPLAN SCAN  |    |19       |120 |
|2 |  UNION ALL    |    |19       |117 |
|3 |   TABLE SCAN  |t1  |7        |38  |
|4 |   TABLE SCAN  |t2  |7        |38  |
|5 |   TABLE SCAN  |t3  |5        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c3]), partitions(p0)
  4 - output([cast(t2.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t2.c3]), partitions(p0)
  5 - output([cast(t3.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t3.c3]), partitions(p0)

select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from t2 group by c1,c2)
      union all
      (select sum(c3) sc3 from t3 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       46 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from t2 group by c1,c2)
      union all
      (select sum(c3) sc3 from t3 group by c1,c2));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |146 |
|1 | SUBPLAN SCAN   |    |19       |143 |
|2 |  UNION ALL     |    |19       |140 |
|3 |   HASH GROUP BY|    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |7        |46  |
|6 |    TABLE SCAN  |t2  |7        |38  |
|7 |   HASH GROUP BY|    |5        |43  |
|8 |    TABLE SCAN  |t3  |5        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.c3], [t1.c1], [t1.c2]), partitions(p0)
  5 - output([T_FUN_SUM(t2.c3)]), filter(nil), 
      group([t2.c1], [t2.c2]), agg_func([T_FUN_SUM(t2.c3)])
  6 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  7 - output([T_FUN_SUM(t3.c3)]), filter(nil), 
      group([t3.c1], [t3.c2]), agg_func([T_FUN_SUM(t3.c3)])
  8 - output([t3.c3], [t3.c1], [t3.c2]), filter(nil), 
      access([t3.c3], [t3.c1], [t3.c2]), partitions(p0)

select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select sum(c3) sc3 from t2 group by c1,c2)
      union all
      (select sum(c3) sc3 from t3 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       46 |
+----------+

EXPLAIN select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select min(c3) sc3 from t2 group by c1,c2)
      union all
      (select sum(c3) sc3 from t3 group by c1,c2));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |132 |
|1 | SUBPLAN SCAN   |    |19       |128 |
|2 |  UNION ALL     |    |19       |126 |
|3 |   TABLE SCAN   |t1  |7        |38  |
|4 |   HASH GROUP BY|    |7        |46  |
|5 |    TABLE SCAN  |t2  |7        |38  |
|6 |   TABLE SCAN   |t3  |5        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c3]), partitions(p0)
  4 - output([cast(T_FUN_MIN(t2.c3), DECIMAL(11, 0))]), filter(nil), 
      group([t2.c1], [t2.c2]), agg_func([T_FUN_MIN(t2.c3)])
  5 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  6 - output([cast(t3.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t3.c3]), partitions(p0)

select sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select min(c3) sc3 from t2 group by c1,c2)
      union all
      (select sum(c3) sc3 from t3 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       31 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select min(c3) sc3 from t2 group by c1,c2)
      union all
      (select sum(c3) sc3 from t3 group by c1,c2));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |146 |
|1 | SUBPLAN SCAN   |    |19       |143 |
|2 |  UNION ALL     |    |19       |140 |
|3 |   HASH GROUP BY|    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |7        |46  |
|6 |    TABLE SCAN  |t2  |7        |38  |
|7 |   HASH GROUP BY|    |5        |43  |
|8 |    TABLE SCAN  |t3  |5        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.c3], [t1.c1], [t1.c2]), partitions(p0)
  5 - output([cast(T_FUN_MIN(t2.c3), DECIMAL(11, 0))]), filter(nil), 
      group([t2.c1], [t2.c2]), agg_func([T_FUN_MIN(t2.c3)])
  6 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  7 - output([T_FUN_SUM(t3.c3)]), filter(nil), 
      group([t3.c1], [t3.c2]), agg_func([T_FUN_SUM(t3.c3)])
  8 - output([t3.c3], [t3.c1], [t3.c2]), filter(nil), 
      access([t3.c3], [t3.c1], [t3.c2]), partitions(p0)

select /*+no_rewrite*/ sum(sc3)
from ((select sum(c3) sc3 from t1 group by c1,c2)
      union all
      (select min(c3) sc3 from t2 group by c1,c2)
      union all
      (select sum(c3) sc3 from t3 group by c1,c2));
+----------+
| sum(sc3) |
+----------+
|       31 |
+----------+

##data type test
EXPLAIN select min(minc2), min(minc3), min(minc4), min(minc5) from (select min(c2) minc2, min(c3) minc3, min(c4) minc4 , min(c5) minc5 from t6 group by c1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t6  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(t6.c2)], [T_FUN_MIN(t6.c3)], [T_FUN_MIN(t6.c4)], [T_FUN_MIN(t6.c5)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(t6.c2)], [T_FUN_MIN(t6.c3)], [T_FUN_MIN(t6.c4)], [T_FUN_MIN(t6.c5)])
  1 - output([t6.c2], [t6.c3], [t6.c4], [t6.c5]), filter(nil), 
      access([t6.c2], [t6.c3], [t6.c4], [t6.c5]), partitions(p0)

select min(minc2), min(minc3), min(minc4), min(minc5) from (select min(c2) minc2, min(c3) minc3, min(c4) minc4 , min(c5) minc5 from t6 group by c1);
+------------+------------+------------+------------+
| min(minc2) | min(minc3) | min(minc4) | min(minc5) |
+------------+------------+------------+------------+
|        2.5 |          4 | ertt       | 2020-07-12 |
+------------+------------+------------+------------+
EXPLAIN select /*+no_rewrite*/ min(minc2), min(minc3), min(minc4), min(minc5) from (select min(c2) minc2, min(c3) minc3, min(c4) minc4 , min(c5) minc5 from t6 group by c1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |44  |
|1 | SUBPLAN SCAN  |    |4        |43  |
|2 |  HASH GROUP BY|    |4        |42  |
|3 |   TABLE SCAN  |t6  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.minc2)], [T_FUN_MIN(.minc3)], [T_FUN_MIN(.minc4)], [T_FUN_MIN(.minc5)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.minc2)], [T_FUN_MIN(.minc3)], [T_FUN_MIN(.minc4)], [T_FUN_MIN(.minc5)])
  1 - output([.minc2], [.minc3], [.minc4], [.minc5]), filter(nil), 
      access([.minc2], [.minc3], [.minc4], [.minc5])
  2 - output([T_FUN_MIN(t6.c2)], [T_FUN_MIN(t6.c3)], [T_FUN_MIN(t6.c4)], [T_FUN_MIN(t6.c5)]), filter(nil), 
      group([t6.c1]), agg_func([T_FUN_MIN(t6.c2)], [T_FUN_MIN(t6.c3)], [T_FUN_MIN(t6.c4)], [T_FUN_MIN(t6.c5)])
  3 - output([t6.c2], [t6.c3], [t6.c4], [t6.c5], [t6.c1]), filter(nil), 
      access([t6.c2], [t6.c3], [t6.c4], [t6.c5], [t6.c1]), partitions(p0)

select /*+no_rewrite*/ min(minc2), min(minc3), min(minc4), min(minc5) from (select min(c2) minc2, min(c3) minc3, min(c4) minc4 , min(c5) minc5 from t6 group by c1);
+------------+------------+------------+------------+
| min(minc2) | min(minc3) | min(minc4) | min(minc5) |
+------------+------------+------------+------------+
|        2.5 |          4 | ertt       | 2020-07-12 |
+------------+------------+------------+------------+
EXPLAIN select max(maxc2), max(maxc3), max(maxc4), max(maxc5) from (select max(c2) maxc2, max(c3) maxc3, max(c4) maxc4 , max(c5) maxc5 from t6 group by c1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t6  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(t6.c2)], [T_FUN_MAX(t6.c3)], [T_FUN_MAX(t6.c4)], [T_FUN_MAX(t6.c5)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t6.c2)], [T_FUN_MAX(t6.c3)], [T_FUN_MAX(t6.c4)], [T_FUN_MAX(t6.c5)])
  1 - output([t6.c2], [t6.c3], [t6.c4], [t6.c5]), filter(nil), 
      access([t6.c2], [t6.c3], [t6.c4], [t6.c5]), partitions(p0)

select max(maxc2), max(maxc3), max(maxc4), max(maxc5) from (select max(c2) maxc2, max(c3) maxc3, max(c4) maxc4 , max(c5) maxc5 from t6 group by c1);
+------------+------------+------------+------------+
| max(maxc2) | max(maxc3) | max(maxc4) | max(maxc5) |
+------------+------------+------------+------------+
|        5.4 |          9 | trew       | 2020-07-30 |
+------------+------------+------------+------------+
EXPLAIN select /*+no_rewrite*/ max(maxc2), max(maxc3), max(maxc4), max(maxc5) from (select max(c2) maxc2, max(c3) maxc3, max(c4) maxc4 , max(c5) maxc5 from t6 group by c1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |44  |
|1 | SUBPLAN SCAN  |    |4        |43  |
|2 |  HASH GROUP BY|    |4        |42  |
|3 |   TABLE SCAN  |t6  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(.maxc2)], [T_FUN_MAX(.maxc3)], [T_FUN_MAX(.maxc4)], [T_FUN_MAX(.maxc5)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(.maxc2)], [T_FUN_MAX(.maxc3)], [T_FUN_MAX(.maxc4)], [T_FUN_MAX(.maxc5)])
  1 - output([.maxc2], [.maxc3], [.maxc4], [.maxc5]), filter(nil), 
      access([.maxc2], [.maxc3], [.maxc4], [.maxc5])
  2 - output([T_FUN_MAX(t6.c2)], [T_FUN_MAX(t6.c3)], [T_FUN_MAX(t6.c4)], [T_FUN_MAX(t6.c5)]), filter(nil), 
      group([t6.c1]), agg_func([T_FUN_MAX(t6.c2)], [T_FUN_MAX(t6.c3)], [T_FUN_MAX(t6.c4)], [T_FUN_MAX(t6.c5)])
  3 - output([t6.c2], [t6.c3], [t6.c4], [t6.c5], [t6.c1]), filter(nil), 
      access([t6.c2], [t6.c3], [t6.c4], [t6.c5], [t6.c1]), partitions(p0)

select /*+no_rewrite*/ max(maxc2), max(maxc3), max(maxc4), max(maxc5) from (select max(c2) maxc2, max(c3) maxc3, max(c4) maxc4 , max(c5) maxc5 from t6 group by c1);
+------------+------------+------------+------------+
| max(maxc2) | max(maxc3) | max(maxc4) | max(maxc5) |
+------------+------------+------------+------------+
|        5.4 |          9 | trew       | 2020-07-30 |
+------------+------------+------------+------------+
EXPLAIN select sum(sumc2), sum(sumc3) from (select sum(c2) sumc2, sum(c3) sumc3 from t6 group by c1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |38  |
|1 | TABLE SCAN    |t6  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(cast(t6.c2, DOUBLE(-1, -1)))], [T_FUN_SUM(t6.c3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(cast(t6.c2, DOUBLE(-1, -1)))], [T_FUN_SUM(t6.c3)])
  1 - output([t6.c3], [cast(t6.c2, DOUBLE(-1, -1))]), filter(nil), 
      access([t6.c2], [t6.c3]), partitions(p0)

select sum(sumc2), sum(sumc3) from (select sum(c2) sumc2, sum(c3) sumc3 from t6 group by c1);
+--------------------+------------+
| sum(sumc2)         | sum(sumc3) |
+--------------------+------------+
| 15.299999952316284 |         24 |
+--------------------+------------+
EXPLAIN select /*+no_rewrite*/ sum(sumc2), sum(sumc3) from (select sum(c2) sumc2, sum(c3) sumc3 from t6 group by c1);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |43  |
|1 | SUBPLAN SCAN  |    |4        |42  |
|2 |  HASH GROUP BY|    |4        |42  |
|3 |   TABLE SCAN  |t6  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sumc2)], [T_FUN_SUM(.sumc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sumc2)], [T_FUN_SUM(.sumc3)])
  1 - output([.sumc2], [.sumc3]), filter(nil), 
      access([.sumc2], [.sumc3])
  2 - output([T_FUN_SUM(cast(t6.c2, DOUBLE(-1, -1)))], [T_FUN_SUM(t6.c3)]), filter(nil), 
      group([t6.c1]), agg_func([T_FUN_SUM(cast(t6.c2, DOUBLE(-1, -1)))], [T_FUN_SUM(t6.c3)])
  3 - output([t6.c3], [t6.c1], [cast(t6.c2, DOUBLE(-1, -1))]), filter(nil), 
      access([t6.c2], [t6.c3], [t6.c1]), partitions(p0)

select /*+no_rewrite*/ sum(sumc2), sum(sumc3) from (select sum(c2) sumc2, sum(c3) sumc3 from t6 group by c1);
+--------------------+------------+
| sum(sumc2)         | sum(sumc3) |
+--------------------+------------+
| 15.299999952316284 |         24 |
+--------------------+------------+

EXPLAIN select sum(sumc3)
from ((select sum(c3) sumc3 from t1 group by c1)
      union all
      (select sum(c2) from t6 group by c1));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |89  |
|1 | SUBPLAN SCAN   |    |11       |87  |
|2 |  UNION ALL     |    |11       |85  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   TABLE SCAN   |t6  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sumc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sumc3)])
  1 - output([.sumc3]), filter(nil), 
      access([.sumc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(T_FUN_SUM(t1.c3), DOUBLE(-1, -1))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([cast(t6.c2, DOUBLE(-1, -1))]), filter(nil), 
      access([t6.c2]), partitions(p0)

select sum(sumc3)
from ((select sum(c3) sumc3 from t1 group by c1)
      union all
      (select sum(c2) from t6 group by c1));
+--------------------+
| sum(sumc3)         |
+--------------------+
| 30.299999952316284 |
+--------------------+
EXPLAIN select /*+no_rewrite*/ sum(sumc3)
from ((select sum(c3) sumc3 from t1 group by c1)
      union all
      (select sum(c2) from t6 group by c1));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |94  |
|1 | SUBPLAN SCAN   |    |11       |91  |
|2 |  UNION ALL     |    |11       |90  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |4        |41  |
|6 |    TABLE SCAN  |t6  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sumc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sumc3)])
  1 - output([.sumc3]), filter(nil), 
      access([.sumc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(T_FUN_SUM(t1.c3), DOUBLE(-1, -1))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([T_FUN_SUM(cast(t6.c2, DOUBLE(-1, -1)))]), filter(nil), 
      group([t6.c1]), agg_func([T_FUN_SUM(cast(t6.c2, DOUBLE(-1, -1)))])
  6 - output([t6.c1], [cast(t6.c2, DOUBLE(-1, -1))]), filter(nil), 
      access([t6.c2], [t6.c1]), partitions(p0)

select /*+no_rewrite*/ sum(sumc3)
from ((select sum(c3) sumc3 from t1 group by c1)
      union all
      (select sum(c2) from t6 group by c1));
+--------------------+
| sum(sumc3)         |
+--------------------+
| 30.299999952316284 |
+--------------------+

EXPLAIN select sum(sumc3)
from ((select sum(c3) sumc3 from t1 group by c1)
      union all
      (select sum(c3) from t6 group by c1));
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |81  |
|1 | SUBPLAN SCAN  |    |11       |79  |
|2 |  UNION ALL    |    |11       |78  |
|3 |   TABLE SCAN  |t1  |7        |38  |
|4 |   TABLE SCAN  |t6  |4        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sumc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sumc3)])
  1 - output([.sumc3]), filter(nil), 
      access([.sumc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c3]), partitions(p0)
  4 - output([t6.c3]), filter(nil), 
      access([t6.c3]), partitions(p0)

select sum(sumc3)
from ((select sum(c3) sumc3 from t1 group by c1)
      union all
      (select sum(c3) from t6 group by c1));
+------------+
| sum(sumc3) |
+------------+
|         39 |
+------------+
EXPLAIN select /*+no_rewrite*/ sum(sumc3)
from ((select sum(c3) sumc3 from t1 group by c1)
      union all
      (select sum(c3) from t6 group by c1));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |94  |
|1 | SUBPLAN SCAN   |    |11       |91  |
|2 |  UNION ALL     |    |11       |90  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |4        |41  |
|6 |    TABLE SCAN  |t6  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sumc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sumc3)])
  1 - output([.sumc3]), filter(nil), 
      access([.sumc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([T_FUN_SUM(t6.c3)]), filter(nil), 
      group([t6.c1]), agg_func([T_FUN_SUM(t6.c3)])
  6 - output([t6.c3], [t6.c1]), filter(nil), 
      access([t6.c3], [t6.c1]), partitions(p0)

select /*+no_rewrite*/ sum(sumc3)
from ((select sum(c3) sumc3 from t1 group by c1)
      union all
      (select sum(c3) from t6 group by c1));
+------------+
| sum(sumc3) |
+------------+
|         39 |
+------------+

EXPLAIN select min(minc3)
from ((select min(c3) minc3 from t1 group by c1)
      union all
      (select min(c3) from t6 group by c1));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |89  |
|1 | SUBPLAN SCAN   |    |11       |87  |
|2 |  UNION ALL     |    |11       |85  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   TABLE SCAN   |t6  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.minc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.minc3)])
  1 - output([.minc3]), filter(nil), 
      access([.minc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(T_FUN_MIN(t1.c3), DECIMAL(11, 0))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MIN(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([t6.c3]), filter(nil), 
      access([t6.c3]), partitions(p0)

select min(minc3)
from ((select min(c3) minc3 from t1 group by c1)
      union all
      (select min(c3) from t6 group by c1));
+------------+
| min(minc3) |
+------------+
|          1 |
+------------+
EXPLAIN select /*+no_rewrite*/ min(minc3)
from ((select min(c3) minc3 from t1 group by c1)
      union all
      (select min(c3) from t6 group by c1));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |94  |
|1 | SUBPLAN SCAN   |    |11       |91  |
|2 |  UNION ALL     |    |11       |90  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |4        |41  |
|6 |    TABLE SCAN  |t6  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.minc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.minc3)])
  1 - output([.minc3]), filter(nil), 
      access([.minc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(T_FUN_MIN(t1.c3), DECIMAL(11, 0))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MIN(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([T_FUN_MIN(t6.c3)]), filter(nil), 
      group([t6.c1]), agg_func([T_FUN_MIN(t6.c3)])
  6 - output([t6.c3], [t6.c1]), filter(nil), 
      access([t6.c3], [t6.c1]), partitions(p0)

select /*+no_rewrite*/ min(minc3)
from ((select min(c3) minc3 from t1 group by c1)
      union all
      (select min(c3) from t6 group by c1));
+------------+
| min(minc3) |
+------------+
|          1 |
+------------+

EXPLAIN select max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1)
      union all
      (select max(c4) from t6 group by c1));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |89  |
|1 | SUBPLAN SCAN   |    |11       |87  |
|2 |  UNION ALL     |    |11       |85  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   TABLE SCAN   |t6  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.maxc3]), filter(nil), 
      access([.maxc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(T_FUN_MAX(t1.c3), VARCHAR(20))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MAX(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([t6.c4]), filter(nil), 
      access([t6.c4]), partitions(p0)

select max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1)
      union all
      (select max(c4) from t6 group by c1));
+------------+
| max(maxc3) |
+------------+
| trew       |
+------------+
EXPLAIN select /*+no_rewrite*/ max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1)
      union all
      (select max(c4) from t6 group by c1));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |94  |
|1 | SUBPLAN SCAN   |    |11       |91  |
|2 |  UNION ALL     |    |11       |90  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |4        |41  |
|6 |    TABLE SCAN  |t6  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.maxc3]), filter(nil), 
      access([.maxc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(T_FUN_MAX(t1.c3), VARCHAR(20))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MAX(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([T_FUN_MAX(t6.c4)]), filter(nil), 
      group([t6.c1]), agg_func([T_FUN_MAX(t6.c4)])
  6 - output([t6.c4], [t6.c1]), filter(nil), 
      access([t6.c4], [t6.c1]), partitions(p0)

select /*+no_rewrite*/ max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1)
      union all
      (select max(c4) from t6 group by c1));
+------------+
| max(maxc3) |
+------------+
| trew       |
+------------+

EXPLAIN select max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1)
      union all
      (select max(c5) from t6 group by c1));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |94  |
|1 | SUBPLAN SCAN   |    |11       |91  |
|2 |  UNION ALL     |    |11       |90  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |4        |41  |
|6 |    TABLE SCAN  |t6  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.maxc3]), filter(nil), 
      access([.maxc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(T_FUN_MAX(t1.c3), VARCHAR(11))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MAX(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([cast(T_FUN_MAX(t6.c5), VARCHAR(11))]), filter(nil), 
      group([t6.c1]), agg_func([T_FUN_MAX(t6.c5)])
  6 - output([t6.c5], [t6.c1]), filter(nil), 
      access([t6.c5], [t6.c1]), partitions(p0)

select max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1)
      union all
      (select max(c5) from t6 group by c1));
+------------+
| max(maxc3) |
+------------+
| 5          |
+------------+
EXPLAIN select /*+no_rewrite*/ max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1)
      union all
      (select max(c5) from t6 group by c1));
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |94  |
|1 | SUBPLAN SCAN   |    |11       |91  |
|2 |  UNION ALL     |    |11       |90  |
|3 |   HASH GROUP BY|    |7        |45  |
|4 |    TABLE SCAN  |t1  |7        |38  |
|5 |   HASH GROUP BY|    |4        |41  |
|6 |    TABLE SCAN  |t6  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(.maxc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(.maxc3)])
  1 - output([.maxc3]), filter(nil), 
      access([.maxc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([cast(T_FUN_MAX(t1.c3), VARCHAR(11))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_MAX(t1.c3)])
  4 - output([t1.c3], [t1.c1]), filter(nil), 
      access([t1.c3], [t1.c1]), partitions(p0)
  5 - output([cast(T_FUN_MAX(t6.c5), VARCHAR(11))]), filter(nil), 
      group([t6.c1]), agg_func([T_FUN_MAX(t6.c5)])
  6 - output([t6.c5], [t6.c1]), filter(nil), 
      access([t6.c5], [t6.c1]), partitions(p0)

select /*+no_rewrite*/ max(maxc3)
from ((select max(c3) maxc3 from t1 group by c1)
      union all
      (select max(c5) from t6 group by c1));
+------------+
| max(maxc3) |
+------------+
| 5          |
+------------+

##消除条件测试
##1.select 中有非 aggr 项
EXPLAIN select c1, sc3 from (select c1, c2, max(c3) sc3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [.sc3]), filter(nil), 
      group([.c1]), agg_func(nil)
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c3], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, sc3 from (select c1, c2, max(c3) sc3 from t1 group by c1,c2) group by c1;
+------+------+
| c1   | sc3  |
+------+------+
| NULL | NULL |
|    1 |    5 |
|    2 |    2 |
+------+------+
EXPLAIN select /*+no_rewrite*/ c1, sc3 from (select c1, c2, max(c3) sc3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [.sc3]), filter(nil), 
      group([.c1]), agg_func(nil)
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sc3 from (select c1, c2, max(c3) sc3 from t1 group by c1,c2) group by c1;
+------+------+
| c1   | sc3  |
+------+------+
| NULL | NULL |
|    1 |    5 |
|    2 |    2 |
+------+------+
EXPLAIN select c1, c2 from (select c1, c2, max(c3) sc3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |49  |
|1 | SUBPLAN SCAN   |    |7        |47  |
|2 |  MERGE GROUP BY|    |7        |46  |
|3 |   SORT         |    |7        |44  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [.c2]), filter(nil), 
      group([.c1]), agg_func(nil)
  1 - output([.c1], [.c2]), filter(nil), 
      access([.c1], [.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select c1, c2 from (select c1, c2, max(c3) sc3 from t1 group by c1,c2) group by c1;
+------+------+
| c1   | c2   |
+------+------+
| NULL | NULL |
|    1 |    1 |
|    2 |    1 |
+------+------+
EXPLAIN select /*+no_rewrite*/c1, c2 from (select c1, c2, max(c3) sc3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [.c2]), filter(nil), 
      group([.c1]), agg_func(nil)
  1 - output([.c1], [.c2]), filter(nil), 
      access([.c1], [.c2])
  2 - output([t1.c1], [t1.c2], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/c1, c2 from (select c1, c2, max(c3) sc3 from t1 group by c1,c2) group by c1;
+------+------+
| c1   | c2   |
+------+------+
| NULL | NULL |
|    1 |    1 |
|    2 |    1 |
+------+------+

##2.aggr 不匹配
EXPLAIN select c1, sum(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.c3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.c3)])
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c3], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, sum(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1;
+------+---------+
| c1   | sum(c3) |
+------+---------+
| NULL |    NULL |
|    1 |       4 |
|    2 |       2 |
+------+---------+
EXPLAIN select /*+no_rewrite*/c1, sum(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.c3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.c3)])
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/c1, sum(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1;
+------+---------+
| c1   | sum(c3) |
+------+---------+
| NULL |    NULL |
|    1 |       4 |
|    2 |       2 |
+------+---------+
EXPLAIN select c1, sum(c3) from (select c1, c2, max(c3) c3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.c3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.c3)])
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c3], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, sum(c3) from (select c1, c2, max(c3) c3 from t1 group by c1,c2) group by c1;
+------+---------+
| c1   | sum(c3) |
+------+---------+
| NULL |    NULL |
|    1 |       9 |
|    2 |       2 |
+------+---------+
EXPLAIN select /*+no_rewrite*/c1, sum(c3) from (select c1, c2, max(c3) c3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.c3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.c3)])
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/c1, sum(c3) from (select c1, c2, max(c3) c3 from t1 group by c1,c2) group by c1;
+------+---------+
| c1   | sum(c3) |
+------+---------+
| NULL |    NULL |
|    1 |       9 |
|    2 |       2 |
+------+---------+
EXPLAIN select c1, max(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_MAX(.c3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_MAX(.c3)])
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c3], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, max(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1;
+------+---------+
| c1   | max(c3) |
+------+---------+
| NULL |    NULL |
|    1 |       3 |
|    2 |       2 |
+------+---------+
EXPLAIN select /*+no_rewrite*/c1, max(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_MAX(.c3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_MAX(.c3)])
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/c1, max(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1;
+------+---------+
| c1   | max(c3) |
+------+---------+
| NULL |    NULL |
|    1 |       3 |
|    2 |       2 |
+------+---------+

##3.limit/distinct
EXPLAIN select sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2 limit 5);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |47  |
|1 | SUBPLAN SCAN   |    |5        |46  |
|2 |  LIMIT         |    |5        |45  |
|3 |   HASH GROUP BY|    |5        |44  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([T_FUN_SUM(t1.c3)]), filter(nil), limit(5), offset(nil)
  3 - output([T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2 limit 5);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2 limit 5);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |47  |
|1 | SUBPLAN SCAN   |    |5        |46  |
|2 |  LIMIT         |    |5        |45  |
|3 |   HASH GROUP BY|    |5        |44  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), limit(5), offset(nil)
  3 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2 limit 5);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+
EXPLAIN select sum(sc3) from (select distinct c1, c2, sum(c3) sc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |39  |
|1 | TABLE SCAN    |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))])
  1 - output([cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c3]), partitions(p0)

select sum(sc3) from (select distinct c1, c2, sum(c3) sc3 from t1 group by c1,c2);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3) from (select distinct c1, c2, sum(c3) sc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |48  |
|1 | SUBPLAN SCAN  |    |7        |47  |
|2 |  HASH GROUP BY|    |7        |46  |
|3 |   TABLE SCAN  |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ sum(sc3) from (select distinct c1, c2, sum(c3) sc3 from t1 group by c1,c2);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+
EXPLAIN select sum(sc3) from (select c1, c2, sum(distinct c3) sc3 from t1 group by c1,c2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([T_FUN_SUM(distinct t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(distinct t1.c3)])
  3 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select sum(sc3) from (select c1, c2, sum(distinct c3) sc3 from t1 group by c1,c2);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+
EXPLAIN select /*+no_rewrite*/ sum(sc3) from (select c1, c2, sum(distinct c3) sc3 from t1 group by c1,c2);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY |    |1        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(distinct t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(distinct t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ sum(sc3) from (select c1, c2, sum(distinct c3) sc3 from t1 group by c1,c2);
+----------+
| sum(sc3) |
+----------+
|       15 |
+----------+
EXPLAIN select sum(distinct sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |48  |
|1 | SUBPLAN SCAN  |    |7        |47  |
|2 |  HASH GROUP BY|    |7        |46  |
|3 |   TABLE SCAN  |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(distinct .sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(distinct .sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select sum(distinct sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2);
+-------------------+
| sum(distinct sc3) |
+-------------------+
|                15 |
+-------------------+
EXPLAIN select /*+no_rewrite*/ sum(distinct sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2);
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |48  |
|1 | SUBPLAN SCAN  |    |7        |47  |
|2 |  HASH GROUP BY|    |7        |46  |
|3 |   TABLE SCAN  |t1  |7        |38  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(distinct .sc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(distinct .sc3)])
  1 - output([.sc3]), filter(nil), 
      access([.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ sum(distinct sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1,c2);
+-------------------+
| sum(distinct sc3) |
+-------------------+
|                15 |
+-------------------+

##4.having/condition测试
EXPLAIN select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1  where c1 > 10 group by c1, c2) group by c1;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |1        |40  |
|1 | SORT         |    |1        |39  |
|2 |  TABLE SCAN  |t1  |1        |39  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))])
  1 - output([t1.c1], [cast(t1.c3, DECIMAL(11, 0))]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c3]), filter([t1.c1 > 10]), 
      access([t1.c1], [t1.c3]), partitions(p0)

select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1  where c1 > 10 group by c1, c2) group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1  where c1 > 10 group by c1, c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |40  |
|1 | SUBPLAN SCAN   |    |1        |40  |
|2 |  MERGE GROUP BY|    |1        |40  |
|3 |   SORT         |    |1        |40  |
|4 |    TABLE SCAN  |t1  |1        |39  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter([t1.c1 > 10]), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1  where c1 > 10 group by c1, c2) group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
+------+----------+
EXPLAIN select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2 having sc3 > 10) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |46  |
|1 | SORT           |    |1        |46  |
|2 |  SUBPLAN SCAN  |    |1        |46  |
|3 |   HASH GROUP BY|    |1        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), sort_keys([.c1, ASC])
  2 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  3 - output([t1.c1], [T_FUN_SUM(t1.c3)]), filter([T_FUN_SUM(t1.c3) > ?]), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2 having sc3 > 10) group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2 having sc3 > 3) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |46  |
|1 | SORT           |    |1        |46  |
|2 |  SUBPLAN SCAN  |    |1        |46  |
|3 |   HASH GROUP BY|    |1        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), sort_keys([.c1, ASC])
  2 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  3 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter([T_FUN_SUM(t1.c3) > ?]), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2 having sc3 > 3) group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
|    1 |       13 |
+------+----------+
EXPLAIN select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) where sc3 > 10 group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |46  |
|1 | SORT           |    |1        |46  |
|2 |  SUBPLAN SCAN  |    |1        |46  |
|3 |   HASH GROUP BY|    |1        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), sort_keys([.c1, ASC])
  2 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  3 - output([t1.c1], [T_FUN_SUM(t1.c3)]), filter([T_FUN_SUM(t1.c3) > ?]), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) where sc3 > 10 group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) where sc3 > 3 group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |46  |
|1 | SORT           |    |1        |46  |
|2 |  SUBPLAN SCAN  |    |1        |46  |
|3 |   HASH GROUP BY|    |1        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), sort_keys([.c1, ASC])
  2 - output([.sc3], [.c1]), filter(nil), 
      access([.sc3], [.c1])
  3 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter([T_FUN_SUM(t1.c3) > ?]), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) where sc3 > 3 group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
|    1 |       13 |
+------+----------+
EXPLAIN select c1, c3 from (select c1, c2, max(c3) c3 from t1 group by c1,c2) group by c1 having c3 > 10;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |4        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [.c3]), filter([.c3 > 10]), 
      group([.c1]), agg_func(nil)
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c3], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, c3 from (select c1, c2, max(c3) c3 from t1 group by c1,c2) group by c1 having c3 > 10;
+------+------+
| c1   | c3   |
+------+------+
+------+------+
EXPLAIN select /*+no_rewrite*/ c1, c3 from (select c1, c2, max(c3) c3 from t1 group by c1,c2) group by c1 having c3 > 3;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |4        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [.c3]), filter([.c3 > 3]), 
      group([.c1]), agg_func(nil)
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MAX(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MAX(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, c3 from (select c1, c2, max(c3) c3 from t1 group by c1,c2) group by c1 having c3 > 3;
+------+------+
| c1   | c3   |
+------+------+
|    1 |    5 |
+------+------+
EXPLAIN select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having sum(sc3)> 3;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |1        |45  |
|1 | TABLE SCAN  |t1  |7        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))]), filter([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0))) > ?]), 
      group([t1.c1]), agg_func([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))])
  1 - output([t1.c1], [cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c1], [t1.c3]), partitions(p0)

select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having sum(sc3)> 3;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
|    1 |       13 |
+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having sum(sc3)> 3;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter([T_FUN_SUM(.sc3) > ?]), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having sum(sc3)> 3;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
|    1 |       13 |
+------+----------+
EXPLAIN select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having sum(c1)> 3;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |52  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter([T_FUN_SUM(.c1) > ?]), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)], [T_FUN_SUM(.c1)])
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c3], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having sum(c1)> 3;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having sum(c1)> 3;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |52  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter([T_FUN_SUM(.c1) > ?]), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)], [T_FUN_SUM(.c1)])
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having sum(c1)> 3;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
+------+----------+
EXPLAIN select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having min(c1)> 1;
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |1        |46  |
|1 | TABLE SCAN  |t1  |7        |38  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))]), filter([T_FUN_MIN(t1.c1) > 1]), 
      group([t1.c1]), agg_func([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))], [T_FUN_MIN(t1.c1)])
  1 - output([t1.c1], [cast(t1.c3, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c1], [t1.c3]), partitions(p0)

select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having min(c1)> 1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
|    2 |        2 |
+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having min(c1)> 1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |52  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter([T_FUN_MIN(.c1) > 1]), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)], [T_FUN_MIN(.c1)])
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having min(c1)> 1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
|    2 |        2 |
+------+----------+
EXPLAIN select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having c1> 1;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |1        |40  |
|1 | SORT         |    |1        |39  |
|2 |  TABLE SCAN  |t1  |1        |39  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))]), filter(nil), 
      group([t1.c1]), agg_func([T_FUN_SUM(cast(t1.c3, DECIMAL(11, 0)))])
  1 - output([t1.c1], [cast(t1.c3, DECIMAL(11, 0))]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c3]), filter([t1.c1 > 1]), 
      access([t1.c1], [t1.c3]), partitions(p0)

select c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having c1> 1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
|    2 |        2 |
+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having c1> 1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |4        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter([.c1 > 1]), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1 having c1> 1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
|    2 |        2 |
+------+----------+

##5.使用child aggr进行计算
EXPLAIN select c1, sum(c1 + sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(cast(.c1, DECIMAL(11, 0)) + .sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(cast(.c1, DECIMAL(11, 0)) + .sc3)])
  1 - output([.c1], [cast(.c1, DECIMAL(11, 0)) + .sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c3], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, sum(c1 + sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1;
+------+---------------+
| c1   | sum(c1 + sc3) |
+------+---------------+
| NULL |          NULL |
|    1 |            15 |
|    2 |             4 |
+------+---------------+
EXPLAIN select /*+no_rewrite*/ c1, sum(c1 + sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(cast(.c1, DECIMAL(11, 0)) + .sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(cast(.c1, DECIMAL(11, 0)) + .sc3)])
  1 - output([.c1], [cast(.c1, DECIMAL(11, 0)) + .sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [t1.c2], [T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(c1 + sc3) from (select c1, c2, sum(c3) sc3 from t1 group by c1, c2) group by c1;
+------+---------------+
| c1   | sum(c1 + sc3) |
+------+---------------+
| NULL |          NULL |
|    1 |            15 |
|    2 |             4 |
+------+---------------+
EXPLAIN select c1, sum(sc3) from (select c1, c2, 2 + sum(c3) sc3 from t1 group by c1, c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [? + T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c3], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, sum(sc3) from (select c1, c2, 2 + sum(c3) sc3 from t1 group by c1, c2) group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
| NULL |     NULL |
|    1 |       17 |
|    2 |        4 |
+------+----------+
EXPLAIN select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, 2 + sum(c3) sc3 from t1 group by c1, c2) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_SUM(.sc3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_SUM(.sc3)])
  1 - output([.c1], [.sc3]), filter(nil), 
      access([.c1], [.sc3])
  2 - output([t1.c1], [t1.c2], [? + T_FUN_SUM(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_SUM(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, sum(sc3) from (select c1, c2, 2 + sum(c3) sc3 from t1 group by c1, c2) group by c1;
+------+----------+
| c1   | sum(sc3) |
+------+----------+
| NULL |     NULL |
|    1 |       17 |
|    2 |        4 |
+------+----------+

##6.rollup test
EXPLAIN select c1, min(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2 with rollup) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |HASH GROUP BY   |    |7        |57  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_MIN(.c3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_MIN(.c3)])
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group(nil), rollup([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c3], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select c1, min(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2 with rollup) group by c1;
+------+---------+
| c1   | min(c3) |
+------+---------+
| NULL |       1 |
|    1 |       1 |
|    2 |       2 |
+------+---------+
EXPLAIN select /*+no_rewrite*/ c1, min(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2 with rollup) group by c1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |HASH GROUP BY   |    |7        |57  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_MIN(.c3)]), filter(nil), 
      group([.c1]), agg_func([T_FUN_MIN(.c3)])
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group(nil), rollup([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, min(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2 with rollup) group by c1;
+------+---------+
| c1   | min(c3) |
+------+---------+
| NULL |       1 |
|    1 |       1 |
|    2 |       2 |
+------+---------+

EXPLAIN select c1, min(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1 with rollup;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |7        |46  |
|1 | SORT         |    |7        |44  |
|2 |  TABLE SCAN  |t1  |7        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group(nil), rollup([t1.c1]), agg_func([T_FUN_MIN(t1.c3)])
  1 - output([t1.c1], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c3]), partitions(p0)

select c1, min(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1 with rollup;
+------+---------+
| c1   | min(c3) |
+------+---------+
| NULL |    NULL |
|    1 |       1 |
|    2 |       2 |
| NULL |       1 |
+------+---------+
EXPLAIN select /*+no_rewrite*/ c1, min(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1 with rollup;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |7        |51  |
|1 | SUBPLAN SCAN   |    |7        |49  |
|2 |  MERGE GROUP BY|    |7        |48  |
|3 |   SORT         |    |7        |46  |
|4 |    TABLE SCAN  |t1  |7        |38  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.c1], [T_FUN_MIN(.c3)]), filter(nil), 
      group(nil), rollup([.c1]), agg_func([T_FUN_MIN(.c3)])
  1 - output([.c1], [.c3]), filter(nil), 
      access([.c1], [.c3])
  2 - output([t1.c1], [t1.c2], [T_FUN_MIN(t1.c3)]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  3 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

select /*+no_rewrite*/ c1, min(c3) from (select c1, c2, min(c3) c3 from t1 group by c1,c2) group by c1 with rollup;
+------+---------+
| c1   | min(c3) |
+------+---------+
| NULL |    NULL |
|    1 |       1 |
|    2 |       2 |
| NULL |       1 |
+------+---------+

EXPLAIN select min(minc3)
from ((select min(c3) minc3 from t1 group by c1,c2 with rollup)
      union all
      (select min(c3) minc3 from t2 group by c1,c2)
      union all
      (select min(c3) minc3 from t3 group by c1,c2));
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SCALAR GROUP BY  |    |1        |135 |
|1 | SUBPLAN SCAN    |    |19       |131 |
|2 |  UNION ALL      |    |19       |128 |
|3 |   MERGE GROUP BY|    |7        |48  |
|4 |    SORT         |    |7        |46  |
|5 |     TABLE SCAN  |t1  |7        |38  |
|6 |   TABLE SCAN    |t2  |7        |38  |
|7 |   TABLE SCAN    |t3  |5        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.minc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.minc3)])
  1 - output([.minc3]), filter(nil), 
      access([.minc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_MIN(t1.c3)]), filter(nil), 
      group(nil), rollup([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  4 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  5 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.c3], [t1.c1], [t1.c2]), partitions(p0)
  6 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p0)
  7 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

select min(minc3)
from ((select min(c3) minc3 from t1 group by c1,c2 with rollup)
      union all
      (select min(c3) minc3 from t2 group by c1,c2)
      union all
      (select min(c3) minc3 from t3 group by c1,c2));
+------------+
| min(minc3) |
+------------+
|          1 |
+------------+
EXPLAIN select /*+no_rewrite*/ min(minc3)
from ((select min(c3) minc3 from t1 group by c1,c2 with rollup)
      union all
      (select min(c3) minc3 from t2 group by c1,c2)
      union all
      (select min(c3) minc3 from t3 group by c1,c2));
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SCALAR GROUP BY  |    |1        |149 |
|1 | SUBPLAN SCAN    |    |19       |145 |
|2 |  UNION ALL      |    |19       |143 |
|3 |   MERGE GROUP BY|    |7        |48  |
|4 |    SORT         |    |7        |46  |
|5 |     TABLE SCAN  |t1  |7        |38  |
|6 |   HASH GROUP BY |    |7        |46  |
|7 |    TABLE SCAN   |t2  |7        |38  |
|8 |   HASH GROUP BY |    |5        |43  |
|9 |    TABLE SCAN   |t3  |5        |37  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(.minc3)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(.minc3)])
  1 - output([.minc3]), filter(nil), 
      access([.minc3])
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_MIN(t1.c3)]), filter(nil), 
      group(nil), rollup([t1.c1], [t1.c2]), agg_func([T_FUN_MIN(t1.c3)])
  4 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  5 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), 
      access([t1.c3], [t1.c1], [t1.c2]), partitions(p0)
  6 - output([T_FUN_MIN(t2.c3)]), filter(nil), 
      group([t2.c1], [t2.c2]), agg_func([T_FUN_MIN(t2.c3)])
  7 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  8 - output([T_FUN_MIN(t3.c3)]), filter(nil), 
      group([t3.c1], [t3.c2]), agg_func([T_FUN_MIN(t3.c3)])
  9 - output([t3.c3], [t3.c1], [t3.c2]), filter(nil), 
      access([t3.c3], [t3.c1], [t3.c2]), partitions(p0)

select /*+no_rewrite*/ min(minc3)
from ((select min(c3) minc3 from t1 group by c1,c2 with rollup)
      union all
      (select min(c3) minc3 from t2 group by c1,c2)
      union all
      (select min(c3) minc3 from t3 group by c1,c2));
+------------+
| min(minc3) |
+------------+
|          1 |
+------------+

##消除冗余distinct
EXPLAIN select distinct c1, c2 from t1
union all
select distinct c1, c2 from t2;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |UNION ALL     |    |14       |96  |
|1 | HASH DISTINCT|    |7        |45  |
|2 |  TABLE SCAN  |t1  |7        |38  |
|3 | HASH DISTINCT|    |7        |45  |
|4 |  TABLE SCAN  |t2  |7        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      distinct([t1.c1], [t1.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      distinct([t2.c1], [t2.c2])
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select distinct c1, c2 from t1
union all
select distinct c1, c2 from t2;
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    1 |    2 |
|    2 |    1 |
| NULL | NULL |
|    1 |    1 |
|    2 |    2 |
|    2 |    1 |
| NULL | NULL |
+------+------+

EXPLAIN select distinct c1, c2 from t1
union
select distinct c1, c2 from t2;
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |HASH UNION DISTINCT|    |14       |90  |
|1 | TABLE SCAN        |t1  |7        |38  |
|2 | TABLE SCAN        |t2  |7        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select distinct c1, c2 from t1
union
select distinct c1, c2 from t2;
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    1 |    2 |
|    2 |    1 |
| NULL | NULL |
|    2 |    2 |
+------+------+

EXPLAIN select distinct c1, c2 from t1
intersect
select distinct c1, c2 from t2;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |HASH INTERSECT DISTINCT|    |7        |89  |
|1 | TABLE SCAN            |t1  |7        |38  |
|2 | TABLE SCAN            |t2  |7        |38  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])], [INTERSECT([2])]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select distinct c1, c2 from t1
intersect
select distinct c1, c2 from t2;
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    2 |    1 |
| NULL | NULL |
+------+------+

EXPLAIN select distinct c1, c2 from t1
except
select distinct c1, c2 from t2;
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH EXCEPT DISTINCT|    |7        |89  |
|1 | TABLE SCAN         |t1  |7        |38  |
|2 | TABLE SCAN         |t2  |7        |38  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])], [EXCEPT([2])]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select distinct c1, c2 from t1
except
select distinct c1, c2 from t2;
+------+------+
| c1   | c2   |
+------+------+
|    1 |    2 |
+------+------+

EXPLAIN select distinct c1, c2 from t1
union
(select distinct c1, c2 from t2
union all
select distinct c1, c2 from t3);
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |HASH UNION DISTINCT|    |19       |137 |
|1 | TABLE SCAN        |t1  |7        |38  |
|2 | UNION ALL         |    |12       |79  |
|3 |  TABLE SCAN       |t2  |7        |38  |
|4 |  TABLE SCAN       |t3  |5        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

select distinct c1, c2 from t1
union
(select distinct c1, c2 from t2
union all
select distinct c1, c2 from t3);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    1 |    2 |
|    2 |    1 |
| NULL | NULL |
|    2 |    2 |
+------+------+

EXPLAIN select distinct c1, c2 from t1
union
(select distinct c1, c2 from t2
union
select distinct c1, c2 from t3);
Query Plan
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH DISTINCT|    |19       |140 |
|1 | UNION ALL   |    |19       |119 |
|2 |  TABLE SCAN |t1  |7        |38  |
|3 |  TABLE SCAN |t2  |7        |38  |
|4 |  TABLE SCAN |t3  |5        |37  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), 
      distinct([UNION([1])], [UNION([2])])
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

select distinct c1, c2 from t1
union
(select distinct c1, c2 from t2
union
select distinct c1, c2 from t3);
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    1 |    2 |
|    2 |    1 |
| NULL | NULL |
|    2 |    2 |
+------+------+

##消除冗余distinct expect no rewrite
EXPLAIN select distinct c1, c2 from t1
union
select distinct c1, c2 from t2 limit 2;
Query Plan
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |LIMIT               |    |2        |82  |
|1 | HASH UNION DISTINCT|    |2        |82  |
|2 |  LIMIT             |    |2        |39  |
|3 |   HASH DISTINCT    |    |2        |39  |
|4 |    TABLE SCAN      |t1  |2        |37  |
|5 |  LIMIT             |    |2        |39  |
|6 |   HASH DISTINCT    |    |2        |39  |
|7 |    TABLE SCAN      |t2  |2        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), limit(2), offset(nil)
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), limit(2), offset(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      distinct([t1.c1], [t1.c2])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2]), filter(nil), limit(2), offset(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      distinct([t2.c1], [t2.c2])
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select distinct c1, c2 from t1
union
select distinct c1, c2 from t2 limit 2;
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    1 |    2 |
+------+------+

EXPLAIN select distinct c1, c2 from t1 limit 2
union
select distinct c1, c2 from t2;
Query Plan
============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |HASH UNION DISTINCT|    |9        |86  |
|1 | LIMIT             |    |2        |39  |
|2 |  HASH DISTINCT    |    |2        |39  |
|3 |   TABLE SCAN      |t1  |2        |37  |
|4 | TABLE SCAN        |t2  |7        |38  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), limit(2), offset(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      distinct([t1.c1], [t1.c2])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select distinct c1, c2 from t1 limit 2
union
select distinct c1, c2 from t2;
+------+------+
| c1   | c2   |
+------+------+
|    1 |    1 |
|    1 |    2 |
|    2 |    2 |
|    2 |    1 |
| NULL | NULL |
+------+------+

drop table t1,t2,t3,tpart1,tpart2,t4,t5,t6;
set autocommit = 0;

************************消除冗余group by/distinct end**********

*********************push down outer join on condition begin**************

set autocommit = 1;

drop table if exists t1,t2,t3,t4,t5,tp1,tp2;
create table t1 (c1 int, c2 int);
create table t2 (c1 int, c2 int);
create table t3 (c1 int, c2 int);
create table t4 (c1 int, c2 int);
create table t5 (c1 int, c2 int);
create table tp1 (c1 int, c2 int) partition by hash(c1) partitions 2;
create table tp2 (c1 int, c2 int) partition by hash(c1) partitions 2;
## basic table
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |MERGE OUTER JOIN |     |4        |127 |
|1 | SORT            |     |4        |41  |
|2 |  TABLE SCAN     |t1   |4        |37  |
|3 | SUBPLAN SCAN    |VIEW1|4        |84  |
|4 |  MERGE SEMI JOIN|     |4        |83  |
|5 |   SORT          |     |4        |41  |
|6 |    TABLE SCAN   |t2   |4        |37  |
|7 |   SORT          |     |4        |40  |
|8 |    TABLE SCAN   |t3   |4        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t2.c1], [VIEW1.t2.c2])
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  8 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL | NULL | NULL | NULL |
|    1 |    1 |    1 |    1 |
|    2 |    2 | NULL | NULL |
|    3 |    3 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3);
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3);
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 ta left join t1 tb on ta.c1 = tb.c1 and tb.c1 in (select c2 from t3);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |MERGE OUTER JOIN |     |4        |127 |
|1 | SORT            |     |4        |41  |
|2 |  TABLE SCAN     |ta   |4        |37  |
|3 | SUBPLAN SCAN    |VIEW1|4        |84  |
|4 |  MERGE SEMI JOIN|     |4        |83  |
|5 |   SORT          |     |4        |41  |
|6 |    TABLE SCAN   |tb   |4        |37  |
|7 |   SORT          |     |4        |40  |
|8 |    TABLE SCAN   |t3   |4        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [VIEW1.tb.c1], [VIEW1.tb.c2]), filter(nil), 
      equal_conds([ta.c1 = VIEW1.tb.c1]), other_conds(nil)
  1 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC])
  2 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p0)
  3 - output([VIEW1.tb.c1], [VIEW1.tb.c2]), filter(nil), 
      access([VIEW1.tb.c1], [VIEW1.tb.c2])
  4 - output([tb.c1], [tb.c2]), filter(nil), 
      equal_conds([tb.c1 = t3.c2]), other_conds(nil)
  5 - output([tb.c1], [tb.c2]), filter(nil), sort_keys([tb.c1, ASC])
  6 - output([tb.c1], [tb.c2]), filter(nil), 
      access([tb.c1], [tb.c2]), partitions(p0)
  7 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  8 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from t1 ta left join t1 tb on ta.c1 = tb.c1 and tb.c1 in (select c2 from t3);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL | NULL | NULL | NULL |
|    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    3 |    3 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 ta left join t1 tb on ta.c1 = tb.c1 and tb.c1 in (select c2 from t3);
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 ta left join t1 tb on ta.c1 = tb.c1 and tb.c1 in (select c2 from t3);
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3), t4;
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |16       |177 |
|1 | MERGE OUTER JOIN         |     |4        |127 |
|2 |  SORT                    |     |4        |41  |
|3 |   TABLE SCAN             |t1   |4        |37  |
|4 |  SUBPLAN SCAN            |VIEW1|4        |84  |
|5 |   MERGE SEMI JOIN        |     |4        |83  |
|6 |    SORT                  |     |4        |41  |
|7 |     TABLE SCAN           |t2   |4        |37  |
|8 |    SORT                  |     |4        |40  |
|9 |     TABLE SCAN           |t3   |4        |37  |
|10| MATERIAL                 |     |4        |39  |
|11|  TABLE SCAN              |t4   |4        |37  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t4.c1], [t4.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t2.c1], [VIEW1.t2.c2])
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  9 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  10 - output([t4.c1], [t4.c2]), filter(nil)
  11 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3), t4;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
| NULL | NULL | NULL | NULL |    2 |    2 |
| NULL | NULL | NULL | NULL |    3 |    3 |
| NULL | NULL | NULL | NULL |    4 |    4 |
| NULL | NULL | NULL | NULL | NULL | NULL |
|    1 |    1 |    1 |    1 |    2 |    2 |
|    1 |    1 |    1 |    1 |    3 |    3 |
|    1 |    1 |    1 |    1 |    4 |    4 |
|    1 |    1 |    1 |    1 | NULL | NULL |
|    2 |    2 | NULL | NULL |    2 |    2 |
|    2 |    2 | NULL | NULL |    3 |    3 |
|    2 |    2 | NULL | NULL |    4 |    4 |
|    2 |    2 | NULL | NULL | NULL | NULL |
|    3 |    3 | NULL | NULL |    2 |    2 |
|    3 |    3 | NULL | NULL |    3 |    3 |
|    3 |    3 | NULL | NULL |    4 |    4 |
|    3 |    3 | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3), t4;
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3), t4;
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t4) left join t3 on t1.c1 = t3.c1;
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |MERGE OUTER JOIN  |     |4        |171 |
|1 | MERGE OUTER JOIN |     |4        |127 |
|2 |  SORT            |     |4        |41  |
|3 |   TABLE SCAN     |t1   |4        |37  |
|4 |  SUBPLAN SCAN    |VIEW1|4        |84  |
|5 |   MERGE SEMI JOIN|     |4        |83  |
|6 |    SORT          |     |4        |41  |
|7 |     TABLE SCAN   |t2   |4        |37  |
|8 |    SORT          |     |4        |40  |
|9 |     TABLE SCAN   |t4   |4        |37  |
|10| SORT             |     |4        |41  |
|11|  TABLE SCAN      |t3   |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t2.c1], [VIEW1.t2.c2])
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  9 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  10 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  11 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t4) left join t3 on t1.c1 = t3.c1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
| NULL | NULL | NULL | NULL | NULL | NULL |
|    1 |    1 | NULL | NULL |    1 |    1 |
|    2 |    2 | NULL | NULL |    2 |    2 |
|    3 |    3 |    3 |    3 | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t4) left join t3 on t1.c1 = t3.c1;
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t4) left join t3 on t1.c1 = t3.c1;
ERROR 0A000: Not supported feature or function

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 and (t1.c1,t2.c1) in (select c1,c2 from t3);
ERROR 0A000: Not supported feature or function
select * from t1 left join t2 on t1.c1 = t2.c1 and (t1.c1,t2.c1) in (select c1,c2 from t3);
ERROR 0A000: Not supported feature or function
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 and (t1.c1,t2.c1) in (select c1,c2 from t3);
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 and (t1.c1,t2.c1) in (select c1,c2 from t3);
ERROR 0A000: Not supported feature or function

EXPLAIN select * from tp1 left join tp2 on tp1.c1 = tp2.c1 and tp2.c1 in (select c2 from t3);
Query Plan
=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |2        |120 |
|1 | EXCHANGE OUT DISTR             |:EX10001|2        |119 |
|2 |  MERGE OUTER JOIN              |        |2        |119 |
|3 |   SORT                         |        |2        |38  |
|4 |    PX PARTITION ITERATOR       |        |2        |37  |
|5 |     TABLE SCAN                 |tp1     |2        |37  |
|6 |   SUBPLAN SCAN                 |VIEW1   |2        |80  |
|7 |    MERGE SEMI JOIN             |        |2        |80  |
|8 |     SORT                       |        |2        |38  |
|9 |      PX PARTITION ITERATOR     |        |2        |37  |
|10|       TABLE SCAN               |tp2     |2        |37  |
|11|     SORT                       |        |4        |40  |
|12|      EXCHANGE IN DISTR         |        |4        |37  |
|13|       EXCHANGE OUT DISTR (PKEY)|:EX10000|4        |37  |
|14|        TABLE SCAN              |t3      |4        |37  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([tp1.c1], [tp1.c2], [VIEW1.tp2.c1], [VIEW1.tp2.c2]), filter(nil)
  1 - output([tp1.c1], [tp1.c2], [VIEW1.tp2.c1], [VIEW1.tp2.c2]), filter(nil), dop=1
  2 - output([tp1.c1], [tp1.c2], [VIEW1.tp2.c1], [VIEW1.tp2.c2]), filter(nil), 
      equal_conds([tp1.c1 = VIEW1.tp2.c1]), other_conds(nil)
  3 - output([tp1.c1], [tp1.c2]), filter(nil), sort_keys([tp1.c1, ASC]), local merge sort
  4 - output([tp1.c1], [tp1.c2]), filter(nil)
  5 - output([tp1.c1], [tp1.c2]), filter(nil), 
      access([tp1.c1], [tp1.c2]), partitions(p[0-1])
  6 - output([VIEW1.tp2.c1], [VIEW1.tp2.c2]), filter(nil), 
      access([VIEW1.tp2.c1], [VIEW1.tp2.c2])
  7 - output([tp2.c1], [tp2.c2]), filter(nil), 
      equal_conds([tp2.c1 = t3.c2]), other_conds(nil)
  8 - output([tp2.c1], [tp2.c2]), filter(nil), sort_keys([tp2.c1, ASC]), local merge sort
  9 - output([tp2.c1], [tp2.c2]), filter(nil)
  10 - output([tp2.c1], [tp2.c2]), filter(nil), 
      access([tp2.c1], [tp2.c2]), partitions(p[0-1])
  11 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  12 - output([t3.c2]), filter(nil)
  13 - (#keys=1, [t3.c2]), output([t3.c2]), filter(nil), is_single, dop=1
  14 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from tp1 left join tp2 on tp1.c1 = tp2.c1 and tp2.c1 in (select c2 from t3);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    3 |    3 | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from tp1 left join tp2 on tp1.c1 = tp2.c1 and tp2.c1 in (select c2 from t3);
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from tp1 left join tp2 on tp1.c1 = tp2.c1 and tp2.c1 in (select c2 from t3);
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 left join tp1 on t1.c1 = tp1.c1 and tp1.c1 in (select c2 from tp2);
Query Plan
=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |HASH RIGHT OUTER JOIN           |        |4        |120 |
|1 | PX COORDINATOR                 |        |2        |78  |
|2 |  EXCHANGE OUT DISTR            |:EX10001|2        |78  |
|3 |   SUBPLAN SCAN                 |VIEW1   |2        |78  |
|4 |    MERGE SEMI JOIN             |        |2        |78  |
|5 |     SORT                       |        |2        |38  |
|6 |      PX PARTITION ITERATOR     |        |2        |37  |
|7 |       TABLE SCAN               |tp1     |2        |37  |
|8 |     SORT                       |        |2        |38  |
|9 |      EXCHANGE IN DISTR         |        |2        |37  |
|10|       EXCHANGE OUT DISTR (PKEY)|:EX10000|2        |37  |
|11|        PX PARTITION ITERATOR   |        |2        |37  |
|12|         TABLE SCAN             |tp2     |2        |37  |
|13| TABLE SCAN                     |t1      |4        |37  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [VIEW1.tp1.c1], [VIEW1.tp1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.tp1.c1]), other_conds(nil)
  1 - output([VIEW1.tp1.c1], [VIEW1.tp1.c2]), filter(nil)
  2 - output([VIEW1.tp1.c1], [VIEW1.tp1.c2]), filter(nil), dop=1
  3 - output([VIEW1.tp1.c1], [VIEW1.tp1.c2]), filter(nil), 
      access([VIEW1.tp1.c1], [VIEW1.tp1.c2])
  4 - output([tp1.c1], [tp1.c2]), filter(nil), 
      equal_conds([tp1.c1 = tp2.c2]), other_conds(nil)
  5 - output([tp1.c1], [tp1.c2]), filter(nil), sort_keys([tp1.c1, ASC]), local merge sort
  6 - output([tp1.c1], [tp1.c2]), filter(nil)
  7 - output([tp1.c1], [tp1.c2]), filter(nil), 
      access([tp1.c1], [tp1.c2]), partitions(p[0-1])
  8 - output([tp2.c2]), filter(nil), sort_keys([tp2.c2, ASC])
  9 - output([tp2.c2]), filter(nil)
  10 - (#keys=1, [tp2.c2]), output([tp2.c2]), filter(nil), dop=1
  11 - output([tp2.c2]), filter(nil)
  12 - output([tp2.c2]), filter(nil), 
      access([tp2.c2]), partitions(p[0-1])
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join tp1 on t1.c1 = tp1.c1 and tp1.c1 in (select c2 from tp2);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
| NULL | NULL | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join tp1 on t1.c1 = tp1.c1 and tp1.c1 in (select c2 from tp2);
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join tp1 on t1.c1 = tp1.c1 and tp1.c1 in (select c2 from tp2);
ERROR 0A000: Not supported feature or function

## generate table
EXPLAIN select * from t1 left join (select c1+c2 a,c2 b from t2) v on t1.c1 = v.a and v.a in (select c2 from t3);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |HASH RIGHT OUTER JOIN |     |4        |117 |
|1 | SUBPLAN SCAN         |VIEW2|1        |79  |
|2 |  HASH RIGHT SEMI JOIN|     |1        |79  |
|3 |   TABLE SCAN         |t3   |4        |37  |
|4 |   TABLE SCAN         |t2   |4        |37  |
|5 | TABLE SCAN           |t1   |4        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [VIEW2.VIEW1.a], [VIEW2.VIEW1.b]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.VIEW1.a]), other_conds(nil)
  1 - output([VIEW2.VIEW1.a], [VIEW2.VIEW1.b]), filter(nil), 
      access([VIEW2.VIEW1.a], [VIEW2.VIEW1.b])
  2 - output([t2.c1 + t2.c2], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 + t2.c2 = t3.c2]), other_conds(nil)
  3 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  4 - output([t2.c2], [t2.c1 + t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join (select c1+c2 a,c2 b from t2) v on t1.c1 = v.a and v.a in (select c2 from t3);
+------+------+------+------+
| c1   | c2   | a    | b    |
+------+------+------+------+
|    1 |    1 | NULL | NULL |
|    2 |    2 |    2 |    1 |
|    3 |    3 | NULL | NULL |
| NULL | NULL | NULL | NULL |
+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join (select c1+c2 a,c2 b from t2) v on t1.c1 = v.a and v.a in (select c2 from t3);
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join (select c1+c2 a,c2 b from t2) v on t1.c1 = v.a and v.a in (select c2 from t3);
ERROR 0A000: Not supported feature or function
EXPLAIN select t1.*, v.b, v.a, v.c from t1 left join (select c1 a,c2 b, c1 + c2 c from t2) v on t1.c1 = v.a and v.a in (select c2 from t3);
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |MERGE OUTER JOIN |     |4        |127 |
|1 | SORT            |     |4        |41  |
|2 |  TABLE SCAN     |t1   |4        |37  |
|3 | SUBPLAN SCAN    |VIEW2|4        |84  |
|4 |  MERGE SEMI JOIN|     |4        |83  |
|5 |   SORT          |     |4        |41  |
|6 |    TABLE SCAN   |t2   |4        |37  |
|7 |   SORT          |     |4        |40  |
|8 |    TABLE SCAN   |t3   |4        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [VIEW2.VIEW1.b], [VIEW2.VIEW1.a], [VIEW2.VIEW1.c]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.VIEW1.a]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW2.VIEW1.a], [VIEW2.VIEW1.b], [VIEW2.VIEW1.c]), filter(nil), 
      access([VIEW2.VIEW1.a], [VIEW2.VIEW1.b], [VIEW2.VIEW1.c])
  4 - output([t2.c1], [t2.c2], [t2.c1 + t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  8 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select t1.*, v.b, v.a, v.c from t1 left join (select c1 a,c2 b, c1 + c2 c from t2) v on t1.c1 = v.a and v.a in (select c2 from t3);
+------+------+------+------+------+
| c1   | c2   | b    | a    | c    |
+------+------+------+------+------+
| NULL | NULL | NULL | NULL | NULL |
|    1 |    1 |    1 |    1 |    2 |
|    2 |    2 | NULL | NULL | NULL |
|    3 |    3 | NULL | NULL | NULL |
+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ t1.*, v.b, v.a, v.c from t1 left join (select c1 a,c2 b, c1 + c2 c from t2) v on t1.c1 = v.a and v.a in (select c2 from t3);
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ t1.*, v.b, v.a, v.c from t1 left join (select c1 a,c2 b, c1 + c2 c from t2) v on t1.c1 = v.a and v.a in (select c2 from t3);
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 left join (select c1+c2 a,c2 b from t2) v on t1.c1 = v.a and v.a in (select c2 from t4) left join t3 on t1.c1 = t3.c1;
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |HASH RIGHT OUTER JOIN  |     |4        |163 |
|1 | TABLE SCAN            |t3   |4        |37  |
|2 | HASH RIGHT OUTER JOIN |     |4        |117 |
|3 |  SUBPLAN SCAN         |VIEW2|1        |79  |
|4 |   HASH RIGHT SEMI JOIN|     |1        |79  |
|5 |    TABLE SCAN         |t4   |4        |37  |
|6 |    TABLE SCAN         |t2   |4        |37  |
|7 |  TABLE SCAN           |t1   |4        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [VIEW2.VIEW1.a], [VIEW2.VIEW1.b], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [VIEW2.VIEW1.a], [VIEW2.VIEW1.b]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.VIEW1.a]), other_conds(nil)
  3 - output([VIEW2.VIEW1.a], [VIEW2.VIEW1.b]), filter(nil), 
      access([VIEW2.VIEW1.a], [VIEW2.VIEW1.b])
  4 - output([t2.c1 + t2.c2], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 + t2.c2 = t4.c2]), other_conds(nil)
  5 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  6 - output([t2.c2], [t2.c1 + t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join (select c1+c2 a,c2 b from t2) v on t1.c1 = v.a and v.a in (select c2 from t4) left join t3 on t1.c1 = t3.c1;
+------+------+------+------+------+------+
| c1   | c2   | a    | b    | c1   | c2   |
+------+------+------+------+------+------+
|    1 |    1 | NULL | NULL |    1 |    1 |
|    2 |    2 |    2 |    1 |    2 |    2 |
|    3 |    3 | NULL | NULL | NULL | NULL |
| NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join (select c1+c2 a,c2 b from t2) v on t1.c1 = v.a and v.a in (select c2 from t4) left join t3 on t1.c1 = t3.c1;
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join (select c1+c2 a,c2 b from t2) v on t1.c1 = v.a and v.a in (select c2 from t4) left join t3 on t1.c1 = t3.c1;
ERROR 0A000: Not supported feature or function

## join table
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |MERGE OUTER JOIN  |     |4        |171 |
|1 | SORT             |     |4        |41  |
|2 |  TABLE SCAN      |t3   |4        |37  |
|3 | SUBPLAN SCAN     |VIEW1|4        |127 |
|4 |  MERGE JOIN      |     |4        |127 |
|5 |   MERGE SEMI JOIN|     |4        |83  |
|6 |    SORT          |     |4        |41  |
|7 |     TABLE SCAN   |t2   |4        |37  |
|8 |    SORT          |     |4        |40  |
|9 |     TABLE SCAN   |t4   |4        |37  |
|10|   SORT           |     |4        |41  |
|11|    TABLE SCAN    |t1   |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2])
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  9 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  10 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4);
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
| NULL | NULL | NULL | NULL | NULL | NULL |
| NULL | NULL | NULL | NULL |    1 |    1 |
| NULL | NULL | NULL | NULL |    2 |    2 |
| NULL | NULL | NULL | NULL |    4 |    4 |
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4);
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4);
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4);
Query Plan
============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST|
--------------------------------------------
|0 |MERGE OUTER JOIN  |     |4        |171 |
|1 | SORT             |     |4        |41  |
|2 |  TABLE SCAN      |t3   |4        |37  |
|3 | SUBPLAN SCAN     |VIEW1|4        |127 |
|4 |  MERGE OUTER JOIN|     |4        |127 |
|5 |   MERGE SEMI JOIN|     |4        |83  |
|6 |    SORT          |     |4        |41  |
|7 |     TABLE SCAN   |t1   |4        |37  |
|8 |    SORT          |     |4        |40  |
|9 |     TABLE SCAN   |t4   |4        |37  |
|10|   SORT           |     |4        |41  |
|11|    TABLE SCAN    |t2   |4        |37  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2])
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  8 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  9 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  10 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4);
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
| NULL | NULL | NULL | NULL | NULL | NULL |
| NULL | NULL | NULL | NULL |    1 |    1 |
|    2 |    2 | NULL | NULL |    2 |    2 |
| NULL | NULL | NULL | NULL |    4 |    4 |
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4);
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4);
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) left join t5 on t1.c1 = t5.c1;
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE OUTER JOIN   |     |4        |215 |
|1 | SORT              |     |4        |41  |
|2 |  TABLE SCAN       |t3   |4        |37  |
|3 | MERGE OUTER JOIN  |     |4        |171 |
|4 |  SUBPLAN SCAN     |VIEW1|4        |127 |
|5 |   MERGE JOIN      |     |4        |127 |
|6 |    MERGE SEMI JOIN|     |4        |83  |
|7 |     SORT          |     |4        |41  |
|8 |      TABLE SCAN   |t2   |4        |37  |
|9 |     SORT          |     |4        |40  |
|10|      TABLE SCAN   |t4   |4        |37  |
|11|    SORT           |     |4        |41  |
|12|     TABLE SCAN    |t1   |4        |37  |
|13|  SORT             |     |4        |41  |
|14|   TABLE SCAN      |t5   |4        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t3.c1], [t3.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t5.c1]), other_conds(nil)
  4 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2])
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  10 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  11 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  13 - output([t5.c1], [t5.c2]), filter(nil), sort_keys([t5.c1, ASC])
  14 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) left join t5 on t1.c1 = t5.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
| NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL | NULL | NULL | NULL |    1 |    1 | NULL | NULL |
| NULL | NULL | NULL | NULL |    2 |    2 | NULL | NULL |
| NULL | NULL | NULL | NULL |    4 |    4 | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) left join t5 on t1.c1 = t5.c1;
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) left join t5 on t1.c1 = t5.c1;
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4) left join t5 on t1.c1 = t5.c1;
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE OUTER JOIN   |     |4        |215 |
|1 | SORT              |     |4        |41  |
|2 |  TABLE SCAN       |t3   |4        |37  |
|3 | MERGE OUTER JOIN  |     |4        |171 |
|4 |  SUBPLAN SCAN     |VIEW1|4        |127 |
|5 |   MERGE OUTER JOIN|     |4        |127 |
|6 |    MERGE SEMI JOIN|     |4        |83  |
|7 |     SORT          |     |4        |41  |
|8 |      TABLE SCAN   |t1   |4        |37  |
|9 |     SORT          |     |4        |40  |
|10|      TABLE SCAN   |t4   |4        |37  |
|11|    SORT           |     |4        |41  |
|12|     TABLE SCAN    |t2   |4        |37  |
|13|  SORT             |     |4        |41  |
|14|   TABLE SCAN      |t5   |4        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t3.c1], [t3.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t5.c1]), other_conds(nil)
  4 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2])
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c2]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  10 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  13 - output([t5.c1], [t5.c2]), filter(nil), sort_keys([t5.c1, ASC])
  14 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4) left join t5 on t1.c1 = t5.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
| NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL | NULL | NULL | NULL |    1 |    1 | NULL | NULL |
|    2 |    2 | NULL | NULL |    2 |    2 |    2 |    2 |
| NULL | NULL | NULL | NULL |    4 |    4 | NULL | NULL |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4) left join t5 on t1.c1 = t5.c1;
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4) left join t5 on t1.c1 = t5.c1;
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) right join t5 on t1.c1 = t5.c1;
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE OUTER JOIN   |     |4        |215 |
|1 | SORT              |     |4        |41  |
|2 |  TABLE SCAN       |t5   |4        |37  |
|3 | MERGE JOIN        |     |4        |171 |
|4 |  SUBPLAN SCAN     |VIEW1|4        |127 |
|5 |   MERGE JOIN      |     |4        |127 |
|6 |    MERGE SEMI JOIN|     |4        |83  |
|7 |     SORT          |     |4        |41  |
|8 |      TABLE SCAN   |t2   |4        |37  |
|9 |     SORT          |     |4        |40  |
|10|      TABLE SCAN   |t4   |4        |37  |
|11|    SORT           |     |4        |41  |
|12|     TABLE SCAN    |t1   |4        |37  |
|13|  SORT             |     |4        |41  |
|14|   TABLE SCAN      |t3   |4        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t3.c1], [t3.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t5.c1]), other_conds(nil)
  1 - output([t5.c1], [t5.c2]), filter(nil), sort_keys([t5.c1, ASC])
  2 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  4 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2])
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  9 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  10 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  11 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  13 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  14 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) right join t5 on t1.c1 = t5.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
| NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL | NULL | NULL | NULL | NULL | NULL |    1 |    1 |
| NULL | NULL | NULL | NULL | NULL | NULL |    2 |    2 |
| NULL | NULL | NULL | NULL | NULL | NULL |    5 |    5 |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) right join t5 on t1.c1 = t5.c1;
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) right join t5 on t1.c1 = t5.c1;
ERROR 0A000: Not supported feature or function
EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4) right join t5 on t1.c1 = t5.c1;
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE OUTER JOIN   |     |4        |215 |
|1 | SORT              |     |4        |41  |
|2 |  TABLE SCAN       |t5   |4        |37  |
|3 | MERGE JOIN        |     |4        |171 |
|4 |  SUBPLAN SCAN     |VIEW1|4        |127 |
|5 |   MERGE OUTER JOIN|     |4        |127 |
|6 |    MERGE SEMI JOIN|     |4        |83  |
|7 |     SORT          |     |4        |41  |
|8 |      TABLE SCAN   |t1   |4        |37  |
|9 |     SORT          |     |4        |40  |
|10|      TABLE SCAN   |t4   |4        |37  |
|11|    SORT           |     |4        |41  |
|12|     TABLE SCAN    |t2   |4        |37  |
|13|  SORT             |     |4        |41  |
|14|   TABLE SCAN      |t3   |4        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t3.c1], [t3.c2], [t5.c1], [t5.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t5.c1]), other_conds(nil)
  1 - output([t5.c1], [t5.c2]), filter(nil), sort_keys([t5.c1, ASC])
  2 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)
  3 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  4 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t2.c1], [VIEW1.t2.c2])
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t4.c2]), other_conds(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  9 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  10 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  11 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  13 - output([t3.c1], [t3.c2]), filter(nil), sort_keys([t3.c1, ASC])
  14 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4) right join t5 on t1.c1 = t5.c1;
+------+------+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+------+------+
| NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |
| NULL | NULL | NULL | NULL | NULL | NULL |    1 |    1 |
|    2 |    2 | NULL | NULL |    2 |    2 |    2 |    2 |
| NULL | NULL | NULL | NULL | NULL | NULL |    5 |    5 |
+------+------+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4) right join t5 on t1.c1 = t5.c1;
ERROR 0A000: Not supported feature or function
select /*+no_rewrite*/ * from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t1.c1 in (select c2 from t4) right join t5 on t1.c1 = t5.c1;
ERROR 0A000: Not supported feature or function

## stmt has semi/anti join
EXPLAIN select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3) where t2.c1 not in (select c1 from t4);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |170 |
|1 | MERGE OUTER JOIN    |     |4        |127 |
|2 |  SORT               |     |4        |40  |
|3 |   TABLE SCAN        |t1   |4        |37  |
|4 |  SUBPLAN SCAN       |VIEW1|4        |84  |
|5 |   MERGE SEMI JOIN   |     |4        |83  |
|6 |    SORT             |     |4        |41  |
|7 |     TABLE SCAN      |t2   |4        |37  |
|8 |    SORT             |     |4        |40  |
|9 |     TABLE SCAN      |t3   |4        |37  |
|10| MATERIAL            |     |4        |38  |
|11|  TABLE SCAN         |t4   |4        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t2.c2]), filter(nil), 
      conds([(T_OP_OR, VIEW1.t2.c1 = t4.c1, (T_OP_IS, VIEW1.t2.c1, NULL, 0), (T_OP_IS, t4.c1, NULL, 0))]), nl_params_(nil)
  1 - output([VIEW1.t2.c2], [VIEW1.t2.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t2.c1], [VIEW1.t2.c2])
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  9 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  10 - output([t4.c1]), filter(nil)
  11 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3) where t2.c1 not in (select c1 from t4);
+------+
| c2   |
+------+
+------+
EXPLAIN select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3) where t2.c1 in (select c1 from t4);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE SEMI JOIN |    |4        |169 |
|1 | MERGE SEMI JOIN|    |4        |126 |
|2 |  MERGE JOIN    |    |4        |83  |
|3 |   SORT         |    |4        |40  |
|4 |    TABLE SCAN  |t1  |4        |37  |
|5 |   SORT         |    |4        |41  |
|6 |    TABLE SCAN  |t2  |4        |37  |
|7 |  SORT          |    |4        |40  |
|8 |   TABLE SCAN   |t4  |4        |37  |
|9 | SORT           |    |4        |40  |
|10|  TABLE SCAN    |t3  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  1 - output([t2.c2], [t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  2 - output([t2.c2], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  5 - output([t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  10 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3) where t2.c1 in (select c1 from t4);
+------+
| c2   |
+------+
+------+

EXPLAIN select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where t2.c1 not in (select c1 from t5);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |213 |
|1 | MERGE OUTER JOIN    |     |4        |169 |
|2 |  SORT               |     |4        |40  |
|3 |   TABLE SCAN        |t3   |4        |37  |
|4 |  SUBPLAN SCAN       |VIEW1|4        |127 |
|5 |   MERGE SEMI JOIN   |     |4        |126 |
|6 |    MERGE JOIN       |     |4        |83  |
|7 |     SORT            |     |4        |40  |
|8 |      TABLE SCAN     |t1   |4        |37  |
|9 |     SORT            |     |4        |41  |
|10|      TABLE SCAN     |t2   |4        |37  |
|11|    SORT             |     |4        |40  |
|12|     TABLE SCAN      |t4   |4        |37  |
|13| MATERIAL            |     |4        |38  |
|14|  TABLE SCAN         |t5   |4        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t2.c2]), filter(nil), 
      conds([(T_OP_OR, VIEW1.t2.c1 = t5.c1, (T_OP_IS, VIEW1.t2.c1, NULL, 0), (T_OP_IS, t5.c1, NULL, 0))]), nl_params_(nil)
  1 - output([VIEW1.t2.c2], [VIEW1.t2.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  2 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([VIEW1.t1.c1], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t2.c1], [VIEW1.t2.c2])
  5 - output([t1.c1], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  6 - output([t1.c1], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  11 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  12 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  13 - output([t5.c1]), filter(nil)
  14 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)

select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where t2.c1 not in (select c1 from t5);
+------+
| c2   |
+------+
+------+
EXPLAIN select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where t2.c1 in (select c1 from t5);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE SEMI JOIN |    |4        |211 |
|1 | MERGE SEMI JOIN|    |4        |169 |
|2 |  MERGE JOIN    |    |4        |126 |
|3 |   MERGE JOIN   |    |4        |82  |
|4 |    SORT        |    |4        |40  |
|5 |     TABLE SCAN |t3  |4        |37  |
|6 |    SORT        |    |4        |40  |
|7 |     TABLE SCAN |t1  |4        |37  |
|8 |   SORT         |    |4        |41  |
|9 |    TABLE SCAN  |t2  |4        |37  |
|10|  SORT          |    |4        |40  |
|11|   TABLE SCAN   |t5  |4        |37  |
|12| SORT           |    |4        |40  |
|13|  TABLE SCAN    |t4  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  1 - output([t2.c2], [t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t5.c1]), other_conds(nil)
  2 - output([t2.c2], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  10 - output([t5.c1]), filter(nil), sort_keys([t5.c1, ASC])
  11 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  12 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  13 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)

select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where t2.c1 in (select c1 from t5);
+------+
| c2   |
+------+
+------+
EXPLAIN select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where t1.c1 not in (select c1 from t5);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |213 |
|1 | MERGE OUTER JOIN    |     |4        |169 |
|2 |  SORT               |     |4        |40  |
|3 |   TABLE SCAN        |t3   |4        |37  |
|4 |  SUBPLAN SCAN       |VIEW1|4        |127 |
|5 |   MERGE SEMI JOIN   |     |4        |126 |
|6 |    MERGE JOIN       |     |4        |83  |
|7 |     SORT            |     |4        |40  |
|8 |      TABLE SCAN     |t1   |4        |37  |
|9 |     SORT            |     |4        |41  |
|10|      TABLE SCAN     |t2   |4        |37  |
|11|    SORT             |     |4        |40  |
|12|     TABLE SCAN      |t4   |4        |37  |
|13| MATERIAL            |     |4        |38  |
|14|  TABLE SCAN         |t5   |4        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t2.c2]), filter(nil), 
      conds([(T_OP_OR, VIEW1.t1.c1 = t5.c1, (T_OP_IS, VIEW1.t1.c1, NULL, 0), (T_OP_IS, t5.c1, NULL, 0))]), nl_params_(nil)
  1 - output([VIEW1.t2.c2], [VIEW1.t1.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  2 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([VIEW1.t1.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t2.c2])
  5 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  6 - output([t1.c1], [t2.c2], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  11 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  12 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  13 - output([t5.c1]), filter(nil)
  14 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)

select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where t1.c1 not in (select c1 from t5);
+------+
| c2   |
+------+
+------+
EXPLAIN select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where t1.c1 in (select c1 from t5);
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE SEMI JOIN |    |4        |211 |
|1 | MERGE SEMI JOIN|    |4        |169 |
|2 |  MERGE JOIN    |    |4        |126 |
|3 |   MERGE JOIN   |    |4        |82  |
|4 |    SORT        |    |4        |40  |
|5 |     TABLE SCAN |t3  |4        |37  |
|6 |    SORT        |    |4        |40  |
|7 |     TABLE SCAN |t1  |4        |37  |
|8 |   SORT         |    |4        |41  |
|9 |    TABLE SCAN  |t2  |4        |37  |
|10|  SORT          |    |4        |40  |
|11|   TABLE SCAN   |t5  |4        |37  |
|12| SORT           |    |4        |40  |
|13|  TABLE SCAN    |t4  |4        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  1 - output([t2.c2], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t5.c1]), other_conds(nil)
  2 - output([t2.c2], [t2.c1], [t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c2], [t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  10 - output([t5.c1]), filter(nil), sort_keys([t5.c1, ASC])
  11 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  12 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  13 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)

select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where t1.c1 in (select c1 from t5);
+------+
| c2   |
+------+
+------+
EXPLAIN select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where (t1.c1, t2.c1) not in (select c1,c2 from t5);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |215 |
|1 | MERGE OUTER JOIN    |     |4        |169 |
|2 |  SORT               |     |4        |40  |
|3 |   TABLE SCAN        |t3   |4        |37  |
|4 |  SUBPLAN SCAN       |VIEW1|4        |127 |
|5 |   MERGE SEMI JOIN   |     |4        |126 |
|6 |    MERGE JOIN       |     |4        |83  |
|7 |     SORT            |     |4        |40  |
|8 |      TABLE SCAN     |t1   |4        |37  |
|9 |     SORT            |     |4        |41  |
|10|      TABLE SCAN     |t2   |4        |37  |
|11|    SORT             |     |4        |40  |
|12|     TABLE SCAN      |t4   |4        |37  |
|13| MATERIAL            |     |4        |39  |
|14|  TABLE SCAN         |t5   |4        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t2.c2]), filter(nil), 
      conds([(T_OP_OR, VIEW1.t1.c1 = t5.c1, (T_OP_IS, VIEW1.t1.c1, NULL, 0), (T_OP_IS, t5.c1, NULL, 0))], [(T_OP_OR, VIEW1.t2.c1 = t5.c2, (T_OP_IS, VIEW1.t2.c1, NULL, 0), (T_OP_IS, t5.c2, NULL, 0))]), nl_params_(nil)
  1 - output([VIEW1.t2.c2], [VIEW1.t1.c1], [VIEW1.t2.c1]), filter(nil), 
      equal_conds([VIEW1.t1.c1 = t3.c1]), other_conds(nil)
  2 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([VIEW1.t1.c1], [VIEW1.t2.c1], [VIEW1.t2.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t2.c1], [VIEW1.t2.c2])
  5 - output([t1.c1], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  6 - output([t1.c1], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  9 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  11 - output([t4.c2]), filter(nil), sort_keys([t4.c2, ASC])
  12 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  13 - output([t5.c1], [t5.c2]), filter(nil)
  14 - output([t5.c1], [t5.c2]), filter(nil), 
      access([t5.c1], [t5.c2]), partitions(p0)

select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where (t1.c1, t2.c1) not in (select c1,c2 from t5);
+------+
| c2   |
+------+
+------+
EXPLAIN select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where (t1.c1, t2.c1) in (select c1,c2 from t5);
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |HASH JOIN              |     |1        |195 |
|1 | HASH SEMI JOIN        |     |1        |155 |
|2 |  HASH JOIN            |     |1        |115 |
|3 |   HASH RIGHT SEMI JOIN|     |1        |76  |
|4 |    SUBPLAN SCAN       |VIEW3|1        |37  |
|5 |     TABLE SCAN        |t5   |1        |37  |
|6 |    TABLE SCAN         |t1   |4        |37  |
|7 |   TABLE SCAN          |t2   |4        |37  |
|8 |  TABLE SCAN           |t4   |4        |37  |
|9 | TABLE SCAN            |t3   |4        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t2.c2], [t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t4.c2]), other_conds(nil)
  2 - output([t2.c2], [t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW3.c1]), other_conds(nil)
  4 - output([VIEW3.c1]), filter(nil), 
      access([VIEW3.c1])
  5 - output([t5.c1]), filter([t5.c1 = t5.c2]), 
      access([t5.c1], [t5.c2]), partitions(p0)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

select t2.c2 from t1 left join t2 on t1.c1 = t2.c1 right join t3 on t1.c1 = t3.c1 and t2.c1 in (select c2 from t4) where (t1.c1, t2.c1) in (select c1,c2 from t5);
+------+
| c2   |
+------+
+------+

EXPLAIN select * from t4 where c1 not in (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |170 |
|1 | TABLE SCAN          |t4   |4        |37  |
|2 | MATERIAL            |     |4        |127 |
|3 |  SUBPLAN SCAN       |VIEW3|4        |126 |
|4 |   MERGE OUTER JOIN  |     |4        |126 |
|5 |    SORT             |     |4        |40  |
|6 |     TABLE SCAN      |t1   |4        |37  |
|7 |    SUBPLAN SCAN     |VIEW1|4        |83  |
|8 |     MERGE SEMI JOIN |     |4        |82  |
|9 |      SORT           |     |4        |40  |
|10|       TABLE SCAN    |t2   |4        |37  |
|11|      SORT           |     |4        |40  |
|12|       TABLE SCAN    |t3   |4        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      conds([(T_OP_OR, t4.c1 = VIEW3.c1, (T_OP_IS, t4.c1, NULL, 0), (T_OP_IS, VIEW3.c1, NULL, 0))]), nl_params_(nil)
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  2 - output([VIEW3.c1]), filter(nil)
  3 - output([VIEW3.c1]), filter(nil), 
      access([VIEW3.c1])
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  8 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  12 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from t4 where c1 not in (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t4 where c1 in (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
Query Plan
=============================================
|ID|OPERATOR           |NAME |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE SEMI JOIN    |     |4        |170 |
|1 | SORT              |     |4        |41  |
|2 |  TABLE SCAN       |t4   |4        |37  |
|3 | SUBPLAN SCAN      |VIEW3|4        |126 |
|4 |  MERGE OUTER JOIN |     |4        |126 |
|5 |   SORT            |     |4        |40  |
|6 |    TABLE SCAN     |t1   |4        |37  |
|7 |   SUBPLAN SCAN    |VIEW1|4        |83  |
|8 |    MERGE SEMI JOIN|     |4        |82  |
|9 |     SORT          |     |4        |40  |
|10|      TABLE SCAN   |t2   |4        |37  |
|11|     SORT          |     |4        |40  |
|12|      TABLE SCAN   |t3   |4        |37  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = VIEW3.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  2 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  3 - output([VIEW3.c1]), filter(nil), 
      access([VIEW3.c1])
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  8 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  12 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from t4 where c1 in (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
+------+------+
| c1   | c2   |
+------+------+
|    2 |    2 |
|    3 |    3 |
+------+------+
EXPLAIN select * from t4 where c1 not in (select t2.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |170 |
|1 | TABLE SCAN          |t4   |4        |37  |
|2 | MATERIAL            |     |4        |127 |
|3 |  SUBPLAN SCAN       |VIEW3|4        |126 |
|4 |   MERGE OUTER JOIN  |     |4        |126 |
|5 |    SORT             |     |4        |40  |
|6 |     TABLE SCAN      |t1   |4        |37  |
|7 |    SUBPLAN SCAN     |VIEW1|4        |83  |
|8 |     MERGE SEMI JOIN |     |4        |82  |
|9 |      SORT           |     |4        |40  |
|10|       TABLE SCAN    |t2   |4        |37  |
|11|      SORT           |     |4        |40  |
|12|       TABLE SCAN    |t3   |4        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      conds([(T_OP_OR, t4.c1 = VIEW3.c1, (T_OP_IS, t4.c1, NULL, 0), (T_OP_IS, VIEW3.c1, NULL, 0))]), nl_params_(nil)
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  2 - output([VIEW3.c1]), filter(nil)
  3 - output([VIEW3.c1]), filter(nil), 
      access([VIEW3.c1])
  4 - output([VIEW1.t2.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  8 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  12 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from t4 where c1 not in (select t2.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t4 where c1 in (select t2.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
Query Plan
===========================================
|ID|OPERATOR         |NAME |EST. ROWS|COST|
-------------------------------------------
|0 |MERGE SEMI JOIN  |     |4        |169 |
|1 | SORT            |     |4        |41  |
|2 |  TABLE SCAN     |t4   |4        |37  |
|3 | SUBPLAN SCAN    |VIEW3|4        |126 |
|4 |  MERGE SEMI JOIN|     |4        |125 |
|5 |   MERGE JOIN    |     |4        |82  |
|6 |    SORT         |     |4        |40  |
|7 |     TABLE SCAN  |t1   |4        |37  |
|8 |    SORT         |     |4        |40  |
|9 |     TABLE SCAN  |t2   |4        |37  |
|10|   SORT          |     |4        |40  |
|11|    TABLE SCAN   |t3   |4        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = VIEW3.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2]), filter(nil), sort_keys([t4.c1, ASC])
  2 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  3 - output([VIEW3.c1]), filter(nil), 
      access([VIEW3.c1])
  4 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  8 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  10 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  11 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from t4 where c1 in (select t2.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t4 where c1 not in (select t1.c1 + t2.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |170 |
|1 | TABLE SCAN          |t4   |4        |37  |
|2 | MATERIAL            |     |4        |127 |
|3 |  SUBPLAN SCAN       |VIEW3|4        |126 |
|4 |   MERGE OUTER JOIN  |     |4        |126 |
|5 |    SORT             |     |4        |40  |
|6 |     TABLE SCAN      |t1   |4        |37  |
|7 |    SUBPLAN SCAN     |VIEW1|4        |83  |
|8 |     MERGE SEMI JOIN |     |4        |82  |
|9 |      SORT           |     |4        |40  |
|10|       TABLE SCAN    |t2   |4        |37  |
|11|      SORT           |     |4        |40  |
|12|       TABLE SCAN    |t3   |4        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      conds([(T_OP_OR, t4.c1 = VIEW3.t1.c1 + t2.c1, (T_OP_IS, t4.c1, NULL, 0), (T_OP_IS, VIEW3.t1.c1 + t2.c1, NULL, 0))]), nl_params_(nil)
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  2 - output([VIEW3.t1.c1 + t2.c1]), filter(nil)
  3 - output([VIEW3.t1.c1 + t2.c1]), filter(nil), 
      access([VIEW3.t1.c1 + t2.c1])
  4 - output([t1.c1 + VIEW1.t2.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([VIEW1.t2.c1]), filter(nil), 
      access([VIEW1.t2.c1])
  8 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  11 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  12 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from t4 where c1 not in (select t1.c1 + t2.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t4 where c1 in (select t1.c1 + t2.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
Query Plan
==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |HASH RIGHT SEMI JOIN|     |4        |171 |
|1 | SUBPLAN SCAN       |VIEW3|4        |126 |
|2 |  MERGE SEMI JOIN   |     |4        |125 |
|3 |   MERGE JOIN       |     |4        |82  |
|4 |    SORT            |     |4        |40  |
|5 |     TABLE SCAN     |t1   |4        |37  |
|6 |    SORT            |     |4        |40  |
|7 |     TABLE SCAN     |t2   |4        |37  |
|8 |   SORT             |     |4        |40  |
|9 |    TABLE SCAN      |t3   |4        |37  |
|10| TABLE SCAN         |t4   |4        |37  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t4.c1 = VIEW3.t1.c1 + t2.c1]), other_conds(nil)
  1 - output([VIEW3.t1.c1 + t2.c1]), filter(nil), 
      access([VIEW3.t1.c1 + t2.c1])
  2 - output([t1.c1 + t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  3 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  9 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  10 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)

select * from t4 where c1 in (select t1.c1 + t2.c1 from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3));
+------+------+
| c1   | c2   |
+------+------+
|    2 |    2 |
+------+------+

EXPLAIN select * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3) where t2.c1 not in (select t4.c1 from t4 left join t5 on t4.c1 = t5.c1 and t5.c1 in (select c2 from t3));
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |260 |
|1 | MERGE OUTER JOIN    |     |4        |127 |
|2 |  SORT               |     |4        |41  |
|3 |   TABLE SCAN        |t1   |4        |37  |
|4 |  SUBPLAN SCAN       |VIEW2|4        |84  |
|5 |   MERGE SEMI JOIN   |     |4        |83  |
|6 |    SORT             |     |4        |41  |
|7 |     TABLE SCAN      |t2   |4        |37  |
|8 |    SORT             |     |4        |40  |
|9 |     TABLE SCAN      |t3   |4        |37  |
|10| MATERIAL            |     |4        |127 |
|11|  SUBPLAN SCAN       |VIEW5|4        |126 |
|12|   MERGE OUTER JOIN  |     |4        |126 |
|13|    SORT             |     |4        |40  |
|14|     TABLE SCAN      |t4   |4        |37  |
|15|    SUBPLAN SCAN     |VIEW1|4        |83  |
|16|     MERGE SEMI JOIN |     |4        |82  |
|17|      SORT           |     |4        |40  |
|18|       TABLE SCAN    |t5   |4        |37  |
|19|      SORT           |     |4        |40  |
|20|       TABLE SCAN    |t3   |4        |37  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [VIEW2.t2.c1], [VIEW2.t2.c2]), filter(nil), 
      conds([(T_OP_OR, VIEW2.t2.c1 = VIEW5.c1, (T_OP_IS, VIEW2.t2.c1, NULL, 0), (T_OP_IS, VIEW5.c1, NULL, 0))]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [VIEW2.t2.c1], [VIEW2.t2.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([VIEW2.t2.c1], [VIEW2.t2.c2]), filter(nil), 
      access([VIEW2.t2.c1], [VIEW2.t2.c2])
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c2]), other_conds(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c1, ASC])
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  8 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  9 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)
  10 - output([VIEW5.c1]), filter(nil)
  11 - output([VIEW5.c1]), filter(nil), 
      access([VIEW5.c1])
  12 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.t5.c1]), other_conds(nil)
  13 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  14 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  15 - output([VIEW1.t5.c1]), filter(nil), 
      access([VIEW1.t5.c1])
  16 - output([t5.c1]), filter(nil), 
      equal_conds([t5.c1 = t3.c2]), other_conds(nil)
  17 - output([t5.c1]), filter(nil), sort_keys([t5.c1, ASC])
  18 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p0)
  19 - output([t3.c2]), filter(nil), sort_keys([t3.c2, ASC])
  20 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from t1 left join t2 on t1.c1 = t2.c1 and t2.c1 in (select c2 from t3) where t2.c1 not in (select t4.c1 from t4 left join t5 on t4.c1 = t5.c1 and t5.c1 in (select c2 from t3));
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
+------+------+------+------+

## update outer join
explain update t1 left join t2 on t1.c1 = t2.c1 and t2.c2 in (select c1 from t3) set t2.c2 = 10;
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                 |     |4        |131 |
|1 | HASH OUTER JOIN       |     |4        |127 |
|2 |  TABLE SCAN           |t1   |4        |37  |
|3 |  SUBPLAN SCAN         |VIEW1|4        |82  |
|4 |   HASH RIGHT SEMI JOIN|     |4        |82  |
|5 |    TABLE SCAN         |t3   |4        |37  |
|6 |    TABLE SCAN         |t2   |4        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2: ({t2: (VIEW1.t2.__pk_increment, VIEW1.t2.c1, VIEW1.t2.c2)}), hash_distinct}]),
      update([VIEW1.t2.c2=?])
  1 - output([VIEW1.t2.__pk_increment], [VIEW1.t2.c1], [VIEW1.t2.c2], [?]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([VIEW1.t2.c1], [VIEW1.t2.c2], [VIEW1.t2.__pk_increment]), filter(nil), 
      access([VIEW1.t2.c1], [VIEW1.t2.c2], [VIEW1.t2.__pk_increment])
  4 - output([t2.c1], [t2.c2], [t2.__pk_increment]), filter(nil), 
      equal_conds([t2.c2 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.__pk_increment]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.__pk_increment]), partitions(p0)

EXPLAIN update t1 left join t2 on t1.c1 = t2.c1 and t2.c2 in (select c1 from t3) set t2.c2 = 10;
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |UPDATE                 |     |4        |131 |
|1 | HASH OUTER JOIN       |     |4        |127 |
|2 |  TABLE SCAN           |t1   |4        |37  |
|3 |  SUBPLAN SCAN         |VIEW1|4        |82  |
|4 |   HASH RIGHT SEMI JOIN|     |4        |82  |
|5 |    TABLE SCAN         |t3   |4        |37  |
|6 |    TABLE SCAN         |t2   |4        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t2: ({t2: (VIEW1.t2.__pk_increment, VIEW1.t2.c1, VIEW1.t2.c2)}), hash_distinct}]),
      update([VIEW1.t2.c2=?])
  1 - output([VIEW1.t2.__pk_increment], [VIEW1.t2.c1], [VIEW1.t2.c2], [?]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([VIEW1.t2.c1], [VIEW1.t2.c2], [VIEW1.t2.__pk_increment]), filter(nil), 
      access([VIEW1.t2.c1], [VIEW1.t2.c2], [VIEW1.t2.__pk_increment])
  4 - output([t2.c1], [t2.c2], [t2.__pk_increment]), filter(nil), 
      equal_conds([t2.c2 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.__pk_increment]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.__pk_increment]), partitions(p0)

update t1 left join t2 on t1.c1 = t2.c1 and t2.c2 in (select c1 from t3) set t2.c2 = 10;
explain update tp1 left join tp2 on tp1.c1 = tp2.c1 and tp2.c1 in (select c1 from t3) set tp2.c2 = 10;
Query Plan
==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |MULTI PARTITION UPDATE           |        |2        |122 |
|1 | PX COORDINATOR                  |        |2        |120 |
|2 |  EXCHANGE OUT DISTR             |:EX10001|2        |119 |
|3 |   MERGE OUTER JOIN              |        |2        |119 |
|4 |    SORT                         |        |2        |38  |
|5 |     PX PARTITION ITERATOR       |        |2        |37  |
|6 |      TABLE SCAN                 |tp1     |2        |37  |
|7 |    SUBPLAN SCAN                 |VIEW1   |2        |80  |
|8 |     MERGE SEMI JOIN             |        |2        |80  |
|9 |      SORT                       |        |2        |39  |
|10|       PX PARTITION ITERATOR     |        |2        |37  |
|11|        TABLE SCAN               |tp2     |2        |37  |
|12|      SORT                       |        |4        |40  |
|13|       EXCHANGE IN DISTR         |        |4        |37  |
|14|        EXCHANGE OUT DISTR (PKEY)|:EX10000|4        |37  |
|15|         TABLE SCAN              |t3      |4        |37  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{tp2: ({tp2: (VIEW1.tp2.c1, VIEW1.tp2.__pk_increment, VIEW1.tp2.c2)}), hash_distinct}]),
      update([VIEW1.tp2.c2=?])
  1 - output([VIEW1.tp2.c1], [VIEW1.tp2.__pk_increment], [VIEW1.tp2.c2], [?]), filter(nil)
  2 - output([VIEW1.tp2.c1], [VIEW1.tp2.__pk_increment], [VIEW1.tp2.c2], [?]), filter(nil), dop=1
  3 - output([VIEW1.tp2.c1], [VIEW1.tp2.__pk_increment], [VIEW1.tp2.c2], [?]), filter(nil), 
      equal_conds([tp1.c1 = VIEW1.tp2.c1]), other_conds(nil)
  4 - output([tp1.c1]), filter(nil), sort_keys([tp1.c1, ASC]), local merge sort
  5 - output([tp1.c1]), filter(nil)
  6 - output([tp1.c1]), filter(nil), 
      access([tp1.c1]), partitions(p[0-1])
  7 - output([VIEW1.tp2.c1], [VIEW1.tp2.c2], [VIEW1.tp2.__pk_increment]), filter(nil), 
      access([VIEW1.tp2.c1], [VIEW1.tp2.c2], [VIEW1.tp2.__pk_increment])
  8 - output([tp2.c1], [tp2.c2], [tp2.__pk_increment]), filter(nil), 
      equal_conds([tp2.c1 = t3.c1]), other_conds(nil)
  9 - output([tp2.c1], [tp2.c2], [tp2.__pk_increment]), filter(nil), sort_keys([tp2.c1, ASC]), local merge sort
  10 - output([tp2.c1], [tp2.c2], [tp2.__pk_increment]), filter(nil)
  11 - output([tp2.c1], [tp2.c2], [tp2.__pk_increment]), filter(nil), 
      access([tp2.c1], [tp2.c2], [tp2.__pk_increment]), partitions(p[0-1])
  12 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  13 - output([t3.c1]), filter(nil)
  14 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), is_single, dop=1
  15 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

EXPLAIN update tp1 left join tp2 on tp1.c1 = tp2.c1 and tp2.c1 in (select c1 from t3) set tp2.c2 = 10;
Query Plan
==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |MULTI PARTITION UPDATE           |        |2        |122 |
|1 | PX COORDINATOR                  |        |2        |120 |
|2 |  EXCHANGE OUT DISTR             |:EX10001|2        |119 |
|3 |   MERGE OUTER JOIN              |        |2        |119 |
|4 |    SORT                         |        |2        |38  |
|5 |     PX PARTITION ITERATOR       |        |2        |37  |
|6 |      TABLE SCAN                 |tp1     |2        |37  |
|7 |    SUBPLAN SCAN                 |VIEW1   |2        |80  |
|8 |     MERGE SEMI JOIN             |        |2        |80  |
|9 |      SORT                       |        |2        |39  |
|10|       PX PARTITION ITERATOR     |        |2        |37  |
|11|        TABLE SCAN               |tp2     |2        |37  |
|12|      SORT                       |        |4        |40  |
|13|       EXCHANGE IN DISTR         |        |4        |37  |
|14|        EXCHANGE OUT DISTR (PKEY)|:EX10000|4        |37  |
|15|         TABLE SCAN              |t3      |4        |37  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{tp2: ({tp2: (VIEW1.tp2.c1, VIEW1.tp2.__pk_increment, VIEW1.tp2.c2)}), hash_distinct}]),
      update([VIEW1.tp2.c2=?])
  1 - output([VIEW1.tp2.c1], [VIEW1.tp2.__pk_increment], [VIEW1.tp2.c2], [?]), filter(nil)
  2 - output([VIEW1.tp2.c1], [VIEW1.tp2.__pk_increment], [VIEW1.tp2.c2], [?]), filter(nil), dop=1
  3 - output([VIEW1.tp2.c1], [VIEW1.tp2.__pk_increment], [VIEW1.tp2.c2], [?]), filter(nil), 
      equal_conds([tp1.c1 = VIEW1.tp2.c1]), other_conds(nil)
  4 - output([tp1.c1]), filter(nil), sort_keys([tp1.c1, ASC]), local merge sort
  5 - output([tp1.c1]), filter(nil)
  6 - output([tp1.c1]), filter(nil), 
      access([tp1.c1]), partitions(p[0-1])
  7 - output([VIEW1.tp2.c1], [VIEW1.tp2.c2], [VIEW1.tp2.__pk_increment]), filter(nil), 
      access([VIEW1.tp2.c1], [VIEW1.tp2.c2], [VIEW1.tp2.__pk_increment])
  8 - output([tp2.c1], [tp2.c2], [tp2.__pk_increment]), filter(nil), 
      equal_conds([tp2.c1 = t3.c1]), other_conds(nil)
  9 - output([tp2.c1], [tp2.c2], [tp2.__pk_increment]), filter(nil), sort_keys([tp2.c1, ASC]), local merge sort
  10 - output([tp2.c1], [tp2.c2], [tp2.__pk_increment]), filter(nil)
  11 - output([tp2.c1], [tp2.c2], [tp2.__pk_increment]), filter(nil), 
      access([tp2.c1], [tp2.c2], [tp2.__pk_increment]), partitions(p[0-1])
  12 - output([t3.c1]), filter(nil), sort_keys([t3.c1, ASC])
  13 - output([t3.c1]), filter(nil)
  14 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), is_single, dop=1
  15 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

update tp1 left join tp2 on tp1.c1 = tp2.c1 and tp2.c1 in (select c1 from t3) set tp2.c2 = 10;

drop table if exists C, D, BB, CC, B;
CREATE TABLE C (
col_varchar_10 varchar(10),
col_varchar varchar (1),
col_int int,
pk int,
col_varchar_20 varchar(20),
col_varchar_key varchar (1),
col_varchar_10_key varchar(10),
col_int_key int,
col_varchar_20_key varchar(20),
/*Indices*/
primary key (pk) ,
key idx3(pk, col_varchar_key ),
key idx5(pk, col_varchar_10_key ),
key idx1(pk, col_int_key ),
key idx7(pk, col_varchar_20_key )) ;

CREATE TABLE D (
pk int,
col_varchar_10 varchar(10),
col_varchar_20 varchar(20),
col_varchar_10_key varchar(10),
col_varchar_20_key varchar(20),
col_int int,
col_int_key int,
col_varchar_key varchar (1),
col_varchar varchar (1),
/*Indices*/
primary key (pk) ,
key idx5(pk, col_varchar_10_key ),
key idx7(pk, col_varchar_20_key ),
key idx1(pk, col_int_key ),
key idx3(pk, col_varchar_key )) ;

CREATE TABLE BB (
col_varchar_20_key varchar(20),
col_int_key int,
col_int int,
col_varchar_10 varchar(10),
col_varchar_10_key varchar(10),
col_varchar_key varchar (1),
col_varchar varchar (1),
col_varchar_20 varchar(20),
pk int,
/*Indices*/
key idx7(pk, col_varchar_20_key ),
key idx1(pk, col_int_key ),
key idx5(pk, col_varchar_10_key ),
key idx3(pk, col_varchar_key ),
primary key (pk) ) ;

CREATE TABLE CC (
col_varchar_20_key varchar(20),
col_varchar_key varchar (1),
col_varchar_10_key varchar(10),
col_varchar_20 varchar(20),
col_int int,
pk int,
col_varchar varchar (1),
col_varchar_10 varchar(10),
col_int_key int,
/*Indices*/
key idx7(pk, col_varchar_20_key ),
key idx3(pk, col_varchar_key ),
key idx5(pk, col_varchar_10_key ),
primary key (pk) ,
key idx1(pk, col_int_key )) ;

CREATE TABLE B (
col_varchar varchar (1),
col_int int,
col_varchar_20 varchar(20),
col_varchar_10 varchar(10),
col_int_key int,
col_varchar_10_key varchar(10),
pk int,
col_varchar_20_key varchar(20),
col_varchar_key varchar (1),
/*Indices*/
key idx1(pk, col_int_key ),
key idx5(pk, col_varchar_10_key ),
primary key (pk) ,
key idx7(pk, col_varchar_20_key ),
key idx3(pk, col_varchar_key )) ;

EXPLAIN SELECT table2 . col_int_key AS field1 
FROM ( C AS table1 LEFT  JOIN 
      ( CC AS table2 INNER JOIN 
        (  SELECT   SUBQUERY1_t2 . * 
            FROM ( D AS SUBQUERY1_t2 RIGHT  JOIN 
                      CC AS SUBQUERY1_t3 ON (SUBQUERY1_t3 . `col_varchar_10_key` = SUBQUERY1_t2 . `col_varchar_key`
                                            AND SUBQUERY1_t2 . `col_varchar_10` != SOME ( SELECT   CHILD_SUBQUERY1_t1 . `col_varchar_10_key` AS CHILD_SUBQUERY1_field1
                                                                                    FROM C AS CHILD_SUBQUERY1_t1 ))) 
            WHERE   EXISTS ( SELECT DISTINCT  CHILD_SUBQUERY2_t1 . `col_varchar_10` AS CHILD_SUBQUERY1_field1 FROM CC AS CHILD_SUBQUERY2_t1 WHERE CHILD_SUBQUERY2_t1 . `col_int_key` != SUBQUERY1_t3 . `pk` ) )
        AS table3 ON (table3 . `col_varchar_key` = table2 . `col_varchar_20_key`  ) ) 
     ON (table3 . `pk` = table2 . `pk`  ) ) 
WHERE ( table1 . `col_varchar_10_key` > table3 . `col_varchar_20` AND table1 . `col_int` <> table1 . `col_int` )  GROUP BY field1  ORDER BY field1;
Query Plan
===================================================================================
|ID|OPERATOR                  |NAME                    |EST. ROWS   |COST         |
-----------------------------------------------------------------------------------
|0 |SORT                      |                        |101         |2.512494e+12 |
|1 | HASH GROUP BY            |                        |101         |2.512494e+12 |
|2 |  NESTED-LOOP JOIN        |                        |400248337500|2.381112e+12 |
|3 |   NESTED-LOOP SEMI JOIN  |                        |24014901    |1.361088e+12 |
|4 |    HASH JOIN             |                        |48029801    |6606964932   |
|5 |     TABLE SCAN           |SUBQUERY1_t3(idx5)      |100000      |27937        |
|6 |     NESTED-LOOP SEMI JOIN|                        |49005       |6559769374   |
|7 |      MERGE JOIN          |                        |98010       |261974       |
|8 |       TABLE SCAN         |table2                  |100000      |64066        |
|9 |       TABLE SCAN         |SUBQUERY1_t2            |100000      |66272        |
|10|      MATERIAL            |                        |100000      |50906        |
|11|       TABLE SCAN         |CHILD_SUBQUERY1_t1(idx5)|100000      |27937        |
|12|    MATERIAL              |                        |100000      |46313        |
|13|     TABLE SCAN           |CHILD_SUBQUERY2_t1(idx1)|100000      |27937        |
|14|   MATERIAL               |                        |50000       |93111        |
|15|    TABLE SCAN            |table1                  |50000       |72438        |
===================================================================================

Outputs & filters: 
-------------------------------------
  0 - output([table2.col_int_key]), filter(nil), sort_keys([table2.col_int_key, ASC])
  1 - output([table2.col_int_key]), filter(nil), 
      group([table2.col_int_key]), agg_func(nil)
  2 - output([table2.col_int_key]), filter(nil), 
      conds([table1.col_varchar_10_key > SUBQUERY1_t2.col_varchar_20]), nl_params_(nil)
  3 - output([table2.col_int_key], [SUBQUERY1_t2.col_varchar_20]), filter(nil), 
      conds([CHILD_SUBQUERY2_t1.col_int_key != SUBQUERY1_t3.pk]), nl_params_(nil)
  4 - output([table2.col_int_key], [SUBQUERY1_t2.col_varchar_20], [SUBQUERY1_t3.pk]), filter(nil), 
      equal_conds([SUBQUERY1_t3.col_varchar_10_key = SUBQUERY1_t2.col_varchar_key]), other_conds(nil)
  5 - output([SUBQUERY1_t3.col_varchar_10_key], [SUBQUERY1_t3.pk]), filter(nil), 
      access([SUBQUERY1_t3.col_varchar_10_key], [SUBQUERY1_t3.pk]), partitions(p0)
  6 - output([table2.col_int_key], [SUBQUERY1_t2.col_varchar_20], [SUBQUERY1_t2.col_varchar_key]), filter(nil), 
      conds([SUBQUERY1_t2.col_varchar_10 != CHILD_SUBQUERY1_t1.col_varchar_10_key]), nl_params_(nil)
  7 - output([table2.col_int_key], [SUBQUERY1_t2.col_varchar_20], [SUBQUERY1_t2.col_varchar_key], [SUBQUERY1_t2.col_varchar_10]), filter(nil), 
      equal_conds([SUBQUERY1_t2.pk = table2.pk], [SUBQUERY1_t2.col_varchar_key = table2.col_varchar_20_key]), other_conds(nil)
  8 - output([table2.col_varchar_20_key], [table2.pk], [table2.col_int_key]), filter(nil), 
      access([table2.col_varchar_20_key], [table2.pk], [table2.col_int_key]), partitions(p0)
  9 - output([SUBQUERY1_t2.col_varchar_key], [SUBQUERY1_t2.col_varchar_10], [SUBQUERY1_t2.pk], [SUBQUERY1_t2.col_varchar_20]), filter(nil), 
      access([SUBQUERY1_t2.col_varchar_key], [SUBQUERY1_t2.col_varchar_10], [SUBQUERY1_t2.pk], [SUBQUERY1_t2.col_varchar_20]), partitions(p0)
  10 - output([CHILD_SUBQUERY1_t1.col_varchar_10_key]), filter(nil)
  11 - output([CHILD_SUBQUERY1_t1.col_varchar_10_key]), filter(nil), 
      access([CHILD_SUBQUERY1_t1.col_varchar_10_key]), partitions(p0)
  12 - output([CHILD_SUBQUERY2_t1.col_int_key]), filter(nil)
  13 - output([CHILD_SUBQUERY2_t1.col_int_key]), filter(nil), 
      access([CHILD_SUBQUERY2_t1.col_int_key]), partitions(p0)
  14 - output([table1.col_varchar_10_key]), filter(nil)
  15 - output([table1.col_varchar_10_key]), filter([table1.col_int != table1.col_int]), 
      access([table1.col_varchar_10_key], [table1.col_int]), partitions(p0)

SELECT table2 . col_int_key AS field1 
FROM ( C AS table1 LEFT  JOIN 
      ( CC AS table2 INNER JOIN 
        (  SELECT   SUBQUERY1_t2 . * 
            FROM ( D AS SUBQUERY1_t2 RIGHT  JOIN 
                      CC AS SUBQUERY1_t3 ON (SUBQUERY1_t3 . `col_varchar_10_key` = SUBQUERY1_t2 . `col_varchar_key`
                                            AND SUBQUERY1_t2 . `col_varchar_10` != SOME ( SELECT   CHILD_SUBQUERY1_t1 . `col_varchar_10_key` AS CHILD_SUBQUERY1_field1
                                                                                    FROM C AS CHILD_SUBQUERY1_t1 ))) 
            WHERE   EXISTS ( SELECT DISTINCT  CHILD_SUBQUERY2_t1 . `col_varchar_10` AS CHILD_SUBQUERY1_field1 FROM CC AS CHILD_SUBQUERY2_t1 WHERE CHILD_SUBQUERY2_t1 . `col_int_key` != SUBQUERY1_t3 . `pk` ) )
        AS table3 ON (table3 . `col_varchar_key` = table2 . `col_varchar_20_key`  ) ) 
     ON (table3 . `pk` = table2 . `pk`  ) ) 
WHERE ( table1 . `col_varchar_10_key` > table3 . `col_varchar_20` AND table1 . `col_int` <> table1 . `col_int` )  GROUP BY field1  ORDER BY field1;
+--------+
| field1 |
+--------+
+--------+

EXPLAIN SELECT  SUBQUERY1_t2 . * 
FROM ( D AS SUBQUERY1_t2 RIGHT  JOIN 
          CC AS SUBQUERY1_t3 ON (SUBQUERY1_t3 . `col_varchar_10_key` = SUBQUERY1_t2 . `col_varchar_key`
                                AND SUBQUERY1_t2 . `col_varchar_10` != SOME ( SELECT   CHILD_SUBQUERY1_t1 . `col_varchar_10_key` AS CHILD_SUBQUERY1_field1
                                                                        FROM C AS CHILD_SUBQUERY1_t1 ))) 
WHERE EXISTS (SELECT DISTINCT CHILD_SUBQUERY2_t1 . `col_varchar_10` AS CHILD_SUBQUERY1_field1 FROM CC AS CHILD_SUBQUERY2_t1 WHERE CHILD_SUBQUERY2_t1 . `col_int_key` != SUBQUERY1_t2 . `pk`);
Query Plan
==========================================================================
|ID|OPERATOR               |NAME                    |EST. ROWS|COST      |
--------------------------------------------------------------------------
|0 |HASH JOIN              |                        |24502500 |6190717737|
|1 | NESTED-LOOP SEMI JOIN |                        |25000    |6166579702|
|2 |  NESTED-LOOP SEMI JOIN|                        |50000    |2820208781|
|3 |   TABLE SCAN          |SUBQUERY1_t2            |100000   |77301     |
|4 |   MATERIAL            |                        |100000   |46313     |
|5 |    TABLE SCAN         |CHILD_SUBQUERY2_t1(idx1)|100000   |27937     |
|6 |  MATERIAL             |                        |100000   |50906     |
|7 |   TABLE SCAN          |CHILD_SUBQUERY1_t1(idx5)|100000   |27937     |
|8 | TABLE SCAN            |SUBQUERY1_t3(idx5)      |100000   |27937     |
==========================================================================

Outputs & filters: 
-------------------------------------
  0 - output([SUBQUERY1_t2.pk], [SUBQUERY1_t2.col_varchar_10], [SUBQUERY1_t2.col_varchar_20], [SUBQUERY1_t2.col_varchar_10_key], [SUBQUERY1_t2.col_varchar_20_key], [SUBQUERY1_t2.col_int], [SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar_key], [SUBQUERY1_t2.col_varchar]), filter(nil), 
      equal_conds([SUBQUERY1_t3.col_varchar_10_key = SUBQUERY1_t2.col_varchar_key]), other_conds(nil)
  1 - output([SUBQUERY1_t2.pk], [SUBQUERY1_t2.col_varchar_10], [SUBQUERY1_t2.col_varchar_20], [SUBQUERY1_t2.col_varchar_10_key], [SUBQUERY1_t2.col_varchar_20_key], [SUBQUERY1_t2.col_int], [SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar_key], [SUBQUERY1_t2.col_varchar]), filter(nil), 
      conds([SUBQUERY1_t2.col_varchar_10 != CHILD_SUBQUERY1_t1.col_varchar_10_key]), nl_params_(nil)
  2 - output([SUBQUERY1_t2.pk], [SUBQUERY1_t2.col_varchar_10], [SUBQUERY1_t2.col_varchar_20], [SUBQUERY1_t2.col_varchar_10_key], [SUBQUERY1_t2.col_varchar_20_key], [SUBQUERY1_t2.col_int], [SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar_key], [SUBQUERY1_t2.col_varchar]), filter(nil), 
      conds([CHILD_SUBQUERY2_t1.col_int_key != SUBQUERY1_t2.pk]), nl_params_(nil)
  3 - output([SUBQUERY1_t2.col_varchar_key], [SUBQUERY1_t2.col_varchar_10], [SUBQUERY1_t2.pk], [SUBQUERY1_t2.col_varchar_20], [SUBQUERY1_t2.col_varchar_10_key], [SUBQUERY1_t2.col_varchar_20_key], [SUBQUERY1_t2.col_int], [SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar]), filter(nil), 
      access([SUBQUERY1_t2.col_varchar_key], [SUBQUERY1_t2.col_varchar_10], [SUBQUERY1_t2.pk], [SUBQUERY1_t2.col_varchar_20], [SUBQUERY1_t2.col_varchar_10_key], [SUBQUERY1_t2.col_varchar_20_key], [SUBQUERY1_t2.col_int], [SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar]), partitions(p0)
  4 - output([CHILD_SUBQUERY2_t1.col_int_key]), filter(nil)
  5 - output([CHILD_SUBQUERY2_t1.col_int_key]), filter(nil), 
      access([CHILD_SUBQUERY2_t1.col_int_key]), partitions(p0)
  6 - output([CHILD_SUBQUERY1_t1.col_varchar_10_key]), filter(nil)
  7 - output([CHILD_SUBQUERY1_t1.col_varchar_10_key]), filter(nil), 
      access([CHILD_SUBQUERY1_t1.col_varchar_10_key]), partitions(p0)
  8 - output([SUBQUERY1_t3.col_varchar_10_key]), filter(nil), 
      access([SUBQUERY1_t3.col_varchar_10_key]), partitions(p0)

SELECT  SUBQUERY1_t2 . * 
FROM ( D AS SUBQUERY1_t2 RIGHT  JOIN 
          CC AS SUBQUERY1_t3 ON (SUBQUERY1_t3 . `col_varchar_10_key` = SUBQUERY1_t2 . `col_varchar_key`
                                AND SUBQUERY1_t2 . `col_varchar_10` != SOME ( SELECT   CHILD_SUBQUERY1_t1 . `col_varchar_10_key` AS CHILD_SUBQUERY1_field1
                                                                        FROM C AS CHILD_SUBQUERY1_t1 ))) 
WHERE EXISTS (SELECT DISTINCT CHILD_SUBQUERY2_t1 . `col_varchar_10` AS CHILD_SUBQUERY1_field1 FROM CC AS CHILD_SUBQUERY2_t1 WHERE CHILD_SUBQUERY2_t1 . `col_int_key` != SUBQUERY1_t2 . `pk`);
+----+----------------+----------------+--------------------+--------------------+---------+-------------+-----------------+-------------+
| pk | col_varchar_10 | col_varchar_20 | col_varchar_10_key | col_varchar_20_key | col_int | col_int_key | col_varchar_key | col_varchar |
+----+----------------+----------------+--------------------+--------------------+---------+-------------+-----------------+-------------+
+----+----------------+----------------+--------------------+--------------------+---------+-------------+-----------------+-------------+

## 简化case
EXPLAIN select * from ( t1 right  join t2 on (t2.c1 = t1.c1 and t1.c2 not in ( select c1 from t3)));
Query Plan
=================================================
|ID|OPERATOR               |NAME |EST. ROWS|COST|
-------------------------------------------------
|0 |HASH RIGHT OUTER JOIN  |     |4        |119 |
|1 | SUBPLAN SCAN          |VIEW1|0        |81  |
|2 |  NESTED-LOOP ANTI JOIN|     |0        |81  |
|3 |   TABLE SCAN          |t1   |4        |37  |
|4 |   MATERIAL            |     |4        |38  |
|5 |    TABLE SCAN         |t3   |4        |37  |
|6 | TABLE SCAN            |t2   |4        |37  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.t1.c1]), other_conds(nil)
  1 - output([VIEW1.t1.c1], [VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([(T_OP_OR, t1.c2 = t3.c1, (T_OP_IS, t1.c2, NULL, 0), (T_OP_IS, t3.c1, NULL, 0))]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1]), filter(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from ( t1 right  join t2 on (t2.c1 = t1.c1 and t1.c2 not in ( select c1 from t3)));
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL | NULL |    1 |   10 |
| NULL | NULL |    3 |    3 |
| NULL | NULL |    4 |    4 |
| NULL | NULL | NULL | NULL |
+------+------+------+------+

EXPLAIN select * from ( t1 right join t2 on (t2.c1 = t1.c1 and t1.c2 not in (select c1 from t3)))
where exists (select distinct c2 from t2 where t1.c2 != t2.c1);
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN  |    |0        |156 |
|1 | HASH JOIN             |    |0        |119 |
|2 |  NESTED-LOOP ANTI JOIN|    |0        |81  |
|3 |   TABLE SCAN          |t1  |4        |37  |
|4 |   MATERIAL            |    |4        |38  |
|5 |    TABLE SCAN         |t3  |4        |37  |
|6 |  TABLE SCAN           |t2  |4        |37  |
|7 | MATERIAL              |    |4        |38  |
|8 |  TABLE SCAN           |t2  |4        |37  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      conds([t1.c2 != t2.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([(T_OP_OR, t1.c2 = t3.c1, (T_OP_IS, t1.c2, NULL, 0), (T_OP_IS, t3.c1, NULL, 0))]), nl_params_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t3.c1]), filter(nil)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

select * from ( t1 right join t2 on (t2.c1 = t1.c1 and t1.c2 not in (select c1 from t3)))
where exists (select distinct c2 from t2 where t1.c2 != t2.c1);
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
+------+------+------+------+

EXPLAIN select * from ( t1 right join t3 on t1.c1 = t3.c1 right join t2 on (t2.c1 = t1.c1 and t1.c2 not in ( select c1 from t4)));
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |HASH RIGHT OUTER JOIN   |     |4        |157 |
|1 | SUBPLAN SCAN           |VIEW1|0        |119 |
|2 |  HASH JOIN             |     |0        |119 |
|3 |   NESTED-LOOP ANTI JOIN|     |0        |81  |
|4 |    TABLE SCAN          |t1   |4        |37  |
|5 |    MATERIAL            |     |4        |38  |
|6 |     TABLE SCAN         |t4   |4        |37  |
|7 |   TABLE SCAN           |t3   |4        |37  |
|8 | TABLE SCAN             |t2   |4        |37  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t3.c1], [VIEW1.t3.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t2.c1 = VIEW1.t1.c1]), other_conds(nil)
  1 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t3.c1], [VIEW1.t3.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW1.t3.c1], [VIEW1.t3.c2])
  2 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([(T_OP_OR, t1.c2 = t4.c1, (T_OP_IS, t1.c2, NULL, 0), (T_OP_IS, t4.c1, NULL, 0))]), nl_params_(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t4.c1]), filter(nil)
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p0)
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

select * from ( t1 right join t3 on t1.c1 = t3.c1 right join t2 on (t2.c1 = t1.c1 and t1.c2 not in ( select c1 from t4)));
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c1   | c2   |
+------+------+------+------+------+------+
| NULL | NULL | NULL | NULL |    1 |   10 |
| NULL | NULL | NULL | NULL |    3 |    3 |
| NULL | NULL | NULL | NULL |    4 |    4 |
| NULL | NULL | NULL | NULL | NULL | NULL |
+------+------+------+------+------+------+

EXPLAIN SELECT Count(table1 . `pk`)     AS field1, 
       table1 . col_varchar_key AS field2 
FROM   ( (SELECT DISTINCT SUBQUERY1_t1 . * 
        FROM   ( cc AS SUBQUERY1_t1 
                 RIGHT JOIN bb AS SUBQUERY1_t2 
                         ON ( SUBQUERY1_t2 . `pk` = SUBQUERY1_t1 . `col_int` ) ) 
        WHERE  SUBQUERY1_t1 . `pk` < 7) AS table1 
         RIGHT OUTER JOIN d AS table2 
                       ON ( table2 . `pk` = table1 . `col_int_key` 
                            AND ( 9, 7 ) IN (SELECT Sum(SUBQUERY2_t1 . 
                                                        `col_int_key`) AS 
                                                    SUBQUERY2_field1, 
                                                    Count(SUBQUERY2_t1 . `pk`) 
                                                    AS 
                                                    SUBQUERY2_field2 
                                             FROM   ( cc AS SUBQUERY2_t1 
                                                      INNER JOIN cc AS 
                                                      SUBQUERY2_t2 
                                                              ON ( SUBQUERY2_t2 . 
                                                                   `col_int_key` 
                                                                   = 
                                                                   SUBQUERY2_t1 . 
                                                                   `pk` ) 
                                                    ) 
                                            ) ) ) 
WHERE  ( EXISTS ((SELECT 5 
                  FROM   DUAL)) ) 
        OR table1 . `pk` < table1 . `col_int` 
GROUP  BY field2 
ORDER  BY field1, 
          field2;
Query Plan
========================================================================
|ID|OPERATOR                       |NAME              |EST. ROWS|COST  |
------------------------------------------------------------------------
|0 |SORT                           |                  |101      |355614|
|1 | HASH GROUP BY                 |                  |101      |355406|
|2 |  SUBPLAN FILTER               |                  |66667    |329919|
|3 |   MERGE OUTER JOIN            |                  |66667    |320717|
|4 |    TABLE SCAN                 |table2(idx5)      |100000   |25731 |
|5 |    SORT                       |                  |5        |281180|
|6 |     NESTED-LOOP JOIN CARTESIAN|                  |5        |281173|
|7 |      SUBPLAN SCAN             |VIEW5             |1        |281133|
|8 |       SCALAR GROUP BY         |                  |1        |281133|
|9 |        HASH JOIN              |                  |99000    |256977|
|10|         TABLE SCAN            |SUBQUERY2_t2(idx1)|100000   |27937 |
|11|         TABLE SCAN            |SUBQUERY2_t1(idx1)|100000   |27937 |
|12|      MERGE JOIN               |                  |9900     |73654 |
|13|       SORT                    |                  |10000    |26869 |
|14|        TABLE SCAN             |SUBQUERY1_t1      |10000    |6660  |
|15|       TABLE SCAN              |SUBQUERY1_t2(idx7)|100000   |25731 |
|16|   LIMIT                       |                  |1        |1     |
|17|    EXPRESSION                 |                  |1        |1     |
========================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(SUBQUERY1_t1.pk)], [SUBQUERY1_t1.col_varchar_key]), filter(nil), sort_keys([T_FUN_COUNT(SUBQUERY1_t1.pk), ASC], [SUBQUERY1_t1.col_varchar_key, ASC])
  1 - output([T_FUN_COUNT(SUBQUERY1_t1.pk)], [SUBQUERY1_t1.col_varchar_key]), filter(nil), 
      group([SUBQUERY1_t1.col_varchar_key]), agg_func([T_FUN_COUNT(SUBQUERY1_t1.pk)])
  2 - output([SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_key]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_key]), filter([? OR SUBQUERY1_t1.pk < SUBQUERY1_t1.col_int]), 
      equal_conds([table2.pk = SUBQUERY1_t1.col_int_key]), other_conds(nil)
  4 - output([table2.pk]), filter(nil), 
      access([table2.pk]), partitions(p0)
  5 - output([SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_key], [SUBQUERY1_t1.col_int_key], [SUBQUERY1_t1.col_int]), filter(nil), sort_keys([SUBQUERY1_t1.col_int_key, ASC])
  6 - output([SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_key], [SUBQUERY1_t1.col_int_key], [SUBQUERY1_t1.col_int]), filter(nil), 
      conds(nil), nl_params_(nil)
  7 - output([1]), filter(nil), 
      access(nil)
  8 - output([T_FUN_SUM(SUBQUERY2_t1.col_int_key)], [T_FUN_COUNT(SUBQUERY2_t1.pk)]), filter([T_FUN_COUNT(SUBQUERY2_t1.pk) = 7], [T_FUN_SUM(SUBQUERY2_t1.col_int_key) = ?]), 
      group(nil), agg_func([T_FUN_SUM(SUBQUERY2_t1.col_int_key)], [T_FUN_COUNT(SUBQUERY2_t1.pk)])
  9 - output([SUBQUERY2_t1.col_int_key], [SUBQUERY2_t1.pk]), filter(nil), 
      equal_conds([SUBQUERY2_t2.col_int_key = SUBQUERY2_t1.pk]), other_conds(nil)
  10 - output([SUBQUERY2_t2.col_int_key]), filter(nil), 
      access([SUBQUERY2_t2.col_int_key]), partitions(p0)
  11 - output([SUBQUERY2_t1.pk], [SUBQUERY2_t1.col_int_key]), filter(nil), 
      access([SUBQUERY2_t1.pk], [SUBQUERY2_t1.col_int_key]), partitions(p0)
  12 - output([SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_key], [SUBQUERY1_t1.col_int_key], [SUBQUERY1_t1.col_int]), filter(nil), 
      equal_conds([SUBQUERY1_t2.pk = SUBQUERY1_t1.col_int]), other_conds(nil)
  13 - output([SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_key], [SUBQUERY1_t1.col_int_key], [SUBQUERY1_t1.col_int]), filter(nil), sort_keys([SUBQUERY1_t1.col_int, ASC])
  14 - output([SUBQUERY1_t1.col_int], [SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_key], [SUBQUERY1_t1.col_int_key]), filter(nil), 
      access([SUBQUERY1_t1.col_int], [SUBQUERY1_t1.pk], [SUBQUERY1_t1.col_varchar_key], [SUBQUERY1_t1.col_int_key]), partitions(p0)
  15 - output([SUBQUERY1_t2.pk]), filter(nil), 
      access([SUBQUERY1_t2.pk]), partitions(p0)
  16 - output([5]), filter(nil), limit(1), offset(nil)
  17 - output([1]), filter(nil)
      values({1})

SELECT Count(table1 . `pk`)     AS field1, 
       table1 . col_varchar_key AS field2 
FROM   ( (SELECT DISTINCT SUBQUERY1_t1 . * 
        FROM   ( cc AS SUBQUERY1_t1 
                 RIGHT JOIN bb AS SUBQUERY1_t2 
                         ON ( SUBQUERY1_t2 . `pk` = SUBQUERY1_t1 . `col_int` ) ) 
        WHERE  SUBQUERY1_t1 . `pk` < 7) AS table1 
         RIGHT OUTER JOIN d AS table2 
                       ON ( table2 . `pk` = table1 . `col_int_key` 
                            AND ( 9, 7 ) IN (SELECT Sum(SUBQUERY2_t1 . 
                                                        `col_int_key`) AS 
                                                    SUBQUERY2_field1, 
                                                    Count(SUBQUERY2_t1 . `pk`) 
                                                    AS 
                                                    SUBQUERY2_field2 
                                             FROM   ( cc AS SUBQUERY2_t1 
                                                      INNER JOIN cc AS 
                                                      SUBQUERY2_t2 
                                                              ON ( SUBQUERY2_t2 . 
                                                                   `col_int_key` 
                                                                   = 
                                                                   SUBQUERY2_t1 . 
                                                                   `pk` ) 
                                                    ) 
                                            ) ) ) 
WHERE  ( EXISTS ((SELECT 5 
                  FROM   DUAL)) ) 
        OR table1 . `pk` < table1 . `col_int` 
GROUP  BY field2 
ORDER  BY field1, 
          field2;
+--------+--------+
| field1 | field2 |
+--------+--------+
+--------+--------+

EXPLAIN SELECT  table1 . col_varchar_key 
FROM (SELECT * FROM CC AS SUBQUERY1_t1) AS table1 
      RIGHT OUTER JOIN D AS table2 ON table2 . `pk` = table1 . `col_int_key` 
                                    AND 9  IN (SELECT `col_int_key` AS SUBQUERY2_field1 FROM CC AS SUBQUERY2_t1);
Query Plan
============================================================================
|ID|OPERATOR                         |NAME              |EST. ROWS|COST    |
----------------------------------------------------------------------------
|0 |HASH OUTER JOIN                  |                  |100000   |20030531|
|1 | TABLE SCAN                      |table2(idx5)      |100000   |25731   |
|2 | SUBPLAN SCAN                    |VIEW2             |100000   |19803698|
|3 |  NESTED-LOOP SEMI JOIN CARTESIAN|                  |100000   |19789895|
|4 |   TABLE SCAN                    |SUBQUERY1_t1      |100000   |64066   |
|5 |   MATERIAL                      |                  |990      |45001   |
|6 |    SUBPLAN SCAN                 |VIEW3             |990      |44819   |
|7 |     TABLE SCAN                  |SUBQUERY2_t1(idx1)|990      |44682   |
============================================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW2.VIEW1.col_varchar_key]), filter(nil), 
      equal_conds([table2.pk = VIEW2.VIEW1.col_int_key]), other_conds(nil)
  1 - output([table2.pk]), filter(nil), 
      access([table2.pk]), partitions(p0)
  2 - output([VIEW2.VIEW1.col_varchar_key], [VIEW2.VIEW1.col_int_key]), filter(nil), 
      access([VIEW2.VIEW1.col_varchar_key], [VIEW2.VIEW1.col_int_key])
  3 - output([SUBQUERY1_t1.col_varchar_key], [SUBQUERY1_t1.col_int_key]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([SUBQUERY1_t1.col_varchar_key], [SUBQUERY1_t1.col_int_key]), filter(nil), 
      access([SUBQUERY1_t1.col_varchar_key], [SUBQUERY1_t1.col_int_key]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access(nil)
  7 - output([1]), filter([SUBQUERY2_t1.col_int_key = 9]), 
      access([SUBQUERY2_t1.col_int_key]), partitions(p0)

SELECT  table1 . col_varchar_key 
FROM (SELECT * FROM CC AS SUBQUERY1_t1) AS table1 
      RIGHT OUTER JOIN D AS table2 ON table2 . `pk` = table1 . `col_int_key` 
                                    AND 9  IN (SELECT `col_int_key` AS SUBQUERY2_field1 FROM CC AS SUBQUERY2_t1);
+-----------------+
| col_varchar_key |
+-----------------+
+-----------------+

EXPLAIN SELECT Min(table2 . `pk`) AS field1 
FROM   ( cc AS table1 
RIGHT OUTER JOIN c AS table2 
ON ( table2 . `col_varchar` = table1 . `col_varchar_key` ) 
) 
WHERE  ( ( 9, 5 ) IN (SELECT Sum(SUBQUERY1_t1 . `col_int`) AS SUBQUERY1_field1, 
Max(SUBQUERY1_t1 . `pk`)      AS SUBQUERY1_field2 
FROM   ( cc AS SUBQUERY1_t1 
LEFT JOIN ( c AS SUBQUERY1_t2 
INNER JOIN c AS SUBQUERY1_t3 
ON ( SUBQUERY1_t3 . 
`col_int_key` = 
SUBQUERY1_t2 . 
`col_int_key` 
OR ( 'x', 'j' ) IN 
(SELECT Sum(CHILD_SUBQUERY1_t1 . 
`col_varchar_key`) AS 
CHILD_SUBQUERY1_field1, 
Sum(CHILD_SUBQUERY1_t1 . 
`col_varchar` 
) 
AS 
CHILD_SUBQUERY1_field2 
FROM   ( cc AS CHILD_SUBQUERY1_t1 
INNER JOIN cc AS 
CHILD_SUBQUERY1_t2 
ON ( 
CHILD_SUBQUERY1_t2 . 
`col_varchar_20` 
= 
CHILD_SUBQUERY1_t1 . 
`col_varchar_key` 
) ) 
) ) ) 
ON ( SUBQUERY1_t3 . `col_varchar` = 
SUBQUERY1_t2 . `col_varchar_key` 
OR 
SUBQUERY1_t3 . `col_varchar_20_key` NOT 
IN 
(SELECT 5 
UNION 
SELECT 8) 
) ) 
WHERE  ( 'i', 'm' ) IN (SELECT Min(CHILD_SUBQUERY3_t1 . 
`col_varchar`)       AS 
CHILD_SUBQUERY3_field1, 
Count(CHILD_SUBQUERY3_t1 . 
`col_varchar_key`) AS 
CHILD_SUBQUERY3_field2 
FROM   ( cc AS CHILD_SUBQUERY3_t1 
RIGHT JOIN b AS 
CHILD_SUBQUERY3_t2 
ON ( 
CHILD_SUBQUERY3_t2 . 
`col_varchar_10` = 
CHILD_SUBQUERY3_t1 . 
`col_varchar_key` ) 
) 
WHERE 
CHILD_SUBQUERY3_t2 . `col_varchar_10` 
<= 
CHILD_SUBQUERY3_t2 . `col_varchar`)) ) 
AND ( table1 . `col_int_key` NOT BETWEEN 226 AND ( 226 + 183 ) 
OR table1 . `col_varchar_key` <= 'm' ) 
AND (SELECT Max(SUBQUERY2_t1 . `col_varchar_20`) AS SUBQUERY2_field1 
FROM   ( cc AS SUBQUERY2_t1 
INNER JOIN c AS SUBQUERY2_t2 
ON ( SUBQUERY2_t2 . `col_varchar_key` = 
SUBQUERY2_t1 . `col_varchar` ) )) IS NULL 
HAVING field1 > 't' 
ORDER  BY field1;
Query Plan
=============================================================================================
|ID|OPERATOR                              |NAME              |EST. ROWS      |COST          |
---------------------------------------------------------------------------------------------
|0 |SCALAR GROUP BY                       |                  |1              |5285272607    |
|1 | NESTED-LOOP JOIN CARTESIAN           |                  |1348           |5285272350    |
|2 |  SUBPLAN SCAN                        |VIEW20            |1              |114861662     |
|3 |   SCALAR GROUP BY                    |                  |1              |114861662     |
|4 |    HASH JOIN                         |                  |98010000       |96140537      |
|5 |     TABLE SCAN                       |SUBQUERY2_t2(idx3)|100000         |27937         |
|6 |     TABLE SCAN                       |SUBQUERY2_t1      |100000         |64066         |
|7 |  NESTED-LOOP JOIN CARTESIAN          |                  |26953          |103408196302  |
|8 |   SUBPLAN SCAN                       |VIEW7             |1              |103408130766  |
|9 |    SCALAR GROUP BY                   |                  |1              |103408130766  |
|10|     NESTED-LOOP JOIN CARTESIAN       |                  |64643294591    |87634981224   |
|11|      SUBPLAN SCAN                    |VIEW4             |1              |40212539      |
|12|       SCALAR GROUP BY                |                  |1              |40212539      |
|13|        HASH OUTER JOIN               |                  |32670000       |32240965      |
|14|         TABLE SCAN                   |CHILD_SUBQUERY3_t2|33334          |110903        |
|15|         TABLE SCAN                   |CHILD_SUBQUERY3_t1|100000         |64066         |
|16|      NESTED-LOOP OUTER JOIN CARTESIAN|                  |1.292866e+14   |9.149205e+13  |
|17|       TABLE SCAN                     |SUBQUERY1_t1      |100000         |61860         |
|18|       MATERIAL                       |                  |1292865892     |3774567240    |
|19|        SUBPLAN SCAN                  |VIEW1             |1292865892     |3536998278    |
|20|         UNION ALL                    |                  |1292865892     |3358554425    |
|21|          SUBPLAN FILTER              |                  |49485299       |206585288     |
|22|           HASH JOIN                  |                  |49485299       |79666051      |
|23|            TABLE SCAN                |SUBQUERY1_t2      |100000         |64066         |
|24|            TABLE SCAN                |SUBQUERY1_t3      |100000         |64066         |
|25|           SCALAR GROUP BY            |                  |1              |120089181     |
|26|            HASH JOIN                 |                  |98010000       |96174459      |
|27|             TABLE SCAN               |CHILD_SUBQUERY1_t1|100000         |64066         |
|28|             TABLE SCAN               |CHILD_SUBQUERY1_t2|100000         |61860         |
|29|          SUBPLAN FILTER              |                  |1243380594     |2726571861    |
|30|           NESTED-LOOP JOIN           |                  |1243380594     |2434868884    |
|31|            NESTED-LOOP ANTI JOIN     |                  |49253          |148523        |
|32|             TABLE SCAN               |SUBQUERY1_t3      |100000         |66272         |
|33|             MATERIAL                 |                  |2              |2             |
|34|              SUBPLAN SCAN            |VIEW21            |2              |2             |
|35|               MERGE UNION DISTINCT   |                  |2              |1             |
|36|                EXPRESSION            |                  |1              |1             |
|37|                EXPRESSION            |                  |1              |1             |
|38|            MATERIAL                  |                  |100000         |82441         |
|39|             TABLE SCAN               |SUBQUERY1_t2      |100000         |64066         |
|40|           SCALAR GROUP BY            |                  |1              |120089181     |
|41|            HASH JOIN                 |                  |98010000       |96174459      |
|42|             TABLE SCAN               |CHILD_SUBQUERY1_t1|100000         |64066         |
|43|             TABLE SCAN               |CHILD_SUBQUERY1_t2|100000         |61860         |
|44|   HASH OUTER JOIN                    |                  |53905500       |96174459      |
|45|    TABLE SCAN                        |table2            |100000         |61860         |
|46|    TABLE SCAN                        |table1            |100000         |64066         |
=============================================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(table2.pk)]), filter([cast(T_FUN_MIN(table2.pk), DECIMAL(11, 0)) > ?]), 
      group(nil), agg_func([T_FUN_MIN(table2.pk)])
  1 - output([table2.pk]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([1]), filter(nil), 
      access(nil)
  3 - output([T_FUN_MAX(SUBQUERY2_t1.col_varchar_20)]), filter([(T_OP_IS, T_FUN_MAX(SUBQUERY2_t1.col_varchar_20), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MAX(SUBQUERY2_t1.col_varchar_20)])
  4 - output([SUBQUERY2_t1.col_varchar_20]), filter(nil), 
      equal_conds([SUBQUERY2_t2.col_varchar_key = SUBQUERY2_t1.col_varchar]), other_conds(nil)
  5 - output([SUBQUERY2_t2.col_varchar_key]), filter(nil), 
      access([SUBQUERY2_t2.col_varchar_key]), partitions(p0)
  6 - output([SUBQUERY2_t1.col_varchar], [SUBQUERY2_t1.col_varchar_20]), filter(nil), 
      access([SUBQUERY2_t1.col_varchar], [SUBQUERY2_t1.col_varchar_20]), partitions(p0)
  7 - output([table2.pk]), filter(nil), 
      conds(nil), nl_params_(nil)
  8 - output([1]), filter(nil), 
      access(nil)
  9 - output([T_FUN_SUM(SUBQUERY1_t1.col_int)], [T_FUN_MAX(SUBQUERY1_t1.pk)]), filter([T_FUN_MAX(SUBQUERY1_t1.pk) = 5], [T_FUN_SUM(SUBQUERY1_t1.col_int) = ?]), 
      group(nil), agg_func([T_FUN_SUM(SUBQUERY1_t1.col_int)], [T_FUN_MAX(SUBQUERY1_t1.pk)])
  10 - output([SUBQUERY1_t1.col_int], [SUBQUERY1_t1.pk]), filter(nil), 
      conds(nil), nl_params_(nil)
  11 - output([1]), filter(nil), 
      access(nil)
  12 - output([T_FUN_MIN(CHILD_SUBQUERY3_t1.col_varchar)], [cast(T_FUN_COUNT(CHILD_SUBQUERY3_t1.col_varchar_key), DECIMAL(20, 0))]), filter([T_FUN_MIN(CHILD_SUBQUERY3_t1.col_varchar) = 'i'], [cast(T_FUN_COUNT(CHILD_SUBQUERY3_t1.col_varchar_key), DECIMAL(20, 0)) = ?]), 
      group(nil), agg_func([T_FUN_MIN(CHILD_SUBQUERY3_t1.col_varchar)], [T_FUN_COUNT(CHILD_SUBQUERY3_t1.col_varchar_key)])
  13 - output([CHILD_SUBQUERY3_t1.col_varchar], [CHILD_SUBQUERY3_t1.col_varchar_key]), filter(nil), 
      equal_conds([CHILD_SUBQUERY3_t2.col_varchar_10 = CHILD_SUBQUERY3_t1.col_varchar_key]), other_conds(nil)
  14 - output([CHILD_SUBQUERY3_t2.col_varchar_10]), filter([CHILD_SUBQUERY3_t2.col_varchar_10 <= CHILD_SUBQUERY3_t2.col_varchar]), 
      access([CHILD_SUBQUERY3_t2.col_varchar_10], [CHILD_SUBQUERY3_t2.col_varchar]), partitions(p0)
  15 - output([CHILD_SUBQUERY3_t1.col_varchar_key], [CHILD_SUBQUERY3_t1.col_varchar]), filter(nil), 
      access([CHILD_SUBQUERY3_t1.col_varchar_key], [CHILD_SUBQUERY3_t1.col_varchar]), partitions(p0)
  16 - output([SUBQUERY1_t1.col_int], [SUBQUERY1_t1.pk]), filter(nil), 
      conds(nil), nl_params_(nil)
  17 - output([SUBQUERY1_t1.col_int], [SUBQUERY1_t1.pk]), filter(nil), 
      access([SUBQUERY1_t1.col_int], [SUBQUERY1_t1.pk]), partitions(p0)
  18 - output([1]), filter(nil)
  19 - output([1]), filter(nil), 
      access(nil)
  20 - output([UNION([1])]), filter(nil)
  21 - output([1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(?, ?) = ANY(subquery(1))]), init_plan_idxs_(nil)
  22 - output([1]), filter(nil), 
      equal_conds([SUBQUERY1_t3.col_varchar = SUBQUERY1_t2.col_varchar_key]), other_conds([SUBQUERY1_t3.col_int_key = SUBQUERY1_t2.col_int_key OR ?])
  23 - output([SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar_key]), filter(nil), 
      access([SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar_key]), partitions(p0)
  24 - output([SUBQUERY1_t3.col_int_key], [SUBQUERY1_t3.col_varchar]), filter(nil), 
      access([SUBQUERY1_t3.col_int_key], [SUBQUERY1_t3.col_varchar]), partitions(p0)
  25 - output([T_FUN_SUM(cast(CHILD_SUBQUERY1_t1.col_varchar_key, DOUBLE(-1, -1)))], [T_FUN_SUM(cast(CHILD_SUBQUERY1_t1.col_varchar, DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(cast(CHILD_SUBQUERY1_t1.col_varchar_key, DOUBLE(-1, -1)))], [T_FUN_SUM(cast(CHILD_SUBQUERY1_t1.col_varchar, DOUBLE(-1, -1)))])
  26 - output([cast(CHILD_SUBQUERY1_t1.col_varchar_key, DOUBLE(-1, -1))], [cast(CHILD_SUBQUERY1_t1.col_varchar, DOUBLE(-1, -1))]), filter(nil), 
      equal_conds([CHILD_SUBQUERY1_t2.col_varchar_20 = CHILD_SUBQUERY1_t1.col_varchar_key]), other_conds(nil)
  27 - output([CHILD_SUBQUERY1_t1.col_varchar_key], [CHILD_SUBQUERY1_t1.col_varchar]), filter(nil), 
      access([CHILD_SUBQUERY1_t1.col_varchar_key], [CHILD_SUBQUERY1_t1.col_varchar]), partitions(p0)
  28 - output([CHILD_SUBQUERY1_t2.col_varchar_20]), filter(nil), 
      access([CHILD_SUBQUERY1_t2.col_varchar_20]), partitions(p0)
  29 - output([1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(?, ?) = ANY(subquery(1))]), init_plan_idxs_(nil)
  30 - output([1]), filter(nil), 
      conds([SUBQUERY1_t3.col_int_key = SUBQUERY1_t2.col_int_key OR ?], [lnnvl(cast(SUBQUERY1_t3.col_varchar = SUBQUERY1_t2.col_varchar_key, TINYINT(-1, 0)))]), nl_params_(nil)
  31 - output([SUBQUERY1_t3.col_int_key], [SUBQUERY1_t3.col_varchar]), filter(nil), 
      conds([(T_OP_OR, cast(SUBQUERY1_t3.col_varchar_20_key, DECIMAL(-1, -1)) = VIEW21.5, (T_OP_IS, cast(SUBQUERY1_t3.col_varchar_20_key, DECIMAL(-1, -1)), NULL, 0), (T_OP_IS, VIEW21.5, NULL, 0))]), nl_params_(nil)
  32 - output([SUBQUERY1_t3.col_int_key], [SUBQUERY1_t3.col_varchar], [SUBQUERY1_t3.col_varchar_20_key]), filter(nil), 
      access([SUBQUERY1_t3.col_int_key], [SUBQUERY1_t3.col_varchar], [SUBQUERY1_t3.col_varchar_20_key]), partitions(p0)
  33 - output([VIEW21.5]), filter(nil)
  34 - output([VIEW21.5]), filter(nil),
      access([VIEW21.5])
  35 - output([cast(UNION([1]), DECIMAL(1, 0))]), filter(nil)
  36 - output([5]), filter(nil)
      values({5})
  37 - output([8]), filter(nil)
      values({8})
  38 - output([SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar_key]), filter(nil)
  39 - output([SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar_key]), filter(nil), 
      access([SUBQUERY1_t2.col_int_key], [SUBQUERY1_t2.col_varchar_key]), partitions(p0)
  40 - output([T_FUN_SUM(cast(CHILD_SUBQUERY1_t1.col_varchar_key, DOUBLE(-1, -1)))], [T_FUN_SUM(cast(CHILD_SUBQUERY1_t1.col_varchar, DOUBLE(-1, -1)))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(cast(CHILD_SUBQUERY1_t1.col_varchar_key, DOUBLE(-1, -1)))], [T_FUN_SUM(cast(CHILD_SUBQUERY1_t1.col_varchar, DOUBLE(-1, -1)))])
  41 - output([cast(CHILD_SUBQUERY1_t1.col_varchar_key, DOUBLE(-1, -1))], [cast(CHILD_SUBQUERY1_t1.col_varchar, DOUBLE(-1, -1))]), filter(nil), 
      equal_conds([CHILD_SUBQUERY1_t2.col_varchar_20 = CHILD_SUBQUERY1_t1.col_varchar_key]), other_conds(nil)
  42 - output([CHILD_SUBQUERY1_t1.col_varchar_key], [CHILD_SUBQUERY1_t1.col_varchar]), filter(nil), 
      access([CHILD_SUBQUERY1_t1.col_varchar_key], [CHILD_SUBQUERY1_t1.col_varchar]), partitions(p0)
  43 - output([CHILD_SUBQUERY1_t2.col_varchar_20]), filter(nil), 
      access([CHILD_SUBQUERY1_t2.col_varchar_20]), partitions(p0)
  44 - output([table2.pk]), filter([(T_OP_NOT_BTW, cast(table1.col_int_key, DECIMAL(11, 0)), ?, ?) OR table1.col_varchar_key <= 'm']), 
      equal_conds([table2.col_varchar = table1.col_varchar_key]), other_conds(nil)
  45 - output([table2.col_varchar], [table2.pk]), filter(nil), 
      access([table2.col_varchar], [table2.pk]), partitions(p0)
  46 - output([table1.col_varchar_key], [table1.col_int_key]), filter(nil), 
      access([table1.col_varchar_key], [table1.col_int_key]), partitions(p0)

Warnings:
Warning	1292	Truncated incorrect DOUBLE value: 'x'
Warning	1292	Truncated incorrect DOUBLE value: 'j'
SELECT Min(table2 . `pk`) AS field1 
FROM   ( cc AS table1 
RIGHT OUTER JOIN c AS table2 
ON ( table2 . `col_varchar` = table1 . `col_varchar_key` ) 
) 
WHERE  ( ( 9, 5 ) IN (SELECT Sum(SUBQUERY1_t1 . `col_int`) AS SUBQUERY1_field1, 
Max(SUBQUERY1_t1 . `pk`)      AS SUBQUERY1_field2 
FROM   ( cc AS SUBQUERY1_t1 
LEFT JOIN ( c AS SUBQUERY1_t2 
INNER JOIN c AS SUBQUERY1_t3 
ON ( SUBQUERY1_t3 . 
`col_int_key` = 
SUBQUERY1_t2 . 
`col_int_key` 
OR ( 'x', 'j' ) IN 
(SELECT Sum(CHILD_SUBQUERY1_t1 . 
`col_varchar_key`) AS 
CHILD_SUBQUERY1_field1, 
Sum(CHILD_SUBQUERY1_t1 . 
`col_varchar` 
) 
AS 
CHILD_SUBQUERY1_field2 
FROM   ( cc AS CHILD_SUBQUERY1_t1 
INNER JOIN cc AS 
CHILD_SUBQUERY1_t2 
ON ( 
CHILD_SUBQUERY1_t2 . 
`col_varchar_20` 
= 
CHILD_SUBQUERY1_t1 . 
`col_varchar_key` 
) ) 
) ) ) 
ON ( SUBQUERY1_t3 . `col_varchar` = 
SUBQUERY1_t2 . `col_varchar_key` 
OR 
SUBQUERY1_t3 . `col_varchar_20_key` NOT 
IN 
(SELECT 5 
UNION 
SELECT 8) 
) ) 
WHERE  ( 'i', 'm' ) IN (SELECT Min(CHILD_SUBQUERY3_t1 . 
`col_varchar`)       AS 
CHILD_SUBQUERY3_field1, 
Count(CHILD_SUBQUERY3_t1 . 
`col_varchar_key`) AS 
CHILD_SUBQUERY3_field2 
FROM   ( cc AS CHILD_SUBQUERY3_t1 
RIGHT JOIN b AS 
CHILD_SUBQUERY3_t2 
ON ( 
CHILD_SUBQUERY3_t2 . 
`col_varchar_10` = 
CHILD_SUBQUERY3_t1 . 
`col_varchar_key` ) 
) 
WHERE 
CHILD_SUBQUERY3_t2 . `col_varchar_10` 
<= 
CHILD_SUBQUERY3_t2 . `col_varchar`)) ) 
AND ( table1 . `col_int_key` NOT BETWEEN 226 AND ( 226 + 183 ) 
OR table1 . `col_varchar_key` <= 'm' ) 
AND (SELECT Max(SUBQUERY2_t1 . `col_varchar_20`) AS SUBQUERY2_field1 
FROM   ( cc AS SUBQUERY2_t1 
INNER JOIN c AS SUBQUERY2_t2 
ON ( SUBQUERY2_t2 . `col_varchar_key` = 
SUBQUERY2_t1 . `col_varchar` ) )) IS NULL 
HAVING field1 > 't' 
ORDER  BY field1;
+--------+
| field1 |
+--------+
+--------+
Warnings:
Warning	1292	Truncated incorrect DOUBLE value: 'x'
Warning	1292	Truncated incorrect DOUBLE value: 'j'

## 简化case
EXPLAIN SELECT 1 FROM ( cc AS SUBQUERY1_t1 LEFT JOIN ( c AS SUBQUERY1_t2
INNER JOIN c AS SUBQUERY1_t3 
ON ( SUBQUERY1_t3.`col_int_key` = SUBQUERY1_t2.`col_int_key`
OR 1 IN (SELECT 1 union select 2))
) ON (SUBQUERY1_t3.`col_varchar_20_key` NOT IN (SELECT 5 UNION SELECT 8)));
Query Plan
========================================================================================
|ID|OPERATOR                        |NAME              |EST. ROWS      |COST           |
----------------------------------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN|                  |2.486761e+14   |1.759768e+14   |
|1 | TABLE SCAN                     |SUBQUERY1_t1(idx7)|100000         |25731          |
|2 | MATERIAL                       |                  |2486761188     |3799200062     |
|3 |  SUBPLAN SCAN                  |VIEW1             |2486761188     |3342248357     |
|4 |   SUBPLAN FILTER               |                  |2486761188     |2999020764     |
|5 |    NESTED-LOOP JOIN            |                  |2486761188     |2655793169     |
|6 |     NESTED-LOOP ANTI JOIN      |                  |49253          |146317         |
|7 |      TABLE SCAN                |SUBQUERY1_t3      |100000         |64066          |
|8 |      MATERIAL                  |                  |2              |2              |
|9 |       SUBPLAN SCAN             |VIEW2             |2              |2              |
|10|        MERGE UNION DISTINCT    |                  |2              |1              |
|11|         EXPRESSION             |                  |1              |1              |
|12|         EXPRESSION             |                  |1              |1              |
|13|     MATERIAL                   |                  |100000         |46313          |
|14|      TABLE SCAN                |SUBQUERY1_t2(idx1)|100000         |27937          |
|15|    MERGE UNION DISTINCT        |                  |2              |1              |
|16|     EXPRESSION                 |                  |1              |1              |
|17|     EXPRESSION                 |                  |1              |1              |
========================================================================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([1]), filter(nil), 
      access([SUBQUERY1_t1.pk]), partitions(p0)
  2 - output([1]), filter(nil)
  3 - output([1]), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([1 = ANY(subquery(1))]), init_plan_idxs_(nil)
  5 - output([1]), filter(nil), 
      conds([SUBQUERY1_t3.col_int_key = SUBQUERY1_t2.col_int_key OR ?]), nl_params_(nil)
  6 - output([SUBQUERY1_t3.col_int_key]), filter(nil), 
      conds([(T_OP_OR, cast(SUBQUERY1_t3.col_varchar_20_key, DECIMAL(-1, -1)) = VIEW2.5, (T_OP_IS, cast(SUBQUERY1_t3.col_varchar_20_key, DECIMAL(-1, -1)), NULL, 0), (T_OP_IS, VIEW2.5, NULL, 0))]), nl_params_(nil)
  7 - output([SUBQUERY1_t3.col_int_key], [SUBQUERY1_t3.col_varchar_20_key]), filter(nil), 
      access([SUBQUERY1_t3.col_int_key], [SUBQUERY1_t3.col_varchar_20_key]), partitions(p0)
  8 - output([VIEW2.5]), filter(nil)
  9 - output([VIEW2.5]), filter(nil), 
      access([VIEW2.5])
  10 - output([cast(UNION([1]), DECIMAL(1, 0))]), filter(nil)
  11 - output([5]), filter(nil)
      values({5})
  12 - output([8]), filter(nil)
      values({8})
  13 - output([SUBQUERY1_t2.col_int_key]), filter(nil)
  14 - output([SUBQUERY1_t2.col_int_key]), filter(nil), 
      access([SUBQUERY1_t2.col_int_key]), partitions(p0)
  15 - output([UNION([1])]), filter(nil)
  16 - output([1]), filter(nil)
      values({1})
  17 - output([2]), filter(nil)
      values({2})

SELECT 1 FROM ( cc AS SUBQUERY1_t1 LEFT JOIN ( c AS SUBQUERY1_t2
INNER JOIN c AS SUBQUERY1_t3 
ON ( SUBQUERY1_t3.`col_int_key` = SUBQUERY1_t2.`col_int_key`
OR 1 IN (SELECT 1 union select 2))
) ON (SUBQUERY1_t3.`col_varchar_20_key` NOT IN (SELECT 5 UNION SELECT 8)));
+---+
| 1 |
+---+
+---+

drop table t1,t2,t3,t4,t5,tp1,tp2,C,D,BB,CC,B;
set autocommit = 0;


*********************push down outer join on condition end**************

************************pullup select expr in query with offset begin**********
************************通过调整逻辑算子分配顺序实现,case不移除**********************

set autocommit = 1;

drop table if exists t1, t2;
create table t1 (c1 int, c2 int);
create table t2 (c1 int, c2 int);
EXPLAIN select c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 limit 1 offset 2;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |74  |
|1 | TABLE SCAN   |t1  |1        |37  |
|2 | TABLE SCAN   |t2  |1        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      limit(1), offset(2)
  2 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 limit 1 offset 2;
+------+------+--------------------------------------+
| c1   | c2   | (select c1 from t2 where c2 = t1.c1) |
+------+------+--------------------------------------+
|    3 |    3 |                                    3 |
+------+------+--------------------------------------+
EXPLAIN select /*+no_rewrite*/ c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 limit 1 offset 2;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |74  |
|1 | TABLE SCAN   |t1  |1        |37  |
|2 | TABLE SCAN   |t2  |1        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      limit(1), offset(2)
  2 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select /*+no_rewrite*/ c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 limit 1 offset 2;
+------+------+--------------------------------------+
| c1   | c2   | (select c1 from t2 where c2 = t1.c1) |
+------+------+--------------------------------------+
|    3 |    3 |                                    3 |
+------+------+--------------------------------------+
EXPLAIN select c1, c2, c1 + c2, c2 + (select c1 from t2 where c2 = t1.c1) from t1 limit 1 offset 2;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |74  |
|1 | TABLE SCAN   |t1  |1        |37  |
|2 | TABLE SCAN   |t2  |1        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c1 + t1.c2], [t1.c2 + subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      limit(1), offset(2)
  2 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select c1, c2, c1 + c2, c2 + (select c1 from t2 where c2 = t1.c1) from t1 limit 1 offset 2;
+------+------+---------+-------------------------------------------+
| c1   | c2   | c1 + c2 | c2 + (select c1 from t2 where c2 = t1.c1) |
+------+------+---------+-------------------------------------------+
|    3 |    3 |       6 |                                         6 |
+------+------+---------+-------------------------------------------+
EXPLAIN select /*+no_rewrite*/ c1, c2, c1 + c2, c2 + (select c1 from t2 where c2 = t1.c1) from t1 limit 1 offset 2;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |74  |
|1 | TABLE SCAN   |t1  |1        |37  |
|2 | TABLE SCAN   |t2  |1        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c1 + t1.c2], [t1.c2 + subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      limit(1), offset(2)
  2 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select /*+no_rewrite*/ c1, c2, c1 + c2, c2 + (select c1 from t2 where c2 = t1.c1) from t1 limit 1 offset 2;
+------+------+---------+-------------------------------------------+
| c1   | c2   | c1 + c2 | c2 + (select c1 from t2 where c2 = t1.c1) |
+------+------+---------+-------------------------------------------+
|    3 |    3 |       6 |                                         6 |
+------+------+---------+-------------------------------------------+

EXPLAIN select c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 order by 3 limit 10 offset 2;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |LIMIT           |    |3        |227 |
|1 | TOP-N SORT     |    |5        |226 |
|2 |  SUBPLAN FILTER|    |5        |222 |
|3 |   TABLE SCAN   |t1  |5        |37  |
|4 |   TABLE SCAN   |t2  |1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), limit(10), offset(2)
  1 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), sort_keys([subquery(1), ASC]), topn(10 + 2)
  2 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 order by 3 limit 10 offset 2;
+------+------+--------------------------------------+
| c1   | c2   | (select c1 from t2 where c2 = t1.c1) |
+------+------+--------------------------------------+
|    1 |    1 |                                    1 |
|    2 |    2 |                                    2 |
|    3 |    3 |                                    3 |
+------+------+--------------------------------------+
EXPLAIN select /*+no_rewrite*/ c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 order by 3 limit 10 offset 2;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |LIMIT           |    |3        |227 |
|1 | TOP-N SORT     |    |5        |226 |
|2 |  SUBPLAN FILTER|    |5        |222 |
|3 |   TABLE SCAN   |t1  |5        |37  |
|4 |   TABLE SCAN   |t2  |1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), limit(10), offset(2)
  1 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), sort_keys([subquery(1), ASC]), topn(10 + 2)
  2 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select /*+no_rewrite*/ c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 order by 3 limit 10 offset 2;
+------+------+--------------------------------------+
| c1   | c2   | (select c1 from t2 where c2 = t1.c1) |
+------+------+--------------------------------------+
|    1 |    1 |                                    1 |
|    2 |    2 |                                    2 |
|    3 |    3 |                                    3 |
+------+------+--------------------------------------+
EXPLAIN select c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 group by c1, c2 limit 10 offset 2;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |3        |154 |
|1 | LIMIT         |    |3        |43  |
|2 |  HASH GROUP BY|    |5        |43  |
|3 |   TABLE SCAN  |t1  |5        |37  |
|4 | TABLE SCAN    |t2  |1        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), limit(10), offset(2)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 group by c1, c2 limit 10 offset 2;
+------+------+--------------------------------------+
| c1   | c2   | (select c1 from t2 where c2 = t1.c1) |
+------+------+--------------------------------------+
|    3 |    3 |                                    3 |
|    4 |    4 |                                 NULL |
|    5 |    5 |                                 NULL |
+------+------+--------------------------------------+
EXPLAIN select /*+no_rewrite*/ c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 group by c1, c2 limit 10 offset 2;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |3        |154 |
|1 | LIMIT         |    |3        |43  |
|2 |  HASH GROUP BY|    |5        |43  |
|3 |   TABLE SCAN  |t1  |5        |37  |
|4 | TABLE SCAN    |t2  |1        |37  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), limit(10), offset(2)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      group([t1.c1], [t1.c2]), agg_func(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select /*+no_rewrite*/ c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 group by c1, c2 limit 10 offset 2;
+------+------+--------------------------------------+
| c1   | c2   | (select c1 from t2 where c2 = t1.c1) |
+------+------+--------------------------------------+
|    3 |    3 |                                    3 |
|    4 |    4 |                                 NULL |
|    5 |    5 |                                 NULL |
+------+------+--------------------------------------+
EXPLAIN select c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 group by c1, c2 with rollup limit 10 offset 2;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |3        |155 |
|1 | LIMIT          |    |3        |44  |
|2 |  MERGE GROUP BY|    |5        |43  |
|3 |   SORT         |    |5        |42  |
|4 |    TABLE SCAN  |t1  |5        |37  |
|5 | TABLE SCAN     |t2  |1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), limit(10), offset(2)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      group(nil), rollup([t1.c1], [t1.c2]), agg_func(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 group by c1, c2 with rollup limit 10 offset 2;
+------+------+--------------------------------------+
| c1   | c2   | (select c1 from t2 where c2 = t1.c1) |
+------+------+--------------------------------------+
|    2 |    2 |                                    2 |
|    2 | NULL |                                    2 |
|    3 |    3 |                                    3 |
|    3 | NULL |                                    3 |
|    4 |    4 |                                 NULL |
|    4 | NULL |                                 NULL |
|    5 |    5 |                                 NULL |
|    5 | NULL |                                 NULL |
| NULL | NULL |                                 NULL |
+------+------+--------------------------------------+
EXPLAIN select /*+no_rewrite*/ c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 group by c1, c2 with rollup limit 10 offset 2;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |3        |155 |
|1 | LIMIT          |    |3        |44  |
|2 |  MERGE GROUP BY|    |5        |43  |
|3 |   SORT         |    |5        |42  |
|4 |    TABLE SCAN  |t1  |5        |37  |
|5 | TABLE SCAN     |t2  |1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [subquery(1)]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), limit(10), offset(2)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      group(nil), rollup([t1.c1], [t1.c2]), agg_func(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [t1.c2, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1]), filter([t2.c2 = ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

select /*+no_rewrite*/ c1, c2, (select c1 from t2 where c2 = t1.c1) from t1 group by c1, c2 with rollup limit 10 offset 2;
+------+------+--------------------------------------+
| c1   | c2   | (select c1 from t2 where c2 = t1.c1) |
+------+------+--------------------------------------+
|    2 |    2 |                                    2 |
|    2 | NULL |                                    2 |
|    3 |    3 |                                    3 |
|    3 | NULL |                                    3 |
|    4 |    4 |                                 NULL |
|    4 | NULL |                                 NULL |
|    5 |    5 |                                 NULL |
|    5 | NULL |                                 NULL |
| NULL | NULL |                                 NULL |
+------+------+--------------------------------------+

##select /*+no_rewrite*/ c1, (select max(c2) from t2) a from t1 order by (select c1 from t2 where c2 = a) + 1;
##select /*+no_rewrite*/ c1, (select max(c2) from t2) a from t1 group  by (select c1 from t2 where c2 = a) + 1;
##select /*+no_rewrite*/ c1, (select max(c2) from t2) a from t1 order by (select c1 from t2 where c2 in (select c1 from t1 where c2 = a)) + 1;
##select /*+no_rewrite*/ c1, (select c1 from t2 where c2 = max(t1.c1) over () limit 1) a from t1 group  by (select c1 from t2 where c2 = a);
##select /*+no_rewrite*/ c1, (select c2 from t2 zt2 where c1 = zt1.c1) a from t1 zt1 order by (select /*+no_rewrite*/ c1 from t2 zt3 where c2 = a);
##select /*+no_rewrite*/ c1, (select c2 from t2 zt2 where c1 = zt1.c1) a from t1 zt1 order by (select /*+no_rewrite*/ c1 from t2 zt3 where c2 = a) desc;
##select /*+no_rewrite*/ zt1.c1, (select zt2.c2 from t2 zt2 where zt2.c1 = zt1.c1) a from t1 zt1 order by (select /*+no_rewrite*/ zt3.c1 from t2 zt3 where zt3.c2 = a);
##select /*+no_rewrite*/ (select c1 from t2 where t1.c1 = c2 limit 1) a from t1 group by a order by a;
drop table t1;
drop table t2;

set autocommit = 0;


************************pullup select expr in query with offset end**********
DROP TABLE IF EXISTS B, C, BB, CC;
CREATE TABLE B (
col_varchar_10_key varchar(10),
pk int,
col_varchar_20_key varchar(20),
col_varchar varchar (1),
col_varchar_10 varchar(10),
col_int int,
col_varchar_20 varchar(20),
col_varchar_key varchar (1),
col_int_key int,
/*Indices*/
key idx5(pk, col_varchar_10_key ),
primary key (pk) ,
key idx7(pk, col_varchar_20_key ),
key idx3(pk, col_varchar_key ),
key idx1(pk, col_int_key )) ;

CREATE TABLE C (
col_varchar_10_key varchar(10),
col_varchar_10 varchar(10),
col_int_key int,
col_varchar_20_key varchar(20),
col_varchar_key varchar (1),
pk int,
col_int int,
col_varchar_20 varchar(20),
col_varchar varchar (1),
/*Indices*/
key idx5(pk, col_varchar_10_key ),
key idx1(pk, col_int_key ),
key idx7(pk, col_varchar_20_key ),
key idx3(pk, col_varchar_key ),
primary key (pk) ) ;

CREATE TABLE BB (
col_varchar_20_key varchar(20),
pk int,
col_varchar_10 varchar(10),
col_varchar_key varchar (1),
col_varchar_10_key varchar(10),
col_int_key int,
col_varchar varchar (1),
col_int int,
col_varchar_20 varchar(20),
/*Indices*/
key idx7(pk, col_varchar_20_key ),
primary key (pk) ,
key idx3(pk, col_varchar_key ),
key idx5(pk, col_varchar_10_key ),
key idx1(pk, col_int_key )) ;

CREATE TABLE CC (
col_varchar_10 varchar(10),
col_varchar varchar (1),
col_int int,
col_varchar_key varchar (1),
pk int,
col_varchar_10_key varchar(10),
col_varchar_20 varchar(20),
col_int_key int,
col_varchar_20_key varchar(20),
/*Indices*/
key idx3(pk, col_varchar_key ),
primary key (pk) ,
key idx5(pk, col_varchar_10_key ),
key idx1(pk, col_int_key ),
key idx7(pk, col_varchar_20_key )) ;
EXPLAIN SELECT table1 . col_int_key AS field1,
       table1 . col_varchar_20_key AS field2,
       MAX(table1 . `col_varchar`) AS field3,
       table2 . `col_int_key` AS field4,

  (SELECT DISTINCT SUM(SUBQUERY1_t1 . `pk`) AS SUBQUERY1_field1
   FROM C AS SUBQUERY1_t1) AS field5,
       CONCAT (table1 . `col_varchar_20`,
               table1 . `col_varchar_20_key`) AS field6,
              table1 . `col_varchar_20` AS field7,
              table2 . col_varchar_10_key AS field8,
              table1 . `col_int` AS field9,
              table1 . col_varchar_20_key AS field10,

  (SELECT MAX(SUBQUERY2_t2 . `pk`) AS SUBQUERY2_field1
   FROM (BB AS SUBQUERY2_t1
         LEFT OUTER JOIN C AS SUBQUERY2_t2 ON (SUBQUERY2_t2 . `col_varchar_key` = SUBQUERY2_t1 . `col_varchar`))) AS field11,
              MIN(table1 . `col_int`) AS field12,
              table1 . col_varchar_10_key AS field13
FROM (CC AS table1
      LEFT  JOIN ((B AS table2
                   INNER JOIN CC AS table3 ON (table3 . `col_varchar_key` = table2 . `col_varchar_10_key`))) ON (table3 . `pk` = table2 . `col_int_key`))
WHERE (table1 . `col_varchar_10` IN
         (SELECT SUBQUERY3_t1 . `col_varchar_20` AS SUBQUERY3_field1
          FROM CC AS SUBQUERY3_t1
          GROUP BY SUBQUERY3_field1))
  AND (table1 . `col_varchar_key` IN ('a')
       OR table1 . `col_varchar_key` <> 'g')
  AND table1 . `col_varchar` IS NULL
GROUP BY field1,
         field2,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field13
HAVING field6 >= 'bx'
ORDER BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field12,
         field13
LIMIT 100;
Query Plan
==================================================================================
|ID|OPERATOR                              |NAME              |EST. ROWS|COST     |
----------------------------------------------------------------------------------
|0 |LIMIT                                 |                  |100      |351842700|
|1 | TOP-N SORT                           |                  |100      |351842686|
|2 |  HASH GROUP BY                       |                  |31388980 |285804647|
|3 |   NESTED-LOOP JOIN CARTESIAN         |                  |31388980 |233285952|
|4 |    SUBPLAN SCAN                      |VIEW3             |1        |114859457|
|5 |     SCALAR GROUP BY                  |                  |1        |114859457|
|6 |      HASH OUTER JOIN                 |                  |98010000 |96138331 |
|7 |       TABLE SCAN                     |SUBQUERY2_t1      |100000   |61860    |
|8 |       TABLE SCAN                     |SUBQUERY2_t2(idx3)|100000   |27937    |
|9 |    NESTED-LOOP JOIN CARTESIAN        |                  |31388980 |98105914 |
|10|     SUBPLAN SCAN                     |VIEW2             |1        |44833    |
|11|      SCALAR GROUP BY                 |                  |1        |44833    |
|12|       TABLE SCAN                     |SUBQUERY1_t1(idx5)|100000   |25731    |
|13|     HASH RIGHT SEMI JOIN             |                  |31388980 |77740499 |
|14|      TABLE SCAN                      |SUBQUERY3_t1      |100000   |61860    |
|15|      NESTED-LOOP OUTER JOIN CARTESIAN|                  |31706041 |23847064 |
|16|       TABLE SCAN                     |table1            |327      |179347   |
|17|       MATERIAL                       |                  |97030    |486167   |
|18|        HASH JOIN                     |                  |97030    |428221   |
|19|         TABLE SCAN                   |table3(idx3)      |100000   |27937    |
|20|         TABLE SCAN                   |table2            |100000   |64066    |
==================================================================================

Outputs & filters: 
-------------------------------------
  0 - output([table1.col_int_key], [table1.col_varchar_20_key], [T_FUN_MAX(table1.col_varchar)], [table2.col_int_key], [VIEW2.SUBQUERY1_field1], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [table1.col_varchar_20_key], [VIEW3.SUBQUERY2_field1], [T_FUN_MIN(table1.col_int)], [table1.col_varchar_10_key]), filter(nil), limit(100), offset(nil)
  1 - output([table1.col_int_key], [table1.col_varchar_20_key], [T_FUN_MAX(table1.col_varchar)], [table2.col_int_key], [VIEW2.SUBQUERY1_field1], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [VIEW3.SUBQUERY2_field1], [T_FUN_MIN(table1.col_int)], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter(nil), sort_keys([table1.col_int_key, ASC], [table1.col_varchar_20_key, ASC], [T_FUN_MAX(table1.col_varchar), ASC], [table2.col_int_key, ASC], [VIEW2.SUBQUERY1_field1, ASC], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key), ASC], [table1.col_varchar_20, ASC], [table2.col_varchar_10_key, ASC], [table1.col_int, ASC], [VIEW3.SUBQUERY2_field1, ASC], [T_FUN_MIN(table1.col_int), ASC], [table1.col_varchar_10_key, ASC]), topn(100)
  2 - output([table1.col_int_key], [table1.col_varchar_20_key], [T_FUN_MAX(table1.col_varchar)], [table2.col_int_key], [VIEW2.SUBQUERY1_field1], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [VIEW3.SUBQUERY2_field1], [T_FUN_MIN(table1.col_int)], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter(nil), 
      group([VIEW2.SUBQUERY1_field1], [VIEW3.SUBQUERY2_field1], [table1.col_int_key], [table1.col_varchar_20_key], [table2.col_int_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [table1.col_varchar_10_key]), agg_func([T_FUN_MAX(table1.col_varchar)], [T_FUN_MIN(table1.col_int)])
  3 - output([table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar], [table2.col_int_key], [VIEW2.SUBQUERY1_field1], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [VIEW3.SUBQUERY2_field1], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([VIEW3.SUBQUERY2_field1]), filter(nil), 
      access([VIEW3.SUBQUERY2_field1])
  5 - output([T_FUN_MAX(SUBQUERY2_t2.pk)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(SUBQUERY2_t2.pk)])
  6 - output([SUBQUERY2_t2.pk]), filter(nil), 
      equal_conds([SUBQUERY2_t2.col_varchar_key = SUBQUERY2_t1.col_varchar]), other_conds(nil)
  7 - output([SUBQUERY2_t1.col_varchar]), filter(nil), 
      access([SUBQUERY2_t1.col_varchar]), partitions(p0)
  8 - output([SUBQUERY2_t2.col_varchar_key], [SUBQUERY2_t2.pk]), filter(nil), 
      access([SUBQUERY2_t2.col_varchar_key], [SUBQUERY2_t2.pk]), partitions(p0)
  9 - output([table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar], [table2.col_int_key], [VIEW2.SUBQUERY1_field1], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter(nil), 
      conds(nil), nl_params_(nil)
  10 - output([VIEW2.SUBQUERY1_field1]), filter(nil), 
      access([VIEW2.SUBQUERY1_field1])
  11 - output([T_FUN_SUM(SUBQUERY1_t1.pk)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(SUBQUERY1_t1.pk)])
  12 - output([SUBQUERY1_t1.pk]), filter(nil), 
      access([SUBQUERY1_t1.pk]), partitions(p0)
  13 - output([table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar], [table2.col_int_key], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter(nil), 
      equal_conds([table1.col_varchar_10 = SUBQUERY3_t1.col_varchar_20]), other_conds(nil)
  14 - output([SUBQUERY3_t1.col_varchar_20]), filter(nil), 
      access([SUBQUERY3_t1.col_varchar_20]), partitions(p0)
  15 - output([table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar], [table2.col_int_key], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)], [table1.col_varchar_10]), filter(nil), 
      conds(nil), nl_params_(nil)
  16 - output([table1.col_varchar_10], [table1.col_varchar], [table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar_20], [table1.col_int], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter([(T_OP_IS, table1.col_varchar, NULL, 0)], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key) >= 'bx'], [table1.col_varchar_key = 'a' OR table1.col_varchar_key != 'g']), 
      access([table1.col_varchar_10], [table1.col_varchar_key], [table1.col_varchar], [table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar_20], [table1.col_int], [table1.col_varchar_10_key]), partitions(p0)
  17 - output([table2.col_int_key], [table2.col_varchar_10_key]), filter(nil)
  18 - output([table2.col_int_key], [table2.col_varchar_10_key]), filter(nil), 
      equal_conds([table3.pk = table2.col_int_key], [table3.col_varchar_key = table2.col_varchar_10_key]), other_conds(nil)
  19 - output([table3.col_varchar_key], [table3.pk]), filter(nil), 
      access([table3.col_varchar_key], [table3.pk]), partitions(p0)
  20 - output([table2.col_varchar_10_key], [table2.col_int_key]), filter(nil), 
      access([table2.col_varchar_10_key], [table2.col_int_key]), partitions(p0)

SELECT table1 . col_int_key AS field1,
       table1 . col_varchar_20_key AS field2,
       MAX(table1 . `col_varchar`) AS field3,
       table2 . `col_int_key` AS field4,

  (SELECT DISTINCT SUM(SUBQUERY1_t1 . `pk`) AS SUBQUERY1_field1
   FROM C AS SUBQUERY1_t1) AS field5,
       CONCAT (table1 . `col_varchar_20`,
               table1 . `col_varchar_20_key`) AS field6,
              table1 . `col_varchar_20` AS field7,
              table2 . col_varchar_10_key AS field8,
              table1 . `col_int` AS field9,
              table1 . col_varchar_20_key AS field10,

  (SELECT MAX(SUBQUERY2_t2 . `pk`) AS SUBQUERY2_field1
   FROM (BB AS SUBQUERY2_t1
         LEFT OUTER JOIN C AS SUBQUERY2_t2 ON (SUBQUERY2_t2 . `col_varchar_key` = SUBQUERY2_t1 . `col_varchar`))) AS field11,
              MIN(table1 . `col_int`) AS field12,
              table1 . col_varchar_10_key AS field13
FROM (CC AS table1
      LEFT  JOIN ((B AS table2
                   INNER JOIN CC AS table3 ON (table3 . `col_varchar_key` = table2 . `col_varchar_10_key`))) ON (table3 . `pk` = table2 . `col_int_key`))
WHERE (table1 . `col_varchar_10` IN
         (SELECT SUBQUERY3_t1 . `col_varchar_20` AS SUBQUERY3_field1
          FROM CC AS SUBQUERY3_t1
          GROUP BY SUBQUERY3_field1))
  AND (table1 . `col_varchar_key` IN ('a')
       OR table1 . `col_varchar_key` <> 'g')
  AND table1 . `col_varchar` IS NULL
GROUP BY field1,
         field2,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field13
HAVING field6 >= 'bx'
ORDER BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field12,
         field13
LIMIT 100;
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+
| field1 | field2 | field3 | field4 | field5 | field6 | field7 | field8 | field9 | field10 | field11 | field12 | field13 |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+
|      5 | w      | NULL   |   NULL |      3 | xw     | x      | NULL   |      2 | w       |       2 |       2 | n       |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+

EXPLAIN SELECT /*+no_rewrite*/table1 . col_int_key AS field1,
       table1 . col_varchar_20_key AS field2,
       MAX(table1 . `col_varchar`) AS field3,
       table2 . `col_int_key` AS field4,

  (SELECT DISTINCT SUM(SUBQUERY1_t1 . `pk`) AS SUBQUERY1_field1
   FROM C AS SUBQUERY1_t1) AS field5,
       CONCAT (table1 . `col_varchar_20`,
               table1 . `col_varchar_20_key`) AS field6,
              table1 . `col_varchar_20` AS field7,
              table2 . col_varchar_10_key AS field8,
              table1 . `col_int` AS field9,
              table1 . col_varchar_20_key AS field10,

  (SELECT MAX(SUBQUERY2_t2 . `pk`) AS SUBQUERY2_field1
   FROM (BB AS SUBQUERY2_t1
         LEFT OUTER JOIN C AS SUBQUERY2_t2 ON (SUBQUERY2_t2 . `col_varchar_key` = SUBQUERY2_t1 . `col_varchar`))) AS field11,
              MIN(table1 . `col_int`) AS field12,
              table1 . col_varchar_10_key AS field13
FROM (CC AS table1
      LEFT  JOIN ((B AS table2
                   INNER JOIN CC AS table3 ON (table3 . `col_varchar_key` = table2 . `col_varchar_10_key`))) ON (table3 . `pk` = table2 . `col_int_key`))
WHERE (table1 . `col_varchar_10` IN
         (SELECT SUBQUERY3_t1 . `col_varchar_20` AS SUBQUERY3_field1
          FROM CC AS SUBQUERY3_t1
          GROUP BY SUBQUERY3_field1))
  AND (table1 . `col_varchar_key` IN ('a')
       OR table1 . `col_varchar_key` <> 'g')
  AND table1 . `col_varchar` IS NULL
GROUP BY field1,
         field2,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field13
HAVING field6 >= 'bx'
ORDER BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field12,
         field13
LIMIT 100;
Query Plan
==================================================================================
|ID|OPERATOR                             |NAME              |EST. ROWS|COST      |
----------------------------------------------------------------------------------
|0 |LIMIT                                |                  |100      |2346780066|
|1 | TOP-N SORT                          |                  |100      |2346780052|
|2 |  HASH GROUP BY                      |                  |15853021 |2316704643|
|3 |   SUBPLAN FILTER                    |                  |47559061 |2239895690|
|4 |    SUBPLAN FILTER                   |                  |47559061 |2118427208|
|5 |     NESTED-LOOP OUTER JOIN CARTESIAN|                  |95118121 |70163328  |
|6 |      TABLE SCAN                     |table1            |981      |132510    |
|7 |      MATERIAL                       |                  |97030    |486167    |
|8 |       HASH JOIN                     |                  |97030    |428221    |
|9 |        TABLE SCAN                   |table3(idx3)      |100000   |27937     |
|10|        TABLE SCAN                   |table2            |100000   |64066     |
|11|     HASH GROUP BY                   |                  |101      |94757     |
|12|      TABLE SCAN                     |SUBQUERY3_t1      |100000   |61860     |
|13|    SCALAR GROUP BY                  |                  |1        |44833     |
|14|     TABLE SCAN                      |SUBQUERY1_t1(idx5)|100000   |25731     |
|15|    SCALAR GROUP BY                  |                  |1        |114859457 |
|16|     HASH OUTER JOIN                 |                  |98010000 |96138331  |
|17|      TABLE SCAN                     |SUBQUERY2_t1      |100000   |61860     |
|18|      TABLE SCAN                     |SUBQUERY2_t2(idx3)|100000   |27937     |
==================================================================================

Outputs & filters: 
-------------------------------------
  0 - output([table1.col_int_key], [table1.col_varchar_20_key], [T_FUN_MAX(table1.col_varchar)], [table2.col_int_key], [?], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [table1.col_varchar_20_key], [?], [T_FUN_MIN(table1.col_int)], [table1.col_varchar_10_key]), filter(nil), limit(100), offset(nil)
  1 - output([table1.col_int_key], [table1.col_varchar_20_key], [T_FUN_MAX(table1.col_varchar)], [table2.col_int_key], [?], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [?], [T_FUN_MIN(table1.col_int)], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter(nil), sort_keys([table1.col_int_key, ASC], [table1.col_varchar_20_key, ASC], [T_FUN_MAX(table1.col_varchar), ASC], [table2.col_int_key, ASC], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key), ASC], [table1.col_varchar_20, ASC], [table2.col_varchar_10_key, ASC], [table1.col_int, ASC], [T_FUN_MIN(table1.col_int), ASC], [table1.col_varchar_10_key, ASC]), topn(100)
  2 - output([table1.col_int_key], [table1.col_varchar_20_key], [T_FUN_MAX(table1.col_varchar)], [table2.col_int_key], [?], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [?], [T_FUN_MIN(table1.col_int)], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter([CONCAT(table1.col_varchar_20, table1.col_varchar_20_key) >= 'bx']), 
      group([table1.col_int_key], [table1.col_varchar_20_key], [table2.col_int_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [table1.col_varchar_20_key], [table1.col_varchar_10_key]), agg_func([T_FUN_MAX(table1.col_varchar)], [T_FUN_MIN(table1.col_int)])
  3 - output([table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar], [table2.col_int_key], [?], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [?], [table1.col_varchar_10_key], [CONCAT(table1.col_varchar_20, table1.col_varchar_20_key)]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)], [subquery(2)]), init_plan_idxs_(nil)
  4 - output([table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar], [table2.col_int_key], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [table1.col_varchar_10_key]), filter([table1.col_varchar_10 = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  5 - output([table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar], [table2.col_int_key], [table1.col_varchar_20], [table2.col_varchar_10_key], [table1.col_int], [table1.col_varchar_10_key], [table1.col_varchar_10]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([table1.col_varchar_10], [table1.col_varchar], [table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar_20], [table1.col_int], [table1.col_varchar_10_key]), filter([(T_OP_IS, table1.col_varchar, NULL, 0)], [table1.col_varchar_key = 'a' OR table1.col_varchar_key != 'g']), 
      access([table1.col_varchar_10], [table1.col_varchar_key], [table1.col_varchar], [table1.col_int_key], [table1.col_varchar_20_key], [table1.col_varchar_20], [table1.col_int], [table1.col_varchar_10_key]), partitions(p0)
  7 - output([table2.col_int_key], [table2.col_varchar_10_key]), filter(nil)
  8 - output([table2.col_int_key], [table2.col_varchar_10_key]), filter(nil), 
      equal_conds([table3.pk = table2.col_int_key], [table3.col_varchar_key = table2.col_varchar_10_key]), other_conds(nil)
  9 - output([table3.col_varchar_key], [table3.pk]), filter(nil), 
      access([table3.col_varchar_key], [table3.pk]), partitions(p0)
  10 - output([table2.col_varchar_10_key], [table2.col_int_key]), filter(nil), 
      access([table2.col_varchar_10_key], [table2.col_int_key]), partitions(p0)
  11 - output([SUBQUERY3_t1.col_varchar_20]), filter(nil), 
      group([SUBQUERY3_t1.col_varchar_20]), agg_func(nil)
  12 - output([SUBQUERY3_t1.col_varchar_20]), filter(nil), 
      access([SUBQUERY3_t1.col_varchar_20]), partitions(p0)
  13 - output([T_FUN_SUM(SUBQUERY1_t1.pk)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(SUBQUERY1_t1.pk)])
  14 - output([SUBQUERY1_t1.pk]), filter(nil), 
      access([SUBQUERY1_t1.pk]), partitions(p0)
  15 - output([T_FUN_MAX(SUBQUERY2_t2.pk)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(SUBQUERY2_t2.pk)])
  16 - output([SUBQUERY2_t2.pk]), filter(nil), 
      equal_conds([SUBQUERY2_t2.col_varchar_key = SUBQUERY2_t1.col_varchar]), other_conds(nil)
  17 - output([SUBQUERY2_t1.col_varchar]), filter(nil), 
      access([SUBQUERY2_t1.col_varchar]), partitions(p0)
  18 - output([SUBQUERY2_t2.col_varchar_key], [SUBQUERY2_t2.pk]), filter(nil), 
      access([SUBQUERY2_t2.col_varchar_key], [SUBQUERY2_t2.pk]), partitions(p0)

SELECT /*+no_rewrite*/table1 . col_int_key AS field1,
       table1 . col_varchar_20_key AS field2,
       MAX(table1 . `col_varchar`) AS field3,
       table2 . `col_int_key` AS field4,

  (SELECT DISTINCT SUM(SUBQUERY1_t1 . `pk`) AS SUBQUERY1_field1
   FROM C AS SUBQUERY1_t1) AS field5,
       CONCAT (table1 . `col_varchar_20`,
               table1 . `col_varchar_20_key`) AS field6,
              table1 . `col_varchar_20` AS field7,
              table2 . col_varchar_10_key AS field8,
              table1 . `col_int` AS field9,
              table1 . col_varchar_20_key AS field10,

  (SELECT MAX(SUBQUERY2_t2 . `pk`) AS SUBQUERY2_field1
   FROM (BB AS SUBQUERY2_t1
         LEFT OUTER JOIN C AS SUBQUERY2_t2 ON (SUBQUERY2_t2 . `col_varchar_key` = SUBQUERY2_t1 . `col_varchar`))) AS field11,
              MIN(table1 . `col_int`) AS field12,
              table1 . col_varchar_10_key AS field13
FROM (CC AS table1
      LEFT  JOIN ((B AS table2
                   INNER JOIN CC AS table3 ON (table3 . `col_varchar_key` = table2 . `col_varchar_10_key`))) ON (table3 . `pk` = table2 . `col_int_key`))
WHERE (table1 . `col_varchar_10` IN
         (SELECT SUBQUERY3_t1 . `col_varchar_20` AS SUBQUERY3_field1
          FROM CC AS SUBQUERY3_t1
          GROUP BY SUBQUERY3_field1))
  AND (table1 . `col_varchar_key` IN ('a')
       OR table1 . `col_varchar_key` <> 'g')
  AND table1 . `col_varchar` IS NULL
GROUP BY field1,
         field2,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field13
HAVING field6 >= 'bx'
ORDER BY field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8,
         field9,
         field10,
         field11,
         field12,
         field13
LIMIT 100;
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+
| field1 | field2 | field3 | field4 | field5 | field6 | field7 | field8 | field9 | field10 | field11 | field12 | field13 |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+
|      5 | w      | NULL   |   NULL |      3 | xw     | x      | NULL   |      2 | w       |       2 |       2 | n       |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+---------+---------+---------+---------+

drop table if exists t1, t2 ,t3;
create table t1(a int, b int, c int);
create table t2(a int, b int, c int);
create table t3(a int, b int, c int);
create table t_temp(a int, b int, c int);
create table t_temp_join(a int, b int, c int, d int, e int, f int);

set autocommit = 0;

##test basic view stmt ==> remove order by
EXPLAIN select a, b from (select a, b from t1 order by a) group by a, b;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |HASH GROUP BY|    |10001    |109862|
|1 | TABLE SCAN  |t1  |100000   |64066 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      group([t1.a], [t1.b]), agg_func(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

select a, b from (select a, b from t1 order by a) group by a, b;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
|    4 |    4 |
+------+------+
EXPLAIN select /*+no_rewrite*/a,b from (select * from t1 order by a) group by a, b;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |HASH GROUP BY|    |10001    |355778|
|1 | SUBPLAN SCAN|    |100000   |309982|
|2 |  SORT       |    |100000   |296180|
|3 |   TABLE SCAN|t1  |100000   |66272 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b]), filter(nil), 
      group([.a], [.b]), agg_func(nil)
  1 - output([.a], [.b]), filter(nil), 
      access([.a], [.b])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select /*+no_rewrite*/a,b from (select * from t1 order by a) group by a, b;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
|    4 |    4 |
+------+------+
EXPLAIN insert into t_temp select * from (select * from t1 order by a) group by a, b;
Query Plan
===========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST  |
-------------------------------------------
|0 |INSERT         |     |10001    |114828|
|1 | SUBPLAN SCAN  |VIEW1|10001    |113448|
|2 |  HASH GROUP BY|     |10001    |112068|
|3 |   TABLE SCAN  |t1   |100000   |66272 |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      group([t1.a], [t1.b]), agg_func(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

insert into t_temp select * from (select * from t1 order by a) group by a, b;
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
|    1 |    1 |    1 |
|    2 |    2 |    2 |
|    3 |    3 |    3 |
|    4 |    4 |    4 |
+------+------+------+
rollback;
EXPLAIN insert /*+NO_REWRITE*/into t_temp select * from (select * from t1 order by a) group by a, b;
Query Plan
===========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST  |
-------------------------------------------
|0 |INSERT         |     |10001    |114828|
|1 | SUBPLAN SCAN  |VIEW1|10001    |113448|
|2 |  HASH GROUP BY|     |10001    |112068|
|3 |   TABLE SCAN  |t1   |100000   |66272 |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      group([t1.a], [t1.b]), agg_func(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

insert /*+NO_REWRITE*/into t_temp select * from (select * from t1 order by a) group by a, b;
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN update t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a);
Query Plan
==================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST  |
--------------------------------------------------
|0 |UPDATE               |      |99000    |428234|
|1 | HASH RIGHT SEMI JOIN|      |99000    |329234|
|2 |  TABLE SCAN         |t1    |100000   |61860 |
|3 |  TABLE SCAN         |t_temp|100000   |66272 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]),
      update([t_temp.b=column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c], [column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))]), filter(nil), 
      equal_conds([t_temp.b = t1.a]), other_conds(nil)
  2 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  3 - output([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), filter(nil), 
      access([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), partitions(p0)

update t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN update /*+no_rewrite*/t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a);
Query Plan
================================================
|ID|OPERATOR       |NAME  |EST. ROWS|COST      |
------------------------------------------------
|0 |UPDATE         |      |50000    |1983232714|
|1 | SUBPLAN FILTER|      |50000    |1983182714|
|2 |  TABLE SCAN   |t_temp|100000   |66272     |
|3 |  SORT         |      |100000   |252929    |
|4 |   TABLE SCAN  |t1    |100000   |61860     |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]),
      update([t_temp.b=column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c], [column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))]), filter([t_temp.b = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), filter(nil), 
      access([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), partitions(p0)
  3 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

update /*+no_rewrite*/t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN delete from t_temp where not exists (select null from t1 where t1.a = t_temp.a order by a);
Query Plan
==================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST  |
--------------------------------------------------
|0 |DELETE               |      |1000     |330234|
|1 | HASH RIGHT ANTI JOIN|      |1000     |329234|
|2 |  TABLE SCAN         |t1    |100000   |61860 |
|3 |  TABLE SCAN         |t_temp|100000   |66272 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      equal_conds([t1.a = t_temp.a]), other_conds(nil)
  2 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  3 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

delete from t_temp where not exists (select null from t1 where t1.a = t_temp.a order by a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN delete /*+no_rewrite*/from t_temp where not exists (select null from t1 where t1.a = t_temp.a order by t_temp.a);
Query Plan
================================================
|ID|OPERATOR       |NAME  |EST. ROWS|COST      |
------------------------------------------------
|0 |DELETE         |      |50000    |7036988616|
|1 | SUBPLAN FILTER|      |50000    |7036938616|
|2 |  TABLE SCAN   |t_temp|100000   |66272     |
|3 |  TABLE SCAN   |t1    |990      |70232     |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_([t_temp.a]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)
  3 - output([NULL]), filter([t1.a = ?]), 
      access([t1.a]), partitions(p0)

delete /*+no_rewrite*/from t_temp where not exists (select null from t1 where t1.a = t_temp.a order by t_temp.a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;

EXPLAIN select a, b from (select a, b from t1 order by a) group by a, b limit 1;
Query Plan
=========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST  |
-----------------------------------------
|0 |LIMIT         |    |1        |102705|
|1 | HASH GROUP BY|    |1        |102705|
|2 |  TABLE SCAN  |t1  |100000   |64066 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), limit(1), offset(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      group([t1.a], [t1.b]), agg_func(nil)
  2 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

select a, b from (select a, b from t1 order by a) group by a, b limit 1;
+------+------+
| a    | b    |
+------+------+
+------+------+
EXPLAIN select /*+no_rewrite*/ a, b from (select a, b from t1 order by a) group by a, b limit 1;
Query Plan
=========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST  |
-----------------------------------------
|0 |LIMIT         |    |1        |326996|
|1 | HASH GROUP BY|    |1        |326996|
|2 |  SUBPLAN SCAN|    |100000   |288357|
|3 |   SORT       |    |100000   |274554|
|4 |    TABLE SCAN|t1  |100000   |64066 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b]), filter(nil), limit(1), offset(nil)
  1 - output([.a], [.b]), filter(nil), 
      group([.a], [.b]), agg_func(nil)
  2 - output([.a], [.b]), filter(nil), 
      access([.a], [.b])
  3 - output([t1.a], [t1.b]), filter(nil), sort_keys([t1.a, ASC])
  4 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

select /*+no_rewrite*/ a, b from (select a, b from t1 order by a) group by a, b limit 1;
+------+------+
| a    | b    |
+------+------+
+------+------+

EXPLAIN select a, b from (select a, b from t1 order by a, (select a from t3)) group by a, b;
Query Plan
===========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST  |
-------------------------------------------
|0 |HASH GROUP BY   |    |10001    |199326|
|1 | SUBPLAN SCAN   |    |100000   |153530|
|2 |  SUBPLAN FILTER|    |100000   |139728|
|3 |   TABLE SCAN   |t1  |100000   |64066 |
|4 |   TABLE SCAN   |t3  |100000   |61860 |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b]), filter(nil), 
      group([.a], [.b]), agg_func(nil)
  1 - output([.a], [.b]), filter(nil), 
      access([.a], [.b])
  2 - output([t1.a], [t1.b]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  4 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

select a, b from (select a, b from t1 order by a, (select a from t3)) group by a, b;
+------+------+
| a    | b    |
+------+------+
+------+------+
EXPLAIN select /*+no_rewrite*/ a, b from (select a, b from t1 order by a, (select a from t3)) group by a, b;
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |HASH GROUP BY    |    |10001    |409814|
|1 | SUBPLAN SCAN    |    |100000   |364018|
|2 |  SORT           |    |100000   |350216|
|3 |   SUBPLAN FILTER|    |100000   |139728|
|4 |    TABLE SCAN   |t1  |100000   |64066 |
|5 |    TABLE SCAN   |t3  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b]), filter(nil), 
      group([.a], [.b]), agg_func(nil)
  1 - output([.a], [.b]), filter(nil), 
      access([.a], [.b])
  2 - output([t1.a], [t1.b]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  5 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

select /*+no_rewrite*/ a, b from (select a, b from t1 order by a, (select a from t3)) group by a, b;
+------+------+
| a    | b    |
+------+------+
+------+------+
EXPLAIN insert into t_temp select * from (select * from t1 order by a, (select a from t3)) group by a, b;
Query Plan
==============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST  |
----------------------------------------------
|0 |INSERT            |     |10001    |204292|
|1 | SUBPLAN SCAN     |VIEW1|10001    |202912|
|2 |  HASH GROUP BY   |     |10001    |201531|
|3 |   SUBPLAN SCAN   |     |100000   |155736|
|4 |    SUBPLAN FILTER|     |100000   |141933|
|5 |     TABLE SCAN   |t1   |100000   |66272 |
|6 |     TABLE SCAN   |t3   |100000   |61860 |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([.a], [.b], [.c]), filter(nil), 
      group([.a], [.b]), agg_func(nil)
  3 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  6 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

insert into t_temp select * from (select * from t1 order by a, (select a from t3)) group by a, b;
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN insert /*+NO_REWRITE*/into t_temp select * from (select * from t1 order by a, (select a from t3)) group by a, b;
Query Plan
==============================================
|ID|OPERATOR          |NAME |EST. ROWS|COST  |
----------------------------------------------
|0 |INSERT            |     |10001    |204292|
|1 | SUBPLAN SCAN     |VIEW1|10001    |202912|
|2 |  HASH GROUP BY   |     |10001    |201531|
|3 |   SUBPLAN SCAN   |     |100000   |155736|
|4 |    SUBPLAN FILTER|     |100000   |141933|
|5 |     TABLE SCAN   |t1   |100000   |66272 |
|6 |     TABLE SCAN   |t3   |100000   |61860 |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([.a], [.b], [.c]), filter(nil), 
      group([.a], [.b]), agg_func(nil)
  3 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  6 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

insert /*+NO_REWRITE*/into t_temp select * from (select * from t1 order by a, (select a from t3)) group by a, b;
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN update t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a, (select a from t3));
Query Plan
==================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST  |
--------------------------------------------------
|0 |UPDATE               |      |99000    |517698|
|1 | HASH RIGHT SEMI JOIN|      |99000    |418698|
|2 |  SUBPLAN SCAN       |VIEW1 |100000   |151324|
|3 |   SUBPLAN FILTER    |      |100000   |137522|
|4 |    TABLE SCAN       |t1    |100000   |61860 |
|5 |    TABLE SCAN       |t3    |100000   |61860 |
|6 |  TABLE SCAN         |t_temp|100000   |66272 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]),
      update([t_temp.b=column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c], [column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))]), filter(nil), 
      equal_conds([t_temp.b = VIEW1.a]), other_conds(nil)
  2 - output([VIEW1.a]), filter(nil), 
      access([VIEW1.a])
  3 - output([t1.a]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  5 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)
  6 - output([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), filter(nil), 
      access([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), partitions(p0)

update t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a, (select a from t3));
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN update /*+NO_REWRITE*/t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a, (select a from t3));
Query Plan
==================================================
|ID|OPERATOR         |NAME  |EST. ROWS|COST      |
--------------------------------------------------
|0 |UPDATE           |      |50000    |1983308375|
|1 | SUBPLAN FILTER  |      |50000    |1983258375|
|2 |  TABLE SCAN     |t_temp|100000   |66272     |
|3 |  SORT           |      |100000   |328590    |
|4 |   SUBPLAN FILTER|      |100000   |137522    |
|5 |    TABLE SCAN   |t1    |100000   |61860     |
|6 |    TABLE SCAN   |t3    |100000   |61860     |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]),
      update([t_temp.b=column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c], [column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))]), filter([t_temp.b = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), filter(nil), 
      access([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), partitions(p0)
  3 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  4 - output([t1.a]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  6 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

update /*+NO_REWRITE*/t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a, (select a from t3));
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN delete from t_temp where t_temp.b in (select a from t1 order by a, (select a from t3));
Query Plan
==================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST  |
--------------------------------------------------
|0 |DELETE               |      |99000    |517698|
|1 | HASH RIGHT SEMI JOIN|      |99000    |418698|
|2 |  SUBPLAN SCAN       |VIEW1 |100000   |151324|
|3 |   SUBPLAN FILTER    |      |100000   |137522|
|4 |    TABLE SCAN       |t1    |100000   |61860 |
|5 |    TABLE SCAN       |t3    |100000   |61860 |
|6 |  TABLE SCAN         |t_temp|100000   |66272 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      equal_conds([t_temp.b = VIEW1.a]), other_conds(nil)
  2 - output([VIEW1.a]), filter(nil), 
      access([VIEW1.a])
  3 - output([t1.a]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  5 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)
  6 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

delete from t_temp where t_temp.b in (select a from t1 order by a, (select a from t3));
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN delete /*+NO_REWRITE*/from t_temp where t_temp.b in (select a from t1 order by a, (select a from t3));
Query Plan
==================================================
|ID|OPERATOR         |NAME  |EST. ROWS|COST      |
--------------------------------------------------
|0 |DELETE           |      |50000    |1983308375|
|1 | SUBPLAN FILTER  |      |50000    |1983258375|
|2 |  TABLE SCAN     |t_temp|100000   |66272     |
|3 |  SORT           |      |100000   |328590    |
|4 |   SUBPLAN FILTER|      |100000   |137522    |
|5 |    TABLE SCAN   |t1    |100000   |61860     |
|6 |    TABLE SCAN   |t3    |100000   |61860     |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter([t_temp.b = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)
  3 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  4 - output([t1.a]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  5 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  6 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

delete /*+NO_REWRITE*/from t_temp where t_temp.b in (select a from t1 order by a, (select a from t3));
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;

EXPLAIN select sum(a) from (select a from t1 order by a);
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |80961|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.a)])
  1 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select sum(a) from (select a from t1 order by a);
+--------+
| sum(a) |
+--------+
|   NULL |
+--------+
EXPLAIN select /*+no_rewrite*/sum(a) from (select a from t1 order by a);
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |SCALAR GROUP BY|    |1        |285832|
|1 | SUBPLAN SCAN  |    |100000   |266731|
|2 |  SORT         |    |100000   |252929|
|3 |   TABLE SCAN  |t1  |100000   |61860 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.a)])
  1 - output([.a]), filter(nil), 
      access([.a])
  2 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select /*+no_rewrite*/sum(a) from (select a from t1 order by a);
+--------+
| sum(a) |
+--------+
|   NULL |
+--------+

EXPLAIN select sum(a) from (select a from t1 order by a) limit 1;
Query Plan
==========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST |
------------------------------------------
|0 |LIMIT           |    |1        |80961|
|1 | SCALAR GROUP BY|    |1        |80961|
|2 |  TABLE SCAN    |t1  |100000   |61860|
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t1.a)]), filter(nil), limit(1), offset(nil)
  1 - output([T_FUN_SUM(t1.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.a)])
  2 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select sum(a) from (select a from t1 order by a) limit 1;
+--------+
| sum(a) |
+--------+
|   NULL |
+--------+
EXPLAIN select /*+no_rewrite*/sum(a) from (select a from t1 order by a) limit 1;
Query Plan
===========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST  |
-------------------------------------------
|0 |LIMIT           |    |1        |285832|
|1 | SCALAR GROUP BY|    |1        |285832|
|2 |  SUBPLAN SCAN  |    |100000   |266731|
|3 |   SORT         |    |100000   |252929|
|4 |    TABLE SCAN  |t1  |100000   |61860 |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.a)]), filter(nil), limit(1), offset(nil)
  1 - output([T_FUN_SUM(.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.a)])
  2 - output([.a]), filter(nil), 
      access([.a])
  3 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select /*+no_rewrite*/sum(a) from (select a from t1 order by a) limit 1;
+--------+
| sum(a) |
+--------+
|   NULL |
+--------+

EXPLAIN select sum(a) from (select a from t1 order by a, (select a from t3));
Query Plan
===========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST  |
-------------------------------------------
|0 |SCALAR GROUP BY |    |1        |170425|
|1 | SUBPLAN SCAN   |    |100000   |151324|
|2 |  SUBPLAN FILTER|    |100000   |137522|
|3 |   TABLE SCAN   |t1  |100000   |61860 |
|4 |   TABLE SCAN   |t3  |100000   |61860 |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.a)])
  1 - output([.a]), filter(nil), 
      access([.a])
  2 - output([t1.a]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  4 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

select sum(a) from (select a from t1 order by a, (select a from t3));
+--------+
| sum(a) |
+--------+
|   NULL |
+--------+
EXPLAIN select /*+no_rewrite*/sum(a) from (select a from t1 order by a, (select a from t3));
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |SCALAR GROUP BY  |    |1        |361494|
|1 | SUBPLAN SCAN    |    |100000   |342393|
|2 |  SORT           |    |100000   |328590|
|3 |   SUBPLAN FILTER|    |100000   |137522|
|4 |    TABLE SCAN   |t1  |100000   |61860 |
|5 |    TABLE SCAN   |t3  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(.a)])
  1 - output([.a]), filter(nil), 
      access([.a])
  2 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  5 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

select /*+no_rewrite*/sum(a) from (select a from t1 order by a, (select a from t3));
+--------+
| sum(a) |
+--------+
|   NULL |
+--------+

EXPLAIN select distinct * from (select * from t1 order by a);
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |HASH DISTINCT|    |100000   |182295|
|1 | TABLE SCAN  |t1  |100000   |66272 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      distinct([t1.a], [t1.b], [t1.c])
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select distinct * from (select * from t1 order by a);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/distinct * from (select * from t1 order by a);
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |HASH DISTINCT|    |100000   |426006|
|1 | SUBPLAN SCAN|    |100000   |309982|
|2 |  SORT       |    |100000   |296180|
|3 |   TABLE SCAN|t1  |100000   |66272 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), 
      distinct([.a], [.b], [.c])
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select /*+no_rewrite*/distinct * from (select * from t1 order by a);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

EXPLAIN select distinct * from (select * from t1 order by a) limit 1;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |LIMIT         |    |1        |38  |
|1 | HASH DISTINCT|    |1        |38  |
|2 |  TABLE SCAN  |t1  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), limit(1), offset(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      distinct([t1.a], [t1.b], [t1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select distinct * from (select * from t1 order by a) limit 1;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/distinct * from (select * from t1 order by a) limit 1;
Query Plan
=========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST  |
-----------------------------------------
|0 |LIMIT         |    |1        |296181|
|1 | HASH DISTINCT|    |1        |296181|
|2 |  SUBPLAN SCAN|    |1        |296180|
|3 |   SORT       |    |1        |296180|
|4 |    TABLE SCAN|t1  |100000   |66272 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), limit(1), offset(nil)
  1 - output([.a], [.b], [.c]), filter(nil), 
      distinct([.a], [.b], [.c])
  2 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select /*+no_rewrite*/distinct * from (select * from t1 order by a) limit 1;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

EXPLAIN select distinct * from (select * from t1 order by a, (select a from t3));
Query Plan
=========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST  |
-----------------------------------------
|0 |SUBPLAN FILTER|    |100000   |257957|
|1 | HASH DISTINCT|    |100000   |182295|
|2 |  TABLE SCAN  |t1  |100000   |66272 |
|3 | TABLE SCAN   |t3  |100000   |61860 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      distinct([t1.a], [t1.b], [t1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  3 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

select distinct * from (select * from t1 order by a, (select a from t3));
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/distinct * from (select * from t1 order by a, (select a from t3));
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |HASH DISTINCT    |    |100000   |501667|
|1 | SUBPLAN SCAN    |    |100000   |385644|
|2 |  SORT           |    |100000   |371842|
|3 |   SUBPLAN FILTER|    |100000   |141933|
|4 |    TABLE SCAN   |t1  |100000   |66272 |
|5 |    TABLE SCAN   |t3  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), 
      distinct([.a], [.b], [.c])
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  5 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

select /*+no_rewrite*/distinct * from (select * from t1 order by a, (select a from t3));
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

EXPLAIN select * from (select * from t1 order by a) order by b;
Query Plan
======================================
|ID|OPERATOR   |NAME|EST. ROWS|COST  |
--------------------------------------
|0 |SORT       |    |100000   |296180|
|1 | TABLE SCAN|t1  |100000   |66272 |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.b, ASC])
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from (select * from t1 order by a) order by b;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a) order by b;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |SORT         |    |100000   |539891|
|1 | SUBPLAN SCAN|    |100000   |309982|
|2 |  SORT       |    |100000   |296180|
|3 |   TABLE SCAN|t1  |100000   |66272 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), sort_keys([.b, ASC])
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a) order by b;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

EXPLAIN select * from (select * from t1 order by a) order by b limit 1;
Query Plan
=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |LIMIT       |    |1        |107637|
|1 | TOP-N SORT |    |1        |107637|
|2 |  TABLE SCAN|t1  |100000   |66272 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), limit(1), offset(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.b, ASC]), topn(1)
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from (select * from t1 order by a) order by b limit 1;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a) order by b limit 1;
Query Plan
=========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST  |
-----------------------------------------
|0 |LIMIT         |    |1        |351348|
|1 | TOP-N SORT   |    |1        |351348|
|2 |  SUBPLAN SCAN|    |100000   |309982|
|3 |   SORT       |    |100000   |296180|
|4 |    TABLE SCAN|t1  |100000   |66272 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), limit(1), offset(nil)
  1 - output([.a], [.b], [.c]), filter(nil), sort_keys([.b, ASC]), topn(1)
  2 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a) order by b limit 1;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

EXPLAIN select * from (select * from t1 order by a, (select a from t3)) order by b;
Query Plan
======================================
|ID|OPERATOR   |NAME|EST. ROWS|COST  |
--------------------------------------
|0 |SORT       |    |100000   |296180|
|1 | TABLE SCAN|t1  |100000   |66272 |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.b, ASC])
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from (select * from t1 order by a, (select a from t3)) order by b;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a, (select a from t3)) order by b;
Query Plan
============================================
|ID|OPERATOR         |NAME|EST. ROWS|COST  |
--------------------------------------------
|0 |SORT             |    |100000   |615552|
|1 | SUBPLAN SCAN    |    |100000   |385644|
|2 |  SORT           |    |100000   |371842|
|3 |   SUBPLAN FILTER|    |100000   |141933|
|4 |    TABLE SCAN   |t1  |100000   |66272 |
|5 |    TABLE SCAN   |t3  |100000   |61860 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), sort_keys([.b, ASC])
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  5 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a, (select a from t3)) order by b;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

##test basic view stmt ==> can't remove order by
EXPLAIN select * from (select * from t1 order by a);
Query Plan
======================================
|ID|OPERATOR   |NAME|EST. ROWS|COST  |
--------------------------------------
|0 |SORT       |    |100000   |296180|
|1 | TABLE SCAN|t1  |100000   |66272 |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from (select * from t1 order by a);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a);
Query Plan
=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |SUBPLAN SCAN|    |100000   |309982|
|1 | SORT       |    |100000   |296180|
|2 |  TABLE SCAN|t1  |100000   |66272 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN insert into t_temp select * from (select * from t1 order by a);
Query Plan
=========================================
|ID|OPERATOR     |NAME |EST. ROWS|COST  |
-----------------------------------------
|0 |INSERT       |     |100000   |323784|
|1 | SUBPLAN SCAN|VIEW1|100000   |309982|
|2 |  SORT       |     |100000   |296180|
|3 |   TABLE SCAN|t1   |100000   |66272 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

insert into t_temp select * from (select * from t1 order by a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN insert /*+NO_REWRITE*/into t_temp select * from (select * from t1 order by a);
Query Plan
=========================================
|ID|OPERATOR     |NAME |EST. ROWS|COST  |
-----------------------------------------
|0 |INSERT       |     |100000   |323784|
|1 | SUBPLAN SCAN|VIEW1|100000   |309982|
|2 |  SORT       |     |100000   |296180|
|3 |   TABLE SCAN|t1   |100000   |66272 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

insert /*+NO_REWRITE*/into t_temp select * from (select * from t1 order by a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN update t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a);
Query Plan
==================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST  |
--------------------------------------------------
|0 |UPDATE               |      |99000    |428234|
|1 | HASH RIGHT SEMI JOIN|      |99000    |329234|
|2 |  TABLE SCAN         |t1    |100000   |61860 |
|3 |  TABLE SCAN         |t_temp|100000   |66272 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]),
      update([t_temp.b=column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c], [column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))]), filter(nil), 
      equal_conds([t_temp.b = t1.a]), other_conds(nil)
  2 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  3 - output([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), filter(nil), 
      access([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), partitions(p0)

update t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN update /*+NO_REWRITE*/t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a);
Query Plan
================================================
|ID|OPERATOR       |NAME  |EST. ROWS|COST      |
------------------------------------------------
|0 |UPDATE         |      |50000    |1983232714|
|1 | SUBPLAN FILTER|      |50000    |1983182714|
|2 |  TABLE SCAN   |t_temp|100000   |66272     |
|3 |  SORT         |      |100000   |252929    |
|4 |   TABLE SCAN  |t1    |100000   |61860     |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}]),
      update([t_temp.b=column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c], [column_conv(INT,PS:(11,0),NULL,cast(t_temp.b + 100, INT(-1, 0)))]), filter([t_temp.b = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), filter(nil), 
      access([t_temp.b], [t_temp.__pk_increment], [t_temp.a], [t_temp.c]), partitions(p0)
  3 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

update /*+NO_REWRITE*/t_temp set t_temp.b = t_temp.b + 100 where t_temp.b in (select a from t1 order by a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN delete from t_temp where t_temp.b in (select a from t1 order by a);
Query Plan
==================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST  |
--------------------------------------------------
|0 |DELETE               |      |99000    |428234|
|1 | HASH RIGHT SEMI JOIN|      |99000    |329234|
|2 |  TABLE SCAN         |t1    |100000   |61860 |
|3 |  TABLE SCAN         |t_temp|100000   |66272 |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      equal_conds([t_temp.b = t1.a]), other_conds(nil)
  2 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  3 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

delete from t_temp where t_temp.b in (select a from t1 order by a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;
EXPLAIN delete /*+NO_REWRITE*/from t_temp where t_temp.b in (select a from t1 order by a);
Query Plan
================================================
|ID|OPERATOR       |NAME  |EST. ROWS|COST      |
------------------------------------------------
|0 |DELETE         |      |50000    |1983232714|
|1 | SUBPLAN FILTER|      |50000    |1983182714|
|2 |  TABLE SCAN   |t_temp|100000   |66272     |
|3 |  SORT         |      |100000   |252929    |
|4 |   TABLE SCAN  |t1    |100000   |61860     |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t_temp: ({t_temp: (t_temp.__pk_increment, t_temp.a, t_temp.b, t_temp.c)})}])
  1 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter([t_temp.b = ANY(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  2 - output([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.__pk_increment], [t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)
  3 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

delete /*+NO_REWRITE*/from t_temp where t_temp.b in (select a from t1 order by a);
EXPLAIN select * from t_temp;
Query Plan
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|t_temp|100000   |66272|
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t_temp.a], [t_temp.b], [t_temp.c]), filter(nil), 
      access([t_temp.a], [t_temp.b], [t_temp.c]), partitions(p0)

select * from t_temp;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
rollback;

EXPLAIN select * from (select * from t1 order by a) limit 1;
Query Plan
=======================================
|ID|OPERATOR    |NAME|EST. ROWS|COST  |
---------------------------------------
|0 |LIMIT       |    |1        |107637|
|1 | TOP-N SORT |    |1        |107637|
|2 |  TABLE SCAN|t1  |100000   |66272 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), limit(1), offset(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from (select * from t1 order by a) limit 1;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a) limit 1;
Query Plan
========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST  |
----------------------------------------
|0 |LIMIT        |    |1        |296180|
|1 | SUBPLAN SCAN|    |1        |296180|
|2 |  TOP-N SORT |    |1        |296180|
|3 |   TABLE SCAN|t1  |100000   |66272 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), limit(1), offset(nil)
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a) limit 1;
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

EXPLAIN select distinct * from (select * from t1 order by a limit 1);
Query Plan
=========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST  |
-----------------------------------------
|0 |HASH DISTINCT |    |1        |107639|
|1 | SUBPLAN SCAN |    |1        |107637|
|2 |  LIMIT       |    |1        |107637|
|3 |   TOP-N SORT |    |1        |107637|
|4 |    TABLE SCAN|t1  |100000   |66272 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), 
      distinct([.a], [.b], [.c])
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), limit(1), offset(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select distinct * from (select * from t1 order by a limit 1);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/distinct * from (select * from t1 order by a limit 1);
Query Plan
=========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST  |
-----------------------------------------
|0 |HASH DISTINCT |    |1        |107639|
|1 | SUBPLAN SCAN |    |1        |107637|
|2 |  LIMIT       |    |1        |107637|
|3 |   TOP-N SORT |    |1        |107637|
|4 |    TABLE SCAN|t1  |100000   |66272 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), 
      distinct([.a], [.b], [.c])
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), limit(1), offset(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select /*+no_rewrite*/distinct * from (select * from t1 order by a limit 1);
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

EXPLAIN select a from (select a from t1 order by a limit 1) group by a;
Query Plan
========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |MERGE GROUP BY|    |1        |84850|
|1 | SUBPLAN SCAN |    |1        |84850|
|2 |  LIMIT       |    |1        |84850|
|3 |   TOP-N SORT |    |1        |84850|
|4 |    TABLE SCAN|t1  |100000   |61860|
========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a]), filter(nil), 
      group([.a]), agg_func(nil)
  1 - output([.a]), filter(nil), 
      access([.a])
  2 - output([t1.a]), filter(nil), limit(1), offset(nil)
  3 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select a from (select a from t1 order by a limit 1) group by a;
+------+
| a    |
+------+
+------+
EXPLAIN select /*+no_rewrite*/a from (select a from t1 order by a limit 1) group by a;
Query Plan
========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |MERGE GROUP BY|    |1        |84850|
|1 | SUBPLAN SCAN |    |1        |84850|
|2 |  LIMIT       |    |1        |84850|
|3 |   TOP-N SORT |    |1        |84850|
|4 |    TABLE SCAN|t1  |100000   |61860|
========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a]), filter(nil), 
      group([.a]), agg_func(nil)
  1 - output([.a]), filter(nil), 
      access([.a])
  2 - output([t1.a]), filter(nil), limit(1), offset(nil)
  3 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select /*+no_rewrite*/a from (select a from t1 order by a limit 1) group by a;
+------+
| a    |
+------+
+------+

EXPLAIN select * from (select * from t1 order by a, (select a from t3));
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |SORT           |    |100000   |371842|
|1 | SUBPLAN FILTER|    |100000   |141933|
|2 |  TABLE SCAN   |t1  |100000   |66272 |
|3 |  TABLE SCAN   |t3  |100000   |61860 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  3 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

select * from (select * from t1 order by a, (select a from t3));
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a, (select a from t3));
Query Plan
===========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST  |
-------------------------------------------
|0 |SUBPLAN SCAN    |    |100000   |385644|
|1 | SORT           |    |100000   |371842|
|2 |  SUBPLAN FILTER|    |100000   |141933|
|3 |   TABLE SCAN   |t1  |100000   |66272 |
|4 |   TABLE SCAN   |t3  |100000   |61860 |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  4 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a, (select a from t3));
+------+------+------+
| a    | b    | c    |
+------+------+------+
+------+------+------+

##test join view stmt ==> remove stmt
EXPLAIN select * from (select * from t1 order by a), t2;
Query Plan
===========================================================
|ID|OPERATOR                  |NAME|EST. ROWS  |COST      |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000000000|7285474711|
|1 | TABLE SCAN               |t2  |100000     |66272     |
|2 | MATERIAL                 |    |100000     |121398    |
|3 |  TABLE SCAN              |t1  |100000     |66272     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from (select * from t1 order by a), t2;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a), t2;
Query Plan
===========================================================
|ID|OPERATOR                  |NAME|EST. ROWS  |COST      |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000000000|7285718422|
|1 | SUBPLAN SCAN             |    |100000     |309982    |
|2 |  SORT                    |    |100000     |296180    |
|3 |   TABLE SCAN             |t1  |100000     |66272     |
|4 | MATERIAL                 |    |100000     |121398    |
|5 |  TABLE SCAN              |t2  |100000     |66272     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  4 - output([t2.a], [t2.b], [t2.c]), filter(nil)
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a), t2;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN insert into t_temp_join (select * from (select * from t1 order by a), t2);
Query Plan
===============================================================
|ID|OPERATOR                    |NAME |EST. ROWS  |COST       |
---------------------------------------------------------------
|0 |INSERT                      |     |10000000000|10045913433|
|1 | SUBPLAN SCAN               |VIEW1|10000000000|8665694072 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |10000000000|7285474711 |
|3 |   TABLE SCAN               |t2   |100000     |66272      |
|4 |   MATERIAL                 |     |100000     |121398     |
|5 |    TABLE SCAN              |t1   |100000     |66272      |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)], [column_conv(INT,PS:(11,0),NULL,VIEW1.c)]), filter(nil), 
      columns([{t_temp_join: ({t_temp_join: (t_temp_join.__pk_increment, t_temp_join.a, t_temp_join.b, t_temp_join.c, t_temp_join.d, t_temp_join.e, t_temp_join.f)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.a], [VIEW1.b], [VIEW1.c]), filter(nil), 
      access([VIEW1.a], [VIEW1.b], [VIEW1.c], [VIEW1.a], [VIEW1.b], [VIEW1.c])
  2 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil)
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

insert into t_temp_join (select * from (select * from t1 order by a), t2);
EXPLAIN insert /*+*/

select * from (select * from t1 order by a, (select a from t3)), t2;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your OceanBase version for the right syntax to use near 'select * from (select * from t1 order by a, (select a from t3)), t2' at line 3
insert /*+*/

select * from (select * from t1 order by a, (select a from t3)), t2;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your OceanBase version for the right syntax to use near 'select * from (select * from t1 order by a, (select a from t3)), t2' at line 3
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a, (select a from t3)), t2;
Query Plan
===========================================================
|ID|OPERATOR                  |NAME|EST. ROWS  |COST      |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000000000|7285794083|
|1 | SUBPLAN SCAN             |    |100000     |385644    |
|2 |  SORT                    |    |100000     |371842    |
|3 |   SUBPLAN FILTER         |    |100000     |141933    |
|4 |    TABLE SCAN            |t1  |100000     |66272     |
|5 |    TABLE SCAN            |t3  |100000     |61860     |
|6 | MATERIAL                 |    |100000     |121398    |
|7 |  TABLE SCAN              |t2  |100000     |66272     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  5 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)
  6 - output([t2.a], [t2.b], [t2.c]), filter(nil)
  7 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a, (select a from t3)), t2;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

EXPLAIN select * from (select * from t1 order by a) v1, (select * from t2 order by a) v2;
Query Plan
===========================================================
|ID|OPERATOR                  |NAME|EST. ROWS  |COST      |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000000000|7285474711|
|1 | TABLE SCAN               |t1  |100000     |66272     |
|2 | MATERIAL                 |    |100000     |121398    |
|3 |  TABLE SCAN              |t2  |100000     |66272     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  2 - output([t2.a], [t2.b], [t2.c]), filter(nil)
  3 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select * from (select * from t1 order by a) v1, (select * from t2 order by a) v2;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a) v1, (select * from t2 order by a) v2;
Query Plan
===========================================================
|ID|OPERATOR                  |NAME|EST. ROWS  |COST      |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000000000|7285962132|
|1 | SUBPLAN SCAN             |v1  |100000     |309982    |
|2 |  SORT                    |    |100000     |296180    |
|3 |   TABLE SCAN             |t1  |100000     |66272     |
|4 | MATERIAL                 |    |100000     |365108    |
|5 |  SUBPLAN SCAN            |v2  |100000     |309982    |
|6 |   SORT                   |    |100000     |296180    |
|7 |    TABLE SCAN            |t2  |100000     |66272     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([v1.a], [v1.b], [v1.c], [v2.a], [v2.b], [v2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([v1.a], [v1.b], [v1.c]), filter(nil), 
      access([v1.a], [v1.b], [v1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  4 - output([v2.a], [v2.b], [v2.c]), filter(nil)
  5 - output([v2.a], [v2.b], [v2.c]), filter(nil), 
      access([v2.a], [v2.b], [v2.c])
  6 - output([t2.a], [t2.b], [t2.c]), filter(nil), sort_keys([t2.a, ASC])
  7 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a) v1, (select * from t2 order by a) v2;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

EXPLAIN select * from (select * from t1 order by a) v left join t2 on v.a = t2.a;
Query Plan
============================================
|ID|OPERATOR       |NAME|EST. ROWS|COST    |
--------------------------------------------
|0 |HASH OUTER JOIN|    |98010000 |58439627|
|1 | TABLE SCAN    |t1  |100000   |66272   |
|2 | TABLE SCAN    |t2  |100000   |66272   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      equal_conds([t1.a = t2.a]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  2 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select * from (select * from t1 order by a) v left join t2 on v.a = t2.a;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a) v left join t2 on v.a = t2.a;
Query Plan
============================================
|ID|OPERATOR       |NAME|EST. ROWS|COST    |
--------------------------------------------
|0 |HASH OUTER JOIN|    |98010000 |58683338|
|1 | SUBPLAN SCAN  |v   |100000   |309982  |
|2 |  SORT         |    |100000   |296180  |
|3 |   TABLE SCAN  |t1  |100000   |66272   |
|4 | TABLE SCAN    |t2  |100000   |66272   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([v.a], [v.b], [v.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      equal_conds([v.a = t2.a]), other_conds(nil)
  1 - output([v.a], [v.b], [v.c]), filter(nil), 
      access([v.a], [v.b], [v.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  4 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a) v left join t2 on v.a = t2.a;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

EXPLAIN select * from (select * from t1 order by a, (select a from t3)) v left join t2 on v.a = t2.a;
Query Plan
=============================================
|ID|OPERATOR        |NAME|EST. ROWS|COST    |
---------------------------------------------
|0 |HASH OUTER JOIN |    |98010000 |58529091|
|1 | SUBPLAN SCAN   |v   |100000   |155736  |
|2 |  SUBPLAN FILTER|    |100000   |141933  |
|3 |   TABLE SCAN   |t1  |100000   |66272   |
|4 |   TABLE SCAN   |t3  |100000   |61860   |
|5 | TABLE SCAN     |t2  |100000   |66272   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([v.a], [v.b], [v.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      equal_conds([v.a = t2.a]), other_conds(nil)
  1 - output([v.a], [v.b], [v.c]), filter(nil), 
      access([v.a], [v.b], [v.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  4 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select * from (select * from t1 order by a, (select a from t3)) v left join t2 on v.a = t2.a;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a) v left join t2 on v.a = t2.a;
Query Plan
============================================
|ID|OPERATOR       |NAME|EST. ROWS|COST    |
--------------------------------------------
|0 |HASH OUTER JOIN|    |98010000 |58683338|
|1 | SUBPLAN SCAN  |v   |100000   |309982  |
|2 |  SORT         |    |100000   |296180  |
|3 |   TABLE SCAN  |t1  |100000   |66272   |
|4 | TABLE SCAN    |t2  |100000   |66272   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([v.a], [v.b], [v.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      equal_conds([v.a = t2.a]), other_conds(nil)
  1 - output([v.a], [v.b], [v.c]), filter(nil), 
      access([v.a], [v.b], [v.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  4 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a) v left join t2 on v.a = t2.a;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

EXPLAIN select * from (select * from t1 order by a) v1 left join (select * from t2 order by a) v2 on v1.a = v2.a;
Query Plan
============================================
|ID|OPERATOR       |NAME|EST. ROWS|COST    |
--------------------------------------------
|0 |HASH OUTER JOIN|    |98010000 |58439627|
|1 | TABLE SCAN    |t1  |100000   |66272   |
|2 | TABLE SCAN    |t2  |100000   |66272   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t1.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      equal_conds([t1.a = t2.a]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  2 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select * from (select * from t1 order by a) v1 left join (select * from t2 order by a) v2 on v1.a = v2.a;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a) v1 left join (select * from t2 order by a) v2 on v1.a = v2.a;
Query Plan
=============================================
|ID|OPERATOR        |NAME|EST. ROWS|COST    |
---------------------------------------------
|0 |MERGE OUTER JOIN|    |98010000 |58775514|
|1 | SUBPLAN SCAN   |v1  |100000   |309982  |
|2 |  SORT          |    |100000   |296180  |
|3 |   TABLE SCAN   |t1  |100000   |66272   |
|4 | SUBPLAN SCAN   |v2  |100000   |309982  |
|5 |  SORT          |    |100000   |296180  |
|6 |   TABLE SCAN   |t2  |100000   |66272   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([v1.a], [v1.b], [v1.c], [v2.a], [v2.b], [v2.c]), filter(nil), 
      equal_conds([v1.a = v2.a]), other_conds(nil)
  1 - output([v1.a], [v1.b], [v1.c]), filter(nil), 
      access([v1.a], [v1.b], [v1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC])
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  4 - output([v2.a], [v2.b], [v2.c]), filter(nil), 
      access([v2.a], [v2.b], [v2.c])
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil), sort_keys([t2.a, ASC])
  6 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a) v1 left join (select * from t2 order by a) v2 on v1.a = v2.a;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

EXPLAIN select * from (select * from t1 order by a limit 1) v1 left join (select * from t2 order by a) v2 on v1.a = v2.a;
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |HASH OUTER JOIN|    |990      |207323|
|1 | SUBPLAN SCAN  |v1  |1        |107637|
|2 |  LIMIT        |    |1        |107637|
|3 |   TOP-N SORT  |    |1        |107637|
|4 |    TABLE SCAN |t1  |100000   |66272 |
|5 | TABLE SCAN    |t2  |100000   |66272 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([v1.a], [v1.b], [v1.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      equal_conds([v1.a = t2.a]), other_conds(nil)
  1 - output([v1.a], [v1.b], [v1.c]), filter(nil), 
      access([v1.a], [v1.b], [v1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), limit(1), offset(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select * from (select * from t1 order by a limit 1) v1 left join (select * from t2 order by a) v2 on v1.a = v2.a;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a limit 1) v1 left join (select * from t2 order by a) v2 on v1.a = v2.a;
Query Plan
===========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST  |
-------------------------------------------
|0 |MERGE OUTER JOIN|    |990      |432009|
|1 | SUBPLAN SCAN   |v1  |1        |107637|
|2 |  LIMIT         |    |1        |107637|
|3 |   TOP-N SORT   |    |1        |107637|
|4 |    TABLE SCAN  |t1  |100000   |66272 |
|5 | SUBPLAN SCAN   |v2  |100000   |309982|
|6 |  SORT          |    |100000   |296180|
|7 |   TABLE SCAN   |t2  |100000   |66272 |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([v1.a], [v1.b], [v1.c], [v2.a], [v2.b], [v2.c]), filter(nil), 
      equal_conds([v1.a = v2.a]), other_conds(nil)
  1 - output([v1.a], [v1.b], [v1.c]), filter(nil), 
      access([v1.a], [v1.b], [v1.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), limit(1), offset(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  5 - output([v2.a], [v2.b], [v2.c]), filter(nil), 
      access([v2.a], [v2.b], [v2.c])
  6 - output([t2.a], [t2.b], [t2.c]), filter(nil), sort_keys([t2.a, ASC])
  7 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a limit 1) v1 left join (select * from t2 order by a) v2 on v1.a = v2.a;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

##test join view stmt ==> can't remove stmt
EXPLAIN select * from (select * from t1 order by (select a from t3)), t2;
Query Plan
===========================================================
|ID|OPERATOR                  |NAME|EST. ROWS  |COST      |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000000000|7285564175|
|1 | SUBPLAN SCAN             |    |100000     |155736    |
|2 |  SUBPLAN FILTER          |    |100000     |141933    |
|3 |   TABLE SCAN             |t1  |100000     |66272     |
|4 |   TABLE SCAN             |t3  |100000     |61860     |
|5 | MATERIAL                 |    |100000     |121398    |
|6 |  TABLE SCAN              |t2  |100000     |66272     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  4 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil)
  6 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select * from (select * from t1 order by (select a from t3)), t2;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by (select a from t3)), t2;
Query Plan
===========================================================
|ID|OPERATOR                  |NAME|EST. ROWS  |COST      |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000000000|7285564175|
|1 | SUBPLAN SCAN             |    |100000     |155736    |
|2 |  SUBPLAN FILTER          |    |100000     |141933    |
|3 |   TABLE SCAN             |t1  |100000     |66272     |
|4 |   TABLE SCAN             |t3  |100000     |61860     |
|5 | MATERIAL                 |    |100000     |121398    |
|6 |  TABLE SCAN              |t2  |100000     |66272     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  2 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)
  4 - output([t3.a]), filter(nil), 
      access([t3.a]), partitions(p0)
  5 - output([t2.a], [t2.b], [t2.c]), filter(nil)
  6 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by (select a from t3)), t2;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

EXPLAIN select * from (select * from t1 order by a limit 1), t2;
Query Plan
=====================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST  |
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100000   |246762|
|1 | TABLE SCAN               |t2  |100000   |66272 |
|2 | MATERIAL                 |    |1        |107638|
|3 |  SUBPLAN SCAN            |    |1        |107637|
|4 |   LIMIT                  |    |1        |107637|
|5 |    TOP-N SORT            |    |1        |107637|
|6 |     TABLE SCAN           |t1  |100000   |66272 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)
  2 - output([.a], [.b], [.c]), filter(nil)
  3 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), limit(1), offset(nil)
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select * from (select * from t1 order by a limit 1), t2;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select /*+no_rewrite*/* from (select * from t1 order by a limit 1), t2;
Query Plan
=====================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST  |
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100000   |246762|
|1 | TABLE SCAN               |t2  |100000   |66272 |
|2 | MATERIAL                 |    |1        |107638|
|3 |  SUBPLAN SCAN            |    |1        |107637|
|4 |   LIMIT                  |    |1        |107637|
|5 |    TOP-N SORT            |    |1        |107637|
|6 |     TABLE SCAN           |t1  |100000   |66272 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([.a], [.b], [.c], [t2.a], [t2.b], [t2.c]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.a], [t2.b], [t2.c]), filter(nil), 
      access([t2.a], [t2.b], [t2.c]), partitions(p0)
  2 - output([.a], [.b], [.c]), filter(nil)
  3 - output([.a], [.b], [.c]), filter(nil), 
      access([.a], [.b], [.c])
  4 - output([t1.a], [t1.b], [t1.c]), filter(nil), limit(1), offset(nil)
  5 - output([t1.a], [t1.b], [t1.c]), filter(nil), sort_keys([t1.a, ASC]), topn(1)
  6 - output([t1.a], [t1.b], [t1.c]), filter(nil), 
      access([t1.a], [t1.b], [t1.c]), partitions(p0)

select /*+no_rewrite*/* from (select * from t1 order by a limit 1), t2;
+------+------+------+------+------+------+
| a    | b    | c    | a    | b    | c    |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

drop table if exists t1, t2, t3, t4;
create table t1 (pk int primary key, c1 int, c2 int);
create table t2 (pk int primary key, c1 int, c2 int);
create table t3 (pk int primary key, c1 int, c2 int);
create table t4 (pk int primary key, c1 int, c2 int);

insert/**/ into t3 values (1, 1, 1);

EXPLAIN select * from t3 where not exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t3.c2);
Query Plan
===============================================================
|ID|OPERATOR                    |NAME |EST. ROWS  |COST       |
---------------------------------------------------------------
|0 |HASH ANTI JOIN              |     |1000       |11739554317|
|1 | TABLE SCAN                 |t3   |100000     |64066      |
|2 | SUBPLAN SCAN               |VIEW1|10000000000|8456752484 |
|3 |  NESTED-LOOP JOIN CARTESIAN|     |10000000000|7076533123 |
|4 |   TABLE SCAN               |t1   |100000     |59654      |
|5 |   MATERIAL                 |     |100000     |80235      |
|6 |    TABLE SCAN              |t2   |100000     |61860      |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.pk], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([VIEW1.t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.pk], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.pk], [t3.c1]), partitions(p0)
  2 - output([VIEW1.t2.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.t2.c2])
  3 - output([t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([1]), filter(nil), 
      access([t1.pk]), partitions(p0)
  5 - output([t2.c2]), filter(nil)
  6 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

select * from t3 where not exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t3.c2);
+----+------+------+
| pk | c1   | c2   |
+----+------+------+
|  1 |    1 |    1 |
+----+------+------+
EXPLAIN select /*+no_rewrite*/ * from t3 where not exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t3.c2);
Query Plan
=================================================================
|ID|OPERATOR                   |NAME|EST. ROWS  |COST           |
-----------------------------------------------------------------
|0 |SUBPLAN FILTER             |    |50000      |2.087386e+14   |
|1 | TABLE SCAN                |t3  |100000     |64066          |
|2 | NESTED-LOOP JOIN CARTESIAN|    |10000000000|7076530917     |
|3 |  TABLE SCAN               |t1  |100000     |59654          |
|4 |  MATERIAL                 |    |100000     |78030          |
|5 |   TABLE SCAN              |t2  |100000     |59654          |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.pk], [t3.c1], [t3.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t3.c2], [t3.pk], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.pk], [t3.c1]), partitions(p0)
  2 - output([1]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  3 - output([1]), filter(nil), 
      access([t1.pk]), partitions(p0)
  4 - output([1]), filter(nil)
  5 - output([1]), filter(nil), 
      access([t2.pk]), partitions(p0)

select /*+no_rewrite*/ * from t3 where not exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t3.c2);
+----+------+------+
| pk | c1   | c2   |
+----+------+------+
|  1 |    1 |    1 |
+----+------+------+

EXPLAIN select * from t3 where exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t3.c2);
Query Plan
===============================================================
|ID|OPERATOR                    |NAME |EST. ROWS  |COST       |
---------------------------------------------------------------
|0 |HASH SEMI JOIN              |     |99000      |11739554317|
|1 | TABLE SCAN                 |t3   |100000     |64066      |
|2 | SUBPLAN SCAN               |VIEW1|10000000000|8456752484 |
|3 |  NESTED-LOOP JOIN CARTESIAN|     |10000000000|7076533123 |
|4 |   TABLE SCAN               |t1   |100000     |59654      |
|5 |   MATERIAL                 |     |100000     |80235      |
|6 |    TABLE SCAN              |t2   |100000     |61860      |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.pk], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([VIEW1.t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.pk], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.pk], [t3.c1]), partitions(p0)
  2 - output([VIEW1.t2.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.t2.c2])
  3 - output([t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([1]), filter(nil), 
      access([t1.pk]), partitions(p0)
  5 - output([t2.c2]), filter(nil)
  6 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

select * from t3 where exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t3.c2);
+----+------+------+
| pk | c1   | c2   |
+----+------+------+
+----+------+------+
EXPLAIN select /*+no_rewrite*/ * from t3 where exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t3.c2);
Query Plan
=================================================================
|ID|OPERATOR                   |NAME|EST. ROWS  |COST           |
-----------------------------------------------------------------
|0 |SUBPLAN FILTER             |    |50000      |2.087386e+14   |
|1 | TABLE SCAN                |t3  |100000     |64066          |
|2 | NESTED-LOOP JOIN CARTESIAN|    |10000000000|7076530917     |
|3 |  TABLE SCAN               |t1  |100000     |59654          |
|4 |  MATERIAL                 |    |100000     |78030          |
|5 |   TABLE SCAN              |t2  |100000     |59654          |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.pk], [t3.c1], [t3.c2]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t3.c2], [t3.pk], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.pk], [t3.c1]), partitions(p0)
  2 - output([1]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  3 - output([1]), filter(nil), 
      access([t1.pk]), partitions(p0)
  4 - output([1]), filter(nil)
  5 - output([1]), filter(nil), 
      access([t2.pk]), partitions(p0)

select /*+no_rewrite*/ * from t3 where exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t3.c2);
+----+------+------+
| pk | c1   | c2   |
+----+------+------+
+----+------+------+

EXPLAIN select * from t3 where not exists (select 1 from t4 where t3.c2 = t4.c2 and exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t4.c2));
Query Plan
=================================================================
|ID|OPERATOR                      |NAME |EST. ROWS  |COST       |
-----------------------------------------------------------------
|0 |HASH RIGHT ANTI JOIN          |     |1000       |11739793097|
|1 | SUBPLAN SCAN                 |VIEW2|99000      |11739529025|
|2 |  HASH SEMI JOIN              |     |99000      |11739515361|
|3 |   TABLE SCAN                 |t4   |100000     |61860      |
|4 |   SUBPLAN SCAN               |VIEW1|10000000000|8456752484 |
|5 |    NESTED-LOOP JOIN CARTESIAN|     |10000000000|7076533123 |
|6 |     TABLE SCAN               |t1   |100000     |59654      |
|7 |     MATERIAL                 |     |100000     |80235      |
|8 |      TABLE SCAN              |t2   |100000     |61860      |
|9 | TABLE SCAN                   |t3   |100000     |64066      |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.pk], [t3.c1], [t3.c2]), filter(nil), 
      equal_conds([t3.c2 = VIEW2.t4.c2]), other_conds(nil)
  1 - output([VIEW2.t4.c2]), filter(nil), 
      access([VIEW2.t4.c2])
  2 - output([t4.c2]), filter(nil), 
      equal_conds([VIEW1.t2.c2 = t4.c2]), other_conds(nil)
  3 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0)
  4 - output([VIEW1.t2.c2]), filter(nil), startup_filter([0]), 
      access([VIEW1.t2.c2])
  5 - output([t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter(nil), 
      access([t1.pk]), partitions(p0)
  7 - output([t2.c2]), filter(nil)
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  9 - output([t3.c2], [t3.pk], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.pk], [t3.c1]), partitions(p0)

select * from t3 where not exists (select 1 from t4 where t3.c2 = t4.c2 and exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t4.c2));
+----+------+------+
| pk | c1   | c2   |
+----+------+------+
|  1 |    1 |    1 |
+----+------+------+
EXPLAIN select /*+no_rewrite*/ * from t3 where not exists (select 1 from t4 where t3.c2 = t4.c2 and exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t4.c2));
Query Plan
============================================================================
|ID|OPERATOR                    |NAME|EST. ROWS       |COST                |
----------------------------------------------------------------------------
|0 |SUBPLAN FILTER              |    |50000           |2.191851e+19        |
|1 | TABLE SCAN                 |t3  |100000          |64066               |
|2 | NESTED-LOOP JOIN CARTESIAN |    |1.000000e+15    |7.076464e+14        |
|3 |  NESTED-LOOP JOIN CARTESIAN|    |10000000000     |7076530917          |
|4 |   TABLE SCAN               |t4  |100000          |59654               |
|5 |   MATERIAL                 |    |100000          |78030               |
|6 |    TABLE SCAN              |t1  |100000          |59654               |
|7 |  MATERIAL                  |    |100000          |78030               |
|8 |   TABLE SCAN               |t2  |100000          |59654               |
============================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.pk], [t3.c1], [t3.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t3.c2], [t3.pk], [t3.c1]), filter(nil), 
      access([t3.c2], [t3.pk], [t3.c1]), partitions(p0)
  2 - output([1]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  3 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([1]), filter(nil), 
      access([t4.pk]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([1]), filter(nil), 
      access([t1.pk]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access([t2.pk]), partitions(p0)

select /*+no_rewrite*/ * from t3 where not exists (select 1 from t4 where t3.c2 = t4.c2 and exists (select 1 from t1 left join t2 on t1.c1 = t2.c1 where t2.pk is null and t2.c2 = t4.c2));
+----+------+------+
| pk | c1   | c2   |
+----+------+------+
|  1 |    1 |    1 |
+----+------+------+

drop table t1,t2,t3,t_temp;

DROP TABLE IF EXISTS `d`, `cc`;

CREATE TABLE `d` (
  `col_varchar_10` varchar(10) DEFAULT NULL,
  `col_varchar` varchar(1) DEFAULT NULL,
  `col_varchar_20_key` varchar(20) DEFAULT NULL,
  `col_varchar_20` varchar(20) DEFAULT NULL,
  `col_varchar_10_key` varchar(10) DEFAULT NULL,
  `col_int` int(11) DEFAULT NULL,
  `col_varchar_key` varchar(1) DEFAULT NULL,
  `col_int_key` int(11) DEFAULT NULL,
  `pk` int(11) NOT NULL,
  PRIMARY KEY (`pk`),
  KEY `idx7` (`pk`, `col_varchar_20_key`) BLOCK_SIZE 16384 GLOBAL,
  KEY `idx5` (`pk`, `col_varchar_10_key`) BLOCK_SIZE 16384 GLOBAL,
  KEY `idx3` (`pk`, `col_varchar_key`) BLOCK_SIZE 16384 GLOBAL,
  KEY `idx1` (`pk`, `col_int_key`) BLOCK_SIZE 16384 GLOBAL
) ;

CREATE TABLE `cc` (
  `col_varchar_key` varchar(1) DEFAULT NULL,
  `col_int` int(11) DEFAULT NULL,
  `col_varchar_20` varchar(20) DEFAULT NULL,
  `col_int_key` int(11) DEFAULT NULL,
  `col_varchar_20_key` varchar(20) DEFAULT NULL,
  `col_varchar` varchar(1) DEFAULT NULL,
  `col_varchar_10_key` varchar(10) DEFAULT NULL,
  `pk` int(11) NOT NULL,
  `col_varchar_10` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`pk`),
  KEY `idx3` (`pk`, `col_varchar_key`) BLOCK_SIZE 16384 GLOBAL,
  KEY `idx1` (`pk`, `col_int_key`) BLOCK_SIZE 16384 GLOBAL,
  KEY `idx7` (`pk`, `col_varchar_20_key`) BLOCK_SIZE 16384 GLOBAL,
  KEY `idx5` (`pk`, `col_varchar_10_key`) BLOCK_SIZE 16384 GLOBAL
) ;

EXPLAIN SELECT DISTINCT MIN(DISTINCT table1 . `col_varchar_10`) AS field1,
                table1 . col_varchar_10_key AS field2,
                table2 . `col_int_key` AS field3,
                table1 . `col_varchar_key` AS field4,
                table2 . col_varchar_20_key AS field5,
                MIN(table1 . `col_varchar_10`) AS field6,
                table1 . col_varchar_20_key AS field7,
                table1 . col_varchar_10_key AS field8
FROM (CC AS table1
      RIGHT OUTER JOIN CC AS table2 ON (table2 . `pk` = table1 . `col_int`))
WHERE (
         (SELECT MAX(SUBQUERY1_t1 . `pk`) AS SUBQUERY1_field1
          FROM (CC AS SUBQUERY1_t1
                INNER JOIN CC AS SUBQUERY1_t2 ON (SUBQUERY1_t2 . `col_int` = SUBQUERY1_t1 . `pk`
                                                  AND SUBQUERY1_t2 . `col_varchar_10_key` >=
                                                    (SELECT MAX(CHILD_SUBQUERY1_t1 . `col_varchar_20`) AS CHILD_SUBQUERY1_field1
                                                     FROM (CC AS CHILD_SUBQUERY1_t1
                                                           INNER JOIN D AS CHILD_SUBQUERY1_t2 ON (CHILD_SUBQUERY1_t2 . `pk` = CHILD_SUBQUERY1_t1 . `col_int`)))))) IS NULL)
  OR table1 . `col_varchar_key` <= 'n'
GROUP BY field2,
         field3,
         field4,
         field5,
         field7,
         field8
ORDER BY 1,
         field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8;
Query Plan
=======================================================================
|ID|OPERATOR               |NAME                    |EST. ROWS|COST   |
-----------------------------------------------------------------------
|0 |SORT                   |                        |10000    |1124593|
|1 | HASH GROUP BY         |                        |10000    |1036142|
|2 |  NESTED-LOOP JOIN     |                        |10000    |1022847|
|3 |   SUBPLAN SCAN        |VIEW3                   |1        |595414 |
|4 |    SCALAR GROUP BY    |                        |1        |595414 |
|5 |     HASH JOIN         |                        |33000    |589111 |
|6 |      NESTED-LOOP JOIN |                        |33334    |451493 |
|7 |       SUBPLAN SCAN    |VIEW2                   |1        |309810 |
|8 |        SCALAR GROUP BY|                        |1        |309810 |
|9 |         HASH JOIN     |                        |99000    |290899 |
|10|          TABLE SCAN   |CHILD_SUBQUERY1_t2(idx7)|100000   |25731  |
|11|          TABLE SCAN   |CHILD_SUBQUERY1_t1      |100000   |64066  |
|12|       TABLE SCAN      |SUBQUERY1_t2            |100000   |64066  |
|13|      TABLE SCAN       |SUBQUERY1_t1(idx3)      |100000   |25731  |
|14|   HASH OUTER JOIN     |                        |100000   |400165 |
|15|    TABLE SCAN         |table2                  |100000   |64066  |
|16|    TABLE SCAN         |table1                  |100000   |70683  |
=======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(table1.col_varchar_10)], [table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [T_FUN_MIN(table1.col_varchar_10)], [table1.col_varchar_20_key], [table1.col_varchar_10_key]), filter(nil), sort_keys([T_FUN_MIN(table1.col_varchar_10), ASC], [table1.col_varchar_10_key, ASC], [table2.col_int_key, ASC], [table1.col_varchar_key, ASC], [table2.col_varchar_20_key, ASC], [table1.col_varchar_20_key, ASC])
  1 - output([T_FUN_MIN(table1.col_varchar_10)], [table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [table1.col_varchar_20_key]), filter(nil), 
      group([table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [table1.col_varchar_20_key]), agg_func([T_FUN_MIN(table1.col_varchar_10)])
  2 - output([table1.col_varchar_10], [table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [table1.col_varchar_20_key]), filter(nil), 
      conds([(T_OP_IS, VIEW3.SUBQUERY1_field1, NULL, 0) OR table1.col_varchar_key <= 'n']), nl_params_(nil)
  3 - output([VIEW3.SUBQUERY1_field1]), filter(nil), 
      access([VIEW3.SUBQUERY1_field1])
  4 - output([T_FUN_MAX(SUBQUERY1_t1.pk)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(SUBQUERY1_t1.pk)])
  5 - output([SUBQUERY1_t1.pk]), filter(nil), 
      equal_conds([SUBQUERY1_t2.col_int = SUBQUERY1_t1.pk]), other_conds(nil)
  6 - output([SUBQUERY1_t2.col_int]), filter(nil), 
      conds([SUBQUERY1_t2.col_varchar_10_key >= VIEW2.CHILD_SUBQUERY1_field1]), nl_params_(nil)
  7 - output([VIEW2.CHILD_SUBQUERY1_field1]), filter(nil), 
      access([VIEW2.CHILD_SUBQUERY1_field1])
  8 - output([T_FUN_MAX(CHILD_SUBQUERY1_t1.col_varchar_20)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(CHILD_SUBQUERY1_t1.col_varchar_20)])
  9 - output([CHILD_SUBQUERY1_t1.col_varchar_20]), filter(nil), 
      equal_conds([CHILD_SUBQUERY1_t2.pk = CHILD_SUBQUERY1_t1.col_int]), other_conds(nil)
  10 - output([CHILD_SUBQUERY1_t2.pk]), filter(nil), 
      access([CHILD_SUBQUERY1_t2.pk]), partitions(p0)
  11 - output([CHILD_SUBQUERY1_t1.col_int], [CHILD_SUBQUERY1_t1.col_varchar_20]), filter(nil), 
      access([CHILD_SUBQUERY1_t1.col_int], [CHILD_SUBQUERY1_t1.col_varchar_20]), partitions(p0)
  12 - output([SUBQUERY1_t2.col_int], [SUBQUERY1_t2.col_varchar_10_key]), filter(nil), 
      access([SUBQUERY1_t2.col_int], [SUBQUERY1_t2.col_varchar_10_key]), partitions(p0)
  13 - output([SUBQUERY1_t1.pk]), filter(nil), 
      access([SUBQUERY1_t1.pk]), partitions(p0)
  14 - output([table1.col_varchar_10], [table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [table1.col_varchar_20_key]), filter(nil), 
      equal_conds([table2.pk = table1.col_int]), other_conds(nil)
  15 - output([table2.pk], [table2.col_int_key], [table2.col_varchar_20_key]), filter(nil), 
      access([table2.pk], [table2.col_int_key], [table2.col_varchar_20_key]), partitions(p0)
  16 - output([table1.col_int], [table1.col_varchar_key], [table1.col_varchar_10], [table1.col_varchar_10_key], [table1.col_varchar_20_key]), filter(nil), 
      access([table1.col_int], [table1.col_varchar_key], [table1.col_varchar_10], [table1.col_varchar_10_key], [table1.col_varchar_20_key]), partitions(p0)

SELECT DISTINCT MIN(DISTINCT table1 . `col_varchar_10`) AS field1,
                table1 . col_varchar_10_key AS field2,
                table2 . `col_int_key` AS field3,
                table1 . `col_varchar_key` AS field4,
                table2 . col_varchar_20_key AS field5,
                MIN(table1 . `col_varchar_10`) AS field6,
                table1 . col_varchar_20_key AS field7,
                table1 . col_varchar_10_key AS field8
FROM (CC AS table1
      RIGHT OUTER JOIN CC AS table2 ON (table2 . `pk` = table1 . `col_int`))
WHERE (
         (SELECT MAX(SUBQUERY1_t1 . `pk`) AS SUBQUERY1_field1
          FROM (CC AS SUBQUERY1_t1
                INNER JOIN CC AS SUBQUERY1_t2 ON (SUBQUERY1_t2 . `col_int` = SUBQUERY1_t1 . `pk`
                                                  AND SUBQUERY1_t2 . `col_varchar_10_key` >=
                                                    (SELECT MAX(CHILD_SUBQUERY1_t1 . `col_varchar_20`) AS CHILD_SUBQUERY1_field1
                                                     FROM (CC AS CHILD_SUBQUERY1_t1
                                                           INNER JOIN D AS CHILD_SUBQUERY1_t2 ON (CHILD_SUBQUERY1_t2 . `pk` = CHILD_SUBQUERY1_t1 . `col_int`)))))) IS NULL)
  OR table1 . `col_varchar_key` <= 'n'
GROUP BY field2,
         field3,
         field4,
         field5,
         field7,
         field8
ORDER BY 1,
         field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8;
+--------+--------+--------+--------+--------+--------+--------+--------+
| field1 | field2 | field3 | field4 | field5 | field6 | field7 | field8 |
+--------+--------+--------+--------+--------+--------+--------+--------+
| NULL   | NULL   |   NULL | NULL   | g      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      0 | NULL   | e      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      0 | NULL   | j      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      0 | NULL   | s      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      1 | NULL   | NULL   | NULL   | NULL   | NULL   |
| NULL   | NULL   |      1 | NULL   | a      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      1 | NULL   | f      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      1 | NULL   | n      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      2 | NULL   | r      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      2 | NULL   | s      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      2 | k      | NULL   | NULL   | v      | NULL   |
| NULL   | NULL   |      3 | NULL   | NULL   | NULL   | NULL   | NULL   |
| NULL   | NULL   |      4 | NULL   | m      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      4 | NULL   | o      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      4 | NULL   | x      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      5 | NULL   | m      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      5 | NULL   | v      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      6 | NULL   | NULL   | NULL   | NULL   | NULL   |
| NULL   | NULL   |      7 | NULL   | j      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      8 | NULL   | s      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      9 | NULL   | c      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      9 | NULL   | h      | NULL   | NULL   | NULL   |
| NULL   | k      |      2 | m      | NULL   | NULL   | NULL   | k      |
| NULL   | p      |      6 | h      | NULL   | NULL   | c      | p      |
| NULL   | t      |   NULL | j      | d      | NULL   | x      | t      |
| a      | n      |   NULL | NULL   | d      | a      | r      | n      |
| b      | b      |   NULL | NULL   | NULL   | b      | m      | b      |
| o      | NULL   |      8 | t      | b      | o      | h      | NULL   |
| o      | c      |      5 | n      | q      | o      | m      | c      |
| o      | j      |      6 | g      | NULL   | o      | s      | j      |
| p      | i      |      3 | f      | NULL   | p      | g      | i      |
| q      | g      |   NULL | z      | d      | q      | n      | g      |
| q      | r      |      5 | d      | q      | q      | NULL   | r      |
| s      | NULL   |      6 | f      | NULL   | s      | f      | NULL   |
| x      | i      |      5 | m      | q      | x      | q      | i      |
| x      | i      |      8 | j      | b      | x      | a      | i      |
| y      | i      |      8 | d      | b      | y      | s      | i      |
| z      | h      |      5 | k      | q      | z      | b      | h      |
+--------+--------+--------+--------+--------+--------+--------+--------+

EXPLAIN SELECT /*+no_rewrite*/ DISTINCT MIN(DISTINCT table1 . `col_varchar_10`) AS field1,
                table1 . col_varchar_10_key AS field2,
                table2 . `col_int_key` AS field3,
                table1 . `col_varchar_key` AS field4,
                table2 . col_varchar_20_key AS field5,
                MIN(table1 . `col_varchar_10`) AS field6,
                table1 . col_varchar_20_key AS field7,
                table1 . col_varchar_10_key AS field8
FROM (CC AS table1
      RIGHT OUTER JOIN CC AS table2 ON (table2 . `pk` = table1 . `col_int`))
WHERE (
         (SELECT MAX(SUBQUERY1_t1 . `pk`) AS SUBQUERY1_field1
          FROM (CC AS SUBQUERY1_t1
                INNER JOIN CC AS SUBQUERY1_t2 ON (SUBQUERY1_t2 . `col_int` = SUBQUERY1_t1 . `pk`
                                                  AND SUBQUERY1_t2 . `col_varchar_10_key` >=
                                                    (SELECT MAX(CHILD_SUBQUERY1_t1 . `col_varchar_20`) AS CHILD_SUBQUERY1_field1
                                                     FROM (CC AS CHILD_SUBQUERY1_t1
                                                           INNER JOIN D AS CHILD_SUBQUERY1_t2 ON (CHILD_SUBQUERY1_t2 . `pk` = CHILD_SUBQUERY1_t1 . `col_int`)))))) IS NULL)
  OR table1 . `col_varchar_key` <= 'n'
GROUP BY field2,
         field3,
         field4,
         field5,
         field7,
         field8
ORDER BY 1,
         field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8;
Query Plan
=======================================================================
|ID|OPERATOR               |NAME                    |EST. ROWS|COST   |
-----------------------------------------------------------------------
|0 |SORT                   |                        |55001    |2120494|
|1 | MERGE GROUP BY        |                        |55001    |1580708|
|2 |  SORT                 |                        |55001    |1539659|
|3 |   SUBPLAN FILTER      |                        |55001    |1003170|
|4 |    HASH OUTER JOIN    |                        |55001    |400165 |
|5 |     TABLE SCAN        |table2                  |100000   |64066  |
|6 |     TABLE SCAN        |table1                  |100000   |70683  |
|7 |    SCALAR GROUP BY    |                        |1        |595414 |
|8 |     HASH JOIN         |                        |33000    |589111 |
|9 |      NESTED-LOOP JOIN |                        |33334    |451493 |
|10|       SUBPLAN SCAN    |VIEW1                   |1        |309810 |
|11|        SCALAR GROUP BY|                        |1        |309810 |
|12|         HASH JOIN     |                        |99000    |290899 |
|13|          TABLE SCAN   |CHILD_SUBQUERY1_t2(idx7)|100000   |25731  |
|14|          TABLE SCAN   |CHILD_SUBQUERY1_t1      |100000   |64066  |
|15|       TABLE SCAN      |SUBQUERY1_t2            |100000   |64066  |
|16|      TABLE SCAN       |SUBQUERY1_t1(idx3)      |100000   |25731  |
=======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(distinct table1.col_varchar_10)], [table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [T_FUN_MIN(table1.col_varchar_10)], [table1.col_varchar_20_key], [table1.col_varchar_10_key]), filter(nil), sort_keys([T_FUN_MIN(distinct table1.col_varchar_10), ASC], [table1.col_varchar_10_key, ASC], [table2.col_int_key, ASC], [table1.col_varchar_key, ASC], [table2.col_varchar_20_key, ASC], [T_FUN_MIN(table1.col_varchar_10), ASC], [table1.col_varchar_20_key, ASC])
  1 - output([T_FUN_MIN(distinct table1.col_varchar_10)], [table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [T_FUN_MIN(table1.col_varchar_10)], [table1.col_varchar_20_key]), filter(nil), 
      group([table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [table1.col_varchar_20_key], [table1.col_varchar_10_key]), agg_func([T_FUN_MIN(distinct table1.col_varchar_10)], [T_FUN_MIN(table1.col_varchar_10)])
  2 - output([table1.col_varchar_10], [table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [table1.col_varchar_20_key]), filter(nil), sort_keys([table1.col_varchar_10_key, ASC], [table2.col_int_key, ASC], [table1.col_varchar_key, ASC], [table2.col_varchar_20_key, ASC], [table1.col_varchar_20_key, ASC], [table1.col_varchar_10_key, ASC])
  3 - output([table1.col_varchar_10], [table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [table1.col_varchar_20_key]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_IS, subquery(1), NULL, 0)]), init_plan_idxs_(nil)
  4 - output([table1.col_varchar_10], [table1.col_varchar_10_key], [table2.col_int_key], [table1.col_varchar_key], [table2.col_varchar_20_key], [table1.col_varchar_20_key]), filter([? OR table1.col_varchar_key <= 'n']), 
      equal_conds([table2.pk = table1.col_int]), other_conds(nil)
  5 - output([table2.pk], [table2.col_int_key], [table2.col_varchar_20_key]), filter(nil), 
      access([table2.pk], [table2.col_int_key], [table2.col_varchar_20_key]), partitions(p0)
  6 - output([table1.col_int], [table1.col_varchar_key], [table1.col_varchar_10], [table1.col_varchar_10_key], [table1.col_varchar_20_key]), filter(nil), 
      access([table1.col_int], [table1.col_varchar_key], [table1.col_varchar_10], [table1.col_varchar_10_key], [table1.col_varchar_20_key]), partitions(p0)
  7 - output([T_FUN_MAX(SUBQUERY1_t1.pk)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(SUBQUERY1_t1.pk)])
  8 - output([SUBQUERY1_t1.pk]), filter(nil), 
      equal_conds([SUBQUERY1_t2.col_int = SUBQUERY1_t1.pk]), other_conds(nil)
  9 - output([SUBQUERY1_t2.col_int]), filter(nil), 
      conds([SUBQUERY1_t2.col_varchar_10_key >= VIEW1.CHILD_SUBQUERY1_field1]), nl_params_(nil)
  10 - output([VIEW1.CHILD_SUBQUERY1_field1]), filter(nil), 
      access([VIEW1.CHILD_SUBQUERY1_field1])
  11 - output([T_FUN_MAX(CHILD_SUBQUERY1_t1.col_varchar_20)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(CHILD_SUBQUERY1_t1.col_varchar_20)])
  12 - output([CHILD_SUBQUERY1_t1.col_varchar_20]), filter(nil), 
      equal_conds([CHILD_SUBQUERY1_t2.pk = CHILD_SUBQUERY1_t1.col_int]), other_conds(nil)
  13 - output([CHILD_SUBQUERY1_t2.pk]), filter(nil), 
      access([CHILD_SUBQUERY1_t2.pk]), partitions(p0)
  14 - output([CHILD_SUBQUERY1_t1.col_int], [CHILD_SUBQUERY1_t1.col_varchar_20]), filter(nil), 
      access([CHILD_SUBQUERY1_t1.col_int], [CHILD_SUBQUERY1_t1.col_varchar_20]), partitions(p0)
  15 - output([SUBQUERY1_t2.col_int], [SUBQUERY1_t2.col_varchar_10_key]), filter(nil), 
      access([SUBQUERY1_t2.col_int], [SUBQUERY1_t2.col_varchar_10_key]), partitions(p0)
  16 - output([SUBQUERY1_t1.pk]), filter(nil), 
      access([SUBQUERY1_t1.pk]), partitions(p0)

SELECT /*+no_rewrite*/ DISTINCT MIN(DISTINCT table1 . `col_varchar_10`) AS field1,
                table1 . col_varchar_10_key AS field2,
                table2 . `col_int_key` AS field3,
                table1 . `col_varchar_key` AS field4,
                table2 . col_varchar_20_key AS field5,
                MIN(table1 . `col_varchar_10`) AS field6,
                table1 . col_varchar_20_key AS field7,
                table1 . col_varchar_10_key AS field8
FROM (CC AS table1
      RIGHT OUTER JOIN CC AS table2 ON (table2 . `pk` = table1 . `col_int`))
WHERE (
         (SELECT MAX(SUBQUERY1_t1 . `pk`) AS SUBQUERY1_field1
          FROM (CC AS SUBQUERY1_t1
                INNER JOIN CC AS SUBQUERY1_t2 ON (SUBQUERY1_t2 . `col_int` = SUBQUERY1_t1 . `pk`
                                                  AND SUBQUERY1_t2 . `col_varchar_10_key` >=
                                                    (SELECT MAX(CHILD_SUBQUERY1_t1 . `col_varchar_20`) AS CHILD_SUBQUERY1_field1
                                                     FROM (CC AS CHILD_SUBQUERY1_t1
                                                           INNER JOIN D AS CHILD_SUBQUERY1_t2 ON (CHILD_SUBQUERY1_t2 . `pk` = CHILD_SUBQUERY1_t1 . `col_int`)))))) IS NULL)
  OR table1 . `col_varchar_key` <= 'n'
GROUP BY field2,
         field3,
         field4,
         field5,
         field7,
         field8
ORDER BY 1,
         field1,
         field2,
         field3,
         field4,
         field5,
         field6,
         field7,
         field8;
+--------+--------+--------+--------+--------+--------+--------+--------+
| field1 | field2 | field3 | field4 | field5 | field6 | field7 | field8 |
+--------+--------+--------+--------+--------+--------+--------+--------+
| NULL   | NULL   |   NULL | NULL   | g      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      0 | NULL   | e      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      0 | NULL   | j      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      0 | NULL   | s      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      1 | NULL   | NULL   | NULL   | NULL   | NULL   |
| NULL   | NULL   |      1 | NULL   | a      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      1 | NULL   | f      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      1 | NULL   | n      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      2 | NULL   | r      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      2 | NULL   | s      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      2 | k      | NULL   | NULL   | v      | NULL   |
| NULL   | NULL   |      3 | NULL   | NULL   | NULL   | NULL   | NULL   |
| NULL   | NULL   |      4 | NULL   | m      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      4 | NULL   | o      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      4 | NULL   | x      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      5 | NULL   | m      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      5 | NULL   | v      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      6 | NULL   | NULL   | NULL   | NULL   | NULL   |
| NULL   | NULL   |      7 | NULL   | j      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      8 | NULL   | s      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      9 | NULL   | c      | NULL   | NULL   | NULL   |
| NULL   | NULL   |      9 | NULL   | h      | NULL   | NULL   | NULL   |
| NULL   | k      |      2 | m      | NULL   | NULL   | NULL   | k      |
| NULL   | p      |      6 | h      | NULL   | NULL   | c      | p      |
| NULL   | t      |   NULL | j      | d      | NULL   | x      | t      |
| a      | n      |   NULL | NULL   | d      | a      | r      | n      |
| b      | b      |   NULL | NULL   | NULL   | b      | m      | b      |
| o      | NULL   |      8 | t      | b      | o      | h      | NULL   |
| o      | c      |      5 | n      | q      | o      | m      | c      |
| o      | j      |      6 | g      | NULL   | o      | s      | j      |
| p      | i      |      3 | f      | NULL   | p      | g      | i      |
| q      | g      |   NULL | z      | d      | q      | n      | g      |
| q      | r      |      5 | d      | q      | q      | NULL   | r      |
| s      | NULL   |      6 | f      | NULL   | s      | f      | NULL   |
| x      | i      |      5 | m      | q      | x      | q      | i      |
| x      | i      |      8 | j      | b      | x      | a      | i      |
| y      | i      |      8 | d      | b      | y      | s      | i      |
| z      | h      |      5 | k      | q      | z      | b      | h      |
+--------+--------+--------+--------+--------+--------+--------+--------+

##简化case
EXPLAIN SELECT MIN(DISTINCT col_varchar_10), MIN(col_varchar_10) FROM CC WHERE (SELECT /*+unnest*/ MAX(pk) FROM CC) IS NULL;
Query Plan
=============================================
|ID|OPERATOR         |NAME |EST. ROWS|COST  |
---------------------------------------------
|0 |SCALAR GROUP BY  |     |1        |103136|
|1 | SUBPLAN SCAN    |VIEW1|0        |103136|
|2 |  WINDOW FUNCTION|     |100000   |80961 |
|3 |   TABLE SCAN    |cc   |100000   |61860 |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.cc.col_varchar_10)], [T_FUN_MIN(VIEW1.cc.col_varchar_10)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW1.cc.col_varchar_10)])
  1 - output([VIEW1.cc.col_varchar_10]), filter([(T_OP_IS, VIEW1.MAX(pk), NULL, 0)]), 
      access([VIEW1.MAX(pk)], [VIEW1.cc.col_varchar_10])
  2 - output([T_FUN_MAX(cc.pk)], [cc.col_varchar_10]), filter(nil), 
      win_expr(T_FUN_MAX(cc.pk)), partition_by(nil), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  3 - output([cc.pk], [cc.col_varchar_10]), filter(nil), 
      access([cc.pk], [cc.col_varchar_10]), partitions(p0)

SELECT MIN(DISTINCT col_varchar_10), MIN(col_varchar_10) FROM CC WHERE (SELECT /*+unnest*/ MAX(pk) FROM CC) IS NULL;
+------------------------------+---------------------+
| MIN(DISTINCT col_varchar_10) | MIN(col_varchar_10) |
+------------------------------+---------------------+
| NULL                         | NULL                |
+------------------------------+---------------------+
EXPLAIN SELECT /*+no_rewrite*/ MIN(DISTINCT col_varchar_10), MIN(col_varchar_10) FROM CC WHERE (SELECT /*+unnest*/ MAX(pk) FROM CC) IS NULL;
Query Plan
=======================================================
|ID|OPERATOR         |NAME            |EST. ROWS|COST |
-------------------------------------------------------
|0 |SCALAR GROUP BY  |                |1        |87899|
|1 | SUBPLAN FILTER  |                |50000    |75698|
|2 |  TABLE SCAN     |cc              |100000   |61860|
|3 |  SCALAR GROUP BY|                |1        |37   |
|4 |   SUBPLAN SCAN  |VIEW1           |1        |37   |
|5 |    TABLE SCAN   |cc(idx3,Reverse)|1        |36   |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(distinct cc.col_varchar_10)], [T_FUN_MIN(cc.col_varchar_10)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(distinct cc.col_varchar_10)], [T_FUN_MIN(cc.col_varchar_10)])
  1 - output([cc.col_varchar_10]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_IS, subquery(1), NULL, 0)]), init_plan_idxs_(nil)
  2 - output([cc.col_varchar_10]), filter(nil), 
      access([cc.col_varchar_10]), partitions(p0)
  3 - output([T_FUN_MAX(VIEW1.pk)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW1.pk)])
  4 - output([VIEW1.pk]), filter(nil), 
      access([VIEW1.pk])
  5 - output([cc.pk]), filter(nil), 
      access([cc.pk]), partitions(p0), 
      limit(1), offset(nil)

SELECT /*+no_rewrite*/ MIN(DISTINCT col_varchar_10), MIN(col_varchar_10) FROM CC WHERE (SELECT /*+unnest*/ MAX(pk) FROM CC) IS NULL;
+------------------------------+---------------------+
| MIN(DISTINCT col_varchar_10) | MIN(col_varchar_10) |
+------------------------------+---------------------+
| NULL                         | NULL                |
+------------------------------+---------------------+

drop table `d`, `cc`;

##test remove win func after remove distinct in win func
drop table if exists t1;
create table t1(a int, b int);

EXPLAIN select max(distinct a) over(order by a), max(a) over(order by a) from t1;
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |WINDOW FUNCTION|    |100000   |272030|
|1 | SORT          |    |100000   |252929|
|2 |  TABLE SCAN   |t1  |100000   |61860 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(t1.a)], [T_FUN_MAX(t1.a)]), filter(nil), 
      win_expr(T_FUN_MAX(t1.a)), partition_by(nil), order_by([t1.a, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  1 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  2 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select max(distinct a) over(order by a), max(a) over(order by a) from t1;
+----------------------------------+-------------------------+
| max(distinct a) over(order by a) | max(a) over(order by a) |
+----------------------------------+-------------------------+
|                                1 |                       1 |
|                                2 |                       2 |
|                                3 |                       3 |
|                                4 |                       4 |
+----------------------------------+-------------------------+
EXPLAIN select /*+no_rewrite*/max(distinct a) over(order by a), max(a) over(order by a) from t1;
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |WINDOW FUNCTION|    |100000   |272030|
|1 | SORT          |    |100000   |252929|
|2 |  TABLE SCAN   |t1  |100000   |61860 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(distinct t1.a)], [T_FUN_MAX(t1.a)]), filter(nil), 
      win_expr(T_FUN_MAX(distinct t1.a)), partition_by(nil), order_by([t1.a, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_MAX(t1.a)), partition_by(nil), order_by([t1.a, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  1 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  2 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select /*+no_rewrite*/max(distinct a) over(order by a), max(a) over(order by a) from t1;
+----------------------------------+-------------------------+
| max(distinct a) over(order by a) | max(a) over(order by a) |
+----------------------------------+-------------------------+
|                                1 |                       1 |
|                                2 |                       2 |
|                                3 |                       3 |
|                                4 |                       4 |
+----------------------------------+-------------------------+

EXPLAIN select max(distinct a) over(order by a), max(a) over(order by a), min(a) over(order by a) , min(distinct a) over(order by a) from t1;
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |WINDOW FUNCTION|    |100000   |272030|
|1 | SORT          |    |100000   |252929|
|2 |  TABLE SCAN   |t1  |100000   |61860 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(t1.a)], [T_FUN_MAX(t1.a)], [T_FUN_MIN(t1.a)], [T_FUN_MIN(t1.a)]), filter(nil), 
      win_expr(T_FUN_MAX(t1.a)), partition_by(nil), order_by([t1.a, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_MIN(t1.a)), partition_by(nil), order_by([t1.a, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  1 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  2 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select max(distinct a) over(order by a), max(a) over(order by a), min(a) over(order by a) , min(distinct a) over(order by a) from t1;
+----------------------------------+-------------------------+-------------------------+----------------------------------+
| max(distinct a) over(order by a) | max(a) over(order by a) | min(a) over(order by a) | min(distinct a) over(order by a) |
+----------------------------------+-------------------------+-------------------------+----------------------------------+
|                                1 |                       1 |                       1 |                                1 |
|                                2 |                       2 |                       1 |                                1 |
|                                3 |                       3 |                       1 |                                1 |
|                                4 |                       4 |                       1 |                                1 |
+----------------------------------+-------------------------+-------------------------+----------------------------------+
EXPLAIN select /*+no_rewrite*/max(distinct a) over(order by a), max(a) over(order by a), min(a) over(order by a), min(distinct a) over(order by a) from t1;
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |WINDOW FUNCTION|    |100000   |272030|
|1 | SORT          |    |100000   |252929|
|2 |  TABLE SCAN   |t1  |100000   |61860 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(distinct t1.a)], [T_FUN_MAX(t1.a)], [T_FUN_MIN(t1.a)], [T_FUN_MIN(distinct t1.a)]), filter(nil), 
      win_expr(T_FUN_MAX(distinct t1.a)), partition_by(nil), order_by([t1.a, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_MAX(t1.a)), partition_by(nil), order_by([t1.a, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_MIN(t1.a)), partition_by(nil), order_by([t1.a, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_MIN(distinct t1.a)), partition_by(nil), order_by([t1.a, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  1 - output([t1.a]), filter(nil), sort_keys([t1.a, ASC])
  2 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)

select /*+no_rewrite*/max(distinct a) over(order by a), max(a) over(order by a), min(a) over(order by a), min(distinct a) over(order by a) from t1;
+----------------------------------+-------------------------+-------------------------+----------------------------------+
| max(distinct a) over(order by a) | max(a) over(order by a) | min(a) over(order by a) | min(distinct a) over(order by a) |
+----------------------------------+-------------------------+-------------------------+----------------------------------+
|                                1 |                       1 |                       1 |                                1 |
|                                2 |                       2 |                       1 |                                1 |
|                                3 |                       3 |                       1 |                                1 |
|                                4 |                       4 |                       1 |                                1 |
+----------------------------------+-------------------------+-------------------------+----------------------------------+

drop table if exists t1, t2;
create table t1(a int, b int);
create table t2(a int, b int);

EXPLAIN insert into t1 select * from t2 order by a;
Query Plan
=========================================
|ID|OPERATOR     |NAME |EST. ROWS|COST  |
-----------------------------------------
|0 |INSERT       |     |100000   |302159|
|1 | SUBPLAN SCAN|VIEW1|100000   |288357|
|2 |  SORT       |     |100000   |274554|
|3 |   TABLE SCAN|t2   |100000   |64066 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b]), filter(nil), 
      access([VIEW1.a], [VIEW1.b])
  2 - output([t2.a], [t2.b]), filter(nil), sort_keys([t2.a, ASC])
  3 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)

insert into t1 select * from t2 order by a;
select/**/ * from t1;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
+------+------+
EXPLAIN insert into t1 select * from t2 where a > 1 order by a, b;
Query Plan
=========================================
|ID|OPERATOR     |NAME |EST. ROWS|COST  |
-----------------------------------------
|0 |INSERT       |     |10000    |101950|
|1 | SUBPLAN SCAN|VIEW1|10000    |100570|
|2 |  SORT       |     |10000    |99190 |
|3 |   TABLE SCAN|t2   |10000    |80811 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b]), filter(nil), 
      access([VIEW1.a], [VIEW1.b])
  2 - output([t2.a], [t2.b]), filter(nil), sort_keys([t2.a, ASC], [t2.b, ASC])
  3 - output([t2.a], [t2.b]), filter([t2.a > 1]), 
      access([t2.a], [t2.b]), partitions(p0)

insert into t1 select * from t2 where a > 1 order by a, b;
select/**/ * from t1;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
|    2 |    2 |
|    3 |    3 |
+------+------+
EXPLAIN insert into t1 select * from t2 where a in (select a from t2 order by a) order by a;
Query Plan
=========================================
|ID|OPERATOR     |NAME |EST. ROWS|COST  |
-----------------------------------------
|0 |INSERT       |     |99000    |308030|
|1 | SUBPLAN SCAN|VIEW1|99000    |294366|
|2 |  SORT       |     |99000    |280702|
|3 |   TABLE SCAN|t2   |99000    |72438 |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([column_conv(BIGINT UNSIGNED,PS:(-1,-1),NOT NULL,nextval(1))], [column_conv(INT,PS:(11,0),NULL,VIEW1.a)], [column_conv(INT,PS:(11,0),NULL,VIEW1.b)]), filter(nil), 
      columns([{t1: ({t1: (t1.__pk_increment, t1.a, t1.b)})}]), partitions(p0)
  1 - output([VIEW1.a], [VIEW1.b]), filter(nil), 
      access([VIEW1.a], [VIEW1.b])
  2 - output([t2.a], [t2.b]), filter(nil), sort_keys([t2.a, ASC])
  3 - output([t2.a], [t2.b]), filter([(T_OP_IS_NOT, t2.a, NULL, 0)]), 
      access([t2.a], [t2.b]), partitions(p0)

insert into t1 select * from t2 where a in (select a from t2 order by a) order by a;
select/**/ * from t1;
+------+------+
| a    | b    |
+------+------+
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
|    2 |    2 |
|    3 |    3 |
|    1 |    1 |
|    2 |    2 |
|    3 |    3 |
+------+------+


************************消除冗余case when**********

drop table if exists t1;
create table t1 (c1 int, c2 int);
EXPLAIN select * from t1 where case when t1.c1 > 2 
                            then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                            else t1.c2 = 5 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 2 THEN t1.c2 = 3 ELSE t1.c2 = 5 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 where case when t1.c1 > 2 
                            then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                            else t1.c2 = 5 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+
EXPLAIN select /*+no_rewrite*/* from t1 where case when t1.c1 > 2 
                                          then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                          else t1.c2 = 5 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 2 THEN CASE WHEN t1.c1 > 2 THEN t1.c2 = 3 ELSE t1.c2 = 4 END ELSE t1.c2 = 5 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 where case when t1.c1 > 2 
                                          then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                          else t1.c2 = 5 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+

EXPLAIN select * from t1 where case when t1.c1 > 1 
                            then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                            when t1.c1 > 2 
                            then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                            else t1.c2 = 5 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 1 THEN CASE WHEN t1.c1 > 2 THEN t1.c2 = 3 ELSE t1.c2 = 4 END WHEN t1.c1 > 2 THEN t1.c2 = 3 ELSE t1.c2 = 5 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 where case when t1.c1 > 1 
                            then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                            when t1.c1 > 2 
                            then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                            else t1.c2 = 5 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+
EXPLAIN select /*+no_rewrite*/* from t1 where case when t1.c1 > 1 
                                          then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                          when t1.c1 > 2 
                                          then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                          else t1.c2 = 5 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 1 THEN CASE WHEN t1.c1 > 2 THEN t1.c2 = 3 ELSE t1.c2 = 4 END WHEN t1.c1 > 2 THEN CASE WHEN t1.c1 > 2 THEN t1.c2 = 3 ELSE t1.c2 = 4 END ELSE t1.c2 = 5 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 where case when t1.c1 > 1 
                                          then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                          when t1.c1 > 2 
                                          then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                          else t1.c2 = 5 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+

EXPLAIN select * from t1 where case when t1.c1 > 2 
                            then (case when t1.c1 > 1 
                                       then (case when t1.c1 > 1 then t1.c2 = 3 else t1.c2 = 4 end)
                                       else t1.c2 = 5 end)
                            else t1.c2 = 6 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 2 THEN CASE WHEN t1.c1 > 1 THEN t1.c2 = 3 ELSE t1.c2 = 5 END ELSE t1.c2 = 6 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 where case when t1.c1 > 2 
                            then (case when t1.c1 > 1 
                                       then (case when t1.c1 > 1 then t1.c2 = 3 else t1.c2 = 4 end)
                                       else t1.c2 = 5 end)
                            else t1.c2 = 6 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+
EXPLAIN select /*+no_rewrite*/* from t1 where case when t1.c1 > 2 
                                          then (case when t1.c1 > 1 
                                                    then (case when t1.c1 > 1 then t1.c2 = 3 else t1.c2 = 4 end)
                                                    else t1.c2 = 5 end)
                                          else t1.c2 = 6 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 2 THEN CASE WHEN t1.c1 > 1 THEN CASE WHEN t1.c1 > 1 THEN t1.c2 = 3 ELSE t1.c2 = 4 END ELSE t1.c2 = 5 END ELSE t1.c2 = 6 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 where case when t1.c1 > 2 
                                          then (case when t1.c1 > 1 
                                                    then (case when t1.c1 > 1 then t1.c2 = 3 else t1.c2 = 4 end)
                                                    else t1.c2 = 5 end)
                                          else t1.c2 = 6 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+
EXPLAIN select * from t1 where case when t1.c1 > 2 
                            then (case when t1.c1 > 2 
                                       then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                       else t1.c2 = 5 end)
                            else t1.c2 = 6 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 2 THEN t1.c2 = 3 ELSE t1.c2 = 6 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 where case when t1.c1 > 2 
                            then (case when t1.c1 > 2 
                                       then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                       else t1.c2 = 5 end)
                            else t1.c2 = 6 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+
EXPLAIN select /*+no_rewrite*/* from t1 where case when t1.c1 > 2 
                                          then (case when t1.c1 > 2 
                                                    then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                                    else t1.c2 = 5 end)
                                          else t1.c2 = 6 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 2 THEN CASE WHEN t1.c1 > 2 THEN CASE WHEN t1.c1 > 2 THEN t1.c2 = 3 ELSE t1.c2 = 4 END ELSE t1.c2 = 5 END ELSE t1.c2 = 6 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 where case when t1.c1 > 2 
                                          then (case when t1.c1 > 2 
                                                    then (case when t1.c1 > 2 then t1.c2 = 3 else t1.c2 = 4 end)
                                                    else t1.c2 = 5 end)
                                          else t1.c2 = 6 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+
EXPLAIN select * from t1 where case when t1.c1 > 2 
                            then (case when t1.c1 > 1 
                                       then t1.c2 = 3 
                                       when t1.c1 > 2
                                       then t1.c2 = 4
                                       else t1.c2 = 5 end)
                            else t1.c2 = 6 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 2 THEN CASE WHEN t1.c1 > 1 THEN t1.c2 = 3 WHEN t1.c1 > 2 THEN t1.c2 = 4 ELSE t1.c2 = 5 END ELSE t1.c2 = 6 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select * from t1 where case when t1.c1 > 2 
                            then (case when t1.c1 > 1 
                                       then t1.c2 = 3 
                                       when t1.c1 > 2
                                       then t1.c2 = 4
                                       else t1.c2 = 5 end)
                            else t1.c2 = 6 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+
EXPLAIN select /*+no_rewrite*/* from t1 where case when t1.c1 > 2 
                                          then (case when t1.c1 > 1 
                                                    then t1.c2 = 3 
                                                    when t1.c1 > 2
                                                    then t1.c2 = 4
                                                    else t1.c2 = 5 end)
                                          else t1.c2 = 6 end;
Query Plan
====================================
|ID|OPERATOR  |NAME|EST. ROWS|COST |
------------------------------------
|0 |TABLE SCAN|t1  |50000    |72438|
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([CASE WHEN t1.c1 > 2 THEN CASE WHEN t1.c1 > 1 THEN t1.c2 = 3 WHEN t1.c1 > 2 THEN t1.c2 = 4 ELSE t1.c2 = 5 END ELSE t1.c2 = 6 END]), 
      access([t1.c1], [t1.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 where case when t1.c1 > 2 
                                          then (case when t1.c1 > 1 
                                                    then t1.c2 = 3 
                                                    when t1.c1 > 2
                                                    then t1.c2 = 4
                                                    else t1.c2 = 5 end)
                                          else t1.c2 = 6 end;
+------+------+
| c1   | c2   |
+------+------+
|    3 |    3 |
+------+------+

EXPLAIN select 1
from   (select 40 as c0
        from mysql.time_zone as ref_1
        limit  89) AS subq_0
where  exists (
  select 71 as c0 from mysql.time_zone_name as ref_3 right join mysql.time_zone as ref_4
  on (exists (select subq_0.c0 as c0 from mysql.time_zone_transition ) or subq_0.c0 is not null)
);
Query Plan
===========================================================================================
|ID|OPERATOR                          |NAME                             |EST. ROWS|COST   |
-------------------------------------------------------------------------------------------
|0 |SUBPLAN FILTER                    |                                 |45       |8172376|
|1 | SUBPLAN SCAN                     |subq_0                           |89       |100    |
|2 |  TABLE SCAN                      |__all_tenant_time_zone           |89       |88     |
|3 | LIMIT                            |                                 |1        |91824  |
|4 |  NESTED-LOOP OUTER JOIN CARTESIAN|                                 |1        |91823  |
|5 |   SUBPLAN SCAN                   |VIEW3                            |1        |36     |
|6 |    TABLE SCAN                    |__all_tenant_time_zone           |1        |36     |
|7 |   MATERIAL                       |                                 |50000    |91787  |
|8 |    SUBPLAN SCAN                  |VIEW2                            |50000    |82599  |
|9 |     SUBPLAN FILTER               |                                 |50000    |75698  |
|10|      TABLE SCAN                  |__all_tenant_time_zone_name      |100000   |61860  |
|11|      TABLE SCAN                  |__all_tenant_time_zone_transition|1        |36     |
===========================================================================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([(T_OP_IS_NOT, subq_0.c0, NULL, 0)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([subq_0.c0]), filter(nil), 
      access([subq_0.c0])
  2 - output([40]), filter(nil), 
      access([__all_tenant_time_zone.tenant_id]), partitions(p0), 
      limit(89), offset(nil)
  3 - output([71]), filter(nil), limit(1), offset(nil)
  4 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([1]), filter(nil), 
      access(nil)
  6 - output([1]), filter(nil), 
      access([__all_tenant_time_zone.tenant_id]), partitions(p0), 
      limit(1), offset(nil)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access(nil)
  9 - output([1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1)) OR ?]), init_plan_idxs_(nil)
  10 - output([1]), filter(nil), 
      access([__all_tenant_time_zone_name.tenant_id]), partitions(p0)
  11 - output([1]), filter(nil), 
      access([__all_tenant_time_zone_transition.tenant_id]), partitions(p0), 
      limit(1), offset(nil)

select 1
from   (select 40 as c0
        from mysql.time_zone as ref_1
        limit  89) AS subq_0
where  exists (
  select 71 as c0 from mysql.time_zone_name as ref_3 right join mysql.time_zone as ref_4
  on (exists (select subq_0.c0 as c0 from mysql.time_zone_transition ) or subq_0.c0 is not null)
);
+---+
| 1 |
+---+
+---+

EXPLAIN select subq_1.c10 as c5
from   (select case when ( exists (select ref_2.c2 as c0,
                                          ref_2.c1 as c1
                                   from   mysql.time_zone_transition_type as ref_6)
                      ) then 60 end as c10,
               ref_2.c1 as c12
        from   t1 as ref_2) as subq_1
where  exists (select subq_1.c10 as c0
               from   mysql.time_zone_name as ref_16
                      inner join t2 as ref_17
                      on (subq_1.c12 is not null) );
Query Plan
==================================================================================================
|ID|OPERATOR                        |NAME                                  |EST. ROWS|COST       |
--------------------------------------------------------------------------------------------------
|0 |SUBPLAN FILTER                  |                                      |99000    |13598362241|
|1 | NESTED-LOOP SEMI JOIN CARTESIAN|                                      |99000    |5889461661 |
|2 |  TABLE SCAN                    |ref_2                                 |99000    |72438      |
|3 |  MATERIAL                      |                                      |300000   |370721     |
|4 |   SUBPLAN SCAN                 |VIEW1                                 |300000   |315595     |
|5 |    NESTED-LOOP JOIN CARTESIAN  |                                      |300000   |274189     |
|6 |     TABLE SCAN                 |__all_tenant_time_zone_name           |100000   |61860      |
|7 |     MATERIAL                   |                                      |3        |37         |
|8 |      TABLE SCAN                |ref_17                                |3        |37         |
|9 | TABLE SCAN                     |__all_tenant_time_zone_transition_type|100000   |64066      |
==================================================================================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_EXISTS, subquery(1)) THEN 60 ELSE NULL END]), filter(nil), 
      exec_params_([ref_2.c2], [ref_2.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([ref_2.c2], [ref_2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([ref_2.c2], [ref_2.c1]), filter([(T_OP_IS_NOT, ref_2.c1, NULL, 0)]), 
      access([ref_2.c2], [ref_2.c1]), partitions(p0)
  3 - output([1]), filter(nil)
  4 - output([1]), filter(nil), 
      access(nil)
  5 - output([1]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([1]), filter(nil), 
      access([__all_tenant_time_zone_name.tenant_id]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([1]), filter(nil), 
      access([ref_17.__pk_increment]), partitions(p0)
  9 - output([?], [?]), filter(nil), 
      access([__all_tenant_time_zone_transition_type.tenant_id]), partitions(p0)

select subq_1.c10 as c5
from   (select case when ( exists (select ref_2.c2 as c0,
                                          ref_2.c1 as c1
                                   from   mysql.time_zone_transition_type as ref_6)
                      ) then 60 end as c10,
               ref_2.c1 as c12
        from   t1 as ref_2) as subq_1
where  exists (select subq_1.c10 as c0
               from   mysql.time_zone_name as ref_16
                      inner join t2 as ref_17
                      on (subq_1.c12 is not null) );
+------+
| c5   |
+------+
+------+

drop table if exists t1;
drop table if exists t2;
## bug: https://work.aone.alibaba-inc.com/issue/39934374
explain_protocol: 0
drop table if exists t1;
create table t1(c1 int);
insert into t1 values(1);
explain_protocol: 2
EXPLAIN select (SELECT SUM(c1)  FROM t1 GROUP BY c1 WITH ROLLUP) from dual;
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |SUBPLAN FILTER |    |1        |280403|
|1 | EXPRESSION    |    |1        |1     |
|2 | MERGE GROUP BY|    |101      |280402|
|3 |  SORT         |    |100000   |252929|
|4 |   TABLE SCAN  |t1  |100000   |61860 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), rollup([t1.c1]), agg_func([T_FUN_SUM(t1.c1)])
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select (SELECT SUM(c1)  FROM t1 GROUP BY c1 WITH ROLLUP) from dual;
ERROR 21000: Subquery returns more than 1 row
EXPLAIN select /*+no_rewrie*/(SELECT SUM(c1)  FROM t1 GROUP BY c1 WITH ROLLUP) from dual;
Query Plan
==========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST  |
------------------------------------------
|0 |SUBPLAN FILTER |    |1        |280403|
|1 | EXPRESSION    |    |1        |1     |
|2 | MERGE GROUP BY|    |101      |280402|
|3 |  SORT         |    |100000   |252929|
|4 |   TABLE SCAN  |t1  |100000   |61860 |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), rollup([t1.c1]), agg_func([T_FUN_SUM(t1.c1)])
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

select /*+no_rewrie*/(SELECT SUM(c1)  FROM t1 GROUP BY c1 WITH ROLLUP) from dual;
ERROR 21000: Subquery returns more than 1 row
explain_protocol: 0
drop table if exists t1;

drop table if exists t1;
create table t1(c1 int);
insert into t1 values(1);
insert into t1 values(2);

explain select 1 from t1 having count(*) = NULL;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |78755|
|1 | TABLE SCAN    |t1  |100000   |59654|
=========================================

Outputs & filters:
-------------------------------------
  0 - output([1]), filter([T_FUN_COUNT(*) = NULL]),
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil),
      access([t1.__pk_increment]), partitions(p0)

select 1 from t1 having count(*) = NULL;
+---+
| 1 |
+---+
+---+
explain select 1 from t1 having count(*) = NULL or 1 = 1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |78755|
|1 | TABLE SCAN    |t1  |100000   |59654|
=========================================

Outputs & filters:
-------------------------------------
  0 - output([1]), filter([T_FUN_COUNT(*) = NULL OR 1]),
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil),
      access([t1.__pk_increment]), partitions(p0)

select 1 from t1 having count(*) = NULL or 1 = 1;
+---+
| 1 |
+---+
| 1 |
+---+
explain select 1 from t1 having count(*) is NULL or 1 = 1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |78755|
|1 | TABLE SCAN    |t1  |100000   |59654|
=========================================

Outputs & filters:
-------------------------------------
  0 - output([1]), filter([(T_OP_IS, T_FUN_COUNT(*), NULL, 0) OR 1]),
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil),
      access([t1.__pk_increment]), partitions(p0)

select 1 from t1 having count(*) is NULL or 1 = 1;
+---+
| 1 |
+---+
| 1 |
+---+
explain select 1 from t1 having count(*) is NULL;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |78755|
|1 | TABLE SCAN    |t1  |100000   |59654|
=========================================

Outputs & filters:
-------------------------------------
  0 - output([1]), filter([(T_OP_IS, T_FUN_COUNT(*), NULL, 0)]),
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil),
      access([t1.__pk_increment]), partitions(p0)

select 1 from t1 having count(*) is NULL;
+---+
| 1 |
+---+
+---+
##remove dummy filter
explain select 1 from t1 having 1 > 2 and count(*) < 3;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |0        |78755|
|1 | TABLE SCAN    |t1  |100000   |59654|
=========================================

Outputs & filters:
-------------------------------------
  0 - output([1]), filter([0], [T_FUN_COUNT(*) < 3]),
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil),
      access([t1.__pk_increment]), partitions(p0)

select 1 from t1 having 1 > 2 and count(*) < 3;
+---+
| 1 |
+---+
+---+
explain select 1 from t1 having 1 = 1 or count(*) < 3;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |78755|
|1 | TABLE SCAN    |t1  |100000   |59654|
=========================================

Outputs & filters:
-------------------------------------
  0 - output([1]), filter([1 OR T_FUN_COUNT(*) < 3]),
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil),
      access([t1.__pk_increment]), partitions(p0)

select 1 from t1 having 1 = 1 or count(*) < 3;
+---+
| 1 |
+---+
| 1 |
+---+
##remove dummy case when
explain select case when 1 then (case when 1 then 1 else count(*) end) else 2 end from t1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |78755|
|1 | TABLE SCAN    |t1  |100000   |59654|
=========================================

Outputs & filters:
-------------------------------------
  0 - output([CASE WHEN 1 THEN CASE WHEN 1 THEN 1 ELSE T_FUN_COUNT(*) END ELSE 2 END]), filter(nil),
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([1]), filter(nil),
      access([t1.__pk_increment]), partitions(p0)

select case when 1 then (case when 1 then 1 else count(*) end) else 2 end from t1;
+--------------------------------------------------------------------+
| case when 1 then (case when 1 then 1 else count(*) end) else 2 end |
+--------------------------------------------------------------------+
|                                                                  1 |
+--------------------------------------------------------------------+
explain select c1 from t1 having (case when 1 then (case when 1 then 1 else count(*) end) else 2 end) = c1;
Query Plan
=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SCALAR GROUP BY|    |1        |80961|
|1 | TABLE SCAN    |t1  |100000   |61860|
=========================================

Outputs & filters:
-------------------------------------
  0 - output([t1.c1]), filter([CASE WHEN 1 THEN CASE WHEN 1 THEN 1 ELSE T_FUN_COUNT(*) END ELSE 2 END = t1.c1]),
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([t1.c1]), filter(nil),
      access([t1.c1]), partitions(p0)

select c1 from t1 having (case when 1 then (case when 1 then 1 else count(*) end) else 2 end) = c1;
+------+
| c1   |
+------+
|    1 |
+------+
drop table t1;

USE DB_SIMPLIFY;
drop database DB_SIMPLIFY;
alter system set _enable_record_rollback_trans_log=true;
ERROR 42000: System config unknown
set autocommit = 1;
