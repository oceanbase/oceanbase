result_format: 4
explain_protocol: 2
DROP DATABASE IF EXISTS DB_PREDICATE_DEDUCE;
CREATE DATABASE DB_PREDICATE_DEDUCE;
USE DB_PREDICATE_DEDUCE;

create table t1(c1 int, c2 int);
create table t2(c1 int , c2 int, c3 int, c4 int);
create table t3(c1 bigint, c2 varchar(64), c3 datetime);
create table is_t1(c1 int);
create table is_t2(c1 int, c2 int);
create table is_t3(c1 bigint, c2 varchar(64), c3 datetime);

insert/*trace*/into t3 values(20101010000000, '020101010000000', '2010-10-10 00:00:00');
insert/*trace*/into t1 values(NULL, NULL);
insert/*trace*/into t2 values(NULL, NULL, NULL, NULL);

= basic test =

== basic compare: case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 = 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 = 2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 = 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([2 = a.c2], [a.c1 = 2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set c1 = c2 + 1  where a.c1 = a.c2 and a.c1 = 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |36          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(cast(2, INT(11, 0)) + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([2 = a.c2], [a.c1 = 2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set c1 = c2 + 1  where a.c1 = a.c2 and a.c1 = 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 = 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |16          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([2 = a.c2], [a.c1 = 2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 = 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 = 2;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |17          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([2 = a.c2], [a.c1 = 2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 = 2;
rollback;


== basic compare: case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 > 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 > 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 > 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 > 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 > 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |29          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 > 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 > 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |11          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 > 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 > 2;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |12          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 > 2;
rollback;


== basic compare: case 3
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 >= 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 >= 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |29          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 >= 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |11          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 >= 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |12          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 >= 2;
rollback;


== basic compare: case 4
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 < 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 < 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 < 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 < 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c2 < 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 < 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 < 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |29          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c2 < 2], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 < 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 < 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |11          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c2 < 2], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 < 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 < 2;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |12          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c2 < 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 < 2;
rollback;


== basic compare: case 5
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 <= 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 <= 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c2 <= 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 <= 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |29          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c2 <= 2], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 <= 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |11          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c2 <= 2], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 <= 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |12          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c2 <= 2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 <= 2;
rollback;


== basic compare: case 6
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 like '2%';
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 like '2%';
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |31          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 like '2%';
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |13          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 like '2%';
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |13          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 like '2%';
rollback;


== basic compare: case 7
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 <= 3], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c2 <= 3], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |28          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 2], [a.c2 <= 3], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 between 2 and 3;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |11          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 2], [a.c2 <= 3], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |11          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c2 <= 3], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
rollback;


== basic compare: case 7
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)], [a.c2 IN (2, 3)]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |36          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)], [a.c2 IN (2, 3)]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 in (2, 3);
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |16          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)], [a.c2 IN (2, 3)]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |17          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)], [a.c2 IN (2, 3)]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
rollback;

************************** deduce on function *******************************

== deduce on function: case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = round(cast(a.c2, BIGINT(-1, 0)))], [round(cast(a.c1, BIGINT(-1, 0))) = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c2, BIGINT(-1, 0))) = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |28          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c2, BIGINT(-1, 0))) = 1]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where round(a.c1) = round(a.c2) and round(a.c1) = 1;
EXPLAIN delete from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |11          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c2, BIGINT(-1, 0))) = 1]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
EXPLAIN insert into is_t2 select * from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |11          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c2, BIGINT(-1, 0))) = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
rollback;


== deduce on function: case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c1, BIGINT(-1, 0))) = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [a.c2 = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |28          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(cast(1, INT(11, 0)) + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [a.c2 = 1]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where round(a.c1) = a.c2 and round(a.c1) = 1;
EXPLAIN delete from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |11          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [a.c2 = 1]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
EXPLAIN insert into is_t2 select * from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |11          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [a.c2 = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
rollback;

***************************** subquery *********************************

== subquery:case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |8           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_EXISTS, subquery(1))]), rowset=16
      exec_params_([a.c1(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([1]), filter([b.c1 = 1]), startup_filter([:0 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
============================================================
|ID|OPERATOR                   |NAME |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |     |1       |8           |
|1 |├─TABLE FULL SCAN          |a    |1       |4           |
|2 |└─MATERIAL                 |     |1       |4           |
|3 |  └─SUBPLAN SCAN           |VIEW1|1       |4           |
|4 |    └─TABLE FULL SCAN      |b    |1       |4           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil), rowset=16
  3 - output(nil), filter(nil), rowset=16
      access(nil)
  4 - output([1]), filter([b.c1 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
==============================================================
|ID|OPERATOR                     |NAME |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |UPDATE                       |     |1       |40          |
|1 |└─NESTED-LOOP JOIN CARTESIAN |     |1       |8           |
|2 |  ├─TABLE FULL SCAN          |a    |1       |4           |
|3 |  └─MATERIAL                 |     |1       |4           |
|4 |    └─SUBPLAN SCAN           |VIEW1|1       |4           |
|5 |      └─TABLE FULL SCAN      |b    |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)}), hash_distinct}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 1]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil)
  5 - output([1]), filter([b.c1 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
EXPLAIN delete from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
==============================================================
|ID|OPERATOR                     |NAME |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |DELETE                       |     |1       |20          |
|1 |└─NESTED-LOOP JOIN CARTESIAN |     |1       |8           |
|2 |  ├─TABLE FULL SCAN          |a    |1       |4           |
|3 |  └─MATERIAL                 |     |1       |4           |
|4 |    └─SUBPLAN SCAN           |VIEW1|1       |4           |
|5 |      └─TABLE FULL SCAN      |b    |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)}), hash_distinct}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 1]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil)
  5 - output([1]), filter([b.c1 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
EXPLAIN insert into is_t2 select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
==========================================================================
|ID|OPERATOR                       |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |INSERT                         |               |1       |21          |
|1 |└─SUBPLAN SCAN                 |ANONYMOUS_VIEW1|1       |8           |
|2 |  └─NESTED-LOOP JOIN CARTESIAN |               |1       |8           |
|3 |    ├─TABLE FULL SCAN          |a              |1       |4           |
|4 |    └─MATERIAL                 |               |1       |4           |
|5 |      └─SUBPLAN SCAN           |VIEW1          |1       |4           |
|6 |        └─TABLE FULL SCAN      |b              |1       |4           |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  3 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  4 - output(nil), filter(nil), rowset=16
  5 - output(nil), filter(nil), rowset=16
      access(nil)
  6 - output([1]), filter([b.c1 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
rollback;


== subquery:case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |8           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([1]), filter([b.c1 = 2]), rowset=16
      access([b.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |8           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([1]), filter([2 = b.c1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |UPDATE             |    |1       |40          |
|1 |└─SUBPLAN FILTER   |    |1       |8           |
|2 |  ├─TABLE FULL SCAN|a   |1       |4           |
|3 |  └─TABLE FULL SCAN|b   |1       |4           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output([1]), filter([2 = b.c1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
EXPLAIN delete from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |DELETE             |    |1       |20          |
|1 |└─SUBPLAN FILTER   |    |1       |8           |
|2 |  ├─TABLE FULL SCAN|a   |1       |4           |
|3 |  └─TABLE FULL SCAN|b   |1       |4           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output([1]), filter([2 = b.c1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
EXPLAIN insert into is_t2 select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
================================================================
|ID|OPERATOR             |NAME           |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------
|0 |INSERT               |               |1       |21          |
|1 |└─SUBPLAN SCAN       |ANONYMOUS_VIEW1|1       |8           |
|2 |  └─SUBPLAN FILTER   |               |1       |8           |
|3 |    ├─TABLE FULL SCAN|a              |1       |4           |
|4 |    └─TABLE FULL SCAN|b              |1       |4           |
================================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  3 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  4 - output([1]), filter([2 = b.c1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
rollback;


== subquery:case 3
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |8           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = ANY(subquery(1))]), rowset=16
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1]), use_batch=false
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1]), filter([b.c1 = 2]), rowset=16
      access([b.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
============================================================
|ID|OPERATOR                   |NAME |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |     |1       |8           |
|1 |├─TABLE FULL SCAN          |a    |1       |4           |
|2 |└─MATERIAL                 |     |1       |4           |
|3 |  └─SUBPLAN SCAN           |VIEW1|1       |4           |
|4 |    └─TABLE FULL SCAN      |b    |1       |4           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil), rowset=16
  3 - output(nil), filter(nil), rowset=16
      access(nil)
  4 - output([1]), filter([b.c1 = 2]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
==============================================================
|ID|OPERATOR                     |NAME |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |UPDATE                       |     |1       |40          |
|1 |└─NESTED-LOOP JOIN CARTESIAN |     |1       |8           |
|2 |  ├─TABLE FULL SCAN          |a    |1       |4           |
|3 |  └─MATERIAL                 |     |1       |4           |
|4 |    └─SUBPLAN SCAN           |VIEW1|1       |4           |
|5 |      └─TABLE FULL SCAN      |b    |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)}), hash_distinct}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil)
  5 - output([1]), filter([b.c1 = 2]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 in (select c1 from t2 b where b.c1 = 2);
EXPLAIN delete from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
==============================================================
|ID|OPERATOR                     |NAME |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |DELETE                       |     |1       |20          |
|1 |└─NESTED-LOOP JOIN CARTESIAN |     |1       |8           |
|2 |  ├─TABLE FULL SCAN          |a    |1       |4           |
|3 |  └─MATERIAL                 |     |1       |4           |
|4 |    └─SUBPLAN SCAN           |VIEW1|1       |4           |
|5 |      └─TABLE FULL SCAN      |b    |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)}), hash_distinct}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil)
  5 - output([1]), filter([b.c1 = 2]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
==========================================================================
|ID|OPERATOR                       |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------------------
|0 |INSERT                         |               |1       |21          |
|1 |└─SUBPLAN SCAN                 |ANONYMOUS_VIEW1|1       |8           |
|2 |  └─NESTED-LOOP JOIN CARTESIAN |               |1       |8           |
|3 |    ├─TABLE FULL SCAN          |a              |1       |4           |
|4 |    └─MATERIAL                 |               |1       |4           |
|5 |      └─SUBPLAN SCAN           |VIEW1          |1       |4           |
|6 |        └─TABLE FULL SCAN      |b              |1       |4           |
==========================================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  3 - output([a.c1], [a.c2]), filter([a.c1 = 2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  4 - output(nil), filter(nil), rowset=16
  5 - output(nil), filter(nil), rowset=16
      access(nil)
  6 - output([1]), filter([b.c1 = 2]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
rollback;

***************************** type check *******************************

== type check: case 1
EXPLAIN select /*+no_rewrite*/* from t3 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|t3  |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([t3.c1], [t3.c2], [t3.c3]), filter([INTERNAL_FUNCTION(t3.c1, 110, 17) = cast('2010-10-10 00:00:00', DATETIME(0, 0))], [cast(t3.c1, DECIMAL(20,
       0)) = cast(t3.c2, DECIMAL(-1, -1))]), rowset=16
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t3 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
+----------------+-----------------+---------------------+
| c1             | c2              | c3                  |
+----------------+-----------------+---------------------+
| 20101010000000 | 020101010000000 | 2010-10-10 00:00:00 |
+----------------+-----------------+---------------------+
EXPLAIN select * from t3 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|t3  |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([t3.c1], [t3.c2], [t3.c3]), filter([INTERNAL_FUNCTION(t3.c1, 110, 17) = cast('2010-10-10 00:00:00', DATETIME(0, 0))], [cast(t3.c1, DECIMAL(20,
       0)) = cast(t3.c2, DECIMAL(-1, -1))]), rowset=16
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
select * from t3 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
+----------------+-----------------+---------------------+
| c1             | c2              | c3                  |
+----------------+-----------------+---------------------+
| 20101010000000 | 020101010000000 | 2010-10-10 00:00:00 |
+----------------+-----------------+---------------------+
start transaction;
EXPLAIN update t3 set c1 = 1  where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |28          |
|1 |└─TABLE FULL SCAN|t3  |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{t3: ({t3: (t3.__pk_increment, t3.c1, t3.c2, t3.c3)})}]),
      update([t3.c1=column_conv(BIGINT,PS:(20,0),NULL,1)])
  1 - output([t3.__pk_increment], [t3.c1], [t3.c2], [t3.c3]), filter([INTERNAL_FUNCTION(t3.c1, 110, 17) = cast('2010-10-10 00:00:00', DATETIME(0, 0))], 
      [cast(t3.c1, DECIMAL(20, 0)) = cast(t3.c2, DECIMAL(-1, -1))]), rowset=16
      access([t3.__pk_increment], [t3.c1], [t3.c2], [t3.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
update t3 set c1 = 1  where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
rollback;

****************************** remove redundant predicates *************

== remove redundant predicates: case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |36          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 = a.c2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |16          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |17          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
rollback;


== remove redundant predicates: case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c2 = a.c1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |36          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c2 = a.c1;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |16          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |17          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
rollback;


== remove redundant predicates: case 3
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2], [a.c1 >= a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |31          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 >= a.c2 and a.c1 >= a.c2;
EXPLAIN delete from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |13          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |13          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
rollback;


== remove redundant predicates: case 4
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2], [a.c2 <= a.c1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |31          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 >= a.c2 and a.c2 <= a.c1;
EXPLAIN delete from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |13          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |13          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
rollback;


== remove redundant predicates: case 5
EXPLAIN select /*+no_rewrite*/* from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2], [a.c1 >= 1], [a.c1 <= 2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |29          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
EXPLAIN delete from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |11          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
EXPLAIN insert into is_t2 select * from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |11          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
rollback;


== remove redundant predicates: case 6
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 IN (2, 3)], [a.c1 IN (2, 3)]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 IN (2, 3)]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |36          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 IN (2, 3)]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 in (2, 3) and a.c1 in (2, 3);
EXPLAIN delete from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |16          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 IN (2, 3)]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |17          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 IN (2, 3)]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
rollback;


== remove redundant predicates: case 7
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |32          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 not in (2, 3) and a.c1 not in (2, 3);
EXPLAIN delete from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |13          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |14          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
rollback;

************************* can not deduce ******************

== can not deduce: case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |33          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 not like '2%';
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |14          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |15          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
rollback;


== can not deduce: case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
===============================================
|ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------
|0 |TABLE FULL SCAN|a   |1       |4           |
===============================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |UPDATE           |    |1       |32          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 not in (2, 3);
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |DELETE           |    |1       |13          |
|1 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
==============================================================
|ID|OPERATOR           |NAME           |EST.ROWS|EST.TIME(us)|
--------------------------------------------------------------
|0 |INSERT             |               |1       |14          |
|1 |└─SUBPLAN SCAN     |ANONYMOUS_VIEW1|1       |4           |
|2 |  └─TABLE FULL SCAN|a              |1       |4           |
==============================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
rollback;

************************* 不能推导 anti semi join ***************

== 不能推导 anti semi join:case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |8           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), rowset=16
      exec_params_([a.c1(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([1]), filter([b.c1 = 1]), startup_filter([:0 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
| NULL | NULL |
+------+------+
EXPLAIN select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=======================================================
|ID|OPERATOR              |NAME |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN |     |0       |8           |
|1 |├─TABLE FULL SCAN     |a    |1       |4           |
|2 |└─MATERIAL            |     |1       |4           |
|3 |  └─SUBPLAN SCAN      |VIEW1|1       |4           |
|4 |    └─TABLE FULL SCAN |b    |1       |4           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=16
      conds([a.c1 = 1]), nl_params_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil), rowset=16
  3 - output(nil), filter(nil), rowset=16
      access(nil)
  4 - output([1]), filter([b.c1 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
| NULL | NULL |
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=========================================================
|ID|OPERATOR                |NAME |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |UPDATE                  |     |0       |32          |
|1 |└─NESTED-LOOP ANTI JOIN |     |0       |8           |
|2 |  ├─TABLE FULL SCAN     |a    |1       |4           |
|3 |  └─MATERIAL            |     |1       |4           |
|4 |    └─SUBPLAN SCAN      |VIEW1|1       |4           |
|5 |      └─TABLE FULL SCAN |b    |1       |4           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      conds([a.c1 = 1]), nl_params_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil)
  5 - output([1]), filter([b.c1 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
EXPLAIN delete from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=========================================================
|ID|OPERATOR                |NAME |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |DELETE                  |     |0       |15          |
|1 |└─NESTED-LOOP ANTI JOIN |     |0       |8           |
|2 |  ├─TABLE FULL SCAN     |a    |1       |4           |
|3 |  └─MATERIAL            |     |1       |4           |
|4 |    └─SUBPLAN SCAN      |VIEW1|1       |4           |
|5 |      └─TABLE FULL SCAN |b    |1       |4           |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      conds([a.c1 = 1]), nl_params_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil)
  5 - output([1]), filter([b.c1 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
EXPLAIN insert into is_t2 select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=====================================================================
|ID|OPERATOR                  |NAME           |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------
|0 |INSERT                    |               |0       |15          |
|1 |└─SUBPLAN SCAN            |ANONYMOUS_VIEW1|0       |8           |
|2 |  └─NESTED-LOOP ANTI JOIN |               |0       |8           |
|3 |    ├─TABLE FULL SCAN     |a              |1       |4           |
|4 |    └─MATERIAL            |               |1       |4           |
|5 |      └─SUBPLAN SCAN      |VIEW1          |1       |4           |
|6 |        └─TABLE FULL SCAN |b              |1       |4           |
=====================================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
      conds([a.c1 = 1]), nl_params_(nil), use_batch=false
  3 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  4 - output(nil), filter(nil), rowset=16
  5 - output(nil), filter(nil), rowset=16
      access(nil)
  6 - output([1]), filter([b.c1 = 1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
rollback;


== 能推导 anti semi join:case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |8           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([1]), filter([b.c1 = 2]), rowset=16
      access([b.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |8           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([1]), filter([2 = b.c1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |UPDATE             |    |1       |40          |
|1 |└─SUBPLAN FILTER   |    |1       |8           |
|2 |  ├─TABLE FULL SCAN|a   |1       |4           |
|3 |  └─TABLE FULL SCAN|b   |1       |4           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output([1]), filter([2 = b.c1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
EXPLAIN delete from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |DELETE             |    |1       |20          |
|1 |└─SUBPLAN FILTER   |    |1       |8           |
|2 |  ├─TABLE FULL SCAN|a   |1       |4           |
|3 |  └─TABLE FULL SCAN|b   |1       |4           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output([1]), filter([2 = b.c1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
EXPLAIN insert into is_t2 select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
================================================================
|ID|OPERATOR             |NAME           |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------
|0 |INSERT               |               |1       |21          |
|1 |└─SUBPLAN SCAN       |ANONYMOUS_VIEW1|1       |8           |
|2 |  └─SUBPLAN FILTER   |               |1       |8           |
|3 |    ├─TABLE FULL SCAN|a              |1       |4           |
|4 |    └─TABLE FULL SCAN|b              |1       |4           |
================================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  3 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([:0]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  4 - output([1]), filter([2 = b.c1]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
rollback;


== 不能推导 anti semi join:case 3
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |8           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 != ALL(subquery(1))]), rowset=16
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1]), use_batch=false
  1 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1]), filter(nil), rowset=16
      access([b.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite*/* from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
=================================================================
|ID|OPERATOR                        |NAME |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN CARTESIAN |     |0       |8           |
|1 |├─TABLE FULL SCAN               |a    |1       |4           |
|2 |└─MATERIAL                      |     |1       |4           |
|3 |  └─SUBPLAN SCAN                |VIEW1|1       |4           |
|4 |    └─TABLE FULL SCAN           |b    |1       |4           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil), rowset=16
  3 - output(nil), filter(nil), rowset=16
      access(nil)
  4 - output([1]), filter([b.c1 = 1 OR b.c1 IS NULL]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
===================================================================
|ID|OPERATOR                          |NAME |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |UPDATE                            |     |0       |32          |
|1 |└─NESTED-LOOP ANTI JOIN CARTESIAN |     |0       |8           |
|2 |  ├─TABLE FULL SCAN               |a    |1       |4           |
|3 |  └─MATERIAL                      |     |1       |4           |
|4 |    └─SUBPLAN SCAN                |VIEW1|1       |4           |
|5 |      └─TABLE FULL SCAN           |b    |1       |4           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 1]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil)
  5 - output([1]), filter([b.c1 = 1 OR b.c1 IS NULL]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
update t1 a set a.c1 = a.c2 + 1 where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
EXPLAIN delete from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
===================================================================
|ID|OPERATOR                          |NAME |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |DELETE                            |     |0       |15          |
|1 |└─NESTED-LOOP ANTI JOIN CARTESIAN |     |0       |8           |
|2 |  ├─TABLE FULL SCAN               |a    |1       |4           |
|3 |  └─MATERIAL                      |     |1       |4           |
|4 |    └─SUBPLAN SCAN                |VIEW1|1       |4           |
|5 |      └─TABLE FULL SCAN           |b    |1       |4           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 1]), rowset=16
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil)
  5 - output([1]), filter([b.c1 = 1 OR b.c1 IS NULL]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
delete from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
===============================================================================
|ID|OPERATOR                            |NAME           |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------
|0 |INSERT                              |               |0       |15          |
|1 |└─SUBPLAN SCAN                      |ANONYMOUS_VIEW1|0       |8           |
|2 |  └─NESTED-LOOP ANTI JOIN CARTESIAN |               |0       |8           |
|3 |    ├─TABLE FULL SCAN               |a              |1       |4           |
|4 |    └─MATERIAL                      |               |1       |4           |
|5 |      └─SUBPLAN SCAN                |VIEW1          |1       |4           |
|6 |        └─TABLE FULL SCAN           |b              |1       |4           |
===============================================================================
Outputs & filters:
-------------------------------------
  0 - output(nil), filter(nil)
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=16
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  3 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  4 - output(nil), filter(nil), rowset=16
  5 - output(nil), filter(nil), rowset=16
      access(nil)
  6 - output([1]), filter([b.c1 = 1 OR b.c1 IS NULL]), rowset=16
      access([b.c1]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
insert into is_t2 select * from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
rollback;

************************* 不能推导 anti semi join ***************

EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 IS NOT NULL]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 IS NOT NULL]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 IS NOT NULL]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 IS NOT NULL]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is null;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE JOIN         |    |0       |8           |
|1 |├─TABLE FULL SCAN  |b   |0       |4           |
|2 |└─SORT             |    |1       |4           |
|3 |  └─TABLE FULL SCAN|a   |1       |4           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 IS NULL]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
      sort_keys([a.c1, ASC])
  3 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is null;
Query Plan
===========================================================
|ID|OPERATOR                   |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1       |8           |
|1 |├─TABLE FULL SCAN          |b   |1       |4           |
|2 |└─MATERIAL                 |    |1       |4           |
|3 |  └─TABLE FULL SCAN        |a   |1       |4           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), startup_filter([0]), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
  3 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> null;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |0       |8           |
|1 |├─TABLE FULL SCAN|b   |0       |4           |
|2 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> NULL]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> null;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |0       |8           |
|1 |├─TABLE FULL SCAN|b   |0       |4           |
|2 |└─TABLE FULL SCAN|a   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> NULL]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
  2 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> 1]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> 1]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 <=> b.c1 and b.c1 <=> 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 <=> b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> 1]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 <=> b.c1 and b.c1 <=> 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 <=> b.c1 and b.c1 <=> 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|a   |1       |4           |
|2 |└─TABLE FULL SCAN|b   |1       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=16
      equal_conds([a.c1 <=> b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=16
      access([a.c1], [a.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([a.__pk_increment]), range(MIN ; MAX)always true
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> 1]), rowset=16
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([b.__pk_increment]), range(MIN ; MAX)always true
select * from t1 a, t2 b where a.c1 <=> b.c1 and b.c1 <=> 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

####### outer join 谓词推导测试 #######
drop table if exists tt1, tt2, tt3;
create table tt1 (c1 int primary key, c2 varchar(10));
create table tt2 (c1 int primary key, c2 varchar(10));
create table tt3 (c1 int primary key, c2 varchar(10));

## tt1 left join tt2
EXPLAIN select /*+use_merge(tt1 tt2)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 where tt1.c1 = 1;
Query Plan
=================================================================
|ID|OPERATOR                         |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN |    |1       |6           |
|1 |├─TABLE GET                      |tt1 |1       |3           |
|2 |└─TABLE GET                      |tt2 |1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range[1 ; 1], 
      range_cond([tt1.c1 = 1])
  2 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range[1 ; 1], 
      range_cond([tt2.c1 = 1])
select /*+use_merge(tt1 tt2)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 where tt1.c1 = 1;
+----+------+----+------+
| c1 | c2   | c1 | c2   |
+----+------+----+------+
|  1 | a1   | NULL | NULL |
+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 where tt1.c1 = 1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |MERGE OUTER JOIN |    |1       |7           |
|1 |├─TABLE GET      |tt1 |1       |3           |
|2 |└─TABLE FULL SCAN|tt2 |2       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=16
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range[1 ; 1], 
      range_cond([tt1.c1 = 1])
  2 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range(MIN ; MAX)always true
select /*+no_rewrite, use_merge(tt1 tt2)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 where tt1.c1 = 1;
+----+------+----+------+
| c1 | c2   | c1 | c2   |
+----+------+----+------+
|  1 | a1   | NULL | NULL |
+----+------+----+------+

## tt1 left join tt2 left join tt3
EXPLAIN select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
===================================================================
|ID|OPERATOR                           |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN   |    |1       |9           |
|1 |├─NESTED-LOOP OUTER JOIN CARTESIAN |    |1       |6           |
|2 |│ ├─TABLE GET                      |tt1 |1       |3           |
|3 |│ └─TABLE GET                      |tt2 |1       |3           |
|4 |└─TABLE GET                        |tt3 |1       |3           |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range[1 ; 1], 
      range_cond([tt1.c1 = 1])
  3 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range[1 ; 1], 
      range_cond([tt2.c1 = 1])
  4 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=16
      access([tt3.c1], [tt3.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt3.c1]), range[1 ; 1], 
      range_cond([tt3.c1 = 1])
select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
|  1 | a1   | NULL | NULL | NULL | NULL |
+----+------+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE OUTER JOIN   |    |1       |11          |
|1 |├─MERGE OUTER JOIN |    |1       |7           |
|2 |│ ├─TABLE GET      |tt1 |1       |3           |
|3 |│ └─TABLE FULL SCAN|tt2 |2       |4           |
|4 |└─TABLE FULL SCAN  |tt3 |2       |4           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=16
      equal_conds([tt1.c1 = tt3.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=16
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
      merge_directions([ASC])
  2 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range[1 ; 1], 
      range_cond([tt1.c1 = 1])
  3 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range(MIN ; MAX)always true
  4 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=16
      access([tt3.c1], [tt3.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt3.c1]), range(MIN ; MAX)always true
select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
|  1 | a1   | NULL | NULL | NULL | NULL |
+----+------+----+------+----+------+

## tt1 left join tt2 left join tt3
EXPLAIN select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
=================================================================
|ID|OPERATOR                         |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN |    |1       |10          |
|1 |├─TABLE GET                      |tt1 |1       |3           |
|2 |└─MERGE OUTER JOIN               |    |1       |7           |
|3 |  ├─TABLE GET                    |tt2 |1       |3           |
|4 |  └─TABLE FULL SCAN              |tt3 |2       |4           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range[1 ; 1], 
      range_cond([tt1.c1 = 1])
  2 - output([tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=16
      equal_conds([tt2.c1 = tt3.c1]), other_conds(nil)
      merge_directions([ASC])
  3 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range[1 ; 1], 
      range_cond([tt2.c1 = 1])
  4 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=16
      access([tt3.c1], [tt3.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt3.c1]), range(MIN ; MAX)always true
select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
|  1 | a1   | NULL | NULL | NULL | NULL |
+----+------+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE OUTER JOIN   |    |1       |11          |
|1 |├─MERGE OUTER JOIN |    |1       |7           |
|2 |│ ├─TABLE GET      |tt1 |1       |3           |
|3 |│ └─TABLE FULL SCAN|tt2 |2       |4           |
|4 |└─TABLE FULL SCAN  |tt3 |2       |4           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=16
      equal_conds([tt2.c1 = tt3.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=16
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
      merge_directions([ASC])
  2 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range[1 ; 1], 
      range_cond([tt1.c1 = 1])
  3 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range(MIN ; MAX)always true
  4 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=16
      access([tt3.c1], [tt3.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt3.c1]), range(MIN ; MAX)always true
select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
|  1 | a1   | NULL | NULL | NULL | NULL |
+----+------+----+------+----+------+

## tt3 left join (tt1 left join tt2)
EXPLAIN select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
=================================================================
|ID|OPERATOR                         |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN |    |1       |9           |
|1 |├─NESTED-LOOP JOIN CARTESIAN     |    |1       |6           |
|2 |│ ├─TABLE GET                    |tt3 |1       |3           |
|3 |│ └─TABLE GET                    |tt1 |1       |3           |
|4 |└─TABLE GET                      |tt2 |1       |3           |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([tt1.c1], [tt1.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  2 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=16
      access([tt3.c1], [tt3.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt3.c1]), range[1 ; 1], 
      range_cond([tt3.c1 = 1])
  3 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range[1 ; 1], 
      range_cond([tt1.c1 = 1])
  4 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range[1 ; 1], 
      range_cond([tt2.c1 = 1])
select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
+----+------+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE OUTER JOIN   |    |1       |13          |
|1 |├─TABLE FULL SCAN  |tt3 |2       |4           |
|2 |└─MERGE OUTER JOIN |    |3       |9           |
|3 |  ├─TABLE FULL SCAN|tt1 |3       |4           |
|4 |  └─TABLE FULL SCAN|tt2 |2       |4           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter([tt1.c1 = 1]), rowset=16
      equal_conds([tt1.c1 = tt3.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=16
      access([tt3.c1], [tt3.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt3.c1]), range(MIN ; MAX)always true
  2 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=16
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
      merge_directions([ASC])
  3 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true
  4 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range(MIN ; MAX)always true
select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
+----+------+----+------+----+------+

## tt3 left join (tt1 left join tt2)
EXPLAIN select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
=============================================================
|ID|OPERATOR                     |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN   |    |1       |9           |
|1 |├─TABLE GET                  |tt2 |1       |3           |
|2 |└─NESTED-LOOP JOIN CARTESIAN |    |1       |6           |
|3 |  ├─TABLE GET                |tt3 |1       |3           |
|4 |  └─TABLE GET                |tt1 |1       |3           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range[1 ; 1], 
      range_cond([tt2.c1 = 1])
  2 - output([tt1.c1], [tt1.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  3 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=16
      access([tt3.c1], [tt3.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt3.c1]), range[1 ; 1], 
      range_cond([tt3.c1 = 1])
  4 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range[1 ; 1], 
      range_cond([tt1.c1 = 1])
select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
+----+------+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
===========================================================
|ID|OPERATOR                   |NAME|EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------
|0 |MERGE OUTER JOIN           |    |1       |13          |
|1 |├─TABLE FULL SCAN          |tt3 |2       |4           |
|2 |└─SORT                     |    |3       |9           |
|3 |  └─MERGE RIGHT OUTER JOIN |    |3       |8           |
|4 |    ├─TABLE FULL SCAN      |tt2 |2       |4           |
|5 |    └─TABLE FULL SCAN      |tt1 |3       |4           |
===========================================================
Outputs & filters:
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter([tt1.c1 = 1]), rowset=16
      equal_conds([tt2.c1 = tt3.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=16
      access([tt3.c1], [tt3.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt3.c1]), range(MIN ; MAX)always true
  2 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=16
      sort_keys([tt2.c1, ASC])
  3 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=16
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
      merge_directions([ASC])
  4 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=16
      access([tt2.c1], [tt2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt2.c1]), range(MIN ; MAX)always true
  5 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=16
      access([tt1.c1], [tt1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true
select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
+----+------+----+------+----+------+

## online case
drop table if exists cghldinf, puzdjypf, pujydypf;
CREATE TABLE `cghldinf` (
    `HLDGDDM` char(10) NOT NULL,
    `HLDZXWH` char(5)  NOT NULL,
    `HLDTGDM` decimal(9, 0) NOT NULL,
    `HLDKMLB` char(2) NOT NULL,
    PRIMARY KEY (`HLDTGDM`, `HLDGDDM`),
    KEY `HLDINDEX` (`HLDKMLB`) LOCAL
    ) partition by key (hldgddm) partitions 13;

CREATE TABLE `puzdjypf` (
    `PZJZQZH` char(20) NOT NULL,
    `PZJZDJYDY` char(6) NOT NULL,
    `PZJSXRQ` decimal(8,0) NOT NULL,
    PRIMARY KEY (`PZJZQZH`)
    ) partition by key (pzjzqzh) partitions 13;

CREATE TABLE `pujydypf` (
    `PJYSCDM` char(2) NOT NULL,
    `PJYJYDY` char(6) NOT NULL,
    `PJYJYDYLB` char(3) NOT NULL,
    `PJYQSBH` char(8) NOT NULL
    ) partition by key (pjyjydy) partitions 2;

EXPLAIN select /*+use_merge(t1 t2), leading(t1 t2 t3)*/ t1.hldgddm, t2.pzjzqzh, t2.pzjzdjydy, t3.pjyjydy, t3.pjyscdm from cghldinf t1 left join puzdjypf t2 on t2.pzjzqzh = t1.hldgddm left join pujydypf t3 on t2.pzjzdjydy = t3.pjyjydy and t3.pjyscdm = '01' where hldgddm = 'A100013208';
Query Plan
===============================================================================
|ID|OPERATOR                                   |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------
|0 |PX COORDINATOR                             |        |1       |19          |
|1 |└─EXCHANGE OUT DISTR                       |:EX10001|1       |19          |
|2 |  └─HASH OUTER JOIN                        |        |1       |17          |
|3 |    ├─EXCHANGE IN DISTR                    |        |1       |9           |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)          |:EX10000|1       |8           |
|5 |    │   └─NESTED-LOOP OUTER JOIN CARTESIAN |        |1       |7           |
|6 |    │     ├─TABLE FULL SCAN                |t1      |1       |4           |
|7 |    │     └─MATERIAL                       |        |1       |3           |
|8 |    │       └─TABLE GET                    |t2      |1       |3           |
|9 |    └─PX PARTITION ITERATOR                |        |1       |8           |
|10|      └─TABLE FULL SCAN                    |t3      |1       |8           |
===============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.HLDGDDM, t2.PZJZQZH, t2.PZJZDJYDY, t3.PJYJYDY, t3.PJYSCDM)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.HLDGDDM, t2.PZJZQZH, t2.PZJZDJYDY, t3.PJYJYDY, t3.PJYSCDM)]), filter(nil), rowset=16
      dop=1
  2 - output([t2.PZJZDJYDY], [t3.PJYJYDY], [t1.HLDGDDM], [t2.PZJZQZH], [t3.PJYSCDM]), filter(nil), rowset=16
      equal_conds([t2.PZJZDJYDY = t3.PJYJYDY]), other_conds(nil)
  3 - output([t2.PZJZDJYDY], [t1.HLDGDDM], [t2.PZJZQZH]), filter(nil), rowset=16
  4 - output([t2.PZJZDJYDY], [t1.HLDGDDM], [t2.PZJZQZH]), filter(nil), rowset=16
      (#keys=1, [t2.PZJZDJYDY]), is_single, dop=1
  5 - output([t2.PZJZDJYDY], [t1.HLDGDDM], [t2.PZJZQZH]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  6 - output([t1.HLDGDDM]), filter([t1.HLDGDDM = 'A100013208']), rowset=16
      access([t1.HLDGDDM]), partitions(p5)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.HLDTGDM], [t1.HLDGDDM]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.PZJZDJYDY], [t2.PZJZQZH]), filter(nil), rowset=16
  8 - output([t2.PZJZQZH], [t2.PZJZDJYDY]), filter(nil), rowset=16
      access([t2.PZJZQZH], [t2.PZJZDJYDY]), partitions(p5)
      is_index_back=false, is_global_index=false, 
      range_key([t2.PZJZQZH]), range[A100013208 ; A100013208], 
      range_cond([t2.PZJZQZH = 'A100013208'])
  9 - output([t3.PJYJYDY], [t3.PJYSCDM]), filter(nil), rowset=16
      affinitize, force partition granule
 10 - output([t3.PJYJYDY], [t3.PJYSCDM]), filter([t3.PJYSCDM = '01']), rowset=16
      access([t3.PJYJYDY], [t3.PJYSCDM]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2), leading(t1 t2 t3)*/ t1.hldgddm, t2.pzjzqzh, t2.pzjzdjydy, t3.pjyjydy, t3.pjyscdm from cghldinf t1 left join puzdjypf t2 on t2.pzjzqzh = t1.hldgddm left join pujydypf t3 on t2.pzjzdjydy = t3.pjyjydy and t3.pjyscdm = '01' where hldgddm = 'A100013208';
+------------+------------+-----------+---------+---------+
| hldgddm    | pzjzqzh    | pzjzdjydy | pjyjydy | pjyscdm |
+------------+------------+-----------+---------+---------+
| A100013208 | A100013208 | 20605     | NULL    | NULL    |
| A100013208 | A100013208 | 20605     | NULL    | NULL    |
+------------+------------+-----------+---------+---------+
EXPLAIN select /*+no_rewrite, use_merge(t1 t2), leading(t1 t2 t3)*/ t1.hldgddm, t2.pzjzqzh, t2.pzjzdjydy, t3.pjyjydy, t3.pjyscdm from cghldinf t1 left join puzdjypf t2 on t2.pzjzqzh = t1.hldgddm left join pujydypf t3 on t2.pzjzdjydy = t3.pjyjydy and t3.pjyscdm = '01' where hldgddm = 'A100013208';
Query Plan
===============================================================================
|ID|OPERATOR                               |NAME        |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------
|0 |PX COORDINATOR                         |            |2       |72          |
|1 |└─EXCHANGE OUT DISTR                   |:EX10002    |2       |71          |
|2 |  └─HASH OUTER JOIN                    |            |2       |67          |
|3 |    ├─EXCHANGE IN DISTR                |            |2       |58          |
|4 |    │ └─EXCHANGE OUT DISTR (PKEY)      |:EX10001    |2       |57          |
|5 |    │   └─MERGE OUTER JOIN             |            |2       |55          |
|6 |    │     ├─EXCHANGE IN DISTR          |            |2       |5           |
|7 |    │     │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000    |2       |5           |
|8 |    │     │   └─TABLE FULL SCAN        |t1(HLDINDEX)|2       |4           |
|9 |    │     └─SORT                       |            |1       |50          |
|10|    │       └─PX PARTITION ITERATOR    |            |1       |50          |
|11|    │         └─TABLE FULL SCAN        |t2          |1       |50          |
|12|    └─PX PARTITION ITERATOR            |            |1       |8           |
|13|      └─TABLE FULL SCAN                |t3          |1       |8           |
===============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.HLDGDDM, t2.PZJZQZH, t2.PZJZDJYDY, t3.PJYJYDY, t3.PJYSCDM)]), filter(nil), rowset=16
  1 - output([INTERNAL_FUNCTION(t1.HLDGDDM, t2.PZJZQZH, t2.PZJZDJYDY, t3.PJYJYDY, t3.PJYSCDM)]), filter(nil), rowset=16
      dop=1
  2 - output([t2.PZJZDJYDY], [t3.PJYJYDY], [t2.PZJZQZH], [t1.HLDGDDM], [t3.PJYSCDM]), filter(nil), rowset=16
      equal_conds([t2.PZJZDJYDY = t3.PJYJYDY]), other_conds(nil)
  3 - output([t2.PZJZDJYDY], [t2.PZJZQZH], [t1.HLDGDDM]), filter(nil), rowset=16
  4 - output([t2.PZJZDJYDY], [t2.PZJZQZH], [t1.HLDGDDM]), filter(nil), rowset=16
      (#keys=1, [t2.PZJZDJYDY]), dop=1
  5 - output([t2.PZJZDJYDY], [t2.PZJZQZH], [t1.HLDGDDM]), filter(nil), rowset=16
      equal_conds([t2.PZJZQZH = t1.HLDGDDM]), other_conds(nil)
      merge_directions([ASC])
  6 - output([t1.HLDGDDM]), filter(nil), rowset=16
  7 - output([t1.HLDGDDM]), filter(nil), rowset=16
      (#keys=1, [t1.HLDGDDM]), is_single, dop=1
  8 - output([t1.HLDGDDM]), filter([t1.HLDGDDM = 'A100013208']), rowset=16
      access([t1.HLDGDDM]), partitions(p5)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.HLDKMLB], [t1.HLDTGDM], [t1.HLDGDDM]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  9 - output([t2.PZJZDJYDY], [t2.PZJZQZH]), filter(nil), rowset=16
      sort_keys([t2.PZJZQZH, ASC]), local merge sort
 10 - output([t2.PZJZQZH], [t2.PZJZDJYDY]), filter(nil), rowset=16
      affinitize, force partition granule
 11 - output([t2.PZJZQZH], [t2.PZJZDJYDY]), filter(nil), rowset=16
      access([t2.PZJZQZH], [t2.PZJZDJYDY]), partitions(p[0-12])
      is_index_back=false, is_global_index=false, 
      range_key([t2.PZJZQZH]), range(MIN ; MAX)always true
 12 - output([t3.PJYJYDY], [t3.PJYSCDM]), filter(nil), rowset=16
      affinitize, force partition granule
 13 - output([t3.PJYJYDY], [t3.PJYSCDM]), filter([t3.PJYSCDM = '01']), rowset=16
      access([t3.PJYJYDY], [t3.PJYSCDM]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite, use_merge(t1 t2), leading(t1 t2 t3)*/ t1.hldgddm, t2.pzjzqzh, t2.pzjzdjydy, t3.pjyjydy, t3.pjyscdm from cghldinf t1 left join puzdjypf t2 on t2.pzjzqzh = t1.hldgddm left join pujydypf t3 on t2.pzjzdjydy = t3.pjyjydy and t3.pjyscdm = '01' where hldgddm = 'A100013208';
+------------+------------+-----------+---------+---------+
| hldgddm    | pzjzqzh    | pzjzdjydy | pjyjydy | pjyscdm |
+------------+------------+-----------+---------+---------+
| A100013208 | A100013208 | 20605     | NULL    | NULL    |
| A100013208 | A100013208 | 20605     | NULL    | NULL    |
+------------+------------+-----------+---------+---------+

## bug: 
drop table if exists t1, t2;
create table t1 (c1 int, c2 int, primary key(c1));
create table t2 (c1 int, c2 int, primary key(c2));

explain extended_noaddr select count(*) from t1 A, t2 B where A.c1 >= 5630905 and A.c1 < 5631105 and A.c1 = B.c2 and A.c2 = B.c2;
Query Plan
=========================================================
|ID|OPERATOR                 |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------------
|0 |SCALAR GROUP BY          |    |1       |6           |
|1 |└─NESTED-LOOP JOIN       |    |1       |6           |
|2 |  ├─TABLE RANGE SCAN     |A   |1       |4           |
|3 |  └─DISTRIBUTED TABLE GET|B   |1       |18          |
=========================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter(nil), rowset=16
      conds(nil), nl_params_([A.c1(:0)]), use_batch=true
  2 - output([A.c1]), filter([A.c2 < 5631105], [A.c1 = A.c2]), rowset=16
      access([A.c1], [A.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([A.c1]), range[5630905 ; 5631105), 
      range_cond([A.c1 >= 5630905], [A.c1 < 5631105])
  3 - output(nil), filter(nil), rowset=16
      access([GROUP_ID]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([B.c2]), range(MIN ; MAX), 
      range_cond([:0 = B.c2])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1 > SEL$0208448F
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$0208448F" ("db_predicate_deduce"."A"@"SEL$1" "db_predicate_deduce"."B"@"SEL$1"))
      USE_NL(@"SEL$0208448F" "db_predicate_deduce"."B"@"SEL$1")
      FULL(@"SEL$0208448F" "A"@"SEL$1")
      FULL(@"SEL$0208448F" "B"@"SEL$1")
      USE_DAS(@"SEL$0208448F" "B"@"SEL$1")
      PRED_DEDUCE(@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  A:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats version:0
      dynamic sampling level:1
  B:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats version:0
      dynamic sampling level:1
  Plan Type:
      LOCAL
  Note:
      Degree of Parallelisim is 1 because of table property

drop table t1, t2;
create table t1 (c1 int, c2 int, index (c1));
create table t2 (c1 int, c2 int, index (c2));

explain extended_noaddr select count(*) from t1 A, t2 B where A.c1 >= 5630905 and A.c1 < 5631105 and A.c1 = B.c2 and A.c2 = B.c2;
Query Plan
=================================================================
|ID|OPERATOR                        |NAME |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |SCALAR GROUP BY                 |     |1       |9           |
|1 |└─NESTED-LOOP JOIN              |     |1       |9           |
|2 |  ├─TABLE RANGE SCAN            |A(c1)|1       |7           |
|3 |  └─DISTRIBUTED TABLE RANGE SCAN|B(c2)|1       |18          |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter(nil), rowset=16
      conds(nil), nl_params_([A.c1(:0)]), use_batch=true
  2 - output([A.c1]), filter([A.c2 < 5631105], [A.c1 = A.c2]), rowset=16
      access([A.__pk_increment], [A.c1], [A.c2]), partitions(p0)
      is_index_back=true, is_global_index=false, filter_before_indexback[false,false], 
      range_key([A.c1], [A.__pk_increment]), range(5630905,MIN ; 5631105,MIN), 
      range_cond([A.c1 >= 5630905], [A.c1 < 5631105])
  3 - output(nil), filter(nil), rowset=16
      access([GROUP_ID]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([B.c2], [B.__pk_increment]), range(MIN ; MAX), 
      range_cond([:0 = B.c2])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1 > SEL$0208448F
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$0208448F" ("db_predicate_deduce"."A"@"SEL$1" "db_predicate_deduce"."B"@"SEL$1"))
      USE_NL(@"SEL$0208448F" "db_predicate_deduce"."B"@"SEL$1")
      INDEX(@"SEL$0208448F" "A"@"SEL$1" "c1")
      INDEX(@"SEL$0208448F" "B"@"SEL$1" "c2")
      USE_DAS(@"SEL$0208448F" "B"@"SEL$1")
      PRED_DEDUCE(@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  A:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:1
      output_rows:0
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[c1, t1]
      unstable_index_name:[t1]
      stats version:0
      dynamic sampling level:1
  B:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[c2, t2]
      pruned_index_name:[t2]
      stats version:0
      dynamic sampling level:1
  Plan Type:
      LOCAL
  Note:
      Degree of Parallelisim is 1 because of table property

drop table t1, t2;
create table t1 (c1 int, c2 int) partition by hash(c1) partitions 4;
create table t2 (c1 int, c2 int) partition by hash(c2) partitions 4;

explain extended_noaddr select count(*) from t1 A, t2 B where A.c1 >= 5630905 and A.c1 < 5631105 and A.c1 = B.c2 and A.c2 = B.c2;
Query Plan
=================================================================
|ID|OPERATOR                     |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------
|0 |SCALAR GROUP BY              |        |1       |32          |
|1 |└─PX COORDINATOR             |        |1       |32          |
|2 |  └─EXCHANGE OUT DISTR       |:EX10000|1       |32          |
|3 |    └─MERGE GROUP BY         |        |1       |31          |
|4 |      └─PX PARTITION ITERATOR|        |1       |31          |
|5 |        └─HASH JOIN          |        |1       |31          |
|6 |          ├─TABLE FULL SCAN  |B       |1       |16          |
|7 |          └─TABLE FULL SCAN  |A       |1       |16          |
=================================================================
Outputs & filters:
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=16
  2 - output([T_FUN_COUNT(*)]), filter(nil), rowset=16
      dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), rowset=16
      partition wise, force partition granule
  5 - output(nil), filter(nil), rowset=16
      equal_conds([A.c1 = B.c2]), other_conds(nil)
  6 - output([B.c2]), filter([B.c2 < 5631105], [B.c2 >= 5630905]), rowset=16
      access([B.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([B.__pk_increment]), range(MIN ; MAX)always true
  7 - output([A.c1]), filter([A.c1 >= 5630905], [A.c1 < 5631105], [A.c2 < 5631105], [A.c1 = A.c2]), rowset=16
      access([A.c1], [A.c2]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false,false], 
      range_key([A.__pk_increment]), range(MIN ; MAX)always true
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1 > SEL$0208448F
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      GBY_PUSHDOWN(@"SEL$0208448F")
      LEADING(@"SEL$0208448F" ("db_predicate_deduce"."B"@"SEL$1" "db_predicate_deduce"."A"@"SEL$1"))
      USE_HASH(@"SEL$0208448F" "db_predicate_deduce"."A"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$0208448F" "db_predicate_deduce"."A"@"SEL$1" NONE NONE)
      FULL(@"SEL$0208448F" "B"@"SEL$1")
      FULL(@"SEL$0208448F" "A"@"SEL$1")
      PRED_DEDUCE(@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  B:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t2]
      stats version:0
      dynamic sampling level:1
  A:
      table_rows:1
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats version:0
      dynamic sampling level:1
  Plan Type:
      DISTRIBUTED
  Note:
      Degree of Parallelisim is 1 because of table property


drop table if exists t1, t2, t3;
drop table if exists tt1, tt2, tt3;
drop table if exists cghldinf, puzdjypf, pujydypf;
drop table if exists v0;
CREATE TABLE v0 ( v1 varchar(127));
EXPLAIN select * from v0 where v1 in (select -127 minus select _BINARY 'x');
Query Plan
============================================================
|ID|OPERATOR                   |NAME |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |     |1       |4           |
|1 |├─TABLE FULL SCAN          |v0   |1       |4           |
|2 |└─MATERIAL                 |     |1       |1           |
|3 |  └─SUBPLAN SCAN           |VIEW1|1       |1           |
|4 |    └─EXPRESSION           |     |1       |1           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([v0.v1]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([v0.v1]), filter([v0.v1 = cast(cast(-127, VARCHAR(20)), VARCHAR(20))]), rowset=16
      access([v0.v1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([v0.__pk_increment]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil), rowset=16
  3 - output(nil), filter(nil), rowset=16
      access(nil)
  4 - output([1]), filter(nil)
      values({1})
select * from v0 where v1 in (select -127 minus select _BINARY 'x');
+------+
| v1   |
+------+
+------+
explain select * from v0 where v1 in (select -127 minus select _BINARY 'x');
Query Plan
============================================================
|ID|OPERATOR                   |NAME |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |     |1       |4           |
|1 |├─TABLE FULL SCAN          |v0   |1       |4           |
|2 |└─MATERIAL                 |     |1       |1           |
|3 |  └─SUBPLAN SCAN           |VIEW1|1       |1           |
|4 |    └─EXPRESSION           |     |1       |1           |
============================================================
Outputs & filters:
-------------------------------------
  0 - output([v0.v1]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  1 - output([v0.v1]), filter([v0.v1 = cast(cast(-127, VARCHAR(20)), VARCHAR(20))]), rowset=16
      access([v0.v1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([v0.__pk_increment]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil), rowset=16
  3 - output(nil), filter(nil), rowset=16
      access(nil)
  4 - output([1]), filter(nil)
      values({1})
drop table if exists v0;

explain_protocol: 0
drop table if exists t1;
drop table if exists t2;
drop table if exists t3;
create table t1(c1 decimal(10), c2 varchar(10), c3 varbinary(20));
insert into t1(c1,c2) values(10,'a'),(20,'ab'),(50,'ad'),(100,'b'),(150,'c');
create table t2(c1 decimal(20), c2 double, c3 varchar(20));
insert into t2(c1,c2,c3) values(10,10,'a'),(20,20,'b'),(50,50,NULL),(100,100,NULL),(150,150,NULL);
create table t3(c1 decimal(16), c2 float);
insert into t3(c1,c2) values(10,10),(20,20),(50,50),(100,100),(150,150);
explain_protocol: 2
test IN pred
### different accuracy
EXPLAIN select t1.c1,t2.c1 from t1,t2 where t1.c1 = t2.c1 and t2.c1 in (10,20,40);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |4       |9           |
|1 |├─TABLE FULL SCAN|t1  |4       |4           |
|2 |└─TABLE FULL SCAN|t2  |4       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter([t1.c1 IN (cast(10, DECIMAL(2, 0)), cast(20, DECIMAL(2, 0)), cast(40, DECIMAL(2, 0)))]), rowset=16
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t2.c1]), filter([t2.c1 IN (cast(10, DECIMAL(2, 0)), cast(20, DECIMAL(2, 0)), cast(40, DECIMAL(2, 0)))]), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select t1.c1,t2.c1 from t1,t2 where t1.c1 = t2.c1 and t2.c1 in (10,20,40);
+------+------+
| c1   | c1   |
+------+------+
|   10 |   10 |
|   20 |   20 |
+------+------+
EXPLAIN select t1.c1,t2.c1 from t1,t2 where t1.c1 = t2.c1 and t1.c1 in (10,20,40);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |4       |9           |
|1 |├─TABLE FULL SCAN|t1  |4       |4           |
|2 |└─TABLE FULL SCAN|t2  |4       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter([t1.c1 IN (cast(10, DECIMAL(2, 0)), cast(20, DECIMAL(2, 0)), cast(40, DECIMAL(2, 0)))]), rowset=16
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t2.c1]), filter([t2.c1 IN (cast(10, DECIMAL(2, 0)), cast(20, DECIMAL(2, 0)), cast(40, DECIMAL(2, 0)))]), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select t1.c1,t2.c1 from t1,t2 where t1.c1 = t2.c1 and t1.c1 in (10,20,40);
+------+------+
| c1   | c1   |
+------+------+
|   10 |   10 |
|   20 |   20 |
+------+------+
EXPLAIN select t1.c1,t2.c1 from t1,t2,t3 where t1.c1 = t3.c1 and t2.c1 = t3.c1 and t1.c1 in (10,20,40);
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |HASH JOIN          |    |4       |14          |
|1 |├─TABLE FULL SCAN  |t3  |4       |4           |
|2 |└─HASH JOIN        |    |4       |9           |
|3 |  ├─TABLE FULL SCAN|t1  |4       |4           |
|4 |  └─TABLE FULL SCAN|t2  |4       |4           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1]), filter([t3.c1 IN (cast(10, DECIMAL(2, 0)), cast(20, DECIMAL(2, 0)), cast(40, DECIMAL(2, 0)))]), rowset=16
      access([t3.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter([t1.c1 IN (cast(10, DECIMAL(2, 0)), cast(20, DECIMAL(2, 0)), cast(40, DECIMAL(2, 0)))]), rowset=16
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  4 - output([t2.c1]), filter([t2.c1 IN (cast(10, DECIMAL(2, 0)), cast(20, DECIMAL(2, 0)), cast(40, DECIMAL(2, 0)))]), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select t1.c1,t2.c1 from t1,t2,t3 where t1.c1 = t3.c1 and t2.c1 = t3.c1 and t1.c1 in (10,20,40);
+------+------+
| c1   | c1   |
+------+------+
|   10 |   10 |
|   20 |   20 |
+------+------+
### different types
####preds are 'cast(t1.c1,double) = cast(t3.c2,double)' and 'cast(t3.c2,double) in (10,20,40)'. cast(t3.c2,double) is not column ref, so 't1.c1 in (10,20,40)' won't be deduced.
EXPLAIN select * from t1,t3 where t1.c1 = t3.c2 and t3.c2 in (10,20,40);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|t3  |1       |4           |
|2 |└─TABLE FULL SCAN|t1  |5       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t3.c1], [t3.c2]), filter(nil), rowset=16
      equal_conds([cast(t1.c1, DOUBLE(-1, -1)) = cast(t3.c2, DOUBLE(-1, -1))]), other_conds(nil)
  1 - output([t3.c2], [t3.c1]), filter([cast(t3.c2, DOUBLE(-1, -1)) IN (cast(10, DOUBLE(-1, -1)), cast(20, DOUBLE(-1, -1)), cast(40, DOUBLE(-1, -1)))]), rowset=16
      access([t3.c2], [t3.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select * from t1,t3 where t1.c1 = t3.c2 and t3.c2 in (10,20,40);
+------+------+------+------+------+
| c1   | c2   | c3   | c1   | c2   |
+------+------+------+------+------+
|   10 | a    | NULL |   10 |   10 |
|   20 | ab   | NULL |   20 |   20 |
+------+------+------+------+------+
####different collection type
EXPLAIN select * from t1,t2 where t1.c3 = t2.c3 and t2.c3 in ('a','b','c');
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |3       |11          |
|1 |├─TABLE FULL SCAN|t2  |4       |5           |
|2 |└─TABLE FULL SCAN|t1  |5       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      equal_conds([t1.c3 = cast(t2.c3, VARCHAR(1048576))]), other_conds(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2]), filter([t2.c3 IN ('a', 'b', 'c')]), rowset=16
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t1.c3], [t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c3], [t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select * from t1,t2 where t1.c3 = t2.c3 and t2.c3 in ('a','b','c');
+------+------+------+------+------+------+
| c1   | c2   | c3   | c1   | c2   | c3   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1,t2 where t1.c3 = t2.c3 and t1.c3 in ('a','b','c');
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|t2  |1       |4           |
|2 |└─TABLE FULL SCAN|t1  |3       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t2.c1], [t2.c2], [t2.c3]), filter(nil), rowset=16
      equal_conds([t1.c3 = cast(t2.c3, VARCHAR(1048576))]), other_conds(nil)
  1 - output([t2.c3], [t2.c1], [t2.c2], [cast(t2.c3, VARCHAR(1048576))]), filter([cast(t2.c3, VARCHAR(1048576)) IN (cast('a', VARCHAR(1048576)), cast('b',
       VARCHAR(1048576)), cast('c', VARCHAR(1048576)))]), rowset=16
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t1.c3], [t1.c1], [t1.c2]), filter([t1.c3 IN (cast('a', VARCHAR(1048576)), cast('b', VARCHAR(1048576)), cast('c', VARCHAR(1048576)))]), rowset=16
      access([t1.c3], [t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select * from t1,t2 where t1.c3 = t2.c3 and t1.c3 in ('a','b','c');
+------+------+------+------+------+------+
| c1   | c2   | c3   | c1   | c2   | c3   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
test NOT EQUAL
EXPLAIN select t1.c1,t2.c1 from t1,t2 where t1.c1 = t2.c1 and t2.c1 <> 20;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |4       |10          |
|1 |├─TABLE FULL SCAN|t1  |4       |5           |
|2 |└─TABLE FULL SCAN|t2  |4       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter([t1.c1 != cast(20, DECIMAL(2, 0))]), rowset=16
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t2.c1]), filter([t2.c1 != cast(20, DECIMAL(2, 0))]), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select t1.c1,t2.c1 from t1,t2 where t1.c1 = t2.c1 and t2.c1 <> 20;
+------+------+
| c1   | c1   |
+------+------+
|   10 |   10 |
|   50 |   50 |
|  100 |  100 |
|  150 |  150 |
+------+------+
EXPLAIN select t1.c1,t2.c1 from t1,t2 where t1.c1 = t2.c1 and t1.c1 <> 20;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |4       |10          |
|1 |├─TABLE FULL SCAN|t1  |4       |5           |
|2 |└─TABLE FULL SCAN|t2  |4       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter([t1.c1 != cast(20, DECIMAL(2, 0))]), rowset=16
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t2.c1]), filter([t2.c1 != cast(20, DECIMAL(2, 0))]), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select t1.c1,t2.c1 from t1,t2 where t1.c1 = t2.c1 and t1.c1 <> 20;
+------+------+
| c1   | c1   |
+------+------+
|   10 |   10 |
|   50 |   50 |
|  100 |  100 |
|  150 |  150 |
+------+------+
EXPLAIN select t1.c1,t2.c1 from t1,t2,t3 where t1.c1 = t3.c1 and t2.c1 = t3.c1 and t1.c1 <>20;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |HASH JOIN          |    |4       |15          |
|1 |├─TABLE FULL SCAN  |t3  |4       |5           |
|2 |└─HASH JOIN        |    |4       |10          |
|3 |  ├─TABLE FULL SCAN|t1  |4       |5           |
|4 |  └─TABLE FULL SCAN|t2  |4       |5           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1]), filter([t3.c1 != cast(20, DECIMAL(2, 0))]), rowset=16
      access([t3.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter([t1.c1 != cast(20, DECIMAL(2, 0))]), rowset=16
      access([t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  4 - output([t2.c1]), filter([t2.c1 != cast(20, DECIMAL(2, 0))]), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select t1.c1,t2.c1 from t1,t2,t3 where t1.c1 = t3.c1 and t2.c1 = t3.c1 and t1.c1 <>20;
+------+------+
| c1   | c1   |
+------+------+
|   10 |   10 |
|   50 |   50 |
|  100 |  100 |
|  150 |  150 |
+------+------+
EXPLAIN select * from t1,t3 where t1.c1 = t3.c2 and t3.c2 <> 20;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|t3  |3       |5           |
|2 |└─TABLE FULL SCAN|t1  |5       |4           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t3.c1], [t3.c2]), filter(nil), rowset=16
      equal_conds([cast(t1.c1, DOUBLE(-1, -1)) = cast(t3.c2, DOUBLE(-1, -1))]), other_conds(nil)
  1 - output([t3.c2], [t3.c1]), filter([cast(t3.c2, DOUBLE(-1, -1)) != cast(20, DOUBLE(-1, -1))]), rowset=16
      access([t3.c2], [t3.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), rowset=16
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select * from t1,t3 where t1.c1 = t3.c2 and t3.c2 <> 20;
+------+------+------+------+------+
| c1   | c2   | c3   | c1   | c2   |
+------+------+------+------+------+
|   10 | a    | NULL |   10 |   10 |
|   50 | ad   | NULL |   50 |   50 |
|  100 | b    | NULL |  100 |  100 |
|  150 | c    | NULL |  150 |  150 |
+------+------+------+------+------+

test BETWEEN
### differnt types
EXPLAIN select t3.c1,t2.c1 from t3,t2 where t3.c2 = t2.c2 and t2.c2 between 10 and cast(100 as float);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|t2  |1       |4           |
|2 |└─TABLE FULL SCAN|t3  |3       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t3.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([cast(t3.c2, DOUBLE(-1, -1)) = t2.c2]), other_conds(nil)
  1 - output([t2.c2], [t2.c1]), filter([(T_OP_BTW, t2.c2, cast(10, DOUBLE(-1, -1)), cast(cast(100, FLOAT(0, -1)), DOUBLE(-1, -1)))]), rowset=16
      access([t2.c2], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t3.c1], [cast(t3.c2, DOUBLE(-1, -1))]), filter([(T_OP_BTW, cast(t3.c2, DOUBLE(-1, -1)), cast(10, DOUBLE(-1, -1)), cast(cast(100, FLOAT(0, 
      -1)), DOUBLE(-1, -1)))]), rowset=16
      access([t3.c2], [t3.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
select t3.c1,t2.c1 from t3,t2 where t3.c2 = t2.c2 and t2.c2 between 10 and cast(100 as float);
+------+------+
| c1   | c1   |
+------+------+
|   10 |   10 |
|   20 |   20 |
|   50 |   50 |
|  100 |  100 |
+------+------+
EXPLAIN select t3.c1,t2.c1 from t3,t2 where t3.c2 = t2.c2 and t3.c2 between 10 and cast(100 as float);
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |3       |10          |
|1 |├─TABLE FULL SCAN|t3  |3       |5           |
|2 |└─TABLE FULL SCAN|t2  |5       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t3.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([cast(t3.c2, DOUBLE(-1, -1)) = t2.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1]), filter([(T_OP_BTW, cast(t3.c2, DOUBLE(-1, -1)), cast(10, DOUBLE(-1, -1)), cast(cast(100, FLOAT(0, -1)), DOUBLE(-1, -1)))]), rowset=16
      access([t3.c2], [t3.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t2.c2], [t2.c1]), filter(nil), rowset=16
      access([t2.c2], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select t3.c1,t2.c1 from t3,t2 where t3.c2 = t2.c2 and t3.c2 between 10 and cast(100 as float);
+------+------+
| c1   | c1   |
+------+------+
|   10 |   10 |
|   20 |   20 |
|   50 |   50 |
|  100 |  100 |
+------+------+

test LIKE
EXPLAIN select t1.c1,t2.c1 from t1,t2 where t1.c2 = t2.c3 and t2.c3 like 'a_';
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|t1  |1       |5           |
|2 |└─TABLE FULL SCAN|t2  |1       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c2 = t2.c3]), other_conds(nil)
  1 - output([t1.c2], [t1.c1]), filter([(T_OP_LIKE, t1.c2, 'a_', '\\')]), rowset=16
      access([t1.c2], [t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t2.c3], [t2.c1]), filter([(T_OP_LIKE, t2.c3, 'a_', '\\')]), rowset=16
      access([t2.c3], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select t1.c1,t2.c1 from t1,t2 where t1.c2 = t2.c3 and t2.c3 like 'a_';
+------+------+
| c1   | c1   |
+------+------+
+------+------+
EXPLAIN select t1.c1,t2.c1 from t1,t2 where t1.c2 = t2.c3 and t1.c2 like 'a_';
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |HASH JOIN        |    |1       |9           |
|1 |├─TABLE FULL SCAN|t1  |1       |5           |
|2 |└─TABLE FULL SCAN|t2  |1       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), rowset=16
      equal_conds([t1.c2 = t2.c3]), other_conds(nil)
  1 - output([t1.c2], [t1.c1]), filter([(T_OP_LIKE, t1.c2, 'a_', '\\')]), rowset=16
      access([t1.c2], [t1.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  2 - output([t2.c3], [t2.c1]), filter([(T_OP_LIKE, t2.c3, 'a_', '\\')]), rowset=16
      access([t2.c3], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select t1.c1,t2.c1 from t1,t2 where t1.c2 = t2.c3 and t1.c2 like 'a_';
+------+------+
| c1   | c1   |
+------+------+
+------+------+

drop table t1;
drop table t2;
drop table t3;

USE DB_PREDICATE_DEDUCE;
drop database DB_PREDICATE_DEDUCE;
