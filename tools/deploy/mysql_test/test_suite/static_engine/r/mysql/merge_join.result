result_format: 4
explain_protocol: 2


drop table if exists pk_t, t1, t2, t3, t4;
create table pk_t(pk int primary key, c2 int);
create table t1(c1 int, c2 int);
create table t2(c1 int, c2 int);
create table t3(c1 int, c2 int);
create table t4(c1 int, c2 int);
insert/*trace*/ into pk_t values(2,2),(3,3), (6,6), (7, 7);
insert/*trace*/ into t1 values(NULL, 8), (NULL, 8), (2,2),(2,2), (3,3), (3,3), (4,4), (4,4),(7,7),(7, 7);
insert/*trace*/ into t2 values(NULL, 3),(1, 1), (1,1), (2,2), (3,3), (6,6),(6,6),(9,9), (10,10);
insert/*trace*/ into t3 values(1,3), (2,2);
insert/*trace*/ into t4 values(1,2), (1,2), (2,3);

set @@ob_enable_plan_cache = 0;


********* basic merge join
EXPLAIN select /*+use_merge(t1 t2)*/ * from t1, t2 where t1.c1 = t2.c1;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE JOIN         |    |11      |9           |
|1 |├─SORT             |    |9       |4           |
|2 |│ └─TABLE FULL SCAN|t2  |9       |3           |
|3 |└─SORT             |    |10      |4           |
|4 |  └─TABLE FULL SCAN|t1  |10      |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1, t2 where t1.c1 = t2.c1;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 left join t2 on t1.c1 = t2.c1;
Query Plan
=======================================================
|ID|OPERATOR               |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |MERGE RIGHT OUTER JOIN |    |11      |9           |
|1 |├─SORT                 |    |9       |4           |
|2 |│ └─TABLE FULL SCAN    |t2  |9       |3           |
|3 |└─SORT                 |    |10      |4           |
|4 |  └─TABLE FULL SCAN    |t1  |10      |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 left join t2 on t1.c1 = t2.c1;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL |    8 | NULL | NULL |
| NULL |    8 | NULL | NULL |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
|    4 |    4 | NULL | NULL |
|    4 |    4 | NULL | NULL |
|    7 |    7 | NULL | NULL |
|    7 |    7 | NULL | NULL |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 right join t2 on t1.c1 = t2.c1;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE OUTER JOIN   |    |11      |9           |
|1 |├─SORT             |    |9       |4           |
|2 |│ └─TABLE FULL SCAN|t2  |9       |3           |
|3 |└─SORT             |    |10      |4           |
|4 |  └─TABLE FULL SCAN|t1  |10      |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 right join t2 on t1.c1 = t2.c1;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL | NULL | NULL |    3 |
| NULL | NULL |    1 |    1 |
| NULL | NULL |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    9 |    9 |
| NULL | NULL |   10 |   10 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 full join t2 on t1.c1 = t2.c1;
Query Plan
======================================================
|ID|OPERATOR              |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |MERGE FULL OUTER JOIN |    |11      |9           |
|1 |├─SORT                |    |9       |4           |
|2 |│ └─TABLE FULL SCAN   |t2  |9       |3           |
|3 |└─SORT                |    |10      |4           |
|4 |  └─TABLE FULL SCAN   |t1  |10      |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 full join t2 on t1.c1 = t2.c1;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL | NULL | NULL |    3 |
| NULL |    8 | NULL | NULL |
| NULL |    8 | NULL | NULL |
| NULL | NULL |    1 |    1 |
| NULL | NULL |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
|    4 |    4 | NULL | NULL |
|    4 |    4 | NULL | NULL |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    6 |    6 |
|    7 |    7 | NULL | NULL |
|    7 |    7 | NULL | NULL |
| NULL | NULL |    9 |    9 |
| NULL | NULL |   10 |   10 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 where exists(select 1 from t2 where t1.c1 = t2.c1);
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE SEMI JOIN    |    |8       |8           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |3           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1]), filter(nil), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 where exists(select 1 from t2 where t1.c1 = t2.c1);
+------+------+
| c1   | c2   |
+------+------+
|    2 |    2 |
|    2 |    2 |
|    3 |    3 |
|    3 |    3 |
+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 where not exists(select 1 from t2 where t1.c1 = t2.c1);
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE ANTI JOIN    |    |2       |8           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |3           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1]), filter(nil), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 where not exists(select 1 from t2 where t1.c1 = t2.c1);
+------+------+
| c1   | c2   |
+------+------+
| NULL |    8 |
| NULL |    8 |
|    4 |    4 |
|    4 |    4 |
|    7 |    7 |
|    7 |    7 |
+------+------+


********* nullsafe equal condition
EXPLAIN select /*+use_merge(t1 t2)*/ * from t1, t2 where t1.c1 <=> t2.c1;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE JOIN         |    |13      |9           |
|1 |├─SORT             |    |9       |4           |
|2 |│ └─TABLE FULL SCAN|t2  |9       |3           |
|3 |└─SORT             |    |10      |4           |
|4 |  └─TABLE FULL SCAN|t1  |10      |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 <=> t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1, t2 where t1.c1 <=> t2.c1;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL |    8 | NULL |    3 |
| NULL |    8 | NULL |    3 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 left join t2 on t1.c1 <=> t2.c1;
Query Plan
=======================================================
|ID|OPERATOR               |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |MERGE RIGHT OUTER JOIN |    |13      |9           |
|1 |├─SORT                 |    |9       |4           |
|2 |│ └─TABLE FULL SCAN    |t2  |9       |3           |
|3 |└─SORT                 |    |10      |4           |
|4 |  └─TABLE FULL SCAN    |t1  |10      |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 <=> t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 left join t2 on t1.c1 <=> t2.c1;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL |    8 | NULL |    3 |
| NULL |    8 | NULL |    3 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
|    4 |    4 | NULL | NULL |
|    4 |    4 | NULL | NULL |
|    7 |    7 | NULL | NULL |
|    7 |    7 | NULL | NULL |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 right join t2 on t1.c1 <=> t2.c1;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE OUTER JOIN   |    |13      |9           |
|1 |├─SORT             |    |9       |4           |
|2 |│ └─TABLE FULL SCAN|t2  |9       |3           |
|3 |└─SORT             |    |10      |4           |
|4 |  └─TABLE FULL SCAN|t1  |10      |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 <=> t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 right join t2 on t1.c1 <=> t2.c1;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL |    8 | NULL |    3 |
| NULL |    8 | NULL |    3 |
| NULL | NULL |    1 |    1 |
| NULL | NULL |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    9 |    9 |
| NULL | NULL |   10 |   10 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 full join t2 on t1.c1 <=> t2.c1;
Query Plan
======================================================
|ID|OPERATOR              |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |MERGE FULL OUTER JOIN |    |13      |9           |
|1 |├─SORT                |    |9       |4           |
|2 |│ └─TABLE FULL SCAN   |t2  |9       |3           |
|3 |└─SORT                |    |10      |4           |
|4 |  └─TABLE FULL SCAN   |t1  |10      |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 <=> t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 full join t2 on t1.c1 <=> t2.c1;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL |    8 | NULL |    3 |
| NULL |    8 | NULL |    3 |
| NULL | NULL |    1 |    1 |
| NULL | NULL |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
|    4 |    4 | NULL | NULL |
|    4 |    4 | NULL | NULL |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    6 |    6 |
|    7 |    7 | NULL | NULL |
|    7 |    7 | NULL | NULL |
| NULL | NULL |    9 |    9 |
| NULL | NULL |   10 |   10 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 where exists(select 1 from t2 where t1.c1 <=> t2.c1);
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE SEMI JOIN    |    |10      |8           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |3           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 <=> t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1]), filter(nil), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 where exists(select 1 from t2 where t1.c1 <=> t2.c1);
+------+------+
| c1   | c2   |
+------+------+
| NULL |    8 |
| NULL |    8 |
|    2 |    2 |
|    2 |    2 |
|    3 |    3 |
|    3 |    3 |
+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 where not exists(select 1 from t2 where t1.c1 <=> t2.c1);
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE ANTI JOIN    |    |1       |8           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |3           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 <=> t2.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1]), filter(nil), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 where not exists(select 1 from t2 where t1.c1 <=> t2.c1);
+------+------+
| c1   | c2   |
+------+------+
|    4 |    4 |
|    4 |    4 |
|    7 |    7 |
|    7 |    7 |
+------+------+


********  contain other condition
EXPLAIN select /*+use_merge(t1 t2)*/ * from t1, t2 where t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE JOIN         |    |4       |8           |
|1 |├─SORT             |    |9       |4           |
|2 |│ └─TABLE FULL SCAN|t2  |9       |3           |
|3 |└─SORT             |    |10      |4           |
|4 |  └─TABLE FULL SCAN|t1  |10      |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1, t2 where t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10;
Query Plan
=======================================================
|ID|OPERATOR               |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |MERGE RIGHT OUTER JOIN |    |10      |8           |
|1 |├─SORT                 |    |9       |4           |
|2 |│ └─TABLE FULL SCAN    |t2  |9       |3           |
|3 |└─SORT                 |    |10      |4           |
|4 |  └─TABLE FULL SCAN    |t1  |10      |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 left join t2 on t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL |    8 | NULL | NULL |
| NULL |    8 | NULL | NULL |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
|    4 |    4 | NULL | NULL |
|    4 |    4 | NULL | NULL |
|    7 |    7 | NULL | NULL |
|    7 |    7 | NULL | NULL |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 right join t2 on t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE OUTER JOIN   |    |9       |8           |
|1 |├─SORT             |    |9       |4           |
|2 |│ └─TABLE FULL SCAN|t2  |9       |3           |
|3 |└─SORT             |    |10      |4           |
|4 |  └─TABLE FULL SCAN|t1  |10      |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 right join t2 on t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL | NULL | NULL |    3 |
| NULL | NULL |    1 |    1 |
| NULL | NULL |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    9 |    9 |
| NULL | NULL |   10 |   10 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 full join t2 on t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10;
Query Plan
======================================================
|ID|OPERATOR              |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |MERGE FULL OUTER JOIN |    |10      |8           |
|1 |├─SORT                |    |9       |4           |
|2 |│ └─TABLE FULL SCAN   |t2  |9       |3           |
|3 |└─SORT                |    |10      |4           |
|4 |  └─TABLE FULL SCAN   |t1  |10      |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 full join t2 on t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL | NULL | NULL |    3 |
| NULL |    8 | NULL | NULL |
| NULL |    8 | NULL | NULL |
| NULL | NULL |    1 |    1 |
| NULL | NULL |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
|    4 |    4 | NULL | NULL |
|    4 |    4 | NULL | NULL |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    6 |    6 |
|    7 |    7 | NULL | NULL |
|    7 |    7 | NULL | NULL |
| NULL | NULL |    9 |    9 |
| NULL | NULL |   10 |   10 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 where exists(select 1 from t2 where t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10) ;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE SEMI JOIN    |    |3       |8           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |4           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 where exists(select 1 from t2 where t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10) ;
+------+------+
| c1   | c2   |
+------+------+
|    2 |    2 |
|    2 |    2 |
|    3 |    3 |
|    3 |    3 |
+------+------+

EXPLAIN select /*+use_merge(t1 t2)*/ * from t1 where not exists(select 1 from t2 where t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10) ;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE ANTI JOIN    |    |8       |8           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |4           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2)*/ * from t1 where not exists(select 1 from t2 where t1.c1 = t2.c1 and t1.c2 * t2.c2 < 10) ;
+------+------+
| c1   | c2   |
+------+------+
| NULL |    8 |
| NULL |    8 |
|    4 |    4 |
|    4 |    4 |
|    7 |    7 |
|    7 |    7 |
+------+------+


************ equel condition表达式左右子表达式分别来自join operator的右边和左边
EXPLAIN select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1, t2 where t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE JOIN         |    |4       |9           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |4           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t2.c1 = t1.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1, t2 where t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 left join t2 on t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE OUTER JOIN   |    |10      |9           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |4           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t2.c1 = t1.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 left join t2 on t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL |    8 | NULL | NULL |
| NULL |    8 | NULL | NULL |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
|    4 |    4 | NULL | NULL |
|    4 |    4 | NULL | NULL |
|    7 |    7 | NULL | NULL |
|    7 |    7 | NULL | NULL |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 right join t2 on t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10;
Query Plan
=======================================================
|ID|OPERATOR               |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------------
|0 |MERGE RIGHT OUTER JOIN |    |9       |9           |
|1 |├─SORT                 |    |10      |4           |
|2 |│ └─TABLE FULL SCAN    |t1  |10      |3           |
|3 |└─SORT                 |    |9       |4           |
|4 |  └─TABLE FULL SCAN    |t2  |9       |3           |
=======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t2.c1 = t1.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 right join t2 on t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL | NULL | NULL |    3 |
| NULL | NULL |    1 |    1 |
| NULL | NULL |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    9 |    9 |
| NULL | NULL |   10 |   10 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 full join t2 on t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10;
Query Plan
======================================================
|ID|OPERATOR              |NAME|EST.ROWS|EST.TIME(us)|
------------------------------------------------------
|0 |MERGE FULL OUTER JOIN |    |10      |9           |
|1 |├─SORT                |    |10      |4           |
|2 |│ └─TABLE FULL SCAN   |t1  |10      |3           |
|3 |└─SORT                |    |9       |4           |
|4 |  └─TABLE FULL SCAN   |t2  |9       |3           |
======================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([t2.c1 = t1.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 full join t2 on t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
| NULL |    8 | NULL | NULL |
| NULL |    8 | NULL | NULL |
| NULL | NULL | NULL |    3 |
| NULL | NULL |    1 |    1 |
| NULL | NULL |    1 |    1 |
|    2 |    2 |    2 |    2 |
|    2 |    2 |    2 |    2 |
|    3 |    3 |    3 |    3 |
|    3 |    3 |    3 |    3 |
|    4 |    4 | NULL | NULL |
|    4 |    4 | NULL | NULL |
| NULL | NULL |    6 |    6 |
| NULL | NULL |    6 |    6 |
|    7 |    7 | NULL | NULL |
|    7 |    7 | NULL | NULL |
| NULL | NULL |    9 |    9 |
| NULL | NULL |   10 |   10 |
+------+------+------+------+

EXPLAIN select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 where exists(select 1 from t2 where t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10) ;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE SEMI JOIN    |    |3       |8           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |4           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      equal_conds([t2.c1 = t1.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 where exists(select 1 from t2 where t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10) ;
+------+------+
| c1   | c2   |
+------+------+
|    2 |    2 |
|    2 |    2 |
|    3 |    3 |
|    3 |    3 |
+------+------+

EXPLAIN select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 where not exists(select 1 from t2 where t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10) ;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE ANTI JOIN    |    |8       |8           |
|1 |├─SORT             |    |10      |4           |
|2 |│ └─TABLE FULL SCAN|t1  |10      |3           |
|3 |└─SORT             |    |9       |4           |
|4 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      equal_conds([t2.c1 = t1.c1]), other_conds([t1.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  4 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(t1 t2) leading(t1 t2)*/ * from t1 where not exists(select 1 from t2 where t2.c1 = t1.c1 and t1.c2 * t2.c2 < 10) ;
+------+------+
| c1   | c2   |
+------+------+
| NULL |    8 |
| NULL |    8 |
|    4 |    4 |
|    4 |    4 |
|    7 |    7 |
|    7 |    7 |
+------+------+


******* 测试左表为唯一键时不需要进cache的场景, 仅支持inner join
EXPLAIN select /*+use_merge(pk_t t2) leading(pk_t t2)*/ * from pk_t, t2 where pk_t.pk = t2.c1 and pk_t.c2 * t2.c2 < 10;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE JOIN         |    |2       |7           |
|1 |├─TABLE FULL SCAN  |pk_t|4       |3           |
|2 |└─SORT             |    |9       |4           |
|3 |  └─TABLE FULL SCAN|t2  |9       |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([pk_t.pk], [pk_t.c2], [t2.c1], [t2.c2]), filter(nil), rowset=16
      equal_conds([pk_t.pk = t2.c1]), other_conds([pk_t.c2 * t2.c2 < 10])
      merge_directions([ASC])
  1 - output([pk_t.pk], [pk_t.c2]), filter(nil), rowset=16
      access([pk_t.pk], [pk_t.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([pk_t.pk]), range(MIN ; MAX)always true
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      sort_keys([t2.c1, ASC])
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(pk_t t2) leading(pk_t t2)*/ * from pk_t, t2 where pk_t.pk = t2.c1 and pk_t.c2 * t2.c2 < 10;
+----+------+------+------+
| pk | c2   | c1   | c2   |
+----+------+------+------+
|  2 |    2 |    2 |    2 |
|  3 |    3 |    3 |    3 |
+----+------+------+------+

******* 测试不进cache， 且左边最后一行与右边最后一行匹配的场景
EXPLAIN select /*+use_merge(pk_t t1) leading(pk_t t1)*/ * from pk_t, t1 where pk_t.pk = t1.c1;
Query Plan
===================================================
|ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|
---------------------------------------------------
|0 |MERGE JOIN         |    |8       |7           |
|1 |├─TABLE FULL SCAN  |pk_t|4       |3           |
|2 |└─SORT             |    |10      |4           |
|3 |  └─TABLE FULL SCAN|t1  |10      |3           |
===================================================
Outputs & filters:
-------------------------------------
  0 - output([pk_t.pk], [pk_t.c2], [t1.c1], [t1.c2]), filter(nil), rowset=16
      equal_conds([pk_t.pk = t1.c1]), other_conds(nil)
      merge_directions([ASC])
  1 - output([pk_t.pk], [pk_t.c2]), filter(nil), rowset=16
      access([pk_t.pk], [pk_t.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([pk_t.pk]), range(MIN ; MAX)always true
  2 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+use_merge(pk_t t1) leading(pk_t t1)*/ * from pk_t, t1 where pk_t.pk = t1.c1;
+----+------+------+------+
| pk | c2   | c1   | c2   |
+----+------+------+------+
|  2 |    2 |    2 |    2 |
|  2 |    2 |    2 |    2 |
|  3 |    3 |    3 |    3 |
|  3 |    3 |    3 |    3 |
|  7 |    7 |    7 |    7 |
|  7 |    7 |    7 |    7 |
+----+------+------+------+


select/*+use_merge(t3 t4) leading(t3 t4)*/ * from t3 left join t4 on t3.c1 = t4.c1 and t3.c2 < t4.c2;
+------+------+------+------+
| c1   | c2   | c1   | c2   |
+------+------+------+------+
|    1 |    3 | NULL | NULL |
|    2 |    2 |    2 |    3 |
+------+------+------+------+

drop table pk_t;
drop table t1;
drop table t2;
drop table t3;
drop table t4;

