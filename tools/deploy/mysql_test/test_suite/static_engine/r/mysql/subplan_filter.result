result_format: 4

drop table if exists t1;
drop table if exists t2;
create table t1 (c1 int primary key, c2 decimal, c3 int, c4 varchar(20));
create table t2 (c1 int primary key, c2 decimal, c3 int, c4 varchar(20));
insert into t1 (c1, c2, c3, c4) values (1, 1, 1, 'a');
insert into t1 (c1, c2, c3, c4) values (2, 2, null, 'a');
insert into t1 (c1, c2, c3, c4) values (3, 3, null, 'a');
insert into t2 (c1, c2, c3, c4) values (1, 1, 1, 'a');
insert into t2 (c1, c2, c3, c4) values (2, 2, null, 'a');
insert into t2 (c1, c2, c3, c4) values (3, 3, null, 'a');



set @@ob_enable_plan_cache = 0;
set ob_enable_transformation = off;
select (1, 1) = (1, 0);
+-----------------+
| (1, 1) = (1, 0) |
+-----------------+
|               0 |
+-----------------+
select (1, 1) = (1, 1);
+-----------------+
| (1, 1) = (1, 1) |
+-----------------+
|               1 |
+-----------------+

select 1 <=> 1;
+---------+
| 1 <=> 1 |
+---------+
|       1 |
+---------+
select 1 <=> 0;
+---------+
| 1 <=> 0 |
+---------+
|       0 |
+---------+
select 1 <=> null;
+------------+
| 1 <=> null |
+------------+
|          0 |
+------------+
select null <=> 1;
+------------+
| null <=> 1 |
+------------+
|          0 |
+------------+
select null <=> null;
+---------------+
| null <=> null |
+---------------+
|             1 |
+---------------+

select (1, 1) <=> (1, 1);
+-------------------+
| (1, 1) <=> (1, 1) |
+-------------------+
|                 1 |
+-------------------+
select (1, null) <=> (1, 1);
+----------------------+
| (1, null) <=> (1, 1) |
+----------------------+
|                    0 |
+----------------------+
select (1, null) <=> (1, null);
+-------------------------+
| (1, null) <=> (1, null) |
+-------------------------+
|                       1 |
+-------------------------+
select (1, null) <=> (null, null);
+----------------------------+
| (1, null) <=> (null, null) |
+----------------------------+
|                          0 |
+----------------------------+
select (null, null) <=> (null, null);
+-------------------------------+
| (null, null) <=> (null, null) |
+-------------------------------+
|                             1 |
+-------------------------------+

select (select c1, c2 from t1 where c1 = 1) = (1, 1) from t2 where c1 = 1;
+-----------------------------------------------+
| (select c1, c2 from t1 where c1 = 1) = (1, 1) |
+-----------------------------------------------+
|                                             1 |
+-----------------------------------------------+
select (select c1, c2 from t1 where c1 = 1) = (c2, c1) from t2 where c1 = 1;
+-------------------------------------------------+
| (select c1, c2 from t1 where c1 = 1) = (c2, c1) |
+-------------------------------------------------+
|                                               1 |
+-------------------------------------------------+

select (select c1 from t1 where c1 = 1) + 1 from t2 where c1 = 1;
+--------------------------------------+
| (select c1 from t1 where c1 = 1) + 1 |
+--------------------------------------+
|                                    2 |
+--------------------------------------+
select (select c1 from t1 where 1 = 0) + 1 from t2 where c1 = 1;
+-------------------------------------+
| (select c1 from t1 where 1 = 0) + 1 |
+-------------------------------------+
|                                NULL |
+-------------------------------------+

select c2 in (select c2 from t2) from t1;
+---------------------------+
| c2 in (select c2 from t2) |
+---------------------------+
|                         1 |
|                         1 |
|                         1 |
+---------------------------+
select c2 = any(select c2 from t2) from t1;
+-----------------------------+
| c2 = any(select c2 from t2) |
+-----------------------------+
|                           1 |
|                           1 |
|                           1 |
+-----------------------------+
select c2 != any(select c2 from t2) from t1;
+------------------------------+
| c2 != any(select c2 from t2) |
+------------------------------+
|                            1 |
|                            1 |
|                            1 |
+------------------------------+
select c2 < any(select c2 from t2) from t1;
+-----------------------------+
| c2 < any(select c2 from t2) |
+-----------------------------+
|                           1 |
|                           1 |
|                           0 |
+-----------------------------+
select c2 <= any(select c2 from t2) from t1;
+------------------------------+
| c2 <= any(select c2 from t2) |
+------------------------------+
|                            1 |
|                            1 |
|                            1 |
+------------------------------+
select c2 > any(select c2 from t2) from t1;
+-----------------------------+
| c2 > any(select c2 from t2) |
+-----------------------------+
|                           0 |
|                           1 |
|                           1 |
+-----------------------------+
select c2 >= any(select c2 from t2) from t1;
+------------------------------+
| c2 >= any(select c2 from t2) |
+------------------------------+
|                            1 |
|                            1 |
|                            1 |
+------------------------------+
select c2 <=> any(select c2 from t2) from t1;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your OceanBase version for the right syntax to use near '(select c2 from t2) from t1' at line 1
select exists (select * from t2), not exists (select * from t2) from t1;
+---------------------------+-------------------------------+
| exists (select * from t2) | not exists (select * from t2) |
+---------------------------+-------------------------------+
|                         1 |                             0 |
|                         1 |                             0 |
|                         1 |                             0 |
+---------------------------+-------------------------------+
select exists (select * from t2 where 1 = 0), not exists (select * from t2 where 1 = 0) from t1;
+---------------------------------------+-------------------------------------------+
| exists (select * from t2 where 1 = 0) | not exists (select * from t2 where 1 = 0) |
+---------------------------------------+-------------------------------------------+
|                                     0 |                                         1 |
|                                     0 |                                         1 |
|                                     0 |                                         1 |
+---------------------------------------+-------------------------------------------+

select c2 = all (select c2 from t2) from t1;
+------------------------------+
| c2 = all (select c2 from t2) |
+------------------------------+
|                            0 |
|                            0 |
|                            0 |
+------------------------------+
select c2 = any (select c2 from t2) from t1;
+------------------------------+
| c2 = any (select c2 from t2) |
+------------------------------+
|                            1 |
|                            1 |
|                            1 |
+------------------------------+

select c2 = all (select c3 from t2) from t1;
+------------------------------+
| c2 = all (select c3 from t2) |
+------------------------------+
|                         NULL |
|                            0 |
|                            0 |
+------------------------------+
select c2 = any (select c3 from t2) from t1;
+------------------------------+
| c2 = any (select c3 from t2) |
+------------------------------+
|                            1 |
|                         NULL |
|                         NULL |
+------------------------------+

select c3 = all (select c2 from t2) from t1;
+------------------------------+
| c3 = all (select c2 from t2) |
+------------------------------+
|                            0 |
|                         NULL |
|                         NULL |
+------------------------------+
select c3 = any (select c2 from t2) from t1;
+------------------------------+
| c3 = any (select c2 from t2) |
+------------------------------+
|                            1 |
|                         NULL |
|                         NULL |
+------------------------------+

select c3 <=> (select c2 from t2) from t1;
ERROR 21000: Subquery returns more than 1 row

select (c1, c3) = all (select c1, c2 from t2) from t1;
+----------------------------------------+
| (c1, c3) = all (select c1, c2 from t2) |
+----------------------------------------+
|                                      0 |
|                                      0 |
|                                      0 |
+----------------------------------------+
select (c1, c3) = any (select c1, c2 from t2) from t1;
+----------------------------------------+
| (c1, c3) = any (select c1, c2 from t2) |
+----------------------------------------+
|                                      1 |
|                                   NULL |
|                                   NULL |
+----------------------------------------+
select (c1, c3) <=> (select c1, c2 from t2) from t1;
ERROR 21000: Subquery returns more than 1 row

select exists (select 1);
+-------------------+
| exists (select 1) |
+-------------------+
|                 1 |
+-------------------+
select not exists (select 1);
+-----------------------+
| not exists (select 1) |
+-----------------------+
|                     0 |
+-----------------------+
select 1 from dual where exists (select c1 from t2);
+---+
| 1 |
+---+
| 1 |
+---+
select 1 from dual where not exists (select c1 from t2);
+---+
| 1 |
+---+
+---+
select * from t1 where exists (select * from t2 where c1 < 0);
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
+----+------+------+------+
select * from t1 where exists (select * from t2 where c1 > 0);
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  1 |    1 |    1 | a    |
|  2 |    2 | NULL | a    |
|  3 |    3 | NULL | a    |
+----+------+------+------+

select (select c1, c2 from t1 where c1 = 1) = (select c1, c2 from t2 where c1 = 1);
+-----------------------------------------------------------------------------+
| (select c1, c2 from t1 where c1 = 1) = (select c1, c2 from t2 where c1 = 1) |
+-----------------------------------------------------------------------------+
|                                                                           1 |
+-----------------------------------------------------------------------------+
select (select c1, c2 from t1 where c1 = 0) = (select c1, c2 from t2 where c1 = 1);
+-----------------------------------------------------------------------------+
| (select c1, c2 from t1 where c1 = 0) = (select c1, c2 from t2 where c1 = 1) |
+-----------------------------------------------------------------------------+
|                                                                        NULL |
+-----------------------------------------------------------------------------+
select (select c1, c2 from t1 where c1 = 1) = (select c1, c2 from t2 where c1 = 0);
+-----------------------------------------------------------------------------+
| (select c1, c2 from t1 where c1 = 1) = (select c1, c2 from t2 where c1 = 0) |
+-----------------------------------------------------------------------------+
|                                                                        NULL |
+-----------------------------------------------------------------------------+
select (select c1, c2 from t1 where c1 = 0) = (select c1, c2 from t2 where c1 = 0);
+-----------------------------------------------------------------------------+
| (select c1, c2 from t1 where c1 = 0) = (select c1, c2 from t2 where c1 = 0) |
+-----------------------------------------------------------------------------+
|                                                                        NULL |
+-----------------------------------------------------------------------------+
select (select c1, c2 from t1 where c1 = 1) <=> (select c1, c2 from t2 where c1 = 1);
+-------------------------------------------------------------------------------+
| (select c1, c2 from t1 where c1 = 1) <=> (select c1, c2 from t2 where c1 = 1) |
+-------------------------------------------------------------------------------+
|                                                                             1 |
+-------------------------------------------------------------------------------+
select (select c1, c2 from t1 where c1 = 0) <=> (select c1, c2 from t2 where c1 = 1);
+-------------------------------------------------------------------------------+
| (select c1, c2 from t1 where c1 = 0) <=> (select c1, c2 from t2 where c1 = 1) |
+-------------------------------------------------------------------------------+
|                                                                             0 |
+-------------------------------------------------------------------------------+
select (select c1, c2 from t1 where c1 = 1) <=> (select c1, c2 from t2 where c1 = 0);
+-------------------------------------------------------------------------------+
| (select c1, c2 from t1 where c1 = 1) <=> (select c1, c2 from t2 where c1 = 0) |
+-------------------------------------------------------------------------------+
|                                                                             0 |
+-------------------------------------------------------------------------------+
select (select c1, c2 from t1 where c1 = 0) <=> (select c1, c2 from t2 where c1 = 0);
+-------------------------------------------------------------------------------+
| (select c1, c2 from t1 where c1 = 0) <=> (select c1, c2 from t2 where c1 = 0) |
+-------------------------------------------------------------------------------+
|                                                                             1 |
+-------------------------------------------------------------------------------+
select (select c1, c2 from t1 where c1 > 1) = (select c1, c2 from t2 where c1 = 1);
ERROR 21000: Subquery returns more than 1 row
select (select c1, c2 from t1 where c1 = 1) = (select c1, c2 from t2 where c1 > 1);
ERROR 21000: Subquery returns more than 1 row
select (select c1, c2 from t1 where c1 > 1) = (select c1, c2 from t2 where c1 > 1);
ERROR 21000: Subquery returns more than 1 row

explain_protocol: 2
EXPLAIN select c1 + (select c2 from t2 where c1 = 2), c2 in (select c3 from t2) from t1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |3       |10          |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |├─TABLE GET      |t2  |1       |5           |
|3 |└─TABLE FULL SCAN|t2  |3       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(t1.c1, DECIMAL_INT(12, 0)) + :0], [t1.c2 = ANY(subquery(2))]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([subquery(1)(:0)]), init_plan_idxs_([2]), use_batch=false
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([t2.c2]), filter(nil), rowset=16
      access([t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = 2])
  3 - output([cast(t2.c3, DECIMAL_INT(10, 0))]), filter(nil), rowset=16
      access([t2.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
select c1 + (select c2 from t2 where c1 = 2), c2 in (select c3 from t2) from t1;
+---------------------------------------+---------------------------+
| c1 + (select c2 from t2 where c1 = 2) | c2 in (select c3 from t2) |
+---------------------------------------+---------------------------+
|                                     3 |                         1 |
|                                     4 |                      NULL |
|                                     5 |                      NULL |
+---------------------------------------+---------------------------+
EXPLAIN select c1 + (select c2 from t2 where c1 = t1.c2 and c3 <= t1.c2) from t1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |3       |56          |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |└─TABLE FULL SCAN|t2  |1       |18          |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([cast(t1.c1, DECIMAL_INT(12, 0)) + subquery(1)]), filter(nil), rowset=16
      exec_params_([t1.c2(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([t2.c2]), filter([cast(t2.c1, DECIMAL_INT(10, 0)) = :0], [cast(t2.c3, DECIMAL_INT(10, 0)) <= :0]), rowset=16
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
select c1 + (select c2 from t2 where c1 = t1.c2 and c3 <= t1.c2) from t1;
+-----------------------------------------------------------+
| c1 + (select c2 from t2 where c1 = t1.c2 and c3 <= t1.c2) |
+-----------------------------------------------------------+
|                                                         2 |
|                                                      NULL |
|                                                      NULL |
+-----------------------------------------------------------+
EXPLAIN select * from t1 where c1 + (select c2 from t2 where c1 = t1.c2 and c3 <= t1.c2) < 10;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |57          |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |└─TABLE FULL SCAN|t2  |1       |18          |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4]), filter([cast(t1.c1, DECIMAL_INT(12, 0)) + subquery(1) < cast(10, DECIMAL_INT(12, 0))]), rowset=16
      exec_params_([t1.c2(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  1 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4]), filter(nil), rowset=16
      access([t1.c1], [t1.c2], [t1.c3], [t1.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([t2.c2]), filter([cast(t2.c1, DECIMAL_INT(10, 0)) = :0], [cast(t2.c3, DECIMAL_INT(10, 0)) <= :0]), rowset=16
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false,false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
select * from t1 where c1 + (select c2 from t2 where c1 = t1.c2 and c3 <= t1.c2) < 10;
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  1 |    1 |    1 | a    |
+----+------+------+------+

EXPLAIN select (select c1, c2 from t2 where c1 = 1) = (c2, c1) from t1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |3       |7           |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |└─TABLE GET      |t2  |1       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([subquery(1) = (t1.c2, cast(t1.c1, DECIMAL_INT(10, 0)))]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1]), use_batch=false
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([cast(t2.c1, DECIMAL_INT(10, 0))], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = 1])
select (select c1, c2 from t2 where c1 = 1) = (c2, c1) from t1;
+-------------------------------------------------+
| (select c1, c2 from t2 where c1 = 1) = (c2, c1) |
+-------------------------------------------------+
|                                               1 |
|                                               0 |
|                                               0 |
+-------------------------------------------------+
EXPLAIN select (select c1, c2 from t2 where c1 = 1) = (c1, c2) from t1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |3       |7           |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |└─TABLE GET      |t2  |1       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([subquery(1) = (t1.c1, t1.c2)]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1]), use_batch=false
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = 1])
select (select c1, c2 from t2 where c1 = 1) = (c1, c2) from t1;
+-------------------------------------------------+
| (select c1, c2 from t2 where c1 = 1) = (c1, c2) |
+-------------------------------------------------+
|                                               1 |
|                                               0 |
|                                               0 |
+-------------------------------------------------+
EXPLAIN select (c2, c1) <= (select c1, c2 from t2 where c1 = 1) from t1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |3       |7           |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |└─TABLE GET      |t2  |1       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([(t1.c2, cast(t1.c1, DECIMAL_INT(10, 0))) <= subquery(1)]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1]), use_batch=false
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([cast(t2.c1, DECIMAL_INT(10, 0))], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = 1])
select (c2, c1) <= (select c1, c2 from t2 where c1 = 1) from t1;
+--------------------------------------------------+
| (c2, c1) <= (select c1, c2 from t2 where c1 = 1) |
+--------------------------------------------------+
|                                                1 |
|                                                0 |
|                                                0 |
+--------------------------------------------------+
EXPLAIN select (c1, c2) <= (select c1, c2 from t2 where c1 = 1) from t1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |3       |7           |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |└─TABLE GET      |t2  |1       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([(t1.c1, t1.c2) <= subquery(1)]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1]), use_batch=false
  1 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = 1])
select (c1, c2) <= (select c1, c2 from t2 where c1 = 1) from t1;
+--------------------------------------------------+
| (c1, c2) <= (select c1, c2 from t2 where c1 = 1) |
+--------------------------------------------------+
|                                                1 |
|                                                0 |
|                                                0 |
+--------------------------------------------------+
EXPLAIN select (select c2, c1 from t2 where c1 = 2) >= (select c1, c2 from t2 where c1 = 1) from t1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |3       |12          |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |├─TABLE GET      |t2  |1       |5           |
|3 |└─TABLE GET      |t2  |1       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([subquery(1) >= subquery(2)]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1], [2]), use_batch=false
  1 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([t2.c2], [cast(t2.c1, DECIMAL_INT(10, 0))]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = 2])
  3 - output([cast(t2.c1, DECIMAL_INT(10, 0))], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = 1])
select (select c2, c1 from t2 where c1 = 2) >= (select c1, c2 from t2 where c1 = 1) from t1;
+------------------------------------------------------------------------------+
| (select c2, c1 from t2 where c1 = 2) >= (select c1, c2 from t2 where c1 = 1) |
+------------------------------------------------------------------------------+
|                                                                            1 |
|                                                                            1 |
|                                                                            1 |
+------------------------------------------------------------------------------+
EXPLAIN select (select c1, c1 from t2 where c1 = 2) >= (select c1, c2 from t2 where c1 = 1) from t1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |3       |12          |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |├─TABLE GET      |t2  |1       |5           |
|3 |└─TABLE GET      |t2  |1       |5           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([subquery(1) >= subquery(2)]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1], [2]), use_batch=false
  1 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([t2.c1], [cast(t2.c1, DECIMAL_INT(10, 0))]), filter(nil), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = 2])
  3 - output([t2.c1], [t2.c2]), filter(nil), rowset=16
      access([t2.c1], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = 1])
select (select c1, c1 from t2 where c1 = 2) >= (select c1, c2 from t2 where c1 = 1) from t1;
+------------------------------------------------------------------------------+
| (select c1, c1 from t2 where c1 = 2) >= (select c1, c2 from t2 where c1 = 1) |
+------------------------------------------------------------------------------+
|                                                                            1 |
|                                                                            1 |
|                                                                            1 |
+------------------------------------------------------------------------------+

EXPLAIN select c2 > (select c1 from t2 where c3 is not null) from t1;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |3       |5           |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |└─TABLE FULL SCAN|t2  |3       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c2 > cast(:0, DECIMAL_INT(10, 0))]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([subquery(1)(:0)]), init_plan_idxs_(nil), use_batch=false
  1 - output([t1.c2]), filter(nil), rowset=16
      access([t1.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([t2.c1]), filter([t2.c3 IS NOT NULL]), rowset=16
      access([t2.c1], [t2.c3]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
select c2 > (select c1 from t2 where c3 is not null) from t1;
+-----------------------------------------------+
| c2 > (select c1 from t2 where c3 is not null) |
+-----------------------------------------------+
|                                             0 |
|                                             1 |
|                                             1 |
+-----------------------------------------------+
EXPLAIN select * from t1 where c2 + (select c1 from t2 where c1 = t1.c2) < 10;
Query Plan
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |SUBPLAN FILTER   |    |1       |57          |
|1 |├─TABLE FULL SCAN|t1  |3       |3           |
|2 |└─TABLE FULL SCAN|t2  |1       |18          |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4]), filter([t1.c2 + cast(subquery(1), DECIMAL_INT(12, 0)) < cast(10, DECIMAL_INT(12, 0))]), rowset=16
      exec_params_([t1.c2(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  1 - output([t1.c1], [t1.c2], [t1.c3], [t1.c4]), filter(nil), rowset=16
      access([t1.c1], [t1.c2], [t1.c3], [t1.c4]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output([t2.c1]), filter([cast(t2.c1, DECIMAL_INT(10, 0)) = :0]), rowset=16
      access([t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
select * from t1 where c2 + (select c1 from t2 where c1 = t1.c2) < 10;
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  1 |    1 |    1 | a    |
|  2 |    2 | NULL | a    |
|  3 |    3 | NULL | a    |
+----+------+------+------+

explain_protocol: 0
drop table if exists t1;
create table t1(c1 int ,c2 int, c3 int)partition by hash(c1) partitions 5;
drop table if exists t2;
create table t2(c1 int ,c2 int, c3 int)partition by hash(c1) partitions 5;
drop table if exists t3;
create table t3(c1 int ,c2 int, c3 int)partition by hash(c1) partitions 4;
drop table if exists t4;
create table t4(c1 int ,c2 int, c3 int)partition by hash(c1) partitions 4;

insert into t1 values(1, 1, 1);
insert into t1 values(2, 2, 2);
insert into t1 values(3, 3, 3);
insert into t1 values(4, 4, 4);
insert into t1 values(5, 5, 5);

insert into t2 values(1, 1, 1);
insert into t2 values(2, 2, 2);
insert into t2 values(3, 3, 3);
insert into t2 values(4, 4, 4);
insert into t2 values(5, 5, 5);

insert into t3 values(1, 1, 1);
insert into t3 values(2, 2, 2);
insert into t3 values(3, 3, 3);
insert into t3 values(4, 4, 4);
insert into t3 values(5, 5, 5);

insert into t4 values(1, 1, 1);
insert into t4 values(2, 2, 2);
insert into t4 values(3, 3, 3);
insert into t4 values(4, 4, 4);
insert into t4 values(5, 5, 5);
explain_protocol: 2
##PULL TO LOCAL
EXPLAIN select /*+no_rewrite parallel(2)*/ (select count(*) from t1) as ref0 from t2 order by 1;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SUBPLAN FILTER             |        |5       |12          |
|1 |├─PX COORDINATOR           |        |5       |6           |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|5       |6           |
|3 |│   └─PX BLOCK ITERATOR    |        |5       |6           |
|4 |│     └─TABLE FULL SCAN    |t2      |5       |6           |
|5 |└─SCALAR GROUP BY          |        |1       |7           |
|6 |  └─PX COORDINATOR         |        |2       |7           |
|7 |    └─EXCHANGE OUT DISTR   |:EX20000|2       |6           |
|8 |      └─MERGE GROUP BY     |        |2       |6           |
|9 |        └─PX BLOCK ITERATOR|        |5       |6           |
|10|          └─TABLE FULL SCAN|t1      |5       |6           |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([:0]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([subquery(1)(:0)]), init_plan_idxs_(nil), use_batch=false
  1 - output(nil), filter(nil), rowset=16
  2 - output(nil), filter(nil), rowset=16
      dop=2
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  5 - output([T_FUN_COUNT_SUM(T_FUN_COUNT_SUM(T_FUN_COUNT(*)))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT_SUM(T_FUN_COUNT(*)))])
  6 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), rowset=16
  7 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), rowset=16
      dop=2
  8 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), rowset=16
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  9 - output([T_FUN_COUNT(*)]), filter(nil), rowset=16
 10 - output([T_FUN_COUNT(*)]), filter(nil), rowset=16
      access(nil), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true, 
      pushdown_aggregation([T_FUN_COUNT(*)])
select /*+no_rewrite parallel(2)*/ (select count(*) from t1) as ref0 from t2 order by 1;
+------+
| ref0 |
+------+
|    5 |
|    5 |
|    5 |
|    5 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ (select c1 from t1 order by c2 limit 1) as ref0 from t2 order by 1;
Query Plan
==================================================================
|ID|OPERATOR                      |NAME    |EST.ROWS|EST.TIME(us)|
------------------------------------------------------------------
|0 |SUBPLAN FILTER                |        |5       |12          |
|1 |├─PX COORDINATOR              |        |5       |6           |
|2 |│ └─EXCHANGE OUT DISTR        |:EX10000|5       |6           |
|3 |│   └─PX BLOCK ITERATOR       |        |5       |6           |
|4 |│     └─TABLE FULL SCAN       |t2      |5       |6           |
|5 |└─LIMIT                       |        |1       |7           |
|6 |  └─PX COORDINATOR MERGE SORT |        |2       |7           |
|7 |    └─EXCHANGE OUT DISTR      |:EX20000|2       |6           |
|8 |      └─TOP-N SORT            |        |2       |6           |
|9 |        └─PX BLOCK ITERATOR   |        |5       |6           |
|10|          └─TABLE FULL SCAN   |t1      |5       |6           |
==================================================================
Outputs & filters:
-------------------------------------
  0 - output([:0]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([subquery(1)(:0)]), init_plan_idxs_(nil), use_batch=false
  1 - output(nil), filter(nil), rowset=16
  2 - output(nil), filter(nil), rowset=16
      dop=2
  3 - output(nil), filter(nil), rowset=16
  4 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  5 - output([t1.c1]), filter(nil), rowset=16
      limit(1), offset(nil)
  6 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c2, ASC])
  7 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      dop=2
  8 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      sort_keys([t1.c2, ASC]), topn(1)
  9 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
 10 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ (select c1 from t1 order by c2 limit 1) as ref0 from t2 order by 1;
+------+
| ref0 |
+------+
|    1 |
|    1 |
|    1 |
|    1 |
|    1 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2) order by 1;
Query Plan
=============================================================
|ID|OPERATOR                 |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------
|0 |SORT                     |        |5       |13          |
|1 |└─SUBPLAN FILTER         |        |5       |13          |
|2 |  ├─PX COORDINATOR       |        |5       |7           |
|3 |  │ └─EXCHANGE OUT DISTR |:EX10000|5       |7           |
|4 |  │   └─PX BLOCK ITERATOR|        |5       |6           |
|5 |  │     └─TABLE FULL SCAN|t1      |5       |6           |
|6 |  └─PX COORDINATOR       |        |5       |6           |
|7 |    └─EXCHANGE OUT DISTR |:EX20000|5       |6           |
|8 |      └─PX BLOCK ITERATOR|        |5       |6           |
|9 |        └─TABLE FULL SCAN|t2      |5       |6           |
=============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1]), filter(nil), rowset=16
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))(:0)]), init_plan_idxs_(nil), use_batch=false
  2 - output([t1.c1]), filter(nil), startup_filter([:0]), rowset=16
  3 - output([t1.c1]), filter(nil), rowset=16
      dop=2
  4 - output([t1.c1]), filter(nil), rowset=16
  5 - output([t1.c1]), filter(nil), rowset=16
      access([t1.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter(nil), rowset=16
  7 - output(nil), filter(nil), rowset=16
      dop=2
  8 - output(nil), filter(nil), rowset=16
  9 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2)
                                                    and exists(select 1 from t2 where t1.c1 = t2.c1) order by 1;
Query Plan
===================================================================
|ID|OPERATOR                       |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------
|0 |SORT                           |        |3       |461         |
|1 |└─SUBPLAN FILTER               |        |3       |461         |
|2 |  ├─PX COORDINATOR             |        |5       |7           |
|3 |  │ └─EXCHANGE OUT DISTR       |:EX10000|5       |7           |
|4 |  │   └─PX BLOCK ITERATOR      |        |5       |6           |
|5 |  │     └─TABLE FULL SCAN      |t1      |5       |6           |
|6 |  ├─PX COORDINATOR             |        |5       |6           |
|7 |  │ └─EXCHANGE OUT DISTR       |:EX20000|5       |6           |
|8 |  │   └─PX BLOCK ITERATOR      |        |5       |6           |
|9 |  │     └─TABLE FULL SCAN      |t2      |5       |6           |
|10|  └─DISTRIBUTED TABLE FULL SCAN|t2      |1       |90          |
===================================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(2))]), rowset=16
      exec_params_([t1.c1(:0)]), onetime_exprs_([(T_OP_EXISTS, subquery(1))(:1)]), init_plan_idxs_(nil), use_batch=false
  2 - output([t1.c1]), filter(nil), startup_filter([:1]), rowset=16
  3 - output([t1.c1]), filter(nil), rowset=16
      dop=2
  4 - output([t1.c1]), filter(nil), rowset=16
  5 - output([t1.c1]), filter(nil), rowset=16
      access([t1.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter(nil), rowset=16
  7 - output(nil), filter(nil), rowset=16
      dop=2
  8 - output(nil), filter(nil), rowset=16
  9 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
 10 - output([1]), filter([:0 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2)
                                                    and exists(select 1 from t2 where t1.c1 = t2.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

##partition wise
EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c1 = t2.c1) order by 1;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |        |3       |119         |
|1 |└─EXCHANGE OUT DISTR       |:EX10000|3       |118         |
|2 |  └─SORT                   |        |3       |118         |
|3 |    └─PX PARTITION ITERATOR|        |3       |118         |
|4 |      └─SUBPLAN FILTER     |        |3       |118         |
|5 |        ├─TABLE FULL SCAN  |t1      |5       |6           |
|6 |        └─TABLE FULL SCAN  |t2      |1       |45          |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter(nil), rowset=16
      partition wise, force partition granule
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), rowset=16
      exec_params_([t1.c1(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  5 - output([t1.c1]), filter(nil), rowset=16
      access([t1.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter([:0 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c1 = t2.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t2 where t1.c1 = t2.c1) order by 1;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT  |        |2       |230         |
|1 |└─EXCHANGE OUT DISTR       |:EX10000|2       |230         |
|2 |  └─SORT                   |        |2       |230         |
|3 |    └─PX PARTITION ITERATOR|        |2       |230         |
|4 |      └─SUBPLAN FILTER     |        |2       |230         |
|5 |        ├─TABLE FULL SCAN  |t1      |5       |6           |
|6 |        ├─TABLE FULL SCAN  |t2      |1       |45          |
|7 |        └─TABLE FULL SCAN  |t2      |1       |45          |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter(nil), rowset=16
      partition wise, force partition granule
  4 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), rowset=16
      exec_params_([t1.c1(:0)], [t1.c1(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  5 - output([t1.c1]), filter(nil), rowset=16
      access([t1.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter([:0 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  7 - output([1]), filter([:1 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t2 where t1.c1 = t2.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t3 where t1.c1 = t3.c1) order by 1;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |        |2       |410         |
|1 |└─EXCHANGE OUT DISTR               |:EX10000|2       |409         |
|2 |  └─SORT                           |        |2       |409         |
|3 |    └─SUBPLAN FILTER               |        |2       |409         |
|4 |      ├─PX BLOCK ITERATOR          |        |5       |6           |
|5 |      │ └─TABLE FULL SCAN          |t1      |5       |6           |
|6 |      ├─DISTRIBUTED TABLE FULL SCAN|t2      |1       |90          |
|7 |      └─DISTRIBUTED TABLE FULL SCAN|t3      |1       |72          |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), rowset=16
      exec_params_([t1.c1(:0)], [t1.c1(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  4 - output([t1.c1]), filter(nil), rowset=16
  5 - output([t1.c1]), filter(nil), rowset=16
      access([t1.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter([:0 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  7 - output([1]), filter([:1 = t3.c1]), rowset=16
      access([t3.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t3 where t1.c1 = t3.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+
##repart
EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c2 = t2.c1) order by 1;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |        |3       |121         |
|1 |└─EXCHANGE OUT DISTR               |:EX10001|3       |121         |
|2 |  └─SORT                           |        |3       |120         |
|3 |    └─SUBPLAN FILTER               |        |3       |120         |
|4 |      ├─EXCHANGE IN DISTR          |        |5       |8           |
|5 |      │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |8           |
|6 |      │   └─PX BLOCK ITERATOR      |        |5       |6           |
|7 |      │     └─TABLE FULL SCAN      |t1      |5       |6           |
|8 |      └─PX PARTITION ITERATOR      |        |1       |45          |
|9 |        └─TABLE FULL SCAN          |t2      |1       |45          |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), rowset=16
      exec_params_([t1.c2(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
  5 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      (#keys=1, [t1.c2]), dop=2
  6 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
  7 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  8 - output([1]), filter(nil), rowset=16
      affinitize, partition wise
  9 - output(nil), filter([:0 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c2 = t2.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2, t3 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t2 where t1.c2 = t2.c1) order by 1;
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT              |        |2       |455         |
|1 |└─EXCHANGE OUT DISTR                   |:EX10000|2       |455         |
|2 |  └─SORT                               |        |2       |454         |
|3 |    └─SUBPLAN FILTER                   |        |2       |454         |
|4 |      ├─PX BLOCK ITERATOR              |        |5       |6           |
|5 |      │ └─TABLE FULL SCAN              |t1      |5       |6           |
|6 |      ├─NESTED-LOOP JOIN CARTESIAN     |        |5       |90          |
|7 |      │ ├─DISTRIBUTED TABLE FULL SCAN  |t2      |1       |90          |
|8 |      │ └─MATERIAL                     |        |5       |72          |
|9 |      │   └─DISTRIBUTED TABLE FULL SCAN|t3      |5       |72          |
|10|      └─DISTRIBUTED TABLE FULL SCAN    |t2      |1       |90          |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), rowset=16
      exec_params_([t1.c1(:0)], [t1.c2(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
  5 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  7 - output(nil), filter([:0 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  8 - output(nil), filter(nil), rowset=16
  9 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
 10 - output([1]), filter([:1 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2, t3 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t2 where t1.c2 = t2.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2, t3 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t2 where t1.c2 = t2.c1)
                                                    and exists(select 1 from t2 where t1.c2 = t2.c1) order by 1;
Query Plan
===========================================================================
|ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT              |        |2       |679         |
|1 |└─EXCHANGE OUT DISTR                   |:EX10000|2       |679         |
|2 |  └─SORT                               |        |2       |678         |
|3 |    └─SUBPLAN FILTER                   |        |2       |678         |
|4 |      ├─PX BLOCK ITERATOR              |        |5       |6           |
|5 |      │ └─TABLE FULL SCAN              |t1      |5       |6           |
|6 |      ├─NESTED-LOOP JOIN CARTESIAN     |        |5       |90          |
|7 |      │ ├─DISTRIBUTED TABLE FULL SCAN  |t2      |1       |90          |
|8 |      │ └─MATERIAL                     |        |5       |72          |
|9 |      │   └─DISTRIBUTED TABLE FULL SCAN|t3      |5       |72          |
|10|      ├─DISTRIBUTED TABLE FULL SCAN    |t2      |1       |90          |
|11|      └─DISTRIBUTED TABLE FULL SCAN    |t2      |1       |90          |
===========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))], [(T_OP_EXISTS, subquery(3))]), rowset=16
      exec_params_([t1.c1(:0)], [t1.c2(:1)], [t1.c2(:2)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
  5 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  7 - output(nil), filter([:0 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  8 - output(nil), filter(nil), rowset=16
  9 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
 10 - output([1]), filter([:1 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
 11 - output([1]), filter([:2 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2, t3 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t2 where t1.c2 = t2.c1)
                                                    and exists(select 1 from t2 where t1.c2 = t2.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t3 where t1.c2 = t3.c1) order by 1;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |        |2       |410         |
|1 |└─EXCHANGE OUT DISTR               |:EX10000|2       |409         |
|2 |  └─SORT                           |        |2       |409         |
|3 |    └─SUBPLAN FILTER               |        |2       |409         |
|4 |      ├─PX BLOCK ITERATOR          |        |5       |6           |
|5 |      │ └─TABLE FULL SCAN          |t1      |5       |6           |
|6 |      ├─DISTRIBUTED TABLE FULL SCAN|t2      |1       |90          |
|7 |      └─DISTRIBUTED TABLE FULL SCAN|t3      |1       |72          |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), rowset=16
      exec_params_([t1.c1(:0)], [t1.c2(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
  5 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter([:0 = t2.c1]), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  7 - output([1]), filter([:1 = t3.c1]), rowset=16
      access([t3.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c1 = t2.c1)
                                                    and exists(select 1 from t3 where t1.c2 = t3.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t4 where t1.c2 = t4.c1) and exists (select 1 from t3 where t1.c2 = t3.c1) order by 1;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |        |2       |188         |
|1 |└─EXCHANGE OUT DISTR               |:EX10001|2       |188         |
|2 |  └─SORT                           |        |2       |188         |
|3 |    └─SUBPLAN FILTER               |        |2       |188         |
|4 |      ├─EXCHANGE IN DISTR          |        |5       |8           |
|5 |      │ └─EXCHANGE OUT DISTR (PKEY)|:EX10000|5       |8           |
|6 |      │   └─PX BLOCK ITERATOR      |        |5       |6           |
|7 |      │     └─TABLE FULL SCAN      |t1      |5       |6           |
|8 |      ├─PX PARTITION ITERATOR      |        |1       |36          |
|9 |      │ └─TABLE FULL SCAN          |t4      |1       |36          |
|10|      └─PX PARTITION ITERATOR      |        |1       |36          |
|11|        └─TABLE FULL SCAN          |t3      |1       |36          |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), rowset=16
      exec_params_([t1.c2(:0)], [t1.c2(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
  5 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      (#keys=1, [t1.c2]), dop=2
  6 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
  7 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  8 - output([1]), filter(nil), rowset=16
      affinitize, partition wise
  9 - output(nil), filter([:0 = t4.c1]), rowset=16
      access([t4.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t4.__pk_increment]), range(MIN ; MAX)always true
 10 - output([1]), filter(nil), rowset=16
      affinitize, partition wise
 11 - output(nil), filter([:1 = t3.c1]), rowset=16
      access([t3.c1]), partitions(p[0-3])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t4 where t1.c2 = t4.c1) and exists (select 1 from t3 where t1.c2 = t3.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

##bc2host
EXPLAIN select /*+no_rewrite parallel(2)*/ (select c1 from t1 where t1.c1 = t2.c1 order by c2 limit 1) as ref0 from t2 order by 1;
Query Plan
=========================================================================
|ID|OPERATOR                             |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT            |        |5       |232         |
|1 |└─EXCHANGE OUT DISTR                 |:EX10000|5       |231         |
|2 |  └─SORT                             |        |5       |230         |
|3 |    └─SUBPLAN FILTER                 |        |5       |230         |
|4 |      ├─PX BLOCK ITERATOR            |        |5       |6           |
|5 |      │ └─TABLE FULL SCAN            |t2      |5       |6           |
|6 |      └─TOP-N SORT                   |        |1       |90          |
|7 |        └─DISTRIBUTED TABLE FULL SCAN|t1      |1       |90          |
=========================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(subquery(1))]), filter(nil), rowset=16
      sort_keys([subquery(1), ASC])
  1 - output([subquery(1)], [INTERNAL_FUNCTION(subquery(1))]), filter(nil), rowset=16
      dop=2
  2 - output([subquery(1)]), filter(nil), rowset=16
      sort_keys([subquery(1), ASC])
  3 - output([subquery(1)]), filter(nil), rowset=16
      exec_params_([t2.c1(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  4 - output([t2.c1]), filter(nil), rowset=16
  5 - output([t2.c1]), filter(nil), rowset=16
      access([t2.c1]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
  6 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c2, ASC]), topn(1)
  7 - output([t1.c1], [t1.c2]), filter([t1.c1 = :0]), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ (select c1 from t1 where t1.c1 = t2.c1 order by c2 limit 1) as ref0 from t2 order by 1;
+------+
| ref0 |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c2 = t2.c2) order by 1;
Query Plan
=======================================================================
|ID|OPERATOR                           |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT          |        |3       |231         |
|1 |└─EXCHANGE OUT DISTR               |:EX10000|3       |230         |
|2 |  └─SORT                           |        |3       |230         |
|3 |    └─SUBPLAN FILTER               |        |3       |230         |
|4 |      ├─PX BLOCK ITERATOR          |        |5       |6           |
|5 |      │ └─TABLE FULL SCAN          |t1      |5       |6           |
|6 |      └─DISTRIBUTED TABLE FULL SCAN|t2      |1       |90          |
=======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), rowset=16
      exec_params_([t1.c2(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
  5 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter([:0 = t2.c2]), rowset=16
      access([t2.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2 where t1.c2 = t2.c2) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

EXPLAIN select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2, t3, t4 where t1.c2 = t2.c2 group by t1.c1) order by 1;
Query Plan
===============================================================================
|ID|OPERATOR                                   |NAME    |EST.ROWS|EST.TIME(us)|
-------------------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT                  |        |3       |233         |
|1 |└─EXCHANGE OUT DISTR                       |:EX10000|3       |233         |
|2 |  └─SORT                                   |        |3       |232         |
|3 |    └─SUBPLAN FILTER                       |        |3       |232         |
|4 |      ├─PX BLOCK ITERATOR                  |        |5       |6           |
|5 |      │ └─TABLE FULL SCAN                  |t1      |5       |6           |
|6 |      └─MERGE GROUP BY                     |        |1       |91          |
|7 |        └─NESTED-LOOP JOIN CARTESIAN       |        |25      |91          |
|8 |          ├─NESTED-LOOP JOIN CARTESIAN     |        |5       |90          |
|9 |          │ ├─DISTRIBUTED TABLE FULL SCAN  |t2      |1       |90          |
|10|          │ └─MATERIAL                     |        |5       |72          |
|11|          │   └─DISTRIBUTED TABLE FULL SCAN|t3      |5       |72          |
|12|          └─MATERIAL                       |        |5       |72          |
|13|            └─DISTRIBUTED TABLE FULL SCAN  |t4      |5       |72          |
===============================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), rowset=16
      dop=2
  2 - output([t1.c1]), filter(nil), rowset=16
      sort_keys([t1.c1, ASC])
  3 - output([t1.c1]), filter([(T_OP_EXISTS, subquery(1))]), rowset=16
      exec_params_([t1.c2(:0)], [t1.c1(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  4 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
  5 - output([t1.c1], [t1.c2]), filter(nil), rowset=16
      access([t1.c1], [t1.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, 
      range_key([t1.__pk_increment]), range(MIN ; MAX)always true
  6 - output([1]), filter(nil), rowset=16
      group(nil), agg_func(nil)
  7 - output(nil), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  8 - output(nil), filter(nil), rowset=16
      conds(nil), nl_params_(nil), use_batch=false
  9 - output(nil), filter([:0 = t2.c2]), rowset=16
      access([t2.c2]), partitions(p[0-4])
      is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.__pk_increment]), range(MIN ; MAX)always true
 10 - output(nil), filter(nil), rowset=16
 11 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t3.__pk_increment]), range(MIN ; MAX)always true
 12 - output(nil), filter(nil), rowset=16
 13 - output(nil), filter(nil), rowset=16
      access(nil), partitions(p[0-3])
      is_index_back=false, is_global_index=false, 
      range_key([t4.__pk_increment]), range(MIN ; MAX)always true
select /*+no_rewrite parallel(2)*/ c1 from t1 where exists(select 1 from t2, t3, t4 where t1.c2 = t2.c2 group by t1.c1) order by 1;
+------+
| c1   |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
+------+

drop table t1;
drop table t2;
drop table t3;
drop table t4;
set ob_enable_transformation = on;
explain_protocol: 0
drop table if exists t1;
drop table if exists t2;
create table t1 (c1 int primary key, c2 decimal, c3 int, c4 varchar(20)) partition by hash(c1) partitions 2;
create table t2 (c1 int primary key, c2 decimal, c3 int, c4 varchar(20));

insert into t1 (c1, c2, c3, c4) values (1, 1, 1, 'a');
insert into t1 (c1, c2, c3, c4) values (2, 2, null, 'a');
insert into t1 (c1, c2, c3, c4) values (12, 9, null, 'a');
insert into t1 (c1, c2, c3, c4) values (4, 3, null, 'a');
insert into t1 (c1, c2, c3, c4) values (3, 3, null, 'a');
insert into t1 (c1, c2, c3, c4) values (9, 10, null, 'a');
insert into t1 (c1, c2, c3, c4) values (7, 4, null, 'a');
insert into t1 (c1, c2, c3, c4) values (6, 7, null, 'a');

insert into t1 (c1, c2, c3, c4) values (18, 1, null, 'a');
insert into t1 (c1, c2, c3, c4) values (19, 2, null, 'a');
insert into t1 (c1, c2, c3, c4) values (20, 3, null, 'a');
insert into t1 (c1, c2, c3, c4) values (21, 5, null, 'a');
insert into t1 (c1, c2, c3, c4) values (22, 7, null, 'a');
insert into t1 (c1, c2, c3, c4) values (23, 7, null, 'a');
insert into t1 (c1, c2, c3, c4) values (24, 7, null, 'a');
insert into t1 (c1, c2, c3, c4) values (25, 7, null, 'a');
insert into t1 (c1, c2, c3, c4) values (26, 9, null, 'a');
insert into t1 (c1, c2, c3, c4) values (28, 3, null, 'a');

insert into t2 (c1, c2, c3, c4) values (1, 1, 1, 'a');
insert into t2 (c1, c2, c3, c4) values (2, 2, null, 'a');
insert into t2 (c1, c2, c3, c4) values (3, 3, null, 'a');
insert into t2 (c1, c2, c3, c4) values (11, 5, null, 'a');
insert into t2 (c1, c2, c3, c4) values (5, 3, null, 'a');
insert into t2 (c1, c2, c3, c4) values (15, 13, null, 'a');
insert into t2 (c1, c2, c3, c4) values (17, 12, null, 'a');
insert into t2 (c1, c2, c3, c4) values (6, 3, null, 'a');
insert into t2 (c1, c2, c3, c4) values (7, 5, null, 'a');
insert into t2 (c1, c2, c3, c4) values (10, 5, null, 'a');
insert into t2 (c1, c2, c3, c4) values (13, 6, null, 'a');
insert into t2 (c1, c2, c3, c4) values (14, 17, null, 'a');

insert into t2 (c1, c2, c3, c4) values (18, 3, null, 'a');
insert into t2 (c1, c2, c3, c4) values (19, 3, null, 'a');
insert into t2 (c1, c2, c3, c4) values (20, 6, null, 'a');
insert into t2 (c1, c2, c3, c4) values (21, 5, null, 'a');
insert into t2 (c1, c2, c3, c4) values (22, 3, null, 'a');
insert into t2 (c1, c2, c3, c4) values (23, 5, null, 'a');
insert into t2 (c1, c2, c3, c4) values (24, 6, null, 'a');
insert into t2 (c1, c2, c3, c4) values (26, 3, null, 'a');
insert into t2 (c1, c2, c3, c4) values (27, 5, null, 'a');
insert into t2 (c1, c2, c3, c4) values (29, 12, null, 'a');

explain_protocol: 3
EXPLAIN EXTENDED_NOADDR select c1,c1 in (select c1 from t2 where t2.c1 >= t1.c1) as x from t1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |18      |290         |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|18      |287         |
|2 |  └─SUBPLAN FILTER                |        |18      |281         |
|3 |    ├─PX PARTITION ITERATOR       |        |18      |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |18      |5           |
|5 |    └─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [t1.c1 = ANY(subquery(1))]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 >= :0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 in (select c1 from t2 where t2.c1 >= t1.c1) as x from t1;
+----+---+
| c1 | x |
+----+---+
|  1 | 1 |
|  2 | 1 |
|  3 | 1 |
|  4 | 0 |
|  6 | 1 |
|  7 | 1 |
|  9 | 0 |
| 12 | 0 |
| 18 | 1 |
| 19 | 1 |
| 20 | 1 |
| 21 | 1 |
| 22 | 1 |
| 23 | 1 |
| 24 | 1 |
| 25 | 0 |
| 26 | 1 |
| 28 | 0 |
+----+---+
EXPLAIN EXTENDED_NOADDR select c1, (select c1 from t2 where t2.c1 >= t1.c1 and t2.c2 > t1.c3 limit 1) as x from t1;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |SUBPLAN FILTER             |        |18      |346         |
|1 |├─PX COORDINATOR           |        |18      |23          |
|2 |│ └─EXCHANGE OUT DISTR     |:EX10000|18      |18          |
|3 |│   └─PX PARTITION ITERATOR|        |18      |6           |
|4 |│     └─TABLE FULL SCAN    |t1      |18      |6           |
|5 |└─TABLE RANGE SCAN         |t2      |1       |18          |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.c1], [subquery(1)]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)], [t1.c3(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false
  1 - output([t1.c1], [t1.c3]), filter(nil), rowset=256
  2 - output([t1.c1], [t1.c3]), filter(nil), rowset=256
      dop=1
  3 - output([t1.c1], [t1.c3]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1], [t1.c3]), filter(nil), rowset=256
      access([t1.c1], [t1.c3]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter([t2.c2 > cast(:1, DECIMAL_INT(10, 0))]), rowset=256
      access([t2.c1], [t2.c2]), partitions(p0)
      limit(1), offset(nil), is_index_back=false, is_global_index=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 >= :0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2") LOCAL LOCAL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:4
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Parameters:
      :0 => 1
  Note:
      Degree of Parallelisim is 1 because of table property
select c1, (select c1 from t2 where t2.c1 >= t1.c1 and t2.c2 > t1.c3 limit 1) as x from t1;
+----+---+
| c1 | x |
+----+---+
|  1 | 2 |
|  2 | NULL |
|  3 | NULL |
|  4 | NULL |
|  6 | NULL |
|  7 | NULL |
|  9 | NULL |
| 12 | NULL |
| 18 | NULL |
| 19 | NULL |
| 20 | NULL |
| 21 | NULL |
| 22 | NULL |
| 23 | NULL |
| 24 | NULL |
| 25 | NULL |
| 26 | NULL |
| 28 | NULL |
+----+---+
EXPLAIN EXTENDED_NOADDR select c1,c1 + (select c1 from t2 where t2.c1 = t1.c1) as x from t1;
Query Plan
===============================================================
|ID|OPERATOR                   |NAME    |EST.ROWS|EST.TIME(us)|
---------------------------------------------------------------
|0 |PX COORDINATOR             |        |18      |290         |
|1 |└─EXCHANGE OUT DISTR       |:EX10000|18      |287         |
|2 |  └─SUBPLAN FILTER         |        |18      |281         |
|3 |    ├─PX PARTITION ITERATOR|        |18      |5           |
|4 |    │ └─TABLE FULL SCAN    |t1      |18      |5           |
|5 |    └─DISTRIBUTED TABLE GET|t2      |1       |16          |
===============================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 + subquery(1))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 + subquery(1))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [subquery(1)]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = :0])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 + (select c1 from t2 where t2.c1 = t1.c1) as x from t1;
+----+----+
| c1 | x  |
+----+----+
|  1 |  2 |
|  2 |  4 |
|  3 |  6 |
|  4 | NULL |
|  6 | 12 |
|  7 | 14 |
|  9 | NULL |
| 12 | NULL |
| 18 | 36 |
| 19 | 38 |
| 20 | 40 |
| 21 | 42 |
| 22 | 44 |
| 23 | 46 |
| 24 | 48 |
| 25 | NULL |
| 26 | 52 |
| 28 | NULL |
+----+----+
EXPLAIN EXTENDED_NOADDR select c1,c1 in (select c1 from t2 where t2.c1 >= t1.c1) and c1 in  (select c2 from t2 where t2.c1 >= t1.c1) as x from t1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |18      |566         |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|18      |564         |
|2 |  └─SUBPLAN FILTER                |        |18      |557         |
|3 |    ├─PX PARTITION ITERATOR       |        |18      |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |18      |5           |
|5 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|6 |    └─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [t1.c1 = ANY(subquery(1))], [cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2))]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)], [t1.c1(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 >= :0])
  6 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 >= :1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
  stmt_id:3, SEL$3
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2" "SEL$3") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      FULL(@"SEL$3" "test"."t2"@"SEL$3")
      USE_DAS(@"SEL$3" "test"."t2"@"SEL$3")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 in (select c1 from t2 where t2.c1 >= t1.c1) and c1 in  (select c2 from t2 where t2.c1 >= t1.c1) as x from t1;
+----+------+
| c1 | x    |
+----+------+
|  1 |    1 |
|  2 |    1 |
|  3 |    1 |
|  4 |    0 |
|  6 |    1 |
|  7 |    0 |
|  9 |    0 |
| 12 |    0 |
| 18 |    0 |
| 19 |    0 |
| 20 |    0 |
| 21 |    0 |
| 22 |    0 |
| 23 |    0 |
| 24 |    0 |
| 25 |    0 |
| 26 |    0 |
| 28 |    0 |
+----+------+
EXPLAIN EXTENDED_NOADDR select c1,c1 in (select c1 from t2 where t2.c1 >= t1.c1) or c1 in  (select c2 from t2 where t2.c1 >= t1.c1) as x from t1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |18      |566         |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|18      |564         |
|2 |  └─SUBPLAN FILTER                |        |18      |557         |
|3 |    ├─PX PARTITION ITERATOR       |        |18      |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |18      |5           |
|5 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|6 |    └─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) OR cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) OR cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [t1.c1 = ANY(subquery(1))], [cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2))]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)], [t1.c1(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 >= :0])
  6 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 >= :1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
  stmt_id:3, SEL$3
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2" "SEL$3") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      FULL(@"SEL$3" "test"."t2"@"SEL$3")
      USE_DAS(@"SEL$3" "test"."t2"@"SEL$3")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 in (select c1 from t2 where t2.c1 >= t1.c1) or c1 in  (select c2 from t2 where t2.c1 >= t1.c1) as x from t1;
+----+------+
| c1 | x    |
+----+------+
|  1 |    1 |
|  2 |    1 |
|  3 |    1 |
|  4 |    0 |
|  6 |    1 |
|  7 |    1 |
|  9 |    0 |
| 12 |    1 |
| 18 |    1 |
| 19 |    1 |
| 20 |    1 |
| 21 |    1 |
| 22 |    1 |
| 23 |    1 |
| 24 |    1 |
| 25 |    0 |
| 26 |    1 |
| 28 |    0 |
+----+------+
EXPLAIN EXTENDED_NOADDR select c1,c1 in (select c1 from t2 where t2.c1 <= t1.c1) and c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as x from t1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |18      |566         |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|18      |564         |
|2 |  └─SUBPLAN FILTER                |        |18      |557         |
|3 |    ├─PX PARTITION ITERATOR       |        |18      |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |18      |5           |
|5 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|6 |    └─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [t1.c1 = ANY(subquery(1))], [cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2))]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)], [t1.c1(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :0])
  6 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
  stmt_id:3, SEL$3
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2" "SEL$3") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      FULL(@"SEL$3" "test"."t2"@"SEL$3")
      USE_DAS(@"SEL$3" "test"."t2"@"SEL$3")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 in (select c1 from t2 where t2.c1 <= t1.c1) and c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as x from t1;
+----+------+
| c1 | x    |
+----+------+
|  1 |    1 |
|  2 |    1 |
|  3 |    1 |
|  4 |    0 |
|  6 |    0 |
|  7 |    0 |
|  9 |    0 |
| 12 |    0 |
| 18 |    0 |
| 19 |    0 |
| 20 |    0 |
| 21 |    0 |
| 22 |    0 |
| 23 |    0 |
| 24 |    0 |
| 25 |    0 |
| 26 |    0 |
| 28 |    0 |
+----+------+
EXPLAIN EXTENDED_NOADDR select c1,c1 in (select c1 from t2 where t2.c1 <= t1.c1) or c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as x from t1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |18      |566         |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|18      |564         |
|2 |  └─SUBPLAN FILTER                |        |18      |557         |
|3 |    ├─PX PARTITION ITERATOR       |        |18      |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |18      |5           |
|5 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|6 |    └─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) OR cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) OR cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [t1.c1 = ANY(subquery(1))], [cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2))]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)], [t1.c1(:1)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :0])
  6 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
  stmt_id:3, SEL$3
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2" "SEL$3") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      FULL(@"SEL$3" "test"."t2"@"SEL$3")
      USE_DAS(@"SEL$3" "test"."t2"@"SEL$3")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 in (select c1 from t2 where t2.c1 <= t1.c1) or c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as x from t1;
+----+------+
| c1 | x    |
+----+------+
|  1 |    1 |
|  2 |    1 |
|  3 |    1 |
|  4 |    0 |
|  6 |    1 |
|  7 |    1 |
|  9 |    0 |
| 12 |    0 |
| 18 |    1 |
| 19 |    1 |
| 20 |    1 |
| 21 |    1 |
| 22 |    1 |
| 23 |    1 |
| 24 |    1 |
| 25 |    0 |
| 26 |    1 |
| 28 |    0 |
+----+------+
EXPLAIN EXTENDED_NOADDR select c1,c1 in (select c1 from t2 where t2.c1 <= t1.c1) and c1 in  (select c2 from t2 where t2.c1 <= t1.c1) or c1 + (select c1 from t2 where t2.c1 = t1.c1) as x from t1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |18      |842         |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|18      |839         |
|2 |  └─SUBPLAN FILTER                |        |18      |833         |
|3 |    ├─PX PARTITION ITERATOR       |        |18      |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |18      |5           |
|5 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|6 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|7 |    └─DISTRIBUTED TABLE GET       |t2      |1       |16          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)) OR BOOL(t1.c1 + subquery(3)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2)) OR BOOL(t1.c1 + subquery(3)))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [t1.c1 = ANY(subquery(1))], [cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(2))], [subquery(3)]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)], [t1.c1(:1)], [t1.c1(:2)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :0])
  6 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :1])
  7 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = :2])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
  stmt_id:3, SEL$3
  stmt_id:4, SEL$4
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2" "SEL$3" "SEL$4") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      FULL(@"SEL$3" "test"."t2"@"SEL$3")
      USE_DAS(@"SEL$3" "test"."t2"@"SEL$3")
      FULL(@"SEL$4" "test"."t2"@"SEL$4")
      USE_DAS(@"SEL$4" "test"."t2"@"SEL$4")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 in (select c1 from t2 where t2.c1 <= t1.c1) and c1 in  (select c2 from t2 where t2.c1 <= t1.c1) or c1 + (select c1 from t2 where t2.c1 = t1.c1) as x from t1;
+----+------+
| c1 | x    |
+----+------+
|  1 |    1 |
|  2 |    1 |
|  3 |    1 |
|  4 | NULL |
|  6 |    1 |
|  7 |    1 |
|  9 | NULL |
| 12 | NULL |
| 18 |    1 |
| 19 |    1 |
| 20 |    1 |
| 21 |    1 |
| 22 |    1 |
| 23 |    1 |
| 24 |    1 |
| 25 | NULL |
| 26 |    1 |
| 28 | NULL |
+----+------+

EXPLAIN EXTENDED_NOADDR select c1,c1 in (select c1 from t2 where t2.c1=t1.c1) and  c1 in (select c1 from t2 where t2.c1 <= t1.c1) or c1 + (select c1 from t2 where t2.c1 = t1.c1) as x, c1+(select c1 from t2 where t2.c1 = t1.c1) or c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as y,c1+(select c2 from t2 where t1.c1=t2.c1) > 10 and c1 in  (select c1 from t2 where t1.c1>= t2.c1) as z from t1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |18      |1946        |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|18      |1943        |
|2 |  └─SUBPLAN FILTER                |        |18      |1937        |
|3 |    ├─PX PARTITION ITERATOR       |        |18      |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |18      |5           |
|5 |    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|6 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|7 |    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|8 |    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|9 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|10|    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|11|    └─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND t1.c1 = ANY(subquery(2)) OR BOOL(t1.c1 + subquery(3)), BOOL(t1.c1 + subquery(4)) OR 
      cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(5)), cast(t1.c1, DECIMAL_INT(12, 0)) + subquery(6) > cast(10, DECIMAL_INT(12, 0)) AND t1.c1 = ANY(subquery(7)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND t1.c1 = ANY(subquery(2)) OR BOOL(t1.c1 + subquery(3)), BOOL(t1.c1 + subquery(4)) OR 
      cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(5)), cast(t1.c1, DECIMAL_INT(12, 0)) + subquery(6) > cast(10, DECIMAL_INT(12, 0)) AND t1.c1 = ANY(subquery(7)))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [t1.c1 = ANY(subquery(1))], [t1.c1 = ANY(subquery(2))], [cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(5))], [t1.c1 = ANY(subquery(7))],
       [subquery(3)], [subquery(4)], [subquery(6)]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)], [t1.c1(:1)], [t1.c1(:2)], [t1.c1(:3)], [t1.c1(:4)], [t1.c1(:5)], [t1.c1(:6)]), onetime_exprs_(nil), init_plan_idxs_(nil),
       use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = :0])
  6 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :1])
  7 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = :2])
  8 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = :3])
  9 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :4])
 10 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([:5 = t2.c1])
 11 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([:6 >= t2.c1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
  stmt_id:3, SEL$3
  stmt_id:4, SEL$4
  stmt_id:5, SEL$5
  stmt_id:6, SEL$6
  stmt_id:7, SEL$7
  stmt_id:8, SEL$8
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2" "SEL$3" "SEL$4" "SEL$5" "SEL$6" "SEL$7" "SEL$8") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      FULL(@"SEL$3" "test"."t2"@"SEL$3")
      USE_DAS(@"SEL$3" "test"."t2"@"SEL$3")
      FULL(@"SEL$4" "test"."t2"@"SEL$4")
      USE_DAS(@"SEL$4" "test"."t2"@"SEL$4")
      FULL(@"SEL$5" "test"."t2"@"SEL$5")
      USE_DAS(@"SEL$5" "test"."t2"@"SEL$5")
      FULL(@"SEL$6" "test"."t2"@"SEL$6")
      USE_DAS(@"SEL$6" "test"."t2"@"SEL$6")
      FULL(@"SEL$7" "test"."t2"@"SEL$7")
      USE_DAS(@"SEL$7" "test"."t2"@"SEL$7")
      FULL(@"SEL$8" "test"."t2"@"SEL$8")
      USE_DAS(@"SEL$8" "test"."t2"@"SEL$8")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Parameters:
      :0 => 10
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 in (select c1 from t2 where t2.c1=t1.c1) and  c1 in (select c1 from t2 where t2.c1 <= t1.c1) or c1 + (select c1 from t2 where t2.c1 = t1.c1) as x, c1+(select c1 from t2 where t2.c1 = t1.c1) or c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as y,c1+(select c2 from t2 where t1.c1=t2.c1) > 10 and c1 in  (select c1 from t2 where t1.c1>= t2.c1) as z from t1;
+----+------+------+------+
| c1 | x    | y    | z    |
+----+------+------+------+
|  1 |    1 |    1 |    0 |
|  2 |    1 |    1 |    0 |
|  3 |    1 |    1 |    0 |
|  4 | NULL | NULL |    0 |
|  6 |    1 |    1 |    0 |
|  7 |    1 |    1 |    1 |
|  9 | NULL | NULL |    0 |
| 12 | NULL | NULL |    0 |
| 18 |    1 |    1 |    1 |
| 19 |    1 |    1 |    1 |
| 20 |    1 |    1 |    1 |
| 21 |    1 |    1 |    1 |
| 22 |    1 |    1 |    1 |
| 23 |    1 |    1 |    1 |
| 24 |    1 |    1 |    1 |
| 25 | NULL | NULL |    0 |
| 26 |    1 |    1 |    1 |
| 28 | NULL | NULL |    0 |
+----+------+------+------+

EXPLAIN EXTENDED_NOADDR select c1,c1 in (select c1 from t2 where t2.c1>=t1.c1) and  c1 in (select c1 from t2 where t2.c1 <= t1.c1) or c1 + (select c1 from t2 where t2.c1 = t1.c1) as x, c1+(select c1 from t2 where t2.c1 = t1.c1) > 30 or c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as y,c1+(select c2 from t2 where t1.c1=t2.c1) > 10 and c1 in  (select c1 from t2 where t1.c1>= t2.c1) as z from t1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |18      |1946        |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|18      |1943        |
|2 |  └─SUBPLAN FILTER                |        |18      |1937        |
|3 |    ├─PX PARTITION ITERATOR       |        |18      |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |18      |5           |
|5 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|6 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|7 |    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|8 |    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|9 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|10|    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|11|    └─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND t1.c1 = ANY(subquery(2)) OR BOOL(t1.c1 + subquery(3)), t1.c1 + subquery(4) > 30 OR cast(t1.c1,
       DECIMAL_INT(10, 0)) = ANY(subquery(5)), cast(t1.c1, DECIMAL_INT(12, 0)) + subquery(6) > cast(10, DECIMAL_INT(12, 0)) AND t1.c1 = ANY(subquery(7)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND t1.c1 = ANY(subquery(2)) OR BOOL(t1.c1 + subquery(3)), t1.c1 + subquery(4) > 30 OR cast(t1.c1,
       DECIMAL_INT(10, 0)) = ANY(subquery(5)), cast(t1.c1, DECIMAL_INT(12, 0)) + subquery(6) > cast(10, DECIMAL_INT(12, 0)) AND t1.c1 = ANY(subquery(7)))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [t1.c1 = ANY(subquery(1))], [t1.c1 = ANY(subquery(2))], [cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(5))], [t1.c1 = ANY(subquery(7))],
       [subquery(3)], [subquery(4)], [subquery(6)]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)], [t1.c1(:1)], [t1.c1(:2)], [t1.c1(:3)], [t1.c1(:4)], [t1.c1(:5)], [t1.c1(:6)]), onetime_exprs_(nil), init_plan_idxs_(nil),
       use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 >= :0])
  6 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :1])
  7 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = :2])
  8 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = :3])
  9 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :4])
 10 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([:5 = t2.c1])
 11 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([:6 >= t2.c1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
  stmt_id:3, SEL$3
  stmt_id:4, SEL$4
  stmt_id:5, SEL$5
  stmt_id:6, SEL$6
  stmt_id:7, SEL$7
  stmt_id:8, SEL$8
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2" "SEL$3" "SEL$4" "SEL$5" "SEL$6" "SEL$7" "SEL$8") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      FULL(@"SEL$3" "test"."t2"@"SEL$3")
      USE_DAS(@"SEL$3" "test"."t2"@"SEL$3")
      FULL(@"SEL$4" "test"."t2"@"SEL$4")
      USE_DAS(@"SEL$4" "test"."t2"@"SEL$4")
      FULL(@"SEL$5" "test"."t2"@"SEL$5")
      USE_DAS(@"SEL$5" "test"."t2"@"SEL$5")
      FULL(@"SEL$6" "test"."t2"@"SEL$6")
      USE_DAS(@"SEL$6" "test"."t2"@"SEL$6")
      FULL(@"SEL$7" "test"."t2"@"SEL$7")
      USE_DAS(@"SEL$7" "test"."t2"@"SEL$7")
      FULL(@"SEL$8" "test"."t2"@"SEL$8")
      USE_DAS(@"SEL$8" "test"."t2"@"SEL$8")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Parameters:
      :0 => 30
      :1 => 10
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 in (select c1 from t2 where t2.c1>=t1.c1) and  c1 in (select c1 from t2 where t2.c1 <= t1.c1) or c1 + (select c1 from t2 where t2.c1 = t1.c1) as x, c1+(select c1 from t2 where t2.c1 = t1.c1) > 30 or c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as y,c1+(select c2 from t2 where t1.c1=t2.c1) > 10 and c1 in  (select c1 from t2 where t1.c1>= t2.c1) as z from t1;
+----+------+------+------+
| c1 | x    | y    | z    |
+----+------+------+------+
|  1 |    1 |    1 |    0 |
|  2 |    1 |    1 |    0 |
|  3 |    1 |    1 |    0 |
|  4 | NULL | NULL |    0 |
|  6 |    1 |    0 |    0 |
|  7 |    1 |    0 |    1 |
|  9 | NULL | NULL |    0 |
| 12 | NULL | NULL |    0 |
| 18 |    1 |    1 |    1 |
| 19 |    1 |    1 |    1 |
| 20 |    1 |    1 |    1 |
| 21 |    1 |    1 |    1 |
| 22 |    1 |    1 |    1 |
| 23 |    1 |    1 |    1 |
| 24 |    1 |    1 |    1 |
| 25 | NULL | NULL |    0 |
| 26 |    1 |    1 |    1 |
| 28 | NULL | NULL |    0 |
+----+------+------+------+

EXPLAIN EXTENDED_NOADDR select c1,c1 in (select c1 from t2 where t2.c1>=t1.c1) and  c1 in (select c1 from t2 where t2.c1 <= t1.c1) or c1 + (select c1 from t2 where t2.c1 = t1.c1) as x, c1+(select c1 from t2 where t2.c1 = t1.c1) > 30 or c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as y,c1+(select c2 from t2 where t1.c1=t2.c1) > 10 and c1 in  (select c1 from t2 where t1.c1>= t2.c1) as z from t1;
Query Plan
======================================================================
|ID|OPERATOR                          |NAME    |EST.ROWS|EST.TIME(us)|
----------------------------------------------------------------------
|0 |PX COORDINATOR                    |        |18      |1946        |
|1 |└─EXCHANGE OUT DISTR              |:EX10000|18      |1943        |
|2 |  └─SUBPLAN FILTER                |        |18      |1937        |
|3 |    ├─PX PARTITION ITERATOR       |        |18      |5           |
|4 |    │ └─TABLE FULL SCAN           |t1      |18      |5           |
|5 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|6 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|7 |    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|8 |    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|9 |    ├─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
|10|    ├─DISTRIBUTED TABLE GET       |t2      |1       |16          |
|11|    └─DISTRIBUTED TABLE RANGE SCAN|t2      |8       |16          |
======================================================================
Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND t1.c1 = ANY(subquery(2)) OR BOOL(t1.c1 + subquery(3)), t1.c1 + subquery(4) > 30 OR cast(t1.c1,
       DECIMAL_INT(10, 0)) = ANY(subquery(5)), cast(t1.c1, DECIMAL_INT(12, 0)) + subquery(6) > cast(10, DECIMAL_INT(12, 0)) AND t1.c1 = ANY(subquery(7)))]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 = ANY(subquery(1)) AND t1.c1 = ANY(subquery(2)) OR BOOL(t1.c1 + subquery(3)), t1.c1 + subquery(4) > 30 OR cast(t1.c1,
       DECIMAL_INT(10, 0)) = ANY(subquery(5)), cast(t1.c1, DECIMAL_INT(12, 0)) + subquery(6) > cast(10, DECIMAL_INT(12, 0)) AND t1.c1 = ANY(subquery(7)))]), filter(nil), rowset=256
      dop=1
  2 - output([t1.c1], [t1.c1 = ANY(subquery(1))], [t1.c1 = ANY(subquery(2))], [cast(t1.c1, DECIMAL_INT(10, 0)) = ANY(subquery(5))], [t1.c1 = ANY(subquery(7))],
       [subquery(3)], [subquery(4)], [subquery(6)]), filter(nil), rowset=256
      exec_params_([t1.c1(:0)], [t1.c1(:1)], [t1.c1(:2)], [t1.c1(:3)], [t1.c1(:4)], [t1.c1(:5)], [t1.c1(:6)]), onetime_exprs_(nil), init_plan_idxs_(nil),
       use_batch=true
  3 - output([t1.c1]), filter(nil), rowset=256
      force partition granule
  4 - output([t1.c1]), filter(nil), rowset=256
      access([t1.c1]), partitions(p[0-1])
      is_index_back=false, is_global_index=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 >= :0])
  6 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :1])
  7 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = :2])
  8 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = :3])
  9 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 <= :4])
 10 - output([t2.c2]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c2]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([:5 = t2.c1])
 11 - output([t2.c1]), filter(nil), rowset=256
      access([GROUP_ID], [t2.c1]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([:6 >= t2.c1])
Used Hint:
-------------------------------------
  /*+
      
  */
Qb name trace:
-------------------------------------
  stmt_id:0, stmt_type:T_EXPLAIN 
  stmt_id:1, SEL$1
  stmt_id:2, SEL$2
  stmt_id:3, SEL$3
  stmt_id:4, SEL$4
  stmt_id:5, SEL$5
  stmt_id:6, SEL$6
  stmt_id:7, SEL$7
  stmt_id:8, SEL$8
Outline Data: 
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      PQ_SUBQUERY(@"SEL$1" ("SEL$2" "SEL$3" "SEL$4" "SEL$5" "SEL$6" "SEL$7" "SEL$8") NONE ALL)
      FULL(@"SEL$1" "test"."t1"@"SEL$1")
      FULL(@"SEL$2" "test"."t2"@"SEL$2")
      USE_DAS(@"SEL$2" "test"."t2"@"SEL$2")
      FULL(@"SEL$3" "test"."t2"@"SEL$3")
      USE_DAS(@"SEL$3" "test"."t2"@"SEL$3")
      FULL(@"SEL$4" "test"."t2"@"SEL$4")
      USE_DAS(@"SEL$4" "test"."t2"@"SEL$4")
      FULL(@"SEL$5" "test"."t2"@"SEL$5")
      USE_DAS(@"SEL$5" "test"."t2"@"SEL$5")
      FULL(@"SEL$6" "test"."t2"@"SEL$6")
      USE_DAS(@"SEL$6" "test"."t2"@"SEL$6")
      FULL(@"SEL$7" "test"."t2"@"SEL$7")
      USE_DAS(@"SEL$7" "test"."t2"@"SEL$7")
      FULL(@"SEL$8" "test"."t2"@"SEL$8")
      USE_DAS(@"SEL$8" "test"."t2"@"SEL$8")
      OPTIMIZER_FEATURES_ENABLE('')
      END_OUTLINE_DATA
  */
Optimization Info:
-------------------------------------
  t1:
      table_rows:18
      physical_range_rows:18
      logical_range_rows:18
      index_back_rows:0
      output_rows:18
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[t1]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  t2:
      table_rows:22
      physical_range_rows:7
      logical_range_rows:7
      index_back_rows:0
      output_rows:7
      table_dop:1
      dop_method:DAS DOP
      avaiable_index_name:[t2]
      stats info:[version=1970-01-01 08:00:00.000000, is_locked=0, is_expired=0]
      dynamic sampling level:0
      estimation method:[DEFAULT, STORAGE]
  Plan Type:
      DISTRIBUTED
  Parameters:
      :0 => 30
      :1 => 10
  Note:
      Degree of Parallelisim is 1 because of table property
select c1,c1 in (select c1 from t2 where t2.c1>=t1.c1) and  c1 in (select c1 from t2 where t2.c1 <= t1.c1) or c1 + (select c1 from t2 where t2.c1 = t1.c1) as x, c1+(select c1 from t2 where t2.c1 = t1.c1) > 30 or c1 in  (select c2 from t2 where t2.c1 <= t1.c1) as y,c1+(select c2 from t2 where t1.c1=t2.c1) > 10 and c1 in  (select c1 from t2 where t1.c1>= t2.c1) as z from t1;
+----+------+------+------+
| c1 | x    | y    | z    |
+----+------+------+------+
|  1 |    1 |    1 |    0 |
|  2 |    1 |    1 |    0 |
|  3 |    1 |    1 |    0 |
|  4 | NULL | NULL |    0 |
|  6 |    1 |    0 |    0 |
|  7 |    1 |    0 |    1 |
|  9 | NULL | NULL |    0 |
| 12 | NULL | NULL |    0 |
| 18 |    1 |    1 |    1 |
| 19 |    1 |    1 |    1 |
| 20 |    1 |    1 |    1 |
| 21 |    1 |    1 |    1 |
| 22 |    1 |    1 |    1 |
| 23 |    1 |    1 |    1 |
| 24 |    1 |    1 |    1 |
| 25 | NULL | NULL |    0 |
| 26 |    1 |    1 |    1 |
| 28 | NULL | NULL |    0 |
+----+------+------+------+

explain_protocol: 0
drop table if exists t1;
drop table if exists t3;

create table t1 (c1 int primary key, c2 int, c3 int, c4 int) ;
create table t3 (c1 int primary key, c2 int, c3 int, c4 int, index(c3)) ;

insert into t1 (c1, c2, c3, c4) values (1, 1, 1, 1);
insert into t1 (c1, c2, c3, c4) values (2, 2, 2, 2);
insert into t1 (c1, c2, c3, c4) values (12,9, 3, 3);
insert into t1 (c1, c2, c3, c4) values (4, 3, 4, 4);
insert into t1 (c1, c2, c3, c4) values (3, 3, 5, 5);
insert into t1 (c1, c2, c3, c4) values (9, 10,6, 6);
insert into t1 (c1, c2, c3, c4) values (7, 4, 7, 7);
insert into t1 (c1, c2, c3, c4) values (6, 7, 8, 8);

insert into t1 (c1, c2, c3, c4) values (18, 1,9, 9);
insert into t1 (c1, c2, c3, c4) values (19, 2,10,10);
insert into t1 (c1, c2, c3, c4) values (20, 3,11,11);
insert into t1 (c1, c2, c3, c4) values (21, 5,12,12);
insert into t1 (c1, c2, c3, c4) values (22, 7,13,13);
insert into t1 (c1, c2, c3, c4) values (23, 7,14,14);
insert into t1 (c1, c2, c3, c4) values (24, 7,15,15);
insert into t1 (c1, c2, c3, c4) values (25, 7,16,16);
insert into t1 (c1, c2, c3, c4) values (26, 9,17,17);
insert into t1 (c1, c2, c3, c4) values (28, 3,18,18);

insert into t3 (c1, c2, c3, c4) values (1, 1, 1, 1);
insert into t3 (c1, c2, c3, c4) values (2, 2, 2, 2);
insert into t3 (c1, c2, c3, c4) values (12,9, 3, 3);
insert into t3 (c1, c2, c3, c4) values (4, 3, 4, 4);
insert into t3 (c1, c2, c3, c4) values (3, 3, 5, 5);
insert into t3 (c1, c2, c3, c4) values (9, 10,6, 6);
insert into t3 (c1, c2, c3, c4) values (7, 4, 7, 7);
insert into t3 (c1, c2, c3, c4) values (6, 7, 8, 8);

insert into t3 (c1, c2, c3, c4) values (18, 1,9, 9);
insert into t3 (c1, c2, c3, c4) values (19, 2,10,10);
insert into t3 (c1, c2, c3, c4) values (20, 3,11,11);
insert into t3 (c1, c2, c3, c4) values (21, 5,12,12);
insert into t3 (c1, c2, c3, c4) values (22, 7,13,13);
insert into t3 (c1, c2, c3, c4) values (23, 7,14,14);
insert into t3 (c1, c2, c3, c4) values (24, 7,15,15);
insert into t3 (c1, c2, c3, c4) values (25, 7,16,16);
insert into t3 (c1, c2, c3, c4) values (26, 9,17,17);
insert into t3 (c1, c2, c3, c4) values (28, 3,18,18);

select /*+ no_rewrite*/ * from t1 where exists (select /*+no_unnest */ 1 from t3 where t1.c1 > t3.c3 and t3.c4 < 100 limit 1) ;
+----+------+------+------+
| c1 | c2   | c3   | c4   |
+----+------+------+------+
|  2 |    2 |    2 |    2 |
|  3 |    3 |    5 |    5 |
|  4 |    3 |    4 |    4 |
|  6 |    7 |    8 |    8 |
|  7 |    4 |    7 |    7 |
|  9 |   10 |    6 |    6 |
| 12 |    9 |    3 |    3 |
| 18 |    1 |    9 |    9 |
| 19 |    2 |   10 |   10 |
| 20 |    3 |   11 |   11 |
| 21 |    5 |   12 |   12 |
| 22 |    7 |   13 |   13 |
| 23 |    7 |   14 |   14 |
| 24 |    7 |   15 |   15 |
| 25 |    7 |   16 |   16 |
| 26 |    9 |   17 |   17 |
| 28 |    3 |   18 |   18 |
+----+------+------+------+

drop table if exists t;
drop table if exists t2;
drop table if exists t3;
create table t(c1 int);
create table t2(c1 int);
create table t3(c1 int, c2 varchar(1500)) partition by hash(c1) partitions 4;
insert into t2 values(1000);
insert into t3 values(0, repeat('0123456789', 100));
insert into t3 values(0, repeat('0123456789', 101));
insert into t3 values(0, repeat('0123456789', 101));
insert into t3 values(0, repeat('0123456789', 101));
insert into t3 values(0, repeat('0123456789', 101));
insert into t3 values(0, repeat('0123456789', 101));
insert into t3 select * from t3 where length(c2) > 1000;
insert into t3 select * from t3 where length(c2) > 1000;
insert into t3 select * from t3 where length(c2) > 1000;
insert into t3 select * from t3 where length(c2) > 1000;
insert into t3 select * from t3 where length(c2) > 1000;
insert into t3 select * from t3 where length(c2) > 1000;
insert into t3 select * from t3 where length(c2) > 1000;
select /*+ no_rewrite */ * from t where exists (select 1 from t2, t3 where t2.c1 = length(t3.c2));
+------+
| c1   |
+------+
+------+

drop table if exists t;
drop table if exists t2;
drop table if exists t3;
