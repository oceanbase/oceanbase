/**
 * Copyright (c) 2023 OceanBase
 * OceanBase CE is licensed under Mulan PubL v2.
 * You can use this software according to the terms and conditions of the Mulan PubL v2.
 * You may obtain a copy of Mulan PubL v2 at:
 *          http://license.coscl.org.cn/MulanPubL-2.0
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PubL v2 for more details.
 */

/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef hive_metastore_TYPES_H
#define hive_metastore_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>
#include "fb303_types.h"


namespace Apache { namespace Hadoop { namespace Hive {

struct HiveObjectType {
  enum type {
    GLOBAL = 1,
    DATABASE = 2,
    TABLE = 3,
    PARTITION = 4,
    COLUMN = 5,
    DATACONNECTOR = 6
  };
};

extern const std::map<int, const char*> _HiveObjectType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const HiveObjectType::type& val);

std::string to_string(const HiveObjectType::type& val);

struct PrincipalType {
  enum type {
    USER = 1,
    ROLE = 2,
    GROUP = 3
  };
};

extern const std::map<int, const char*> _PrincipalType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const PrincipalType::type& val);

std::string to_string(const PrincipalType::type& val);

struct PartitionEventType {
  enum type {
    LOAD_DONE = 1
  };
};

extern const std::map<int, const char*> _PartitionEventType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const PartitionEventType::type& val);

std::string to_string(const PartitionEventType::type& val);

struct TxnState {
  enum type {
    COMMITTED = 1,
    ABORTED = 2,
    OPEN = 3
  };
};

extern const std::map<int, const char*> _TxnState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TxnState::type& val);

std::string to_string(const TxnState::type& val);

struct LockLevel {
  enum type {
    DB = 1,
    TABLE = 2,
    PARTITION = 3
  };
};

extern const std::map<int, const char*> _LockLevel_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const LockLevel::type& val);

std::string to_string(const LockLevel::type& val);

struct LockState {
  enum type {
    ACQUIRED = 1,
    WAITING = 2,
    ABORT = 3,
    NOT_ACQUIRED = 4
  };
};

extern const std::map<int, const char*> _LockState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const LockState::type& val);

std::string to_string(const LockState::type& val);

struct LockType {
  enum type {
    SHARED_READ = 1,
    SHARED_WRITE = 2,
    EXCLUSIVE = 3,
    EXCL_WRITE = 4
  };
};

extern const std::map<int, const char*> _LockType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const LockType::type& val);

std::string to_string(const LockType::type& val);

struct CompactionType {
  enum type {
    MINOR = 1,
    MAJOR = 2,
    REBALANCE = 3,
    ABORT_TXN_CLEANUP = 4
  };
};

extern const std::map<int, const char*> _CompactionType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const CompactionType::type& val);

std::string to_string(const CompactionType::type& val);

struct GrantRevokeType {
  enum type {
    GRANT = 1,
    REVOKE = 2
  };
};

extern const std::map<int, const char*> _GrantRevokeType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const GrantRevokeType::type& val);

std::string to_string(const GrantRevokeType::type& val);

struct DataOperationType {
  enum type {
    SELECT = 1,
    INSERT = 2,
    UPDATE = 3,
    DELETE = 4,
    UNSET = 5,
    NO_TXN = 6
  };
};

extern const std::map<int, const char*> _DataOperationType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const DataOperationType::type& val);

std::string to_string(const DataOperationType::type& val);

struct EventRequestType {
  enum type {
    INSERT = 1,
    UPDATE = 2,
    DELETE = 3
  };
};

extern const std::map<int, const char*> _EventRequestType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const EventRequestType::type& val);

std::string to_string(const EventRequestType::type& val);

struct SerdeType {
  enum type {
    HIVE = 1,
    SCHEMA_REGISTRY = 2
  };
};

extern const std::map<int, const char*> _SerdeType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SerdeType::type& val);

std::string to_string(const SerdeType::type& val);

struct SchemaType {
  enum type {
    HIVE = 1,
    AVRO = 2
  };
};

extern const std::map<int, const char*> _SchemaType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SchemaType::type& val);

std::string to_string(const SchemaType::type& val);

struct SchemaCompatibility {
  enum type {
    NONE = 1,
    BACKWARD = 2,
    FORWARD = 3,
    BOTH = 4
  };
};

extern const std::map<int, const char*> _SchemaCompatibility_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SchemaCompatibility::type& val);

std::string to_string(const SchemaCompatibility::type& val);

struct SchemaValidation {
  enum type {
    LATEST = 1,
    ALL = 2
  };
};

extern const std::map<int, const char*> _SchemaValidation_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SchemaValidation::type& val);

std::string to_string(const SchemaValidation::type& val);

struct SchemaVersionState {
  enum type {
    INITIATED = 1,
    START_REVIEW = 2,
    CHANGES_REQUIRED = 3,
    REVIEWED = 4,
    ENABLED = 5,
    DISABLED = 6,
    ARCHIVED = 7,
    DELETED = 8
  };
};

extern const std::map<int, const char*> _SchemaVersionState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SchemaVersionState::type& val);

std::string to_string(const SchemaVersionState::type& val);

struct DatabaseType {
  enum type {
    NATIVE = 1,
    REMOTE = 2
  };
};

extern const std::map<int, const char*> _DatabaseType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const DatabaseType::type& val);

std::string to_string(const DatabaseType::type& val);

struct FunctionType {
  enum type {
    JAVA = 1
  };
};

extern const std::map<int, const char*> _FunctionType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FunctionType::type& val);

std::string to_string(const FunctionType::type& val);

struct ResourceType {
  enum type {
    JAR = 1,
    FILE = 2,
    ARCHIVE = 3
  };
};

extern const std::map<int, const char*> _ResourceType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ResourceType::type& val);

std::string to_string(const ResourceType::type& val);

struct TxnType {
  enum type {
    DEFAULT = 0,
    REPL_CREATED = 1,
    READ_ONLY = 2,
    COMPACTION = 3,
    MATER_VIEW_REBUILD = 4,
    SOFT_DELETE = 5,
    REBALANCE_COMPACTION = 6
  };
};

extern const std::map<int, const char*> _TxnType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TxnType::type& val);

std::string to_string(const TxnType::type& val);

struct GetTablesExtRequestFields {
  enum type {
    ACCESS_TYPE = 1,
    PROCESSOR_CAPABILITIES = 2,
    ALL = 2147483647
  };
};

extern const std::map<int, const char*> _GetTablesExtRequestFields_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const GetTablesExtRequestFields::type& val);

std::string to_string(const GetTablesExtRequestFields::type& val);

struct CompactionMetricsMetricType {
  enum type {
    NUM_OBSOLETE_DELTAS = 0,
    NUM_DELTAS = 1,
    NUM_SMALL_DELTAS = 2
  };
};

extern const std::map<int, const char*> _CompactionMetricsMetricType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const CompactionMetricsMetricType::type& val);

std::string to_string(const CompactionMetricsMetricType::type& val);

struct FileMetadataExprType {
  enum type {
    ORC_SARG = 1
  };
};

extern const std::map<int, const char*> _FileMetadataExprType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FileMetadataExprType::type& val);

std::string to_string(const FileMetadataExprType::type& val);

struct ClientCapability {
  enum type {
    TEST_CAPABILITY = 1,
    INSERT_ONLY_TABLES = 2
  };
};

extern const std::map<int, const char*> _ClientCapability_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ClientCapability::type& val);

std::string to_string(const ClientCapability::type& val);

struct WMResourcePlanStatus {
  enum type {
    ACTIVE = 1,
    ENABLED = 2,
    DISABLED = 3
  };
};

extern const std::map<int, const char*> _WMResourcePlanStatus_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const WMResourcePlanStatus::type& val);

std::string to_string(const WMResourcePlanStatus::type& val);

struct WMPoolSchedulingPolicy {
  enum type {
    FAIR = 1,
    FIFO = 2
  };
};

extern const std::map<int, const char*> _WMPoolSchedulingPolicy_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const WMPoolSchedulingPolicy::type& val);

std::string to_string(const WMPoolSchedulingPolicy::type& val);

struct ScheduledQueryMaintenanceRequestType {
  enum type {
    CREATE = 1,
    ALTER = 2,
    DROP = 3
  };
};

extern const std::map<int, const char*> _ScheduledQueryMaintenanceRequestType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ScheduledQueryMaintenanceRequestType::type& val);

std::string to_string(const ScheduledQueryMaintenanceRequestType::type& val);

struct QueryState {
  enum type {
    INITED = 0,
    EXECUTING = 1,
    FAILED = 2,
    FINISHED = 3,
    TIMED_OUT = 4,
    AUTO_DISABLED = 5
  };
};

extern const std::map<int, const char*> _QueryState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const QueryState::type& val);

std::string to_string(const QueryState::type& val);

struct PartitionFilterMode {
  enum type {
    BY_NAMES = 0,
    BY_VALUES = 1,
    BY_EXPR = 2
  };
};

extern const std::map<int, const char*> _PartitionFilterMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const PartitionFilterMode::type& val);

std::string to_string(const PartitionFilterMode::type& val);

class Version;

class FieldSchema;

class EnvironmentContext;

class SQLPrimaryKey;

class SQLForeignKey;

class SQLUniqueConstraint;

class SQLNotNullConstraint;

class SQLDefaultConstraint;

class SQLCheckConstraint;

class SQLAllTableConstraints;

class Type;

class PropertySetRequest;

class PropertyGetRequest;

class PropertyGetResponse;

class HiveObjectRef;

class PrivilegeGrantInfo;

class HiveObjectPrivilege;

class PrivilegeBag;

class PrincipalPrivilegeSet;

class GrantRevokePrivilegeRequest;

class GrantRevokePrivilegeResponse;

class TruncateTableRequest;

class TruncateTableResponse;

class Role;

class RolePrincipalGrant;

class GetRoleGrantsForPrincipalRequest;

class GetRoleGrantsForPrincipalResponse;

class GetPrincipalsInRoleRequest;

class GetPrincipalsInRoleResponse;

class GrantRevokeRoleRequest;

class GrantRevokeRoleResponse;

class Catalog;

class CreateCatalogRequest;

class AlterCatalogRequest;

class GetCatalogRequest;

class GetCatalogResponse;

class GetCatalogsResponse;

class DropCatalogRequest;

class Database;

class SerDeInfo;

class Order;

class SkewedInfo;

class StorageDescriptor;

class CreationMetadata;

class BooleanColumnStatsData;

class DoubleColumnStatsData;

class LongColumnStatsData;

class StringColumnStatsData;

class BinaryColumnStatsData;

class Decimal;

class DecimalColumnStatsData;

class Date;

class DateColumnStatsData;

class Timestamp;

class TimestampColumnStatsData;

class ColumnStatisticsData;

class ColumnStatisticsObj;

class ColumnStatisticsDesc;

class ColumnStatistics;

class FileMetadata;

class ObjectDictionary;

class Table;

class SourceTable;

class Partition;

class PartitionWithoutSD;

class PartitionSpecWithSharedSD;

class PartitionListComposingSpec;

class PartitionSpec;

class AggrStats;

class SetPartitionsStatsRequest;

class SetPartitionsStatsResponse;

class Schema;

class PrimaryKeysRequest;

class PrimaryKeysResponse;

class ForeignKeysRequest;

class ForeignKeysResponse;

class UniqueConstraintsRequest;

class UniqueConstraintsResponse;

class NotNullConstraintsRequest;

class NotNullConstraintsResponse;

class DefaultConstraintsRequest;

class DefaultConstraintsResponse;

class CheckConstraintsRequest;

class CheckConstraintsResponse;

class AllTableConstraintsRequest;

class AllTableConstraintsResponse;

class DropConstraintRequest;

class AddPrimaryKeyRequest;

class AddForeignKeyRequest;

class AddUniqueConstraintRequest;

class AddNotNullConstraintRequest;

class AddDefaultConstraintRequest;

class AddCheckConstraintRequest;

class PartitionsByExprResult;

class PartitionsSpecByExprResult;

class PartitionsByExprRequest;

class TableStatsResult;

class PartitionsStatsResult;

class TableStatsRequest;

class PartitionsStatsRequest;

class AddPartitionsResult;

class AddPartitionsRequest;

class DropPartitionsResult;

class DropPartitionsExpr;

class RequestPartsSpec;

class DropPartitionsRequest;

class DropPartitionRequest;

class PartitionValuesRequest;

class PartitionValuesRow;

class PartitionValuesResponse;

class GetPartitionsByNamesRequest;

class GetPartitionsByNamesResult;

class DataConnector;

class ResourceUri;

class Function;

class TxnInfo;

class GetOpenTxnsInfoResponse;

class GetOpenTxnsResponse;

class OpenTxnRequest;

class OpenTxnsResponse;

class AbortTxnRequest;

class AbortTxnsRequest;

class CommitTxnKeyValue;

class WriteEventInfo;

class ReplLastIdInfo;

class UpdateTransactionalStatsRequest;

class CommitTxnRequest;

class ReplTblWriteIdStateRequest;

class GetValidWriteIdsRequest;

class TableValidWriteIds;

class GetValidWriteIdsResponse;

class TxnToWriteId;

class AllocateTableWriteIdsRequest;

class AllocateTableWriteIdsResponse;

class MaxAllocatedTableWriteIdRequest;

class MaxAllocatedTableWriteIdResponse;

class SeedTableWriteIdsRequest;

class SeedTxnIdRequest;

class LockComponent;

class LockRequest;

class LockResponse;

class CheckLockRequest;

class UnlockRequest;

class ShowLocksRequest;

class ShowLocksResponseElement;

class ShowLocksResponse;

class HeartbeatRequest;

class HeartbeatTxnRangeRequest;

class HeartbeatTxnRangeResponse;

class CompactionRequest;

class CompactionInfoStruct;

class OptionalCompactionInfoStruct;

class CompactionMetricsDataStruct;

class CompactionMetricsDataResponse;

class CompactionMetricsDataRequest;

class CompactionResponse;

class ShowCompactRequest;

class ShowCompactResponseElement;

class ShowCompactResponse;

class AbortCompactionRequest;

class AbortCompactionResponseElement;

class AbortCompactResponse;

class GetLatestCommittedCompactionInfoRequest;

class GetLatestCommittedCompactionInfoResponse;

class FindNextCompactRequest;

class AddDynamicPartitions;

class BasicTxnInfo;

class NotificationEventRequest;

class NotificationEvent;

class NotificationEventResponse;

class CurrentNotificationEventId;

class NotificationEventsCountRequest;

class NotificationEventsCountResponse;

class InsertEventRequestData;

class FireEventRequestData;

class FireEventRequest;

class FireEventResponse;

class WriteNotificationLogRequest;

class WriteNotificationLogResponse;

class WriteNotificationLogBatchRequest;

class WriteNotificationLogBatchResponse;

class MetadataPpdResult;

class GetFileMetadataByExprResult;

class GetFileMetadataByExprRequest;

class GetFileMetadataResult;

class GetFileMetadataRequest;

class PutFileMetadataResult;

class PutFileMetadataRequest;

class ClearFileMetadataResult;

class ClearFileMetadataRequest;

class CacheFileMetadataResult;

class CacheFileMetadataRequest;

class GetAllFunctionsResponse;

class ClientCapabilities;

class GetProjectionsSpec;

class GetTableRequest;

class GetTableResult;

class GetTablesRequest;

class GetTablesResult;

class GetTablesExtRequest;

class ExtendedTableInfo;

class DropTableRequest;

class GetDatabaseRequest;

class AlterDatabaseRequest;

class DropDatabaseRequest;

class CmRecycleRequest;

class CmRecycleResponse;

class TableMeta;

class Materialization;

class WMResourcePlan;

class WMNullableResourcePlan;

class WMPool;

class WMNullablePool;

class WMTrigger;

class WMMapping;

class WMPoolTrigger;

class WMFullResourcePlan;

class WMCreateResourcePlanRequest;

class WMCreateResourcePlanResponse;

class WMGetActiveResourcePlanRequest;

class WMGetActiveResourcePlanResponse;

class WMGetResourcePlanRequest;

class WMGetResourcePlanResponse;

class WMGetAllResourcePlanRequest;

class WMGetAllResourcePlanResponse;

class WMAlterResourcePlanRequest;

class WMAlterResourcePlanResponse;

class WMValidateResourcePlanRequest;

class WMValidateResourcePlanResponse;

class WMDropResourcePlanRequest;

class WMDropResourcePlanResponse;

class WMCreateTriggerRequest;

class WMCreateTriggerResponse;

class WMAlterTriggerRequest;

class WMAlterTriggerResponse;

class WMDropTriggerRequest;

class WMDropTriggerResponse;

class WMGetTriggersForResourePlanRequest;

class WMGetTriggersForResourePlanResponse;

class WMCreatePoolRequest;

class WMCreatePoolResponse;

class WMAlterPoolRequest;

class WMAlterPoolResponse;

class WMDropPoolRequest;

class WMDropPoolResponse;

class WMCreateOrUpdateMappingRequest;

class WMCreateOrUpdateMappingResponse;

class WMDropMappingRequest;

class WMDropMappingResponse;

class WMCreateOrDropTriggerToPoolMappingRequest;

class WMCreateOrDropTriggerToPoolMappingResponse;

class ISchema;

class ISchemaName;

class AlterISchemaRequest;

class SchemaVersion;

class SchemaVersionDescriptor;

class FindSchemasByColsRqst;

class FindSchemasByColsResp;

class MapSchemaVersionToSerdeRequest;

class SetSchemaVersionStateRequest;

class GetSerdeRequest;

class RuntimeStat;

class GetRuntimeStatsRequest;

class CreateTableRequest;

class CreateDatabaseRequest;

class CreateDataConnectorRequest;

class GetDataConnectorRequest;

class AlterDataConnectorRequest;

class DropDataConnectorRequest;

class ScheduledQueryPollRequest;

class ScheduledQueryKey;

class ScheduledQueryPollResponse;

class ScheduledQuery;

class ScheduledQueryMaintenanceRequest;

class ScheduledQueryProgressInfo;

class AlterPartitionsRequest;

class AppendPartitionsRequest;

class AlterPartitionsResponse;

class RenamePartitionRequest;

class RenamePartitionResponse;

class AlterTableRequest;

class AlterTableResponse;

class GetPartitionsFilterSpec;

class GetPartitionsResponse;

class GetPartitionsRequest;

class GetFieldsRequest;

class GetFieldsResponse;

class GetSchemaRequest;

class GetSchemaResponse;

class GetPartitionRequest;

class GetPartitionResponse;

class PartitionsRequest;

class PartitionsResponse;

class GetPartitionsByFilterRequest;

class GetPartitionNamesPsRequest;

class GetPartitionNamesPsResponse;

class GetPartitionsPsWithAuthRequest;

class GetPartitionsPsWithAuthResponse;

class ReplicationMetrics;

class ReplicationMetricList;

class GetReplicationMetricsRequest;

class GetOpenTxnsRequest;

class StoredProcedureRequest;

class ListStoredProcedureRequest;

class StoredProcedure;

class AddPackageRequest;

class GetPackageRequest;

class DropPackageRequest;

class ListPackageRequest;

class Package;

class GetAllWriteEventInfoRequest;

class MetaException;

class UnknownTableException;

class UnknownDBException;

class AlreadyExistsException;

class InvalidPartitionException;

class UnknownPartitionException;

class InvalidObjectException;

class NoSuchObjectException;

class InvalidOperationException;

class ConfigValSecurityException;

class InvalidInputException;

class NoSuchTxnException;

class TxnAbortedException;

class TxnOpenException;

class NoSuchLockException;

class CompactionAbortedException;

class NoSuchCompactionException;

typedef struct _Version__isset {
  _Version__isset() : version(false), comments(false) {}
  bool version :1;
  bool comments :1;
} _Version__isset;

class Version : public virtual ::apache::thrift::TBase {
 public:

  Version(const Version&);
  Version& operator=(const Version&);
  Version() noexcept
          : version(),
            comments() {
  }

  virtual ~Version() noexcept;
  std::string version;
  std::string comments;

  _Version__isset __isset;

  void __set_version(const std::string& val);

  void __set_comments(const std::string& val);

  bool operator == (const Version & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (!(comments == rhs.comments))
      return false;
    return true;
  }
  bool operator != (const Version &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Version & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Version &a, Version &b);

std::ostream& operator<<(std::ostream& out, const Version& obj);

typedef struct _FieldSchema__isset {
  _FieldSchema__isset() : name(false), type(false), comment(false) {}
  bool name :1;
  bool type :1;
  bool comment :1;
} _FieldSchema__isset;

class FieldSchema : public virtual ::apache::thrift::TBase {
 public:

  FieldSchema(const FieldSchema&);
  FieldSchema& operator=(const FieldSchema&);
  FieldSchema() noexcept
              : name(),
                type(),
                comment() {
  }

  virtual ~FieldSchema() noexcept;
  std::string name;
  std::string type;
  std::string comment;

  _FieldSchema__isset __isset;

  void __set_name(const std::string& val);

  void __set_type(const std::string& val);

  void __set_comment(const std::string& val);

  bool operator == (const FieldSchema & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const FieldSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FieldSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FieldSchema &a, FieldSchema &b);

std::ostream& operator<<(std::ostream& out, const FieldSchema& obj);

typedef struct _EnvironmentContext__isset {
  _EnvironmentContext__isset() : properties(false) {}
  bool properties :1;
} _EnvironmentContext__isset;

class EnvironmentContext : public virtual ::apache::thrift::TBase {
 public:

  EnvironmentContext(const EnvironmentContext&);
  EnvironmentContext& operator=(const EnvironmentContext&);
  EnvironmentContext() noexcept {
  }

  virtual ~EnvironmentContext() noexcept;
  std::map<std::string, std::string>  properties;

  _EnvironmentContext__isset __isset;

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const EnvironmentContext & rhs) const
  {
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const EnvironmentContext &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EnvironmentContext & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(EnvironmentContext &a, EnvironmentContext &b);

std::ostream& operator<<(std::ostream& out, const EnvironmentContext& obj);

typedef struct _SQLPrimaryKey__isset {
  _SQLPrimaryKey__isset() : table_db(false), table_name(false), column_name(false), key_seq(false), pk_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false), catName(false) {}
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool key_seq :1;
  bool pk_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
  bool catName :1;
} _SQLPrimaryKey__isset;

class SQLPrimaryKey : public virtual ::apache::thrift::TBase {
 public:

  SQLPrimaryKey(const SQLPrimaryKey&);
  SQLPrimaryKey& operator=(const SQLPrimaryKey&);
  SQLPrimaryKey() noexcept
                : table_db(),
                  table_name(),
                  column_name(),
                  key_seq(0),
                  pk_name(),
                  enable_cstr(0),
                  validate_cstr(0),
                  rely_cstr(0),
                  catName() {
  }

  virtual ~SQLPrimaryKey() noexcept;
  std::string table_db;
  std::string table_name;
  std::string column_name;
  int32_t key_seq;
  std::string pk_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;
  std::string catName;

  _SQLPrimaryKey__isset __isset;

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_key_seq(const int32_t val);

  void __set_pk_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  void __set_catName(const std::string& val);

  bool operator == (const SQLPrimaryKey & rhs) const
  {
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(key_seq == rhs.key_seq))
      return false;
    if (!(pk_name == rhs.pk_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const SQLPrimaryKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLPrimaryKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLPrimaryKey &a, SQLPrimaryKey &b);

std::ostream& operator<<(std::ostream& out, const SQLPrimaryKey& obj);

typedef struct _SQLForeignKey__isset {
  _SQLForeignKey__isset() : pktable_db(false), pktable_name(false), pkcolumn_name(false), fktable_db(false), fktable_name(false), fkcolumn_name(false), key_seq(false), update_rule(false), delete_rule(false), fk_name(false), pk_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false), catName(false) {}
  bool pktable_db :1;
  bool pktable_name :1;
  bool pkcolumn_name :1;
  bool fktable_db :1;
  bool fktable_name :1;
  bool fkcolumn_name :1;
  bool key_seq :1;
  bool update_rule :1;
  bool delete_rule :1;
  bool fk_name :1;
  bool pk_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
  bool catName :1;
} _SQLForeignKey__isset;

class SQLForeignKey : public virtual ::apache::thrift::TBase {
 public:

  SQLForeignKey(const SQLForeignKey&);
  SQLForeignKey& operator=(const SQLForeignKey&);
  SQLForeignKey() noexcept
                : pktable_db(),
                  pktable_name(),
                  pkcolumn_name(),
                  fktable_db(),
                  fktable_name(),
                  fkcolumn_name(),
                  key_seq(0),
                  update_rule(0),
                  delete_rule(0),
                  fk_name(),
                  pk_name(),
                  enable_cstr(0),
                  validate_cstr(0),
                  rely_cstr(0),
                  catName() {
  }

  virtual ~SQLForeignKey() noexcept;
  std::string pktable_db;
  std::string pktable_name;
  std::string pkcolumn_name;
  std::string fktable_db;
  std::string fktable_name;
  std::string fkcolumn_name;
  int32_t key_seq;
  int32_t update_rule;
  int32_t delete_rule;
  std::string fk_name;
  std::string pk_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;
  std::string catName;

  _SQLForeignKey__isset __isset;

  void __set_pktable_db(const std::string& val);

  void __set_pktable_name(const std::string& val);

  void __set_pkcolumn_name(const std::string& val);

  void __set_fktable_db(const std::string& val);

  void __set_fktable_name(const std::string& val);

  void __set_fkcolumn_name(const std::string& val);

  void __set_key_seq(const int32_t val);

  void __set_update_rule(const int32_t val);

  void __set_delete_rule(const int32_t val);

  void __set_fk_name(const std::string& val);

  void __set_pk_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  void __set_catName(const std::string& val);

  bool operator == (const SQLForeignKey & rhs) const
  {
    if (!(pktable_db == rhs.pktable_db))
      return false;
    if (!(pktable_name == rhs.pktable_name))
      return false;
    if (!(pkcolumn_name == rhs.pkcolumn_name))
      return false;
    if (!(fktable_db == rhs.fktable_db))
      return false;
    if (!(fktable_name == rhs.fktable_name))
      return false;
    if (!(fkcolumn_name == rhs.fkcolumn_name))
      return false;
    if (!(key_seq == rhs.key_seq))
      return false;
    if (!(update_rule == rhs.update_rule))
      return false;
    if (!(delete_rule == rhs.delete_rule))
      return false;
    if (!(fk_name == rhs.fk_name))
      return false;
    if (!(pk_name == rhs.pk_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const SQLForeignKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLForeignKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLForeignKey &a, SQLForeignKey &b);

std::ostream& operator<<(std::ostream& out, const SQLForeignKey& obj);

typedef struct _SQLUniqueConstraint__isset {
  _SQLUniqueConstraint__isset() : catName(false), table_db(false), table_name(false), column_name(false), key_seq(false), uk_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false) {}
  bool catName :1;
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool key_seq :1;
  bool uk_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
} _SQLUniqueConstraint__isset;

class SQLUniqueConstraint : public virtual ::apache::thrift::TBase {
 public:

  SQLUniqueConstraint(const SQLUniqueConstraint&);
  SQLUniqueConstraint& operator=(const SQLUniqueConstraint&);
  SQLUniqueConstraint() noexcept
                      : catName(),
                        table_db(),
                        table_name(),
                        column_name(),
                        key_seq(0),
                        uk_name(),
                        enable_cstr(0),
                        validate_cstr(0),
                        rely_cstr(0) {
  }

  virtual ~SQLUniqueConstraint() noexcept;
  std::string catName;
  std::string table_db;
  std::string table_name;
  std::string column_name;
  int32_t key_seq;
  std::string uk_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;

  _SQLUniqueConstraint__isset __isset;

  void __set_catName(const std::string& val);

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_key_seq(const int32_t val);

  void __set_uk_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  bool operator == (const SQLUniqueConstraint & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(key_seq == rhs.key_seq))
      return false;
    if (!(uk_name == rhs.uk_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    return true;
  }
  bool operator != (const SQLUniqueConstraint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLUniqueConstraint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLUniqueConstraint &a, SQLUniqueConstraint &b);

std::ostream& operator<<(std::ostream& out, const SQLUniqueConstraint& obj);

typedef struct _SQLNotNullConstraint__isset {
  _SQLNotNullConstraint__isset() : catName(false), table_db(false), table_name(false), column_name(false), nn_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false) {}
  bool catName :1;
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool nn_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
} _SQLNotNullConstraint__isset;

class SQLNotNullConstraint : public virtual ::apache::thrift::TBase {
 public:

  SQLNotNullConstraint(const SQLNotNullConstraint&);
  SQLNotNullConstraint& operator=(const SQLNotNullConstraint&);
  SQLNotNullConstraint() noexcept
                       : catName(),
                         table_db(),
                         table_name(),
                         column_name(),
                         nn_name(),
                         enable_cstr(0),
                         validate_cstr(0),
                         rely_cstr(0) {
  }

  virtual ~SQLNotNullConstraint() noexcept;
  std::string catName;
  std::string table_db;
  std::string table_name;
  std::string column_name;
  std::string nn_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;

  _SQLNotNullConstraint__isset __isset;

  void __set_catName(const std::string& val);

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_nn_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  bool operator == (const SQLNotNullConstraint & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(nn_name == rhs.nn_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    return true;
  }
  bool operator != (const SQLNotNullConstraint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLNotNullConstraint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLNotNullConstraint &a, SQLNotNullConstraint &b);

std::ostream& operator<<(std::ostream& out, const SQLNotNullConstraint& obj);

typedef struct _SQLDefaultConstraint__isset {
  _SQLDefaultConstraint__isset() : catName(false), table_db(false), table_name(false), column_name(false), default_value(false), dc_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false) {}
  bool catName :1;
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool default_value :1;
  bool dc_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
} _SQLDefaultConstraint__isset;

class SQLDefaultConstraint : public virtual ::apache::thrift::TBase {
 public:

  SQLDefaultConstraint(const SQLDefaultConstraint&);
  SQLDefaultConstraint& operator=(const SQLDefaultConstraint&);
  SQLDefaultConstraint() noexcept
                       : catName(),
                         table_db(),
                         table_name(),
                         column_name(),
                         default_value(),
                         dc_name(),
                         enable_cstr(0),
                         validate_cstr(0),
                         rely_cstr(0) {
  }

  virtual ~SQLDefaultConstraint() noexcept;
  std::string catName;
  std::string table_db;
  std::string table_name;
  std::string column_name;
  std::string default_value;
  std::string dc_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;

  _SQLDefaultConstraint__isset __isset;

  void __set_catName(const std::string& val);

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_default_value(const std::string& val);

  void __set_dc_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  bool operator == (const SQLDefaultConstraint & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(default_value == rhs.default_value))
      return false;
    if (!(dc_name == rhs.dc_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    return true;
  }
  bool operator != (const SQLDefaultConstraint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLDefaultConstraint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLDefaultConstraint &a, SQLDefaultConstraint &b);

std::ostream& operator<<(std::ostream& out, const SQLDefaultConstraint& obj);

typedef struct _SQLCheckConstraint__isset {
  _SQLCheckConstraint__isset() : catName(false), table_db(false), table_name(false), column_name(false), check_expression(false), dc_name(false), enable_cstr(false), validate_cstr(false), rely_cstr(false) {}
  bool catName :1;
  bool table_db :1;
  bool table_name :1;
  bool column_name :1;
  bool check_expression :1;
  bool dc_name :1;
  bool enable_cstr :1;
  bool validate_cstr :1;
  bool rely_cstr :1;
} _SQLCheckConstraint__isset;

class SQLCheckConstraint : public virtual ::apache::thrift::TBase {
 public:

  SQLCheckConstraint(const SQLCheckConstraint&);
  SQLCheckConstraint& operator=(const SQLCheckConstraint&);
  SQLCheckConstraint() noexcept
                     : catName(),
                       table_db(),
                       table_name(),
                       column_name(),
                       check_expression(),
                       dc_name(),
                       enable_cstr(0),
                       validate_cstr(0),
                       rely_cstr(0) {
  }

  virtual ~SQLCheckConstraint() noexcept;
  std::string catName;
  std::string table_db;
  std::string table_name;
  std::string column_name;
  std::string check_expression;
  std::string dc_name;
  bool enable_cstr;
  bool validate_cstr;
  bool rely_cstr;

  _SQLCheckConstraint__isset __isset;

  void __set_catName(const std::string& val);

  void __set_table_db(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_column_name(const std::string& val);

  void __set_check_expression(const std::string& val);

  void __set_dc_name(const std::string& val);

  void __set_enable_cstr(const bool val);

  void __set_validate_cstr(const bool val);

  void __set_rely_cstr(const bool val);

  bool operator == (const SQLCheckConstraint & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(column_name == rhs.column_name))
      return false;
    if (!(check_expression == rhs.check_expression))
      return false;
    if (!(dc_name == rhs.dc_name))
      return false;
    if (!(enable_cstr == rhs.enable_cstr))
      return false;
    if (!(validate_cstr == rhs.validate_cstr))
      return false;
    if (!(rely_cstr == rhs.rely_cstr))
      return false;
    return true;
  }
  bool operator != (const SQLCheckConstraint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLCheckConstraint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLCheckConstraint &a, SQLCheckConstraint &b);

std::ostream& operator<<(std::ostream& out, const SQLCheckConstraint& obj);

typedef struct _SQLAllTableConstraints__isset {
  _SQLAllTableConstraints__isset() : primaryKeys(false), foreignKeys(false), uniqueConstraints(false), notNullConstraints(false), defaultConstraints(false), checkConstraints(false) {}
  bool primaryKeys :1;
  bool foreignKeys :1;
  bool uniqueConstraints :1;
  bool notNullConstraints :1;
  bool defaultConstraints :1;
  bool checkConstraints :1;
} _SQLAllTableConstraints__isset;

class SQLAllTableConstraints : public virtual ::apache::thrift::TBase {
 public:

  SQLAllTableConstraints(const SQLAllTableConstraints&);
  SQLAllTableConstraints& operator=(const SQLAllTableConstraints&);
  SQLAllTableConstraints() noexcept {
  }

  virtual ~SQLAllTableConstraints() noexcept;
  std::vector<SQLPrimaryKey>  primaryKeys;
  std::vector<SQLForeignKey>  foreignKeys;
  std::vector<SQLUniqueConstraint>  uniqueConstraints;
  std::vector<SQLNotNullConstraint>  notNullConstraints;
  std::vector<SQLDefaultConstraint>  defaultConstraints;
  std::vector<SQLCheckConstraint>  checkConstraints;

  _SQLAllTableConstraints__isset __isset;

  void __set_primaryKeys(const std::vector<SQLPrimaryKey> & val);

  void __set_foreignKeys(const std::vector<SQLForeignKey> & val);

  void __set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val);

  void __set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val);

  void __set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val);

  void __set_checkConstraints(const std::vector<SQLCheckConstraint> & val);

  bool operator == (const SQLAllTableConstraints & rhs) const
  {
    if (__isset.primaryKeys != rhs.__isset.primaryKeys)
      return false;
    else if (__isset.primaryKeys && !(primaryKeys == rhs.primaryKeys))
      return false;
    if (__isset.foreignKeys != rhs.__isset.foreignKeys)
      return false;
    else if (__isset.foreignKeys && !(foreignKeys == rhs.foreignKeys))
      return false;
    if (__isset.uniqueConstraints != rhs.__isset.uniqueConstraints)
      return false;
    else if (__isset.uniqueConstraints && !(uniqueConstraints == rhs.uniqueConstraints))
      return false;
    if (__isset.notNullConstraints != rhs.__isset.notNullConstraints)
      return false;
    else if (__isset.notNullConstraints && !(notNullConstraints == rhs.notNullConstraints))
      return false;
    if (__isset.defaultConstraints != rhs.__isset.defaultConstraints)
      return false;
    else if (__isset.defaultConstraints && !(defaultConstraints == rhs.defaultConstraints))
      return false;
    if (__isset.checkConstraints != rhs.__isset.checkConstraints)
      return false;
    else if (__isset.checkConstraints && !(checkConstraints == rhs.checkConstraints))
      return false;
    return true;
  }
  bool operator != (const SQLAllTableConstraints &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SQLAllTableConstraints & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SQLAllTableConstraints &a, SQLAllTableConstraints &b);

std::ostream& operator<<(std::ostream& out, const SQLAllTableConstraints& obj);

typedef struct _Type__isset {
  _Type__isset() : name(false), type1(false), type2(false), fields(false) {}
  bool name :1;
  bool type1 :1;
  bool type2 :1;
  bool fields :1;
} _Type__isset;

class Type : public virtual ::apache::thrift::TBase {
 public:

  Type(const Type&);
  Type& operator=(const Type&);
  Type() noexcept
       : name(),
         type1(),
         type2() {
  }

  virtual ~Type() noexcept;
  std::string name;
  std::string type1;
  std::string type2;
  std::vector<FieldSchema>  fields;

  _Type__isset __isset;

  void __set_name(const std::string& val);

  void __set_type1(const std::string& val);

  void __set_type2(const std::string& val);

  void __set_fields(const std::vector<FieldSchema> & val);

  bool operator == (const Type & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.type1 != rhs.__isset.type1)
      return false;
    else if (__isset.type1 && !(type1 == rhs.type1))
      return false;
    if (__isset.type2 != rhs.__isset.type2)
      return false;
    else if (__isset.type2 && !(type2 == rhs.type2))
      return false;
    if (__isset.fields != rhs.__isset.fields)
      return false;
    else if (__isset.fields && !(fields == rhs.fields))
      return false;
    return true;
  }
  bool operator != (const Type &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Type & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Type &a, Type &b);

std::ostream& operator<<(std::ostream& out, const Type& obj);

typedef struct _PropertySetRequest__isset {
  _PropertySetRequest__isset() : propertyMap(false) {}
  bool propertyMap :1;
} _PropertySetRequest__isset;

class PropertySetRequest : public virtual ::apache::thrift::TBase {
 public:

  PropertySetRequest(const PropertySetRequest&);
  PropertySetRequest& operator=(const PropertySetRequest&);
  PropertySetRequest() noexcept
                     : nameSpace() {
  }

  virtual ~PropertySetRequest() noexcept;
  std::string nameSpace;
  std::map<std::string, std::string>  propertyMap;

  _PropertySetRequest__isset __isset;

  void __set_nameSpace(const std::string& val);

  void __set_propertyMap(const std::map<std::string, std::string> & val);

  bool operator == (const PropertySetRequest & rhs) const
  {
    if (!(nameSpace == rhs.nameSpace))
      return false;
    if (!(propertyMap == rhs.propertyMap))
      return false;
    return true;
  }
  bool operator != (const PropertySetRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PropertySetRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PropertySetRequest &a, PropertySetRequest &b);

std::ostream& operator<<(std::ostream& out, const PropertySetRequest& obj);

typedef struct _PropertyGetRequest__isset {
  _PropertyGetRequest__isset() : mapPrefix(false), mapPredicate(false), mapSelection(false) {}
  bool mapPrefix :1;
  bool mapPredicate :1;
  bool mapSelection :1;
} _PropertyGetRequest__isset;

class PropertyGetRequest : public virtual ::apache::thrift::TBase {
 public:

  PropertyGetRequest(const PropertyGetRequest&);
  PropertyGetRequest& operator=(const PropertyGetRequest&);
  PropertyGetRequest() noexcept
                     : nameSpace(),
                       mapPrefix(),
                       mapPredicate() {
  }

  virtual ~PropertyGetRequest() noexcept;
  std::string nameSpace;
  std::string mapPrefix;
  std::string mapPredicate;
  std::vector<std::string>  mapSelection;

  _PropertyGetRequest__isset __isset;

  void __set_nameSpace(const std::string& val);

  void __set_mapPrefix(const std::string& val);

  void __set_mapPredicate(const std::string& val);

  void __set_mapSelection(const std::vector<std::string> & val);

  bool operator == (const PropertyGetRequest & rhs) const
  {
    if (!(nameSpace == rhs.nameSpace))
      return false;
    if (!(mapPrefix == rhs.mapPrefix))
      return false;
    if (__isset.mapPredicate != rhs.__isset.mapPredicate)
      return false;
    else if (__isset.mapPredicate && !(mapPredicate == rhs.mapPredicate))
      return false;
    if (__isset.mapSelection != rhs.__isset.mapSelection)
      return false;
    else if (__isset.mapSelection && !(mapSelection == rhs.mapSelection))
      return false;
    return true;
  }
  bool operator != (const PropertyGetRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PropertyGetRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PropertyGetRequest &a, PropertyGetRequest &b);

std::ostream& operator<<(std::ostream& out, const PropertyGetRequest& obj);

typedef struct _PropertyGetResponse__isset {
  _PropertyGetResponse__isset() : properties(false) {}
  bool properties :1;
} _PropertyGetResponse__isset;

class PropertyGetResponse : public virtual ::apache::thrift::TBase {
 public:

  PropertyGetResponse(const PropertyGetResponse&);
  PropertyGetResponse& operator=(const PropertyGetResponse&);
  PropertyGetResponse() noexcept {
  }

  virtual ~PropertyGetResponse() noexcept;
  std::map<std::string, std::map<std::string, std::string> >  properties;

  _PropertyGetResponse__isset __isset;

  void __set_properties(const std::map<std::string, std::map<std::string, std::string> > & val);

  bool operator == (const PropertyGetResponse & rhs) const
  {
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const PropertyGetResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PropertyGetResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PropertyGetResponse &a, PropertyGetResponse &b);

std::ostream& operator<<(std::ostream& out, const PropertyGetResponse& obj);

typedef struct _HiveObjectRef__isset {
  _HiveObjectRef__isset() : objectType(false), dbName(false), objectName(false), partValues(false), columnName(false), catName(false) {}
  bool objectType :1;
  bool dbName :1;
  bool objectName :1;
  bool partValues :1;
  bool columnName :1;
  bool catName :1;
} _HiveObjectRef__isset;

class HiveObjectRef : public virtual ::apache::thrift::TBase {
 public:

  HiveObjectRef(const HiveObjectRef&);
  HiveObjectRef& operator=(const HiveObjectRef&);
  HiveObjectRef() noexcept
                : objectType(static_cast<HiveObjectType::type>(0)),
                  dbName(),
                  objectName(),
                  columnName(),
                  catName() {
  }

  virtual ~HiveObjectRef() noexcept;
  /**
   *
   * @see HiveObjectType
   */
  HiveObjectType::type objectType;
  std::string dbName;
  std::string objectName;
  std::vector<std::string>  partValues;
  std::string columnName;
  std::string catName;

  _HiveObjectRef__isset __isset;

  void __set_objectType(const HiveObjectType::type val);

  void __set_dbName(const std::string& val);

  void __set_objectName(const std::string& val);

  void __set_partValues(const std::vector<std::string> & val);

  void __set_columnName(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const HiveObjectRef & rhs) const
  {
    if (!(objectType == rhs.objectType))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(objectName == rhs.objectName))
      return false;
    if (!(partValues == rhs.partValues))
      return false;
    if (!(columnName == rhs.columnName))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const HiveObjectRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HiveObjectRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HiveObjectRef &a, HiveObjectRef &b);

std::ostream& operator<<(std::ostream& out, const HiveObjectRef& obj);

typedef struct _PrivilegeGrantInfo__isset {
  _PrivilegeGrantInfo__isset() : privilege(false), createTime(false), grantor(false), grantorType(false), grantOption(false) {}
  bool privilege :1;
  bool createTime :1;
  bool grantor :1;
  bool grantorType :1;
  bool grantOption :1;
} _PrivilegeGrantInfo__isset;

class PrivilegeGrantInfo : public virtual ::apache::thrift::TBase {
 public:

  PrivilegeGrantInfo(const PrivilegeGrantInfo&);
  PrivilegeGrantInfo& operator=(const PrivilegeGrantInfo&);
  PrivilegeGrantInfo() noexcept
                     : privilege(),
                       createTime(0),
                       grantor(),
                       grantorType(static_cast<PrincipalType::type>(0)),
                       grantOption(0) {
  }

  virtual ~PrivilegeGrantInfo() noexcept;
  std::string privilege;
  int32_t createTime;
  std::string grantor;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type grantorType;
  bool grantOption;

  _PrivilegeGrantInfo__isset __isset;

  void __set_privilege(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_grantor(const std::string& val);

  void __set_grantorType(const PrincipalType::type val);

  void __set_grantOption(const bool val);

  bool operator == (const PrivilegeGrantInfo & rhs) const
  {
    if (!(privilege == rhs.privilege))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(grantor == rhs.grantor))
      return false;
    if (!(grantorType == rhs.grantorType))
      return false;
    if (!(grantOption == rhs.grantOption))
      return false;
    return true;
  }
  bool operator != (const PrivilegeGrantInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrivilegeGrantInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrivilegeGrantInfo &a, PrivilegeGrantInfo &b);

std::ostream& operator<<(std::ostream& out, const PrivilegeGrantInfo& obj);

typedef struct _HiveObjectPrivilege__isset {
  _HiveObjectPrivilege__isset() : hiveObject(false), principalName(false), principalType(false), grantInfo(false), authorizer(false) {}
  bool hiveObject :1;
  bool principalName :1;
  bool principalType :1;
  bool grantInfo :1;
  bool authorizer :1;
} _HiveObjectPrivilege__isset;

class HiveObjectPrivilege : public virtual ::apache::thrift::TBase {
 public:

  HiveObjectPrivilege(const HiveObjectPrivilege&);
  HiveObjectPrivilege& operator=(const HiveObjectPrivilege&);
  HiveObjectPrivilege() noexcept
                      : principalName(),
                        principalType(static_cast<PrincipalType::type>(0)),
                        authorizer() {
  }

  virtual ~HiveObjectPrivilege() noexcept;
  HiveObjectRef hiveObject;
  std::string principalName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type principalType;
  PrivilegeGrantInfo grantInfo;
  std::string authorizer;

  _HiveObjectPrivilege__isset __isset;

  void __set_hiveObject(const HiveObjectRef& val);

  void __set_principalName(const std::string& val);

  void __set_principalType(const PrincipalType::type val);

  void __set_grantInfo(const PrivilegeGrantInfo& val);

  void __set_authorizer(const std::string& val);

  bool operator == (const HiveObjectPrivilege & rhs) const
  {
    if (!(hiveObject == rhs.hiveObject))
      return false;
    if (!(principalName == rhs.principalName))
      return false;
    if (!(principalType == rhs.principalType))
      return false;
    if (!(grantInfo == rhs.grantInfo))
      return false;
    if (!(authorizer == rhs.authorizer))
      return false;
    return true;
  }
  bool operator != (const HiveObjectPrivilege &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HiveObjectPrivilege & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HiveObjectPrivilege &a, HiveObjectPrivilege &b);

std::ostream& operator<<(std::ostream& out, const HiveObjectPrivilege& obj);

typedef struct _PrivilegeBag__isset {
  _PrivilegeBag__isset() : privileges(false) {}
  bool privileges :1;
} _PrivilegeBag__isset;

class PrivilegeBag : public virtual ::apache::thrift::TBase {
 public:

  PrivilegeBag(const PrivilegeBag&);
  PrivilegeBag& operator=(const PrivilegeBag&);
  PrivilegeBag() noexcept {
  }

  virtual ~PrivilegeBag() noexcept;
  std::vector<HiveObjectPrivilege>  privileges;

  _PrivilegeBag__isset __isset;

  void __set_privileges(const std::vector<HiveObjectPrivilege> & val);

  bool operator == (const PrivilegeBag & rhs) const
  {
    if (!(privileges == rhs.privileges))
      return false;
    return true;
  }
  bool operator != (const PrivilegeBag &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrivilegeBag & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrivilegeBag &a, PrivilegeBag &b);

std::ostream& operator<<(std::ostream& out, const PrivilegeBag& obj);

typedef struct _PrincipalPrivilegeSet__isset {
  _PrincipalPrivilegeSet__isset() : userPrivileges(false), groupPrivileges(false), rolePrivileges(false) {}
  bool userPrivileges :1;
  bool groupPrivileges :1;
  bool rolePrivileges :1;
} _PrincipalPrivilegeSet__isset;

class PrincipalPrivilegeSet : public virtual ::apache::thrift::TBase {
 public:

  PrincipalPrivilegeSet(const PrincipalPrivilegeSet&);
  PrincipalPrivilegeSet& operator=(const PrincipalPrivilegeSet&);
  PrincipalPrivilegeSet() noexcept {
  }

  virtual ~PrincipalPrivilegeSet() noexcept;
  std::map<std::string, std::vector<PrivilegeGrantInfo> >  userPrivileges;
  std::map<std::string, std::vector<PrivilegeGrantInfo> >  groupPrivileges;
  std::map<std::string, std::vector<PrivilegeGrantInfo> >  rolePrivileges;

  _PrincipalPrivilegeSet__isset __isset;

  void __set_userPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val);

  void __set_groupPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val);

  void __set_rolePrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val);

  bool operator == (const PrincipalPrivilegeSet & rhs) const
  {
    if (!(userPrivileges == rhs.userPrivileges))
      return false;
    if (!(groupPrivileges == rhs.groupPrivileges))
      return false;
    if (!(rolePrivileges == rhs.rolePrivileges))
      return false;
    return true;
  }
  bool operator != (const PrincipalPrivilegeSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrincipalPrivilegeSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrincipalPrivilegeSet &a, PrincipalPrivilegeSet &b);

std::ostream& operator<<(std::ostream& out, const PrincipalPrivilegeSet& obj);

typedef struct _GrantRevokePrivilegeRequest__isset {
  _GrantRevokePrivilegeRequest__isset() : requestType(false), privileges(false), revokeGrantOption(false) {}
  bool requestType :1;
  bool privileges :1;
  bool revokeGrantOption :1;
} _GrantRevokePrivilegeRequest__isset;

class GrantRevokePrivilegeRequest : public virtual ::apache::thrift::TBase {
 public:

  GrantRevokePrivilegeRequest(const GrantRevokePrivilegeRequest&);
  GrantRevokePrivilegeRequest& operator=(const GrantRevokePrivilegeRequest&);
  GrantRevokePrivilegeRequest() noexcept
                              : requestType(static_cast<GrantRevokeType::type>(0)),
                                revokeGrantOption(0) {
  }

  virtual ~GrantRevokePrivilegeRequest() noexcept;
  /**
   *
   * @see GrantRevokeType
   */
  GrantRevokeType::type requestType;
  PrivilegeBag privileges;
  bool revokeGrantOption;

  _GrantRevokePrivilegeRequest__isset __isset;

  void __set_requestType(const GrantRevokeType::type val);

  void __set_privileges(const PrivilegeBag& val);

  void __set_revokeGrantOption(const bool val);

  bool operator == (const GrantRevokePrivilegeRequest & rhs) const
  {
    if (!(requestType == rhs.requestType))
      return false;
    if (!(privileges == rhs.privileges))
      return false;
    if (__isset.revokeGrantOption != rhs.__isset.revokeGrantOption)
      return false;
    else if (__isset.revokeGrantOption && !(revokeGrantOption == rhs.revokeGrantOption))
      return false;
    return true;
  }
  bool operator != (const GrantRevokePrivilegeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GrantRevokePrivilegeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GrantRevokePrivilegeRequest &a, GrantRevokePrivilegeRequest &b);

std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeRequest& obj);

typedef struct _GrantRevokePrivilegeResponse__isset {
  _GrantRevokePrivilegeResponse__isset() : success(false) {}
  bool success :1;
} _GrantRevokePrivilegeResponse__isset;

class GrantRevokePrivilegeResponse : public virtual ::apache::thrift::TBase {
 public:

  GrantRevokePrivilegeResponse(const GrantRevokePrivilegeResponse&) noexcept;
  GrantRevokePrivilegeResponse& operator=(const GrantRevokePrivilegeResponse&) noexcept;
  GrantRevokePrivilegeResponse() noexcept
                               : success(0) {
  }

  virtual ~GrantRevokePrivilegeResponse() noexcept;
  bool success;

  _GrantRevokePrivilegeResponse__isset __isset;

  void __set_success(const bool val);

  bool operator == (const GrantRevokePrivilegeResponse & rhs) const
  {
    if (__isset.success != rhs.__isset.success)
      return false;
    else if (__isset.success && !(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const GrantRevokePrivilegeResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GrantRevokePrivilegeResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GrantRevokePrivilegeResponse &a, GrantRevokePrivilegeResponse &b);

std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeResponse& obj);

typedef struct _TruncateTableRequest__isset {
  _TruncateTableRequest__isset() : partNames(false), writeId(true), validWriteIdList(false), environmentContext(false) {}
  bool partNames :1;
  bool writeId :1;
  bool validWriteIdList :1;
  bool environmentContext :1;
} _TruncateTableRequest__isset;

class TruncateTableRequest : public virtual ::apache::thrift::TBase {
 public:

  TruncateTableRequest(const TruncateTableRequest&);
  TruncateTableRequest& operator=(const TruncateTableRequest&);
  TruncateTableRequest() noexcept
                       : dbName(),
                         tableName(),
                         writeId(-1LL),
                         validWriteIdList() {
  }

  virtual ~TruncateTableRequest() noexcept;
  std::string dbName;
  std::string tableName;
  std::vector<std::string>  partNames;
  int64_t writeId;
  std::string validWriteIdList;
  EnvironmentContext environmentContext;

  _TruncateTableRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_partNames(const std::vector<std::string> & val);

  void __set_writeId(const int64_t val);

  void __set_validWriteIdList(const std::string& val);

  void __set_environmentContext(const EnvironmentContext& val);

  bool operator == (const TruncateTableRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.partNames != rhs.__isset.partNames)
      return false;
    else if (__isset.partNames && !(partNames == rhs.partNames))
      return false;
    if (__isset.writeId != rhs.__isset.writeId)
      return false;
    else if (__isset.writeId && !(writeId == rhs.writeId))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.environmentContext != rhs.__isset.environmentContext)
      return false;
    else if (__isset.environmentContext && !(environmentContext == rhs.environmentContext))
      return false;
    return true;
  }
  bool operator != (const TruncateTableRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TruncateTableRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TruncateTableRequest &a, TruncateTableRequest &b);

std::ostream& operator<<(std::ostream& out, const TruncateTableRequest& obj);


class TruncateTableResponse : public virtual ::apache::thrift::TBase {
 public:

  TruncateTableResponse(const TruncateTableResponse&) noexcept;
  TruncateTableResponse& operator=(const TruncateTableResponse&) noexcept;
  TruncateTableResponse() noexcept {
  }

  virtual ~TruncateTableResponse() noexcept;

  bool operator == (const TruncateTableResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TruncateTableResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TruncateTableResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TruncateTableResponse &a, TruncateTableResponse &b);

std::ostream& operator<<(std::ostream& out, const TruncateTableResponse& obj);

typedef struct _Role__isset {
  _Role__isset() : roleName(false), createTime(false), ownerName(false) {}
  bool roleName :1;
  bool createTime :1;
  bool ownerName :1;
} _Role__isset;

class Role : public virtual ::apache::thrift::TBase {
 public:

  Role(const Role&);
  Role& operator=(const Role&);
  Role() noexcept
       : roleName(),
         createTime(0),
         ownerName() {
  }

  virtual ~Role() noexcept;
  std::string roleName;
  int32_t createTime;
  std::string ownerName;

  _Role__isset __isset;

  void __set_roleName(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_ownerName(const std::string& val);

  bool operator == (const Role & rhs) const
  {
    if (!(roleName == rhs.roleName))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(ownerName == rhs.ownerName))
      return false;
    return true;
  }
  bool operator != (const Role &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Role & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Role &a, Role &b);

std::ostream& operator<<(std::ostream& out, const Role& obj);

typedef struct _RolePrincipalGrant__isset {
  _RolePrincipalGrant__isset() : roleName(false), principalName(false), principalType(false), grantOption(false), grantTime(false), grantorName(false), grantorPrincipalType(false) {}
  bool roleName :1;
  bool principalName :1;
  bool principalType :1;
  bool grantOption :1;
  bool grantTime :1;
  bool grantorName :1;
  bool grantorPrincipalType :1;
} _RolePrincipalGrant__isset;

class RolePrincipalGrant : public virtual ::apache::thrift::TBase {
 public:

  RolePrincipalGrant(const RolePrincipalGrant&);
  RolePrincipalGrant& operator=(const RolePrincipalGrant&);
  RolePrincipalGrant() noexcept
                     : roleName(),
                       principalName(),
                       principalType(static_cast<PrincipalType::type>(0)),
                       grantOption(0),
                       grantTime(0),
                       grantorName(),
                       grantorPrincipalType(static_cast<PrincipalType::type>(0)) {
  }

  virtual ~RolePrincipalGrant() noexcept;
  std::string roleName;
  std::string principalName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type principalType;
  bool grantOption;
  int32_t grantTime;
  std::string grantorName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type grantorPrincipalType;

  _RolePrincipalGrant__isset __isset;

  void __set_roleName(const std::string& val);

  void __set_principalName(const std::string& val);

  void __set_principalType(const PrincipalType::type val);

  void __set_grantOption(const bool val);

  void __set_grantTime(const int32_t val);

  void __set_grantorName(const std::string& val);

  void __set_grantorPrincipalType(const PrincipalType::type val);

  bool operator == (const RolePrincipalGrant & rhs) const
  {
    if (!(roleName == rhs.roleName))
      return false;
    if (!(principalName == rhs.principalName))
      return false;
    if (!(principalType == rhs.principalType))
      return false;
    if (!(grantOption == rhs.grantOption))
      return false;
    if (!(grantTime == rhs.grantTime))
      return false;
    if (!(grantorName == rhs.grantorName))
      return false;
    if (!(grantorPrincipalType == rhs.grantorPrincipalType))
      return false;
    return true;
  }
  bool operator != (const RolePrincipalGrant &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RolePrincipalGrant & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RolePrincipalGrant &a, RolePrincipalGrant &b);

std::ostream& operator<<(std::ostream& out, const RolePrincipalGrant& obj);


class GetRoleGrantsForPrincipalRequest : public virtual ::apache::thrift::TBase {
 public:

  GetRoleGrantsForPrincipalRequest(const GetRoleGrantsForPrincipalRequest&);
  GetRoleGrantsForPrincipalRequest& operator=(const GetRoleGrantsForPrincipalRequest&);
  GetRoleGrantsForPrincipalRequest() noexcept
                                   : principal_name(),
                                     principal_type(static_cast<PrincipalType::type>(0)) {
  }

  virtual ~GetRoleGrantsForPrincipalRequest() noexcept;
  std::string principal_name;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type principal_type;

  void __set_principal_name(const std::string& val);

  void __set_principal_type(const PrincipalType::type val);

  bool operator == (const GetRoleGrantsForPrincipalRequest & rhs) const
  {
    if (!(principal_name == rhs.principal_name))
      return false;
    if (!(principal_type == rhs.principal_type))
      return false;
    return true;
  }
  bool operator != (const GetRoleGrantsForPrincipalRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetRoleGrantsForPrincipalRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetRoleGrantsForPrincipalRequest &a, GetRoleGrantsForPrincipalRequest &b);

std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalRequest& obj);


class GetRoleGrantsForPrincipalResponse : public virtual ::apache::thrift::TBase {
 public:

  GetRoleGrantsForPrincipalResponse(const GetRoleGrantsForPrincipalResponse&);
  GetRoleGrantsForPrincipalResponse& operator=(const GetRoleGrantsForPrincipalResponse&);
  GetRoleGrantsForPrincipalResponse() noexcept {
  }

  virtual ~GetRoleGrantsForPrincipalResponse() noexcept;
  std::vector<RolePrincipalGrant>  principalGrants;

  void __set_principalGrants(const std::vector<RolePrincipalGrant> & val);

  bool operator == (const GetRoleGrantsForPrincipalResponse & rhs) const
  {
    if (!(principalGrants == rhs.principalGrants))
      return false;
    return true;
  }
  bool operator != (const GetRoleGrantsForPrincipalResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetRoleGrantsForPrincipalResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetRoleGrantsForPrincipalResponse &a, GetRoleGrantsForPrincipalResponse &b);

std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalResponse& obj);


class GetPrincipalsInRoleRequest : public virtual ::apache::thrift::TBase {
 public:

  GetPrincipalsInRoleRequest(const GetPrincipalsInRoleRequest&);
  GetPrincipalsInRoleRequest& operator=(const GetPrincipalsInRoleRequest&);
  GetPrincipalsInRoleRequest() noexcept
                             : roleName() {
  }

  virtual ~GetPrincipalsInRoleRequest() noexcept;
  std::string roleName;

  void __set_roleName(const std::string& val);

  bool operator == (const GetPrincipalsInRoleRequest & rhs) const
  {
    if (!(roleName == rhs.roleName))
      return false;
    return true;
  }
  bool operator != (const GetPrincipalsInRoleRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPrincipalsInRoleRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPrincipalsInRoleRequest &a, GetPrincipalsInRoleRequest &b);

std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleRequest& obj);


class GetPrincipalsInRoleResponse : public virtual ::apache::thrift::TBase {
 public:

  GetPrincipalsInRoleResponse(const GetPrincipalsInRoleResponse&);
  GetPrincipalsInRoleResponse& operator=(const GetPrincipalsInRoleResponse&);
  GetPrincipalsInRoleResponse() noexcept {
  }

  virtual ~GetPrincipalsInRoleResponse() noexcept;
  std::vector<RolePrincipalGrant>  principalGrants;

  void __set_principalGrants(const std::vector<RolePrincipalGrant> & val);

  bool operator == (const GetPrincipalsInRoleResponse & rhs) const
  {
    if (!(principalGrants == rhs.principalGrants))
      return false;
    return true;
  }
  bool operator != (const GetPrincipalsInRoleResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPrincipalsInRoleResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPrincipalsInRoleResponse &a, GetPrincipalsInRoleResponse &b);

std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleResponse& obj);

typedef struct _GrantRevokeRoleRequest__isset {
  _GrantRevokeRoleRequest__isset() : requestType(false), roleName(false), principalName(false), principalType(false), grantor(false), grantorType(false), grantOption(false) {}
  bool requestType :1;
  bool roleName :1;
  bool principalName :1;
  bool principalType :1;
  bool grantor :1;
  bool grantorType :1;
  bool grantOption :1;
} _GrantRevokeRoleRequest__isset;

class GrantRevokeRoleRequest : public virtual ::apache::thrift::TBase {
 public:

  GrantRevokeRoleRequest(const GrantRevokeRoleRequest&);
  GrantRevokeRoleRequest& operator=(const GrantRevokeRoleRequest&);
  GrantRevokeRoleRequest() noexcept
                         : requestType(static_cast<GrantRevokeType::type>(0)),
                           roleName(),
                           principalName(),
                           principalType(static_cast<PrincipalType::type>(0)),
                           grantor(),
                           grantorType(static_cast<PrincipalType::type>(0)),
                           grantOption(0) {
  }

  virtual ~GrantRevokeRoleRequest() noexcept;
  /**
   *
   * @see GrantRevokeType
   */
  GrantRevokeType::type requestType;
  std::string roleName;
  std::string principalName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type principalType;
  std::string grantor;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type grantorType;
  bool grantOption;

  _GrantRevokeRoleRequest__isset __isset;

  void __set_requestType(const GrantRevokeType::type val);

  void __set_roleName(const std::string& val);

  void __set_principalName(const std::string& val);

  void __set_principalType(const PrincipalType::type val);

  void __set_grantor(const std::string& val);

  void __set_grantorType(const PrincipalType::type val);

  void __set_grantOption(const bool val);

  bool operator == (const GrantRevokeRoleRequest & rhs) const
  {
    if (!(requestType == rhs.requestType))
      return false;
    if (!(roleName == rhs.roleName))
      return false;
    if (!(principalName == rhs.principalName))
      return false;
    if (!(principalType == rhs.principalType))
      return false;
    if (__isset.grantor != rhs.__isset.grantor)
      return false;
    else if (__isset.grantor && !(grantor == rhs.grantor))
      return false;
    if (__isset.grantorType != rhs.__isset.grantorType)
      return false;
    else if (__isset.grantorType && !(grantorType == rhs.grantorType))
      return false;
    if (__isset.grantOption != rhs.__isset.grantOption)
      return false;
    else if (__isset.grantOption && !(grantOption == rhs.grantOption))
      return false;
    return true;
  }
  bool operator != (const GrantRevokeRoleRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GrantRevokeRoleRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GrantRevokeRoleRequest &a, GrantRevokeRoleRequest &b);

std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleRequest& obj);

typedef struct _GrantRevokeRoleResponse__isset {
  _GrantRevokeRoleResponse__isset() : success(false) {}
  bool success :1;
} _GrantRevokeRoleResponse__isset;

class GrantRevokeRoleResponse : public virtual ::apache::thrift::TBase {
 public:

  GrantRevokeRoleResponse(const GrantRevokeRoleResponse&) noexcept;
  GrantRevokeRoleResponse& operator=(const GrantRevokeRoleResponse&) noexcept;
  GrantRevokeRoleResponse() noexcept
                          : success(0) {
  }

  virtual ~GrantRevokeRoleResponse() noexcept;
  bool success;

  _GrantRevokeRoleResponse__isset __isset;

  void __set_success(const bool val);

  bool operator == (const GrantRevokeRoleResponse & rhs) const
  {
    if (__isset.success != rhs.__isset.success)
      return false;
    else if (__isset.success && !(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const GrantRevokeRoleResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GrantRevokeRoleResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GrantRevokeRoleResponse &a, GrantRevokeRoleResponse &b);

std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleResponse& obj);

typedef struct _Catalog__isset {
  _Catalog__isset() : name(false), description(false), locationUri(false), createTime(false) {}
  bool name :1;
  bool description :1;
  bool locationUri :1;
  bool createTime :1;
} _Catalog__isset;

class Catalog : public virtual ::apache::thrift::TBase {
 public:

  Catalog(const Catalog&);
  Catalog& operator=(const Catalog&);
  Catalog() noexcept
          : name(),
            description(),
            locationUri(),
            createTime(0) {
  }

  virtual ~Catalog() noexcept;
  std::string name;
  std::string description;
  std::string locationUri;
  int32_t createTime;

  _Catalog__isset __isset;

  void __set_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_locationUri(const std::string& val);

  void __set_createTime(const int32_t val);

  bool operator == (const Catalog & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (!(locationUri == rhs.locationUri))
      return false;
    if (__isset.createTime != rhs.__isset.createTime)
      return false;
    else if (__isset.createTime && !(createTime == rhs.createTime))
      return false;
    return true;
  }
  bool operator != (const Catalog &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Catalog & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Catalog &a, Catalog &b);

std::ostream& operator<<(std::ostream& out, const Catalog& obj);

typedef struct _CreateCatalogRequest__isset {
  _CreateCatalogRequest__isset() : catalog(false) {}
  bool catalog :1;
} _CreateCatalogRequest__isset;

class CreateCatalogRequest : public virtual ::apache::thrift::TBase {
 public:

  CreateCatalogRequest(const CreateCatalogRequest&);
  CreateCatalogRequest& operator=(const CreateCatalogRequest&);
  CreateCatalogRequest() noexcept {
  }

  virtual ~CreateCatalogRequest() noexcept;
  Catalog catalog;

  _CreateCatalogRequest__isset __isset;

  void __set_catalog(const Catalog& val);

  bool operator == (const CreateCatalogRequest & rhs) const
  {
    if (!(catalog == rhs.catalog))
      return false;
    return true;
  }
  bool operator != (const CreateCatalogRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreateCatalogRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreateCatalogRequest &a, CreateCatalogRequest &b);

std::ostream& operator<<(std::ostream& out, const CreateCatalogRequest& obj);

typedef struct _AlterCatalogRequest__isset {
  _AlterCatalogRequest__isset() : name(false), newCat(false) {}
  bool name :1;
  bool newCat :1;
} _AlterCatalogRequest__isset;

class AlterCatalogRequest : public virtual ::apache::thrift::TBase {
 public:

  AlterCatalogRequest(const AlterCatalogRequest&);
  AlterCatalogRequest& operator=(const AlterCatalogRequest&);
  AlterCatalogRequest() noexcept
                      : name() {
  }

  virtual ~AlterCatalogRequest() noexcept;
  std::string name;
  Catalog newCat;

  _AlterCatalogRequest__isset __isset;

  void __set_name(const std::string& val);

  void __set_newCat(const Catalog& val);

  bool operator == (const AlterCatalogRequest & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(newCat == rhs.newCat))
      return false;
    return true;
  }
  bool operator != (const AlterCatalogRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlterCatalogRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AlterCatalogRequest &a, AlterCatalogRequest &b);

std::ostream& operator<<(std::ostream& out, const AlterCatalogRequest& obj);

typedef struct _GetCatalogRequest__isset {
  _GetCatalogRequest__isset() : name(false) {}
  bool name :1;
} _GetCatalogRequest__isset;

class GetCatalogRequest : public virtual ::apache::thrift::TBase {
 public:

  GetCatalogRequest(const GetCatalogRequest&);
  GetCatalogRequest& operator=(const GetCatalogRequest&);
  GetCatalogRequest() noexcept
                    : name() {
  }

  virtual ~GetCatalogRequest() noexcept;
  std::string name;

  _GetCatalogRequest__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const GetCatalogRequest & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const GetCatalogRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetCatalogRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetCatalogRequest &a, GetCatalogRequest &b);

std::ostream& operator<<(std::ostream& out, const GetCatalogRequest& obj);

typedef struct _GetCatalogResponse__isset {
  _GetCatalogResponse__isset() : catalog(false) {}
  bool catalog :1;
} _GetCatalogResponse__isset;

class GetCatalogResponse : public virtual ::apache::thrift::TBase {
 public:

  GetCatalogResponse(const GetCatalogResponse&);
  GetCatalogResponse& operator=(const GetCatalogResponse&);
  GetCatalogResponse() noexcept {
  }

  virtual ~GetCatalogResponse() noexcept;
  Catalog catalog;

  _GetCatalogResponse__isset __isset;

  void __set_catalog(const Catalog& val);

  bool operator == (const GetCatalogResponse & rhs) const
  {
    if (!(catalog == rhs.catalog))
      return false;
    return true;
  }
  bool operator != (const GetCatalogResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetCatalogResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetCatalogResponse &a, GetCatalogResponse &b);

std::ostream& operator<<(std::ostream& out, const GetCatalogResponse& obj);

typedef struct _GetCatalogsResponse__isset {
  _GetCatalogsResponse__isset() : names(false) {}
  bool names :1;
} _GetCatalogsResponse__isset;

class GetCatalogsResponse : public virtual ::apache::thrift::TBase {
 public:

  GetCatalogsResponse(const GetCatalogsResponse&);
  GetCatalogsResponse& operator=(const GetCatalogsResponse&);
  GetCatalogsResponse() noexcept {
  }

  virtual ~GetCatalogsResponse() noexcept;
  std::vector<std::string>  names;

  _GetCatalogsResponse__isset __isset;

  void __set_names(const std::vector<std::string> & val);

  bool operator == (const GetCatalogsResponse & rhs) const
  {
    if (!(names == rhs.names))
      return false;
    return true;
  }
  bool operator != (const GetCatalogsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetCatalogsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetCatalogsResponse &a, GetCatalogsResponse &b);

std::ostream& operator<<(std::ostream& out, const GetCatalogsResponse& obj);

typedef struct _DropCatalogRequest__isset {
  _DropCatalogRequest__isset() : name(false) {}
  bool name :1;
} _DropCatalogRequest__isset;

class DropCatalogRequest : public virtual ::apache::thrift::TBase {
 public:

  DropCatalogRequest(const DropCatalogRequest&);
  DropCatalogRequest& operator=(const DropCatalogRequest&);
  DropCatalogRequest() noexcept
                     : name() {
  }

  virtual ~DropCatalogRequest() noexcept;
  std::string name;

  _DropCatalogRequest__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const DropCatalogRequest & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const DropCatalogRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropCatalogRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropCatalogRequest &a, DropCatalogRequest &b);

std::ostream& operator<<(std::ostream& out, const DropCatalogRequest& obj);

typedef struct _Database__isset {
  _Database__isset() : name(false), description(false), locationUri(false), parameters(false), privileges(false), ownerName(false), ownerType(false), catalogName(false), createTime(false), managedLocationUri(false), type(false), connector_name(false), remote_dbname(false) {}
  bool name :1;
  bool description :1;
  bool locationUri :1;
  bool parameters :1;
  bool privileges :1;
  bool ownerName :1;
  bool ownerType :1;
  bool catalogName :1;
  bool createTime :1;
  bool managedLocationUri :1;
  bool type :1;
  bool connector_name :1;
  bool remote_dbname :1;
} _Database__isset;

class Database : public virtual ::apache::thrift::TBase {
 public:

  Database(const Database&);
  Database& operator=(const Database&);
  Database() noexcept
           : name(),
             description(),
             locationUri(),
             ownerName(),
             ownerType(static_cast<PrincipalType::type>(0)),
             catalogName(),
             createTime(0),
             managedLocationUri(),
             type(static_cast<DatabaseType::type>(0)),
             connector_name(),
             remote_dbname() {
  }

  virtual ~Database() noexcept;
  std::string name;
  std::string description;
  std::string locationUri;
  std::map<std::string, std::string>  parameters;
  PrincipalPrivilegeSet privileges;
  std::string ownerName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type ownerType;
  std::string catalogName;
  int32_t createTime;
  std::string managedLocationUri;
  /**
   *
   * @see DatabaseType
   */
  DatabaseType::type type;
  std::string connector_name;
  std::string remote_dbname;

  _Database__isset __isset;

  void __set_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_locationUri(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_privileges(const PrincipalPrivilegeSet& val);

  void __set_ownerName(const std::string& val);

  void __set_ownerType(const PrincipalType::type val);

  void __set_catalogName(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_managedLocationUri(const std::string& val);

  void __set_type(const DatabaseType::type val);

  void __set_connector_name(const std::string& val);

  void __set_remote_dbname(const std::string& val);

  bool operator == (const Database & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(locationUri == rhs.locationUri))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    if (__isset.ownerName != rhs.__isset.ownerName)
      return false;
    else if (__isset.ownerName && !(ownerName == rhs.ownerName))
      return false;
    if (__isset.ownerType != rhs.__isset.ownerType)
      return false;
    else if (__isset.ownerType && !(ownerType == rhs.ownerType))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.createTime != rhs.__isset.createTime)
      return false;
    else if (__isset.createTime && !(createTime == rhs.createTime))
      return false;
    if (__isset.managedLocationUri != rhs.__isset.managedLocationUri)
      return false;
    else if (__isset.managedLocationUri && !(managedLocationUri == rhs.managedLocationUri))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.connector_name != rhs.__isset.connector_name)
      return false;
    else if (__isset.connector_name && !(connector_name == rhs.connector_name))
      return false;
    if (__isset.remote_dbname != rhs.__isset.remote_dbname)
      return false;
    else if (__isset.remote_dbname && !(remote_dbname == rhs.remote_dbname))
      return false;
    return true;
  }
  bool operator != (const Database &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Database & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Database &a, Database &b);

std::ostream& operator<<(std::ostream& out, const Database& obj);

typedef struct _SerDeInfo__isset {
  _SerDeInfo__isset() : name(false), serializationLib(false), parameters(false), description(false), serializerClass(false), deserializerClass(false), serdeType(false) {}
  bool name :1;
  bool serializationLib :1;
  bool parameters :1;
  bool description :1;
  bool serializerClass :1;
  bool deserializerClass :1;
  bool serdeType :1;
} _SerDeInfo__isset;

class SerDeInfo : public virtual ::apache::thrift::TBase {
 public:

  SerDeInfo(const SerDeInfo&);
  SerDeInfo& operator=(const SerDeInfo&);
  SerDeInfo() noexcept
            : name(),
              serializationLib(),
              description(),
              serializerClass(),
              deserializerClass(),
              serdeType(static_cast<SerdeType::type>(0)) {
  }

  virtual ~SerDeInfo() noexcept;
  std::string name;
  std::string serializationLib;
  std::map<std::string, std::string>  parameters;
  std::string description;
  std::string serializerClass;
  std::string deserializerClass;
  /**
   *
   * @see SerdeType
   */
  SerdeType::type serdeType;

  _SerDeInfo__isset __isset;

  void __set_name(const std::string& val);

  void __set_serializationLib(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_description(const std::string& val);

  void __set_serializerClass(const std::string& val);

  void __set_deserializerClass(const std::string& val);

  void __set_serdeType(const SerdeType::type val);

  bool operator == (const SerDeInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(serializationLib == rhs.serializationLib))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.serializerClass != rhs.__isset.serializerClass)
      return false;
    else if (__isset.serializerClass && !(serializerClass == rhs.serializerClass))
      return false;
    if (__isset.deserializerClass != rhs.__isset.deserializerClass)
      return false;
    else if (__isset.deserializerClass && !(deserializerClass == rhs.deserializerClass))
      return false;
    if (__isset.serdeType != rhs.__isset.serdeType)
      return false;
    else if (__isset.serdeType && !(serdeType == rhs.serdeType))
      return false;
    return true;
  }
  bool operator != (const SerDeInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SerDeInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SerDeInfo &a, SerDeInfo &b);

std::ostream& operator<<(std::ostream& out, const SerDeInfo& obj);

typedef struct _Order__isset {
  _Order__isset() : col(false), order(false) {}
  bool col :1;
  bool order :1;
} _Order__isset;

class Order : public virtual ::apache::thrift::TBase {
 public:

  Order(const Order&);
  Order& operator=(const Order&);
  Order() noexcept
        : col(),
          order(0) {
  }

  virtual ~Order() noexcept;
  std::string col;
  int32_t order;

  _Order__isset __isset;

  void __set_col(const std::string& val);

  void __set_order(const int32_t val);

  bool operator == (const Order & rhs) const
  {
    if (!(col == rhs.col))
      return false;
    if (!(order == rhs.order))
      return false;
    return true;
  }
  bool operator != (const Order &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Order & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Order &a, Order &b);

std::ostream& operator<<(std::ostream& out, const Order& obj);

typedef struct _SkewedInfo__isset {
  _SkewedInfo__isset() : skewedColNames(false), skewedColValues(false), skewedColValueLocationMaps(false) {}
  bool skewedColNames :1;
  bool skewedColValues :1;
  bool skewedColValueLocationMaps :1;
} _SkewedInfo__isset;

class SkewedInfo : public virtual ::apache::thrift::TBase {
 public:

  SkewedInfo(const SkewedInfo&);
  SkewedInfo& operator=(const SkewedInfo&);
  SkewedInfo() noexcept {
  }

  virtual ~SkewedInfo() noexcept;
  std::vector<std::string>  skewedColNames;
  std::vector<std::vector<std::string> >  skewedColValues;
  std::map<std::vector<std::string> , std::string>  skewedColValueLocationMaps;

  _SkewedInfo__isset __isset;

  void __set_skewedColNames(const std::vector<std::string> & val);

  void __set_skewedColValues(const std::vector<std::vector<std::string> > & val);

  void __set_skewedColValueLocationMaps(const std::map<std::vector<std::string> , std::string> & val);

  bool operator == (const SkewedInfo & rhs) const
  {
    if (!(skewedColNames == rhs.skewedColNames))
      return false;
    if (!(skewedColValues == rhs.skewedColValues))
      return false;
    if (!(skewedColValueLocationMaps == rhs.skewedColValueLocationMaps))
      return false;
    return true;
  }
  bool operator != (const SkewedInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SkewedInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SkewedInfo &a, SkewedInfo &b);

std::ostream& operator<<(std::ostream& out, const SkewedInfo& obj);

typedef struct _StorageDescriptor__isset {
  _StorageDescriptor__isset() : cols(false), location(false), inputFormat(false), outputFormat(false), compressed(false), numBuckets(false), serdeInfo(false), bucketCols(false), sortCols(false), parameters(false), skewedInfo(false), storedAsSubDirectories(false) {}
  bool cols :1;
  bool location :1;
  bool inputFormat :1;
  bool outputFormat :1;
  bool compressed :1;
  bool numBuckets :1;
  bool serdeInfo :1;
  bool bucketCols :1;
  bool sortCols :1;
  bool parameters :1;
  bool skewedInfo :1;
  bool storedAsSubDirectories :1;
} _StorageDescriptor__isset;

class StorageDescriptor : public virtual ::apache::thrift::TBase {
 public:

  StorageDescriptor(const StorageDescriptor&);
  StorageDescriptor& operator=(const StorageDescriptor&);
  StorageDescriptor() noexcept
                    : location(),
                      inputFormat(),
                      outputFormat(),
                      compressed(0),
                      numBuckets(0),
                      storedAsSubDirectories(0) {
  }

  virtual ~StorageDescriptor() noexcept;
  std::vector<FieldSchema>  cols;
  std::string location;
  std::string inputFormat;
  std::string outputFormat;
  bool compressed;
  int32_t numBuckets;
  SerDeInfo serdeInfo;
  std::vector<std::string>  bucketCols;
  std::vector<Order>  sortCols;
  std::map<std::string, std::string>  parameters;
  SkewedInfo skewedInfo;
  bool storedAsSubDirectories;

  _StorageDescriptor__isset __isset;

  void __set_cols(const std::vector<FieldSchema> & val);

  void __set_location(const std::string& val);

  void __set_inputFormat(const std::string& val);

  void __set_outputFormat(const std::string& val);

  void __set_compressed(const bool val);

  void __set_numBuckets(const int32_t val);

  void __set_serdeInfo(const SerDeInfo& val);

  void __set_bucketCols(const std::vector<std::string> & val);

  void __set_sortCols(const std::vector<Order> & val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_skewedInfo(const SkewedInfo& val);

  void __set_storedAsSubDirectories(const bool val);

  bool operator == (const StorageDescriptor & rhs) const
  {
    if (!(cols == rhs.cols))
      return false;
    if (!(location == rhs.location))
      return false;
    if (!(inputFormat == rhs.inputFormat))
      return false;
    if (!(outputFormat == rhs.outputFormat))
      return false;
    if (!(compressed == rhs.compressed))
      return false;
    if (!(numBuckets == rhs.numBuckets))
      return false;
    if (!(serdeInfo == rhs.serdeInfo))
      return false;
    if (!(bucketCols == rhs.bucketCols))
      return false;
    if (!(sortCols == rhs.sortCols))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.skewedInfo != rhs.__isset.skewedInfo)
      return false;
    else if (__isset.skewedInfo && !(skewedInfo == rhs.skewedInfo))
      return false;
    if (__isset.storedAsSubDirectories != rhs.__isset.storedAsSubDirectories)
      return false;
    else if (__isset.storedAsSubDirectories && !(storedAsSubDirectories == rhs.storedAsSubDirectories))
      return false;
    return true;
  }
  bool operator != (const StorageDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(StorageDescriptor &a, StorageDescriptor &b);

std::ostream& operator<<(std::ostream& out, const StorageDescriptor& obj);

typedef struct _CreationMetadata__isset {
  _CreationMetadata__isset() : validTxnList(false), materializationTime(false), sourceTables(false) {}
  bool validTxnList :1;
  bool materializationTime :1;
  bool sourceTables :1;
} _CreationMetadata__isset;

class CreationMetadata : public virtual ::apache::thrift::TBase {
 public:

  CreationMetadata(const CreationMetadata&);
  CreationMetadata& operator=(const CreationMetadata&);
  CreationMetadata() noexcept
                   : catName(),
                     dbName(),
                     tblName(),
                     validTxnList(),
                     materializationTime(0) {
  }

  virtual ~CreationMetadata() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  std::set<std::string>  tablesUsed;
  std::string validTxnList;
  int64_t materializationTime;
  std::vector<SourceTable>  sourceTables;

  _CreationMetadata__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_tablesUsed(const std::set<std::string> & val);

  void __set_validTxnList(const std::string& val);

  void __set_materializationTime(const int64_t val);

  void __set_sourceTables(const std::vector<SourceTable> & val);

  bool operator == (const CreationMetadata & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(tablesUsed == rhs.tablesUsed))
      return false;
    if (__isset.validTxnList != rhs.__isset.validTxnList)
      return false;
    else if (__isset.validTxnList && !(validTxnList == rhs.validTxnList))
      return false;
    if (__isset.materializationTime != rhs.__isset.materializationTime)
      return false;
    else if (__isset.materializationTime && !(materializationTime == rhs.materializationTime))
      return false;
    if (__isset.sourceTables != rhs.__isset.sourceTables)
      return false;
    else if (__isset.sourceTables && !(sourceTables == rhs.sourceTables))
      return false;
    return true;
  }
  bool operator != (const CreationMetadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreationMetadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreationMetadata &a, CreationMetadata &b);

std::ostream& operator<<(std::ostream& out, const CreationMetadata& obj);

typedef struct _BooleanColumnStatsData__isset {
  _BooleanColumnStatsData__isset() : bitVectors(false) {}
  bool bitVectors :1;
} _BooleanColumnStatsData__isset;

class BooleanColumnStatsData : public virtual ::apache::thrift::TBase {
 public:

  BooleanColumnStatsData(const BooleanColumnStatsData&);
  BooleanColumnStatsData& operator=(const BooleanColumnStatsData&);
  BooleanColumnStatsData() noexcept
                         : numTrues(0),
                           numFalses(0),
                           numNulls(0),
                           bitVectors() {
  }

  virtual ~BooleanColumnStatsData() noexcept;
  int64_t numTrues;
  int64_t numFalses;
  int64_t numNulls;
  std::string bitVectors;

  _BooleanColumnStatsData__isset __isset;

  void __set_numTrues(const int64_t val);

  void __set_numFalses(const int64_t val);

  void __set_numNulls(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const BooleanColumnStatsData & rhs) const
  {
    if (!(numTrues == rhs.numTrues))
      return false;
    if (!(numFalses == rhs.numFalses))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const BooleanColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BooleanColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(BooleanColumnStatsData &a, BooleanColumnStatsData &b);

std::ostream& operator<<(std::ostream& out, const BooleanColumnStatsData& obj);

typedef struct _DoubleColumnStatsData__isset {
  _DoubleColumnStatsData__isset() : lowValue(false), highValue(false), bitVectors(false), histogram(false) {}
  bool lowValue :1;
  bool highValue :1;
  bool bitVectors :1;
  bool histogram :1;
} _DoubleColumnStatsData__isset;

class DoubleColumnStatsData : public virtual ::apache::thrift::TBase {
 public:

  DoubleColumnStatsData(const DoubleColumnStatsData&);
  DoubleColumnStatsData& operator=(const DoubleColumnStatsData&);
  DoubleColumnStatsData() noexcept
                        : lowValue(0),
                          highValue(0),
                          numNulls(0),
                          numDVs(0),
                          bitVectors(),
                          histogram() {
  }

  virtual ~DoubleColumnStatsData() noexcept;
  double lowValue;
  double highValue;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;
  std::string histogram;

  _DoubleColumnStatsData__isset __isset;

  void __set_lowValue(const double val);

  void __set_highValue(const double val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  void __set_histogram(const std::string& val);

  bool operator == (const DoubleColumnStatsData & rhs) const
  {
    if (__isset.lowValue != rhs.__isset.lowValue)
      return false;
    else if (__isset.lowValue && !(lowValue == rhs.lowValue))
      return false;
    if (__isset.highValue != rhs.__isset.highValue)
      return false;
    else if (__isset.highValue && !(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    if (__isset.histogram != rhs.__isset.histogram)
      return false;
    else if (__isset.histogram && !(histogram == rhs.histogram))
      return false;
    return true;
  }
  bool operator != (const DoubleColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoubleColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DoubleColumnStatsData &a, DoubleColumnStatsData &b);

std::ostream& operator<<(std::ostream& out, const DoubleColumnStatsData& obj);

typedef struct _LongColumnStatsData__isset {
  _LongColumnStatsData__isset() : lowValue(false), highValue(false), bitVectors(false), histogram(false) {}
  bool lowValue :1;
  bool highValue :1;
  bool bitVectors :1;
  bool histogram :1;
} _LongColumnStatsData__isset;

class LongColumnStatsData : public virtual ::apache::thrift::TBase {
 public:

  LongColumnStatsData(const LongColumnStatsData&);
  LongColumnStatsData& operator=(const LongColumnStatsData&);
  LongColumnStatsData() noexcept
                      : lowValue(0),
                        highValue(0),
                        numNulls(0),
                        numDVs(0),
                        bitVectors(),
                        histogram() {
  }

  virtual ~LongColumnStatsData() noexcept;
  int64_t lowValue;
  int64_t highValue;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;
  std::string histogram;

  _LongColumnStatsData__isset __isset;

  void __set_lowValue(const int64_t val);

  void __set_highValue(const int64_t val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  void __set_histogram(const std::string& val);

  bool operator == (const LongColumnStatsData & rhs) const
  {
    if (__isset.lowValue != rhs.__isset.lowValue)
      return false;
    else if (__isset.lowValue && !(lowValue == rhs.lowValue))
      return false;
    if (__isset.highValue != rhs.__isset.highValue)
      return false;
    else if (__isset.highValue && !(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    if (__isset.histogram != rhs.__isset.histogram)
      return false;
    else if (__isset.histogram && !(histogram == rhs.histogram))
      return false;
    return true;
  }
  bool operator != (const LongColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LongColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(LongColumnStatsData &a, LongColumnStatsData &b);

std::ostream& operator<<(std::ostream& out, const LongColumnStatsData& obj);

typedef struct _StringColumnStatsData__isset {
  _StringColumnStatsData__isset() : bitVectors(false) {}
  bool bitVectors :1;
} _StringColumnStatsData__isset;

class StringColumnStatsData : public virtual ::apache::thrift::TBase {
 public:

  StringColumnStatsData(const StringColumnStatsData&);
  StringColumnStatsData& operator=(const StringColumnStatsData&);
  StringColumnStatsData() noexcept
                        : maxColLen(0),
                          avgColLen(0),
                          numNulls(0),
                          numDVs(0),
                          bitVectors() {
  }

  virtual ~StringColumnStatsData() noexcept;
  int64_t maxColLen;
  double avgColLen;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;

  _StringColumnStatsData__isset __isset;

  void __set_maxColLen(const int64_t val);

  void __set_avgColLen(const double val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const StringColumnStatsData & rhs) const
  {
    if (!(maxColLen == rhs.maxColLen))
      return false;
    if (!(avgColLen == rhs.avgColLen))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const StringColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StringColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(StringColumnStatsData &a, StringColumnStatsData &b);

std::ostream& operator<<(std::ostream& out, const StringColumnStatsData& obj);

typedef struct _BinaryColumnStatsData__isset {
  _BinaryColumnStatsData__isset() : bitVectors(false) {}
  bool bitVectors :1;
} _BinaryColumnStatsData__isset;

class BinaryColumnStatsData : public virtual ::apache::thrift::TBase {
 public:

  BinaryColumnStatsData(const BinaryColumnStatsData&);
  BinaryColumnStatsData& operator=(const BinaryColumnStatsData&);
  BinaryColumnStatsData() noexcept
                        : maxColLen(0),
                          avgColLen(0),
                          numNulls(0),
                          bitVectors() {
  }

  virtual ~BinaryColumnStatsData() noexcept;
  int64_t maxColLen;
  double avgColLen;
  int64_t numNulls;
  std::string bitVectors;

  _BinaryColumnStatsData__isset __isset;

  void __set_maxColLen(const int64_t val);

  void __set_avgColLen(const double val);

  void __set_numNulls(const int64_t val);

  void __set_bitVectors(const std::string& val);

  bool operator == (const BinaryColumnStatsData & rhs) const
  {
    if (!(maxColLen == rhs.maxColLen))
      return false;
    if (!(avgColLen == rhs.avgColLen))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    return true;
  }
  bool operator != (const BinaryColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BinaryColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(BinaryColumnStatsData &a, BinaryColumnStatsData &b);

std::ostream& operator<<(std::ostream& out, const BinaryColumnStatsData& obj);


class Decimal : public virtual ::apache::thrift::TBase {
 public:

  Decimal(const Decimal&);
  Decimal& operator=(const Decimal&);
  Decimal() noexcept
          : scale(0),
            unscaled() {
  }

  virtual ~Decimal() noexcept;
  int16_t scale;
  std::string unscaled;

  void __set_scale(const int16_t val);

  void __set_unscaled(const std::string& val);

  bool operator == (const Decimal & rhs) const
  {
    if (!(scale == rhs.scale))
      return false;
    if (!(unscaled == rhs.unscaled))
      return false;
    return true;
  }
  bool operator != (const Decimal &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Decimal & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Decimal &a, Decimal &b);

std::ostream& operator<<(std::ostream& out, const Decimal& obj);

typedef struct _DecimalColumnStatsData__isset {
  _DecimalColumnStatsData__isset() : lowValue(false), highValue(false), bitVectors(false), histogram(false) {}
  bool lowValue :1;
  bool highValue :1;
  bool bitVectors :1;
  bool histogram :1;
} _DecimalColumnStatsData__isset;

class DecimalColumnStatsData : public virtual ::apache::thrift::TBase {
 public:

  DecimalColumnStatsData(const DecimalColumnStatsData&);
  DecimalColumnStatsData& operator=(const DecimalColumnStatsData&);
  DecimalColumnStatsData() noexcept
                         : numNulls(0),
                           numDVs(0),
                           bitVectors(),
                           histogram() {
  }

  virtual ~DecimalColumnStatsData() noexcept;
  Decimal lowValue;
  Decimal highValue;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;
  std::string histogram;

  _DecimalColumnStatsData__isset __isset;

  void __set_lowValue(const Decimal& val);

  void __set_highValue(const Decimal& val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  void __set_histogram(const std::string& val);

  bool operator == (const DecimalColumnStatsData & rhs) const
  {
    if (__isset.lowValue != rhs.__isset.lowValue)
      return false;
    else if (__isset.lowValue && !(lowValue == rhs.lowValue))
      return false;
    if (__isset.highValue != rhs.__isset.highValue)
      return false;
    else if (__isset.highValue && !(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    if (__isset.histogram != rhs.__isset.histogram)
      return false;
    else if (__isset.histogram && !(histogram == rhs.histogram))
      return false;
    return true;
  }
  bool operator != (const DecimalColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DecimalColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DecimalColumnStatsData &a, DecimalColumnStatsData &b);

std::ostream& operator<<(std::ostream& out, const DecimalColumnStatsData& obj);


class Date : public virtual ::apache::thrift::TBase {
 public:

  Date(const Date&) noexcept;
  Date& operator=(const Date&) noexcept;
  Date() noexcept
       : daysSinceEpoch(0) {
  }

  virtual ~Date() noexcept;
  int64_t daysSinceEpoch;

  void __set_daysSinceEpoch(const int64_t val);

  bool operator == (const Date & rhs) const
  {
    if (!(daysSinceEpoch == rhs.daysSinceEpoch))
      return false;
    return true;
  }
  bool operator != (const Date &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Date & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Date &a, Date &b);

std::ostream& operator<<(std::ostream& out, const Date& obj);

typedef struct _DateColumnStatsData__isset {
  _DateColumnStatsData__isset() : lowValue(false), highValue(false), bitVectors(false), histogram(false) {}
  bool lowValue :1;
  bool highValue :1;
  bool bitVectors :1;
  bool histogram :1;
} _DateColumnStatsData__isset;

class DateColumnStatsData : public virtual ::apache::thrift::TBase {
 public:

  DateColumnStatsData(const DateColumnStatsData&);
  DateColumnStatsData& operator=(const DateColumnStatsData&);
  DateColumnStatsData() noexcept
                      : numNulls(0),
                        numDVs(0),
                        bitVectors(),
                        histogram() {
  }

  virtual ~DateColumnStatsData() noexcept;
  Date lowValue;
  Date highValue;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;
  std::string histogram;

  _DateColumnStatsData__isset __isset;

  void __set_lowValue(const Date& val);

  void __set_highValue(const Date& val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  void __set_histogram(const std::string& val);

  bool operator == (const DateColumnStatsData & rhs) const
  {
    if (__isset.lowValue != rhs.__isset.lowValue)
      return false;
    else if (__isset.lowValue && !(lowValue == rhs.lowValue))
      return false;
    if (__isset.highValue != rhs.__isset.highValue)
      return false;
    else if (__isset.highValue && !(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    if (__isset.histogram != rhs.__isset.histogram)
      return false;
    else if (__isset.histogram && !(histogram == rhs.histogram))
      return false;
    return true;
  }
  bool operator != (const DateColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DateColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DateColumnStatsData &a, DateColumnStatsData &b);

std::ostream& operator<<(std::ostream& out, const DateColumnStatsData& obj);


class Timestamp : public virtual ::apache::thrift::TBase {
 public:

  Timestamp(const Timestamp&) noexcept;
  Timestamp& operator=(const Timestamp&) noexcept;
  Timestamp() noexcept
            : secondsSinceEpoch(0) {
  }

  virtual ~Timestamp() noexcept;
  int64_t secondsSinceEpoch;

  void __set_secondsSinceEpoch(const int64_t val);

  bool operator == (const Timestamp & rhs) const
  {
    if (!(secondsSinceEpoch == rhs.secondsSinceEpoch))
      return false;
    return true;
  }
  bool operator != (const Timestamp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Timestamp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Timestamp &a, Timestamp &b);

std::ostream& operator<<(std::ostream& out, const Timestamp& obj);

typedef struct _TimestampColumnStatsData__isset {
  _TimestampColumnStatsData__isset() : lowValue(false), highValue(false), bitVectors(false), histogram(false) {}
  bool lowValue :1;
  bool highValue :1;
  bool bitVectors :1;
  bool histogram :1;
} _TimestampColumnStatsData__isset;

class TimestampColumnStatsData : public virtual ::apache::thrift::TBase {
 public:

  TimestampColumnStatsData(const TimestampColumnStatsData&);
  TimestampColumnStatsData& operator=(const TimestampColumnStatsData&);
  TimestampColumnStatsData() noexcept
                           : numNulls(0),
                             numDVs(0),
                             bitVectors(),
                             histogram() {
  }

  virtual ~TimestampColumnStatsData() noexcept;
  Timestamp lowValue;
  Timestamp highValue;
  int64_t numNulls;
  int64_t numDVs;
  std::string bitVectors;
  std::string histogram;

  _TimestampColumnStatsData__isset __isset;

  void __set_lowValue(const Timestamp& val);

  void __set_highValue(const Timestamp& val);

  void __set_numNulls(const int64_t val);

  void __set_numDVs(const int64_t val);

  void __set_bitVectors(const std::string& val);

  void __set_histogram(const std::string& val);

  bool operator == (const TimestampColumnStatsData & rhs) const
  {
    if (__isset.lowValue != rhs.__isset.lowValue)
      return false;
    else if (__isset.lowValue && !(lowValue == rhs.lowValue))
      return false;
    if (__isset.highValue != rhs.__isset.highValue)
      return false;
    else if (__isset.highValue && !(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    if (__isset.bitVectors != rhs.__isset.bitVectors)
      return false;
    else if (__isset.bitVectors && !(bitVectors == rhs.bitVectors))
      return false;
    if (__isset.histogram != rhs.__isset.histogram)
      return false;
    else if (__isset.histogram && !(histogram == rhs.histogram))
      return false;
    return true;
  }
  bool operator != (const TimestampColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TimestampColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TimestampColumnStatsData &a, TimestampColumnStatsData &b);

std::ostream& operator<<(std::ostream& out, const TimestampColumnStatsData& obj);

typedef struct _ColumnStatisticsData__isset {
  _ColumnStatisticsData__isset() : booleanStats(false), longStats(false), doubleStats(false), stringStats(false), binaryStats(false), decimalStats(false), dateStats(false), timestampStats(false) {}
  bool booleanStats :1;
  bool longStats :1;
  bool doubleStats :1;
  bool stringStats :1;
  bool binaryStats :1;
  bool decimalStats :1;
  bool dateStats :1;
  bool timestampStats :1;
} _ColumnStatisticsData__isset;

class ColumnStatisticsData : public virtual ::apache::thrift::TBase {
 public:

  ColumnStatisticsData(const ColumnStatisticsData&);
  ColumnStatisticsData& operator=(const ColumnStatisticsData&);
  ColumnStatisticsData() noexcept {
  }

  virtual ~ColumnStatisticsData() noexcept;
  BooleanColumnStatsData booleanStats;
  LongColumnStatsData longStats;
  DoubleColumnStatsData doubleStats;
  StringColumnStatsData stringStats;
  BinaryColumnStatsData binaryStats;
  DecimalColumnStatsData decimalStats;
  DateColumnStatsData dateStats;
  TimestampColumnStatsData timestampStats;

  _ColumnStatisticsData__isset __isset;

  void __set_booleanStats(const BooleanColumnStatsData& val);

  void __set_longStats(const LongColumnStatsData& val);

  void __set_doubleStats(const DoubleColumnStatsData& val);

  void __set_stringStats(const StringColumnStatsData& val);

  void __set_binaryStats(const BinaryColumnStatsData& val);

  void __set_decimalStats(const DecimalColumnStatsData& val);

  void __set_dateStats(const DateColumnStatsData& val);

  void __set_timestampStats(const TimestampColumnStatsData& val);

  bool operator == (const ColumnStatisticsData & rhs) const
  {
    if (__isset.booleanStats != rhs.__isset.booleanStats)
      return false;
    else if (__isset.booleanStats && !(booleanStats == rhs.booleanStats))
      return false;
    if (__isset.longStats != rhs.__isset.longStats)
      return false;
    else if (__isset.longStats && !(longStats == rhs.longStats))
      return false;
    if (__isset.doubleStats != rhs.__isset.doubleStats)
      return false;
    else if (__isset.doubleStats && !(doubleStats == rhs.doubleStats))
      return false;
    if (__isset.stringStats != rhs.__isset.stringStats)
      return false;
    else if (__isset.stringStats && !(stringStats == rhs.stringStats))
      return false;
    if (__isset.binaryStats != rhs.__isset.binaryStats)
      return false;
    else if (__isset.binaryStats && !(binaryStats == rhs.binaryStats))
      return false;
    if (__isset.decimalStats != rhs.__isset.decimalStats)
      return false;
    else if (__isset.decimalStats && !(decimalStats == rhs.decimalStats))
      return false;
    if (__isset.dateStats != rhs.__isset.dateStats)
      return false;
    else if (__isset.dateStats && !(dateStats == rhs.dateStats))
      return false;
    if (__isset.timestampStats != rhs.__isset.timestampStats)
      return false;
    else if (__isset.timestampStats && !(timestampStats == rhs.timestampStats))
      return false;
    return true;
  }
  bool operator != (const ColumnStatisticsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatisticsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnStatisticsData &a, ColumnStatisticsData &b);

std::ostream& operator<<(std::ostream& out, const ColumnStatisticsData& obj);


class ColumnStatisticsObj : public virtual ::apache::thrift::TBase {
 public:

  ColumnStatisticsObj(const ColumnStatisticsObj&);
  ColumnStatisticsObj& operator=(const ColumnStatisticsObj&);
  ColumnStatisticsObj() noexcept
                      : colName(),
                        colType() {
  }

  virtual ~ColumnStatisticsObj() noexcept;
  std::string colName;
  std::string colType;
  ColumnStatisticsData statsData;

  void __set_colName(const std::string& val);

  void __set_colType(const std::string& val);

  void __set_statsData(const ColumnStatisticsData& val);

  bool operator == (const ColumnStatisticsObj & rhs) const
  {
    if (!(colName == rhs.colName))
      return false;
    if (!(colType == rhs.colType))
      return false;
    if (!(statsData == rhs.statsData))
      return false;
    return true;
  }
  bool operator != (const ColumnStatisticsObj &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatisticsObj & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnStatisticsObj &a, ColumnStatisticsObj &b);

std::ostream& operator<<(std::ostream& out, const ColumnStatisticsObj& obj);

typedef struct _ColumnStatisticsDesc__isset {
  _ColumnStatisticsDesc__isset() : partName(false), lastAnalyzed(false), catName(false) {}
  bool partName :1;
  bool lastAnalyzed :1;
  bool catName :1;
} _ColumnStatisticsDesc__isset;

class ColumnStatisticsDesc : public virtual ::apache::thrift::TBase {
 public:

  ColumnStatisticsDesc(const ColumnStatisticsDesc&);
  ColumnStatisticsDesc& operator=(const ColumnStatisticsDesc&);
  ColumnStatisticsDesc() noexcept
                       : isTblLevel(0),
                         dbName(),
                         tableName(),
                         partName(),
                         lastAnalyzed(0),
                         catName() {
  }

  virtual ~ColumnStatisticsDesc() noexcept;
  bool isTblLevel;
  std::string dbName;
  std::string tableName;
  std::string partName;
  int64_t lastAnalyzed;
  std::string catName;

  _ColumnStatisticsDesc__isset __isset;

  void __set_isTblLevel(const bool val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_partName(const std::string& val);

  void __set_lastAnalyzed(const int64_t val);

  void __set_catName(const std::string& val);

  bool operator == (const ColumnStatisticsDesc & rhs) const
  {
    if (!(isTblLevel == rhs.isTblLevel))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.partName != rhs.__isset.partName)
      return false;
    else if (__isset.partName && !(partName == rhs.partName))
      return false;
    if (__isset.lastAnalyzed != rhs.__isset.lastAnalyzed)
      return false;
    else if (__isset.lastAnalyzed && !(lastAnalyzed == rhs.lastAnalyzed))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const ColumnStatisticsDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatisticsDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnStatisticsDesc &a, ColumnStatisticsDesc &b);

std::ostream& operator<<(std::ostream& out, const ColumnStatisticsDesc& obj);

typedef struct _ColumnStatistics__isset {
  _ColumnStatistics__isset() : isStatsCompliant(false), engine(true) {}
  bool isStatsCompliant :1;
  bool engine :1;
} _ColumnStatistics__isset;

class ColumnStatistics : public virtual ::apache::thrift::TBase {
 public:

  ColumnStatistics(const ColumnStatistics&);
  ColumnStatistics& operator=(const ColumnStatistics&);
  ColumnStatistics() : isStatsCompliant(0),
                       engine("hive") {
  }

  virtual ~ColumnStatistics() noexcept;
  ColumnStatisticsDesc statsDesc;
  std::vector<ColumnStatisticsObj>  statsObj;
  bool isStatsCompliant;
  std::string engine;

  _ColumnStatistics__isset __isset;

  void __set_statsDesc(const ColumnStatisticsDesc& val);

  void __set_statsObj(const std::vector<ColumnStatisticsObj> & val);

  void __set_isStatsCompliant(const bool val);

  void __set_engine(const std::string& val);

  bool operator == (const ColumnStatistics & rhs) const
  {
    if (!(statsDesc == rhs.statsDesc))
      return false;
    if (!(statsObj == rhs.statsObj))
      return false;
    if (__isset.isStatsCompliant != rhs.__isset.isStatsCompliant)
      return false;
    else if (__isset.isStatsCompliant && !(isStatsCompliant == rhs.isStatsCompliant))
      return false;
    if (__isset.engine != rhs.__isset.engine)
      return false;
    else if (__isset.engine && !(engine == rhs.engine))
      return false;
    return true;
  }
  bool operator != (const ColumnStatistics &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatistics & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnStatistics &a, ColumnStatistics &b);

std::ostream& operator<<(std::ostream& out, const ColumnStatistics& obj);

typedef struct _FileMetadata__isset {
  _FileMetadata__isset() : type(true), version(true), data(false) {}
  bool type :1;
  bool version :1;
  bool data :1;
} _FileMetadata__isset;

class FileMetadata : public virtual ::apache::thrift::TBase {
 public:

  FileMetadata(const FileMetadata&);
  FileMetadata& operator=(const FileMetadata&);
  FileMetadata() noexcept
               : type(1),
                 version(1) {
  }

  virtual ~FileMetadata() noexcept;
  int8_t type;
  int8_t version;
  std::vector<std::string>  data;

  _FileMetadata__isset __isset;

  void __set_type(const int8_t val);

  void __set_version(const int8_t val);

  void __set_data(const std::vector<std::string> & val);

  bool operator == (const FileMetadata & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const FileMetadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileMetadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FileMetadata &a, FileMetadata &b);

std::ostream& operator<<(std::ostream& out, const FileMetadata& obj);


class ObjectDictionary : public virtual ::apache::thrift::TBase {
 public:

  ObjectDictionary(const ObjectDictionary&);
  ObjectDictionary& operator=(const ObjectDictionary&);
  ObjectDictionary() noexcept {
  }

  virtual ~ObjectDictionary() noexcept;
  std::map<std::string, std::vector<std::string> >  values;

  void __set_values(const std::map<std::string, std::vector<std::string> > & val);

  bool operator == (const ObjectDictionary & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    return true;
  }
  bool operator != (const ObjectDictionary &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ObjectDictionary & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ObjectDictionary &a, ObjectDictionary &b);

std::ostream& operator<<(std::ostream& out, const ObjectDictionary& obj);

typedef struct _Table__isset {
  _Table__isset() : tableName(false), dbName(false), owner(false), createTime(false), lastAccessTime(false), retention(false), sd(false), partitionKeys(false), parameters(false), viewOriginalText(false), viewExpandedText(false), tableType(false), privileges(false), temporary(true), rewriteEnabled(false), creationMetadata(false), catName(false), ownerType(true), writeId(true), isStatsCompliant(false), colStats(false), accessType(false), requiredReadCapabilities(false), requiredWriteCapabilities(false), id(false), fileMetadata(false), dictionary(false), txnId(false) {}
  bool tableName :1;
  bool dbName :1;
  bool owner :1;
  bool createTime :1;
  bool lastAccessTime :1;
  bool retention :1;
  bool sd :1;
  bool partitionKeys :1;
  bool parameters :1;
  bool viewOriginalText :1;
  bool viewExpandedText :1;
  bool tableType :1;
  bool privileges :1;
  bool temporary :1;
  bool rewriteEnabled :1;
  bool creationMetadata :1;
  bool catName :1;
  bool ownerType :1;
  bool writeId :1;
  bool isStatsCompliant :1;
  bool colStats :1;
  bool accessType :1;
  bool requiredReadCapabilities :1;
  bool requiredWriteCapabilities :1;
  bool id :1;
  bool fileMetadata :1;
  bool dictionary :1;
  bool txnId :1;
} _Table__isset;

class Table : public virtual ::apache::thrift::TBase {
 public:

  Table(const Table&);
  Table& operator=(const Table&);
  Table() noexcept
        : tableName(),
          dbName(),
          owner(),
          createTime(0),
          lastAccessTime(0),
          retention(0),
          viewOriginalText(),
          viewExpandedText(),
          tableType(),
          temporary(false),
          rewriteEnabled(0),
          catName(),
          ownerType((PrincipalType::type)1),
          writeId(-1LL),
          isStatsCompliant(0),
          accessType(0),
          id(0),
          txnId(0) {
    ownerType = (PrincipalType::type)1;

  }

  virtual ~Table() noexcept;
  std::string tableName;
  std::string dbName;
  std::string owner;
  int32_t createTime;
  int32_t lastAccessTime;
  int32_t retention;
  StorageDescriptor sd;
  std::vector<FieldSchema>  partitionKeys;
  std::map<std::string, std::string>  parameters;
  std::string viewOriginalText;
  std::string viewExpandedText;
  std::string tableType;
  PrincipalPrivilegeSet privileges;
  bool temporary;
  bool rewriteEnabled;
  CreationMetadata creationMetadata;
  std::string catName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type ownerType;
  int64_t writeId;
  bool isStatsCompliant;
  ColumnStatistics colStats;
  int8_t accessType;
  std::vector<std::string>  requiredReadCapabilities;
  std::vector<std::string>  requiredWriteCapabilities;
  int64_t id;
  FileMetadata fileMetadata;
  ObjectDictionary dictionary;
  int64_t txnId;

  _Table__isset __isset;

  void __set_tableName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_owner(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_lastAccessTime(const int32_t val);

  void __set_retention(const int32_t val);

  void __set_sd(const StorageDescriptor& val);

  void __set_partitionKeys(const std::vector<FieldSchema> & val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_viewOriginalText(const std::string& val);

  void __set_viewExpandedText(const std::string& val);

  void __set_tableType(const std::string& val);

  void __set_privileges(const PrincipalPrivilegeSet& val);

  void __set_temporary(const bool val);

  void __set_rewriteEnabled(const bool val);

  void __set_creationMetadata(const CreationMetadata& val);

  void __set_catName(const std::string& val);

  void __set_ownerType(const PrincipalType::type val);

  void __set_writeId(const int64_t val);

  void __set_isStatsCompliant(const bool val);

  void __set_colStats(const ColumnStatistics& val);

  void __set_accessType(const int8_t val);

  void __set_requiredReadCapabilities(const std::vector<std::string> & val);

  void __set_requiredWriteCapabilities(const std::vector<std::string> & val);

  void __set_id(const int64_t val);

  void __set_fileMetadata(const FileMetadata& val);

  void __set_dictionary(const ObjectDictionary& val);

  void __set_txnId(const int64_t val);

  bool operator == (const Table & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(retention == rhs.retention))
      return false;
    if (!(sd == rhs.sd))
      return false;
    if (!(partitionKeys == rhs.partitionKeys))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(viewOriginalText == rhs.viewOriginalText))
      return false;
    if (!(viewExpandedText == rhs.viewExpandedText))
      return false;
    if (!(tableType == rhs.tableType))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    if (__isset.temporary != rhs.__isset.temporary)
      return false;
    else if (__isset.temporary && !(temporary == rhs.temporary))
      return false;
    if (__isset.rewriteEnabled != rhs.__isset.rewriteEnabled)
      return false;
    else if (__isset.rewriteEnabled && !(rewriteEnabled == rhs.rewriteEnabled))
      return false;
    if (__isset.creationMetadata != rhs.__isset.creationMetadata)
      return false;
    else if (__isset.creationMetadata && !(creationMetadata == rhs.creationMetadata))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.ownerType != rhs.__isset.ownerType)
      return false;
    else if (__isset.ownerType && !(ownerType == rhs.ownerType))
      return false;
    if (__isset.writeId != rhs.__isset.writeId)
      return false;
    else if (__isset.writeId && !(writeId == rhs.writeId))
      return false;
    if (__isset.isStatsCompliant != rhs.__isset.isStatsCompliant)
      return false;
    else if (__isset.isStatsCompliant && !(isStatsCompliant == rhs.isStatsCompliant))
      return false;
    if (__isset.colStats != rhs.__isset.colStats)
      return false;
    else if (__isset.colStats && !(colStats == rhs.colStats))
      return false;
    if (__isset.accessType != rhs.__isset.accessType)
      return false;
    else if (__isset.accessType && !(accessType == rhs.accessType))
      return false;
    if (__isset.requiredReadCapabilities != rhs.__isset.requiredReadCapabilities)
      return false;
    else if (__isset.requiredReadCapabilities && !(requiredReadCapabilities == rhs.requiredReadCapabilities))
      return false;
    if (__isset.requiredWriteCapabilities != rhs.__isset.requiredWriteCapabilities)
      return false;
    else if (__isset.requiredWriteCapabilities && !(requiredWriteCapabilities == rhs.requiredWriteCapabilities))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.fileMetadata != rhs.__isset.fileMetadata)
      return false;
    else if (__isset.fileMetadata && !(fileMetadata == rhs.fileMetadata))
      return false;
    if (__isset.dictionary != rhs.__isset.dictionary)
      return false;
    else if (__isset.dictionary && !(dictionary == rhs.dictionary))
      return false;
    if (__isset.txnId != rhs.__isset.txnId)
      return false;
    else if (__isset.txnId && !(txnId == rhs.txnId))
      return false;
    return true;
  }
  bool operator != (const Table &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Table & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Table &a, Table &b);

std::ostream& operator<<(std::ostream& out, const Table& obj);


class SourceTable : public virtual ::apache::thrift::TBase {
 public:

  SourceTable(const SourceTable&);
  SourceTable& operator=(const SourceTable&);
  SourceTable() noexcept
              : insertedCount(0),
                updatedCount(0),
                deletedCount(0) {
  }

  virtual ~SourceTable() noexcept;
  Table table;
  int64_t insertedCount;
  int64_t updatedCount;
  int64_t deletedCount;

  void __set_table(const Table& val);

  void __set_insertedCount(const int64_t val);

  void __set_updatedCount(const int64_t val);

  void __set_deletedCount(const int64_t val);

  bool operator == (const SourceTable & rhs) const
  {
    if (!(table == rhs.table))
      return false;
    if (!(insertedCount == rhs.insertedCount))
      return false;
    if (!(updatedCount == rhs.updatedCount))
      return false;
    if (!(deletedCount == rhs.deletedCount))
      return false;
    return true;
  }
  bool operator != (const SourceTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SourceTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SourceTable &a, SourceTable &b);

std::ostream& operator<<(std::ostream& out, const SourceTable& obj);

typedef struct _Partition__isset {
  _Partition__isset() : values(false), dbName(false), tableName(false), createTime(false), lastAccessTime(false), sd(false), parameters(false), privileges(false), catName(false), writeId(true), isStatsCompliant(false), colStats(false), fileMetadata(false) {}
  bool values :1;
  bool dbName :1;
  bool tableName :1;
  bool createTime :1;
  bool lastAccessTime :1;
  bool sd :1;
  bool parameters :1;
  bool privileges :1;
  bool catName :1;
  bool writeId :1;
  bool isStatsCompliant :1;
  bool colStats :1;
  bool fileMetadata :1;
} _Partition__isset;

class Partition : public virtual ::apache::thrift::TBase {
 public:

  Partition(const Partition&);
  Partition& operator=(const Partition&);
  Partition() noexcept
            : dbName(),
              tableName(),
              createTime(0),
              lastAccessTime(0),
              catName(),
              writeId(-1LL),
              isStatsCompliant(0) {
  }

  virtual ~Partition() noexcept;
  std::vector<std::string>  values;
  std::string dbName;
  std::string tableName;
  int32_t createTime;
  int32_t lastAccessTime;
  StorageDescriptor sd;
  std::map<std::string, std::string>  parameters;
  PrincipalPrivilegeSet privileges;
  std::string catName;
  int64_t writeId;
  bool isStatsCompliant;
  ColumnStatistics colStats;
  FileMetadata fileMetadata;

  _Partition__isset __isset;

  void __set_values(const std::vector<std::string> & val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_lastAccessTime(const int32_t val);

  void __set_sd(const StorageDescriptor& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_privileges(const PrincipalPrivilegeSet& val);

  void __set_catName(const std::string& val);

  void __set_writeId(const int64_t val);

  void __set_isStatsCompliant(const bool val);

  void __set_colStats(const ColumnStatistics& val);

  void __set_fileMetadata(const FileMetadata& val);

  bool operator == (const Partition & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(sd == rhs.sd))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.writeId != rhs.__isset.writeId)
      return false;
    else if (__isset.writeId && !(writeId == rhs.writeId))
      return false;
    if (__isset.isStatsCompliant != rhs.__isset.isStatsCompliant)
      return false;
    else if (__isset.isStatsCompliant && !(isStatsCompliant == rhs.isStatsCompliant))
      return false;
    if (__isset.colStats != rhs.__isset.colStats)
      return false;
    else if (__isset.colStats && !(colStats == rhs.colStats))
      return false;
    if (__isset.fileMetadata != rhs.__isset.fileMetadata)
      return false;
    else if (__isset.fileMetadata && !(fileMetadata == rhs.fileMetadata))
      return false;
    return true;
  }
  bool operator != (const Partition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Partition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Partition &a, Partition &b);

std::ostream& operator<<(std::ostream& out, const Partition& obj);

typedef struct _PartitionWithoutSD__isset {
  _PartitionWithoutSD__isset() : values(false), createTime(false), lastAccessTime(false), relativePath(false), parameters(false), privileges(false) {}
  bool values :1;
  bool createTime :1;
  bool lastAccessTime :1;
  bool relativePath :1;
  bool parameters :1;
  bool privileges :1;
} _PartitionWithoutSD__isset;

class PartitionWithoutSD : public virtual ::apache::thrift::TBase {
 public:

  PartitionWithoutSD(const PartitionWithoutSD&);
  PartitionWithoutSD& operator=(const PartitionWithoutSD&);
  PartitionWithoutSD() noexcept
                     : createTime(0),
                       lastAccessTime(0),
                       relativePath() {
  }

  virtual ~PartitionWithoutSD() noexcept;
  std::vector<std::string>  values;
  int32_t createTime;
  int32_t lastAccessTime;
  std::string relativePath;
  std::map<std::string, std::string>  parameters;
  PrincipalPrivilegeSet privileges;

  _PartitionWithoutSD__isset __isset;

  void __set_values(const std::vector<std::string> & val);

  void __set_createTime(const int32_t val);

  void __set_lastAccessTime(const int32_t val);

  void __set_relativePath(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_privileges(const PrincipalPrivilegeSet& val);

  bool operator == (const PartitionWithoutSD & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(relativePath == rhs.relativePath))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    return true;
  }
  bool operator != (const PartitionWithoutSD &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionWithoutSD & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionWithoutSD &a, PartitionWithoutSD &b);

std::ostream& operator<<(std::ostream& out, const PartitionWithoutSD& obj);

typedef struct _PartitionSpecWithSharedSD__isset {
  _PartitionSpecWithSharedSD__isset() : partitions(false), sd(false) {}
  bool partitions :1;
  bool sd :1;
} _PartitionSpecWithSharedSD__isset;

class PartitionSpecWithSharedSD : public virtual ::apache::thrift::TBase {
 public:

  PartitionSpecWithSharedSD(const PartitionSpecWithSharedSD&);
  PartitionSpecWithSharedSD& operator=(const PartitionSpecWithSharedSD&);
  PartitionSpecWithSharedSD() noexcept {
  }

  virtual ~PartitionSpecWithSharedSD() noexcept;
  std::vector<PartitionWithoutSD>  partitions;
  StorageDescriptor sd;

  _PartitionSpecWithSharedSD__isset __isset;

  void __set_partitions(const std::vector<PartitionWithoutSD> & val);

  void __set_sd(const StorageDescriptor& val);

  bool operator == (const PartitionSpecWithSharedSD & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    if (!(sd == rhs.sd))
      return false;
    return true;
  }
  bool operator != (const PartitionSpecWithSharedSD &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionSpecWithSharedSD & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionSpecWithSharedSD &a, PartitionSpecWithSharedSD &b);

std::ostream& operator<<(std::ostream& out, const PartitionSpecWithSharedSD& obj);

typedef struct _PartitionListComposingSpec__isset {
  _PartitionListComposingSpec__isset() : partitions(false) {}
  bool partitions :1;
} _PartitionListComposingSpec__isset;

class PartitionListComposingSpec : public virtual ::apache::thrift::TBase {
 public:

  PartitionListComposingSpec(const PartitionListComposingSpec&);
  PartitionListComposingSpec& operator=(const PartitionListComposingSpec&);
  PartitionListComposingSpec() noexcept {
  }

  virtual ~PartitionListComposingSpec() noexcept;
  std::vector<Partition>  partitions;

  _PartitionListComposingSpec__isset __isset;

  void __set_partitions(const std::vector<Partition> & val);

  bool operator == (const PartitionListComposingSpec & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const PartitionListComposingSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionListComposingSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionListComposingSpec &a, PartitionListComposingSpec &b);

std::ostream& operator<<(std::ostream& out, const PartitionListComposingSpec& obj);

typedef struct _PartitionSpec__isset {
  _PartitionSpec__isset() : dbName(false), tableName(false), rootPath(false), sharedSDPartitionSpec(false), partitionList(false), catName(false), writeId(true), isStatsCompliant(false) {}
  bool dbName :1;
  bool tableName :1;
  bool rootPath :1;
  bool sharedSDPartitionSpec :1;
  bool partitionList :1;
  bool catName :1;
  bool writeId :1;
  bool isStatsCompliant :1;
} _PartitionSpec__isset;

class PartitionSpec : public virtual ::apache::thrift::TBase {
 public:

  PartitionSpec(const PartitionSpec&);
  PartitionSpec& operator=(const PartitionSpec&);
  PartitionSpec() noexcept
                : dbName(),
                  tableName(),
                  rootPath(),
                  catName(),
                  writeId(-1LL),
                  isStatsCompliant(0) {
  }

  virtual ~PartitionSpec() noexcept;
  std::string dbName;
  std::string tableName;
  std::string rootPath;
  PartitionSpecWithSharedSD sharedSDPartitionSpec;
  PartitionListComposingSpec partitionList;
  std::string catName;
  int64_t writeId;
  bool isStatsCompliant;

  _PartitionSpec__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_rootPath(const std::string& val);

  void __set_sharedSDPartitionSpec(const PartitionSpecWithSharedSD& val);

  void __set_partitionList(const PartitionListComposingSpec& val);

  void __set_catName(const std::string& val);

  void __set_writeId(const int64_t val);

  void __set_isStatsCompliant(const bool val);

  bool operator == (const PartitionSpec & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rootPath == rhs.rootPath))
      return false;
    if (__isset.sharedSDPartitionSpec != rhs.__isset.sharedSDPartitionSpec)
      return false;
    else if (__isset.sharedSDPartitionSpec && !(sharedSDPartitionSpec == rhs.sharedSDPartitionSpec))
      return false;
    if (__isset.partitionList != rhs.__isset.partitionList)
      return false;
    else if (__isset.partitionList && !(partitionList == rhs.partitionList))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.writeId != rhs.__isset.writeId)
      return false;
    else if (__isset.writeId && !(writeId == rhs.writeId))
      return false;
    if (__isset.isStatsCompliant != rhs.__isset.isStatsCompliant)
      return false;
    else if (__isset.isStatsCompliant && !(isStatsCompliant == rhs.isStatsCompliant))
      return false;
    return true;
  }
  bool operator != (const PartitionSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionSpec &a, PartitionSpec &b);

std::ostream& operator<<(std::ostream& out, const PartitionSpec& obj);

typedef struct _AggrStats__isset {
  _AggrStats__isset() : isStatsCompliant(false) {}
  bool isStatsCompliant :1;
} _AggrStats__isset;

class AggrStats : public virtual ::apache::thrift::TBase {
 public:

  AggrStats(const AggrStats&);
  AggrStats& operator=(const AggrStats&);
  AggrStats() noexcept
            : partsFound(0),
              isStatsCompliant(0) {
  }

  virtual ~AggrStats() noexcept;
  std::vector<ColumnStatisticsObj>  colStats;
  int64_t partsFound;
  bool isStatsCompliant;

  _AggrStats__isset __isset;

  void __set_colStats(const std::vector<ColumnStatisticsObj> & val);

  void __set_partsFound(const int64_t val);

  void __set_isStatsCompliant(const bool val);

  bool operator == (const AggrStats & rhs) const
  {
    if (!(colStats == rhs.colStats))
      return false;
    if (!(partsFound == rhs.partsFound))
      return false;
    if (__isset.isStatsCompliant != rhs.__isset.isStatsCompliant)
      return false;
    else if (__isset.isStatsCompliant && !(isStatsCompliant == rhs.isStatsCompliant))
      return false;
    return true;
  }
  bool operator != (const AggrStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AggrStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AggrStats &a, AggrStats &b);

std::ostream& operator<<(std::ostream& out, const AggrStats& obj);

typedef struct _SetPartitionsStatsRequest__isset {
  _SetPartitionsStatsRequest__isset() : needMerge(false), writeId(true), validWriteIdList(false), engine(true) {}
  bool needMerge :1;
  bool writeId :1;
  bool validWriteIdList :1;
  bool engine :1;
} _SetPartitionsStatsRequest__isset;

class SetPartitionsStatsRequest : public virtual ::apache::thrift::TBase {
 public:

  SetPartitionsStatsRequest(const SetPartitionsStatsRequest&);
  SetPartitionsStatsRequest& operator=(const SetPartitionsStatsRequest&);
  SetPartitionsStatsRequest() : needMerge(0),
                                writeId(-1LL),
                                validWriteIdList(),
                                engine("hive") {
  }

  virtual ~SetPartitionsStatsRequest() noexcept;
  std::vector<ColumnStatistics>  colStats;
  bool needMerge;
  int64_t writeId;
  std::string validWriteIdList;
  std::string engine;

  _SetPartitionsStatsRequest__isset __isset;

  void __set_colStats(const std::vector<ColumnStatistics> & val);

  void __set_needMerge(const bool val);

  void __set_writeId(const int64_t val);

  void __set_validWriteIdList(const std::string& val);

  void __set_engine(const std::string& val);

  bool operator == (const SetPartitionsStatsRequest & rhs) const
  {
    if (!(colStats == rhs.colStats))
      return false;
    if (__isset.needMerge != rhs.__isset.needMerge)
      return false;
    else if (__isset.needMerge && !(needMerge == rhs.needMerge))
      return false;
    if (__isset.writeId != rhs.__isset.writeId)
      return false;
    else if (__isset.writeId && !(writeId == rhs.writeId))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.engine != rhs.__isset.engine)
      return false;
    else if (__isset.engine && !(engine == rhs.engine))
      return false;
    return true;
  }
  bool operator != (const SetPartitionsStatsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetPartitionsStatsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SetPartitionsStatsRequest &a, SetPartitionsStatsRequest &b);

std::ostream& operator<<(std::ostream& out, const SetPartitionsStatsRequest& obj);


class SetPartitionsStatsResponse : public virtual ::apache::thrift::TBase {
 public:

  SetPartitionsStatsResponse(const SetPartitionsStatsResponse&) noexcept;
  SetPartitionsStatsResponse& operator=(const SetPartitionsStatsResponse&) noexcept;
  SetPartitionsStatsResponse() noexcept
                             : result(0) {
  }

  virtual ~SetPartitionsStatsResponse() noexcept;
  bool result;

  void __set_result(const bool val);

  bool operator == (const SetPartitionsStatsResponse & rhs) const
  {
    if (!(result == rhs.result))
      return false;
    return true;
  }
  bool operator != (const SetPartitionsStatsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetPartitionsStatsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SetPartitionsStatsResponse &a, SetPartitionsStatsResponse &b);

std::ostream& operator<<(std::ostream& out, const SetPartitionsStatsResponse& obj);

typedef struct _Schema__isset {
  _Schema__isset() : fieldSchemas(false), properties(false) {}
  bool fieldSchemas :1;
  bool properties :1;
} _Schema__isset;

class Schema : public virtual ::apache::thrift::TBase {
 public:

  Schema(const Schema&);
  Schema& operator=(const Schema&);
  Schema() noexcept {
  }

  virtual ~Schema() noexcept;
  std::vector<FieldSchema>  fieldSchemas;
  std::map<std::string, std::string>  properties;

  _Schema__isset __isset;

  void __set_fieldSchemas(const std::vector<FieldSchema> & val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const Schema & rhs) const
  {
    if (!(fieldSchemas == rhs.fieldSchemas))
      return false;
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const Schema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Schema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Schema &a, Schema &b);

std::ostream& operator<<(std::ostream& out, const Schema& obj);

typedef struct _PrimaryKeysRequest__isset {
  _PrimaryKeysRequest__isset() : catName(false), validWriteIdList(false), tableId(true) {}
  bool catName :1;
  bool validWriteIdList :1;
  bool tableId :1;
} _PrimaryKeysRequest__isset;

class PrimaryKeysRequest : public virtual ::apache::thrift::TBase {
 public:

  PrimaryKeysRequest(const PrimaryKeysRequest&);
  PrimaryKeysRequest& operator=(const PrimaryKeysRequest&);
  PrimaryKeysRequest() noexcept
                     : db_name(),
                       tbl_name(),
                       catName(),
                       validWriteIdList(),
                       tableId(-1LL) {
  }

  virtual ~PrimaryKeysRequest() noexcept;
  std::string db_name;
  std::string tbl_name;
  std::string catName;
  std::string validWriteIdList;
  int64_t tableId;

  _PrimaryKeysRequest__isset __isset;

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  void __set_catName(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_tableId(const int64_t val);

  bool operator == (const PrimaryKeysRequest & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    return true;
  }
  bool operator != (const PrimaryKeysRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrimaryKeysRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrimaryKeysRequest &a, PrimaryKeysRequest &b);

std::ostream& operator<<(std::ostream& out, const PrimaryKeysRequest& obj);


class PrimaryKeysResponse : public virtual ::apache::thrift::TBase {
 public:

  PrimaryKeysResponse(const PrimaryKeysResponse&);
  PrimaryKeysResponse& operator=(const PrimaryKeysResponse&);
  PrimaryKeysResponse() noexcept {
  }

  virtual ~PrimaryKeysResponse() noexcept;
  std::vector<SQLPrimaryKey>  primaryKeys;

  void __set_primaryKeys(const std::vector<SQLPrimaryKey> & val);

  bool operator == (const PrimaryKeysResponse & rhs) const
  {
    if (!(primaryKeys == rhs.primaryKeys))
      return false;
    return true;
  }
  bool operator != (const PrimaryKeysResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrimaryKeysResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PrimaryKeysResponse &a, PrimaryKeysResponse &b);

std::ostream& operator<<(std::ostream& out, const PrimaryKeysResponse& obj);

typedef struct _ForeignKeysRequest__isset {
  _ForeignKeysRequest__isset() : parent_db_name(false), parent_tbl_name(false), foreign_db_name(false), foreign_tbl_name(false), catName(false), validWriteIdList(false), tableId(true) {}
  bool parent_db_name :1;
  bool parent_tbl_name :1;
  bool foreign_db_name :1;
  bool foreign_tbl_name :1;
  bool catName :1;
  bool validWriteIdList :1;
  bool tableId :1;
} _ForeignKeysRequest__isset;

class ForeignKeysRequest : public virtual ::apache::thrift::TBase {
 public:

  ForeignKeysRequest(const ForeignKeysRequest&);
  ForeignKeysRequest& operator=(const ForeignKeysRequest&);
  ForeignKeysRequest() noexcept
                     : parent_db_name(),
                       parent_tbl_name(),
                       foreign_db_name(),
                       foreign_tbl_name(),
                       catName(),
                       validWriteIdList(),
                       tableId(-1LL) {
  }

  virtual ~ForeignKeysRequest() noexcept;
  std::string parent_db_name;
  std::string parent_tbl_name;
  std::string foreign_db_name;
  std::string foreign_tbl_name;
  std::string catName;
  std::string validWriteIdList;
  int64_t tableId;

  _ForeignKeysRequest__isset __isset;

  void __set_parent_db_name(const std::string& val);

  void __set_parent_tbl_name(const std::string& val);

  void __set_foreign_db_name(const std::string& val);

  void __set_foreign_tbl_name(const std::string& val);

  void __set_catName(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_tableId(const int64_t val);

  bool operator == (const ForeignKeysRequest & rhs) const
  {
    if (!(parent_db_name == rhs.parent_db_name))
      return false;
    if (!(parent_tbl_name == rhs.parent_tbl_name))
      return false;
    if (!(foreign_db_name == rhs.foreign_db_name))
      return false;
    if (!(foreign_tbl_name == rhs.foreign_tbl_name))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    return true;
  }
  bool operator != (const ForeignKeysRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ForeignKeysRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ForeignKeysRequest &a, ForeignKeysRequest &b);

std::ostream& operator<<(std::ostream& out, const ForeignKeysRequest& obj);


class ForeignKeysResponse : public virtual ::apache::thrift::TBase {
 public:

  ForeignKeysResponse(const ForeignKeysResponse&);
  ForeignKeysResponse& operator=(const ForeignKeysResponse&);
  ForeignKeysResponse() noexcept {
  }

  virtual ~ForeignKeysResponse() noexcept;
  std::vector<SQLForeignKey>  foreignKeys;

  void __set_foreignKeys(const std::vector<SQLForeignKey> & val);

  bool operator == (const ForeignKeysResponse & rhs) const
  {
    if (!(foreignKeys == rhs.foreignKeys))
      return false;
    return true;
  }
  bool operator != (const ForeignKeysResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ForeignKeysResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ForeignKeysResponse &a, ForeignKeysResponse &b);

std::ostream& operator<<(std::ostream& out, const ForeignKeysResponse& obj);

typedef struct _UniqueConstraintsRequest__isset {
  _UniqueConstraintsRequest__isset() : validWriteIdList(false), tableId(true) {}
  bool validWriteIdList :1;
  bool tableId :1;
} _UniqueConstraintsRequest__isset;

class UniqueConstraintsRequest : public virtual ::apache::thrift::TBase {
 public:

  UniqueConstraintsRequest(const UniqueConstraintsRequest&);
  UniqueConstraintsRequest& operator=(const UniqueConstraintsRequest&);
  UniqueConstraintsRequest() noexcept
                           : catName(),
                             db_name(),
                             tbl_name(),
                             validWriteIdList(),
                             tableId(-1LL) {
  }

  virtual ~UniqueConstraintsRequest() noexcept;
  std::string catName;
  std::string db_name;
  std::string tbl_name;
  std::string validWriteIdList;
  int64_t tableId;

  _UniqueConstraintsRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_tableId(const int64_t val);

  bool operator == (const UniqueConstraintsRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    return true;
  }
  bool operator != (const UniqueConstraintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UniqueConstraintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UniqueConstraintsRequest &a, UniqueConstraintsRequest &b);

std::ostream& operator<<(std::ostream& out, const UniqueConstraintsRequest& obj);


class UniqueConstraintsResponse : public virtual ::apache::thrift::TBase {
 public:

  UniqueConstraintsResponse(const UniqueConstraintsResponse&);
  UniqueConstraintsResponse& operator=(const UniqueConstraintsResponse&);
  UniqueConstraintsResponse() noexcept {
  }

  virtual ~UniqueConstraintsResponse() noexcept;
  std::vector<SQLUniqueConstraint>  uniqueConstraints;

  void __set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val);

  bool operator == (const UniqueConstraintsResponse & rhs) const
  {
    if (!(uniqueConstraints == rhs.uniqueConstraints))
      return false;
    return true;
  }
  bool operator != (const UniqueConstraintsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UniqueConstraintsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UniqueConstraintsResponse &a, UniqueConstraintsResponse &b);

std::ostream& operator<<(std::ostream& out, const UniqueConstraintsResponse& obj);

typedef struct _NotNullConstraintsRequest__isset {
  _NotNullConstraintsRequest__isset() : validWriteIdList(false), tableId(true) {}
  bool validWriteIdList :1;
  bool tableId :1;
} _NotNullConstraintsRequest__isset;

class NotNullConstraintsRequest : public virtual ::apache::thrift::TBase {
 public:

  NotNullConstraintsRequest(const NotNullConstraintsRequest&);
  NotNullConstraintsRequest& operator=(const NotNullConstraintsRequest&);
  NotNullConstraintsRequest() noexcept
                            : catName(),
                              db_name(),
                              tbl_name(),
                              validWriteIdList(),
                              tableId(-1LL) {
  }

  virtual ~NotNullConstraintsRequest() noexcept;
  std::string catName;
  std::string db_name;
  std::string tbl_name;
  std::string validWriteIdList;
  int64_t tableId;

  _NotNullConstraintsRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_tableId(const int64_t val);

  bool operator == (const NotNullConstraintsRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    return true;
  }
  bool operator != (const NotNullConstraintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotNullConstraintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotNullConstraintsRequest &a, NotNullConstraintsRequest &b);

std::ostream& operator<<(std::ostream& out, const NotNullConstraintsRequest& obj);


class NotNullConstraintsResponse : public virtual ::apache::thrift::TBase {
 public:

  NotNullConstraintsResponse(const NotNullConstraintsResponse&);
  NotNullConstraintsResponse& operator=(const NotNullConstraintsResponse&);
  NotNullConstraintsResponse() noexcept {
  }

  virtual ~NotNullConstraintsResponse() noexcept;
  std::vector<SQLNotNullConstraint>  notNullConstraints;

  void __set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val);

  bool operator == (const NotNullConstraintsResponse & rhs) const
  {
    if (!(notNullConstraints == rhs.notNullConstraints))
      return false;
    return true;
  }
  bool operator != (const NotNullConstraintsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotNullConstraintsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotNullConstraintsResponse &a, NotNullConstraintsResponse &b);

std::ostream& operator<<(std::ostream& out, const NotNullConstraintsResponse& obj);

typedef struct _DefaultConstraintsRequest__isset {
  _DefaultConstraintsRequest__isset() : validWriteIdList(false), tableId(true) {}
  bool validWriteIdList :1;
  bool tableId :1;
} _DefaultConstraintsRequest__isset;

class DefaultConstraintsRequest : public virtual ::apache::thrift::TBase {
 public:

  DefaultConstraintsRequest(const DefaultConstraintsRequest&);
  DefaultConstraintsRequest& operator=(const DefaultConstraintsRequest&);
  DefaultConstraintsRequest() noexcept
                            : catName(),
                              db_name(),
                              tbl_name(),
                              validWriteIdList(),
                              tableId(-1LL) {
  }

  virtual ~DefaultConstraintsRequest() noexcept;
  std::string catName;
  std::string db_name;
  std::string tbl_name;
  std::string validWriteIdList;
  int64_t tableId;

  _DefaultConstraintsRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_tableId(const int64_t val);

  bool operator == (const DefaultConstraintsRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    return true;
  }
  bool operator != (const DefaultConstraintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DefaultConstraintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DefaultConstraintsRequest &a, DefaultConstraintsRequest &b);

std::ostream& operator<<(std::ostream& out, const DefaultConstraintsRequest& obj);


class DefaultConstraintsResponse : public virtual ::apache::thrift::TBase {
 public:

  DefaultConstraintsResponse(const DefaultConstraintsResponse&);
  DefaultConstraintsResponse& operator=(const DefaultConstraintsResponse&);
  DefaultConstraintsResponse() noexcept {
  }

  virtual ~DefaultConstraintsResponse() noexcept;
  std::vector<SQLDefaultConstraint>  defaultConstraints;

  void __set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val);

  bool operator == (const DefaultConstraintsResponse & rhs) const
  {
    if (!(defaultConstraints == rhs.defaultConstraints))
      return false;
    return true;
  }
  bool operator != (const DefaultConstraintsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DefaultConstraintsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DefaultConstraintsResponse &a, DefaultConstraintsResponse &b);

std::ostream& operator<<(std::ostream& out, const DefaultConstraintsResponse& obj);

typedef struct _CheckConstraintsRequest__isset {
  _CheckConstraintsRequest__isset() : validWriteIdList(false), tableId(true) {}
  bool validWriteIdList :1;
  bool tableId :1;
} _CheckConstraintsRequest__isset;

class CheckConstraintsRequest : public virtual ::apache::thrift::TBase {
 public:

  CheckConstraintsRequest(const CheckConstraintsRequest&);
  CheckConstraintsRequest& operator=(const CheckConstraintsRequest&);
  CheckConstraintsRequest() noexcept
                          : catName(),
                            db_name(),
                            tbl_name(),
                            validWriteIdList(),
                            tableId(-1LL) {
  }

  virtual ~CheckConstraintsRequest() noexcept;
  std::string catName;
  std::string db_name;
  std::string tbl_name;
  std::string validWriteIdList;
  int64_t tableId;

  _CheckConstraintsRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_tableId(const int64_t val);

  bool operator == (const CheckConstraintsRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    return true;
  }
  bool operator != (const CheckConstraintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CheckConstraintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CheckConstraintsRequest &a, CheckConstraintsRequest &b);

std::ostream& operator<<(std::ostream& out, const CheckConstraintsRequest& obj);


class CheckConstraintsResponse : public virtual ::apache::thrift::TBase {
 public:

  CheckConstraintsResponse(const CheckConstraintsResponse&);
  CheckConstraintsResponse& operator=(const CheckConstraintsResponse&);
  CheckConstraintsResponse() noexcept {
  }

  virtual ~CheckConstraintsResponse() noexcept;
  std::vector<SQLCheckConstraint>  checkConstraints;

  void __set_checkConstraints(const std::vector<SQLCheckConstraint> & val);

  bool operator == (const CheckConstraintsResponse & rhs) const
  {
    if (!(checkConstraints == rhs.checkConstraints))
      return false;
    return true;
  }
  bool operator != (const CheckConstraintsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CheckConstraintsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CheckConstraintsResponse &a, CheckConstraintsResponse &b);

std::ostream& operator<<(std::ostream& out, const CheckConstraintsResponse& obj);

typedef struct _AllTableConstraintsRequest__isset {
  _AllTableConstraintsRequest__isset() : validWriteIdList(false), tableId(true) {}
  bool validWriteIdList :1;
  bool tableId :1;
} _AllTableConstraintsRequest__isset;

class AllTableConstraintsRequest : public virtual ::apache::thrift::TBase {
 public:

  AllTableConstraintsRequest(const AllTableConstraintsRequest&);
  AllTableConstraintsRequest& operator=(const AllTableConstraintsRequest&);
  AllTableConstraintsRequest() noexcept
                             : dbName(),
                               tblName(),
                               catName(),
                               validWriteIdList(),
                               tableId(-1LL) {
  }

  virtual ~AllTableConstraintsRequest() noexcept;
  std::string dbName;
  std::string tblName;
  std::string catName;
  std::string validWriteIdList;
  int64_t tableId;

  _AllTableConstraintsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_catName(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_tableId(const int64_t val);

  bool operator == (const AllTableConstraintsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(catName == rhs.catName))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    return true;
  }
  bool operator != (const AllTableConstraintsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AllTableConstraintsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AllTableConstraintsRequest &a, AllTableConstraintsRequest &b);

std::ostream& operator<<(std::ostream& out, const AllTableConstraintsRequest& obj);


class AllTableConstraintsResponse : public virtual ::apache::thrift::TBase {
 public:

  AllTableConstraintsResponse(const AllTableConstraintsResponse&);
  AllTableConstraintsResponse& operator=(const AllTableConstraintsResponse&);
  AllTableConstraintsResponse() noexcept {
  }

  virtual ~AllTableConstraintsResponse() noexcept;
  SQLAllTableConstraints allTableConstraints;

  void __set_allTableConstraints(const SQLAllTableConstraints& val);

  bool operator == (const AllTableConstraintsResponse & rhs) const
  {
    if (!(allTableConstraints == rhs.allTableConstraints))
      return false;
    return true;
  }
  bool operator != (const AllTableConstraintsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AllTableConstraintsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AllTableConstraintsResponse &a, AllTableConstraintsResponse &b);

std::ostream& operator<<(std::ostream& out, const AllTableConstraintsResponse& obj);

typedef struct _DropConstraintRequest__isset {
  _DropConstraintRequest__isset() : catName(false) {}
  bool catName :1;
} _DropConstraintRequest__isset;

class DropConstraintRequest : public virtual ::apache::thrift::TBase {
 public:

  DropConstraintRequest(const DropConstraintRequest&);
  DropConstraintRequest& operator=(const DropConstraintRequest&);
  DropConstraintRequest() noexcept
                        : dbname(),
                          tablename(),
                          constraintname(),
                          catName() {
  }

  virtual ~DropConstraintRequest() noexcept;
  std::string dbname;
  std::string tablename;
  std::string constraintname;
  std::string catName;

  _DropConstraintRequest__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_constraintname(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const DropConstraintRequest & rhs) const
  {
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (!(constraintname == rhs.constraintname))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const DropConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropConstraintRequest &a, DropConstraintRequest &b);

std::ostream& operator<<(std::ostream& out, const DropConstraintRequest& obj);


class AddPrimaryKeyRequest : public virtual ::apache::thrift::TBase {
 public:

  AddPrimaryKeyRequest(const AddPrimaryKeyRequest&);
  AddPrimaryKeyRequest& operator=(const AddPrimaryKeyRequest&);
  AddPrimaryKeyRequest() noexcept {
  }

  virtual ~AddPrimaryKeyRequest() noexcept;
  std::vector<SQLPrimaryKey>  primaryKeyCols;

  void __set_primaryKeyCols(const std::vector<SQLPrimaryKey> & val);

  bool operator == (const AddPrimaryKeyRequest & rhs) const
  {
    if (!(primaryKeyCols == rhs.primaryKeyCols))
      return false;
    return true;
  }
  bool operator != (const AddPrimaryKeyRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddPrimaryKeyRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddPrimaryKeyRequest &a, AddPrimaryKeyRequest &b);

std::ostream& operator<<(std::ostream& out, const AddPrimaryKeyRequest& obj);


class AddForeignKeyRequest : public virtual ::apache::thrift::TBase {
 public:

  AddForeignKeyRequest(const AddForeignKeyRequest&);
  AddForeignKeyRequest& operator=(const AddForeignKeyRequest&);
  AddForeignKeyRequest() noexcept {
  }

  virtual ~AddForeignKeyRequest() noexcept;
  std::vector<SQLForeignKey>  foreignKeyCols;

  void __set_foreignKeyCols(const std::vector<SQLForeignKey> & val);

  bool operator == (const AddForeignKeyRequest & rhs) const
  {
    if (!(foreignKeyCols == rhs.foreignKeyCols))
      return false;
    return true;
  }
  bool operator != (const AddForeignKeyRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddForeignKeyRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddForeignKeyRequest &a, AddForeignKeyRequest &b);

std::ostream& operator<<(std::ostream& out, const AddForeignKeyRequest& obj);


class AddUniqueConstraintRequest : public virtual ::apache::thrift::TBase {
 public:

  AddUniqueConstraintRequest(const AddUniqueConstraintRequest&);
  AddUniqueConstraintRequest& operator=(const AddUniqueConstraintRequest&);
  AddUniqueConstraintRequest() noexcept {
  }

  virtual ~AddUniqueConstraintRequest() noexcept;
  std::vector<SQLUniqueConstraint>  uniqueConstraintCols;

  void __set_uniqueConstraintCols(const std::vector<SQLUniqueConstraint> & val);

  bool operator == (const AddUniqueConstraintRequest & rhs) const
  {
    if (!(uniqueConstraintCols == rhs.uniqueConstraintCols))
      return false;
    return true;
  }
  bool operator != (const AddUniqueConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddUniqueConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddUniqueConstraintRequest &a, AddUniqueConstraintRequest &b);

std::ostream& operator<<(std::ostream& out, const AddUniqueConstraintRequest& obj);


class AddNotNullConstraintRequest : public virtual ::apache::thrift::TBase {
 public:

  AddNotNullConstraintRequest(const AddNotNullConstraintRequest&);
  AddNotNullConstraintRequest& operator=(const AddNotNullConstraintRequest&);
  AddNotNullConstraintRequest() noexcept {
  }

  virtual ~AddNotNullConstraintRequest() noexcept;
  std::vector<SQLNotNullConstraint>  notNullConstraintCols;

  void __set_notNullConstraintCols(const std::vector<SQLNotNullConstraint> & val);

  bool operator == (const AddNotNullConstraintRequest & rhs) const
  {
    if (!(notNullConstraintCols == rhs.notNullConstraintCols))
      return false;
    return true;
  }
  bool operator != (const AddNotNullConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddNotNullConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddNotNullConstraintRequest &a, AddNotNullConstraintRequest &b);

std::ostream& operator<<(std::ostream& out, const AddNotNullConstraintRequest& obj);


class AddDefaultConstraintRequest : public virtual ::apache::thrift::TBase {
 public:

  AddDefaultConstraintRequest(const AddDefaultConstraintRequest&);
  AddDefaultConstraintRequest& operator=(const AddDefaultConstraintRequest&);
  AddDefaultConstraintRequest() noexcept {
  }

  virtual ~AddDefaultConstraintRequest() noexcept;
  std::vector<SQLDefaultConstraint>  defaultConstraintCols;

  void __set_defaultConstraintCols(const std::vector<SQLDefaultConstraint> & val);

  bool operator == (const AddDefaultConstraintRequest & rhs) const
  {
    if (!(defaultConstraintCols == rhs.defaultConstraintCols))
      return false;
    return true;
  }
  bool operator != (const AddDefaultConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddDefaultConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddDefaultConstraintRequest &a, AddDefaultConstraintRequest &b);

std::ostream& operator<<(std::ostream& out, const AddDefaultConstraintRequest& obj);


class AddCheckConstraintRequest : public virtual ::apache::thrift::TBase {
 public:

  AddCheckConstraintRequest(const AddCheckConstraintRequest&);
  AddCheckConstraintRequest& operator=(const AddCheckConstraintRequest&);
  AddCheckConstraintRequest() noexcept {
  }

  virtual ~AddCheckConstraintRequest() noexcept;
  std::vector<SQLCheckConstraint>  checkConstraintCols;

  void __set_checkConstraintCols(const std::vector<SQLCheckConstraint> & val);

  bool operator == (const AddCheckConstraintRequest & rhs) const
  {
    if (!(checkConstraintCols == rhs.checkConstraintCols))
      return false;
    return true;
  }
  bool operator != (const AddCheckConstraintRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddCheckConstraintRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddCheckConstraintRequest &a, AddCheckConstraintRequest &b);

std::ostream& operator<<(std::ostream& out, const AddCheckConstraintRequest& obj);


class PartitionsByExprResult : public virtual ::apache::thrift::TBase {
 public:

  PartitionsByExprResult(const PartitionsByExprResult&);
  PartitionsByExprResult& operator=(const PartitionsByExprResult&);
  PartitionsByExprResult() noexcept
                         : hasUnknownPartitions(0) {
  }

  virtual ~PartitionsByExprResult() noexcept;
  std::vector<Partition>  partitions;
  bool hasUnknownPartitions;

  void __set_partitions(const std::vector<Partition> & val);

  void __set_hasUnknownPartitions(const bool val);

  bool operator == (const PartitionsByExprResult & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    if (!(hasUnknownPartitions == rhs.hasUnknownPartitions))
      return false;
    return true;
  }
  bool operator != (const PartitionsByExprResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsByExprResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsByExprResult &a, PartitionsByExprResult &b);

std::ostream& operator<<(std::ostream& out, const PartitionsByExprResult& obj);


class PartitionsSpecByExprResult : public virtual ::apache::thrift::TBase {
 public:

  PartitionsSpecByExprResult(const PartitionsSpecByExprResult&);
  PartitionsSpecByExprResult& operator=(const PartitionsSpecByExprResult&);
  PartitionsSpecByExprResult() noexcept
                             : hasUnknownPartitions(0) {
  }

  virtual ~PartitionsSpecByExprResult() noexcept;
  std::vector<PartitionSpec>  partitionsSpec;
  bool hasUnknownPartitions;

  void __set_partitionsSpec(const std::vector<PartitionSpec> & val);

  void __set_hasUnknownPartitions(const bool val);

  bool operator == (const PartitionsSpecByExprResult & rhs) const
  {
    if (!(partitionsSpec == rhs.partitionsSpec))
      return false;
    if (!(hasUnknownPartitions == rhs.hasUnknownPartitions))
      return false;
    return true;
  }
  bool operator != (const PartitionsSpecByExprResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsSpecByExprResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsSpecByExprResult &a, PartitionsSpecByExprResult &b);

std::ostream& operator<<(std::ostream& out, const PartitionsSpecByExprResult& obj);

typedef struct _PartitionsByExprRequest__isset {
  _PartitionsByExprRequest__isset() : defaultPartitionName(false), maxParts(true), catName(false), order(false), validWriteIdList(false), id(true), skipColumnSchemaForPartition(false), includeParamKeyPattern(false), excludeParamKeyPattern(false) {}
  bool defaultPartitionName :1;
  bool maxParts :1;
  bool catName :1;
  bool order :1;
  bool validWriteIdList :1;
  bool id :1;
  bool skipColumnSchemaForPartition :1;
  bool includeParamKeyPattern :1;
  bool excludeParamKeyPattern :1;
} _PartitionsByExprRequest__isset;

class PartitionsByExprRequest : public virtual ::apache::thrift::TBase {
 public:

  PartitionsByExprRequest(const PartitionsByExprRequest&);
  PartitionsByExprRequest& operator=(const PartitionsByExprRequest&);
  PartitionsByExprRequest() noexcept
                          : dbName(),
                            tblName(),
                            expr(),
                            defaultPartitionName(),
                            maxParts(-1),
                            catName(),
                            order(),
                            validWriteIdList(),
                            id(-1LL),
                            skipColumnSchemaForPartition(0),
                            includeParamKeyPattern(),
                            excludeParamKeyPattern() {
  }

  virtual ~PartitionsByExprRequest() noexcept;
  std::string dbName;
  std::string tblName;
  std::string expr;
  std::string defaultPartitionName;
  int16_t maxParts;
  std::string catName;
  std::string order;
  std::string validWriteIdList;
  int64_t id;
  bool skipColumnSchemaForPartition;
  std::string includeParamKeyPattern;
  std::string excludeParamKeyPattern;

  _PartitionsByExprRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_expr(const std::string& val);

  void __set_defaultPartitionName(const std::string& val);

  void __set_maxParts(const int16_t val);

  void __set_catName(const std::string& val);

  void __set_order(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_id(const int64_t val);

  void __set_skipColumnSchemaForPartition(const bool val);

  void __set_includeParamKeyPattern(const std::string& val);

  void __set_excludeParamKeyPattern(const std::string& val);

  bool operator == (const PartitionsByExprRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(expr == rhs.expr))
      return false;
    if (__isset.defaultPartitionName != rhs.__isset.defaultPartitionName)
      return false;
    else if (__isset.defaultPartitionName && !(defaultPartitionName == rhs.defaultPartitionName))
      return false;
    if (__isset.maxParts != rhs.__isset.maxParts)
      return false;
    else if (__isset.maxParts && !(maxParts == rhs.maxParts))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.order != rhs.__isset.order)
      return false;
    else if (__isset.order && !(order == rhs.order))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.skipColumnSchemaForPartition != rhs.__isset.skipColumnSchemaForPartition)
      return false;
    else if (__isset.skipColumnSchemaForPartition && !(skipColumnSchemaForPartition == rhs.skipColumnSchemaForPartition))
      return false;
    if (__isset.includeParamKeyPattern != rhs.__isset.includeParamKeyPattern)
      return false;
    else if (__isset.includeParamKeyPattern && !(includeParamKeyPattern == rhs.includeParamKeyPattern))
      return false;
    if (__isset.excludeParamKeyPattern != rhs.__isset.excludeParamKeyPattern)
      return false;
    else if (__isset.excludeParamKeyPattern && !(excludeParamKeyPattern == rhs.excludeParamKeyPattern))
      return false;
    return true;
  }
  bool operator != (const PartitionsByExprRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsByExprRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsByExprRequest &a, PartitionsByExprRequest &b);

std::ostream& operator<<(std::ostream& out, const PartitionsByExprRequest& obj);

typedef struct _TableStatsResult__isset {
  _TableStatsResult__isset() : isStatsCompliant(false) {}
  bool isStatsCompliant :1;
} _TableStatsResult__isset;

class TableStatsResult : public virtual ::apache::thrift::TBase {
 public:

  TableStatsResult(const TableStatsResult&);
  TableStatsResult& operator=(const TableStatsResult&);
  TableStatsResult() noexcept
                   : isStatsCompliant(0) {
  }

  virtual ~TableStatsResult() noexcept;
  std::vector<ColumnStatisticsObj>  tableStats;
  bool isStatsCompliant;

  _TableStatsResult__isset __isset;

  void __set_tableStats(const std::vector<ColumnStatisticsObj> & val);

  void __set_isStatsCompliant(const bool val);

  bool operator == (const TableStatsResult & rhs) const
  {
    if (!(tableStats == rhs.tableStats))
      return false;
    if (__isset.isStatsCompliant != rhs.__isset.isStatsCompliant)
      return false;
    else if (__isset.isStatsCompliant && !(isStatsCompliant == rhs.isStatsCompliant))
      return false;
    return true;
  }
  bool operator != (const TableStatsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableStatsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableStatsResult &a, TableStatsResult &b);

std::ostream& operator<<(std::ostream& out, const TableStatsResult& obj);

typedef struct _PartitionsStatsResult__isset {
  _PartitionsStatsResult__isset() : isStatsCompliant(false) {}
  bool isStatsCompliant :1;
} _PartitionsStatsResult__isset;

class PartitionsStatsResult : public virtual ::apache::thrift::TBase {
 public:

  PartitionsStatsResult(const PartitionsStatsResult&);
  PartitionsStatsResult& operator=(const PartitionsStatsResult&);
  PartitionsStatsResult() noexcept
                        : isStatsCompliant(0) {
  }

  virtual ~PartitionsStatsResult() noexcept;
  std::map<std::string, std::vector<ColumnStatisticsObj> >  partStats;
  bool isStatsCompliant;

  _PartitionsStatsResult__isset __isset;

  void __set_partStats(const std::map<std::string, std::vector<ColumnStatisticsObj> > & val);

  void __set_isStatsCompliant(const bool val);

  bool operator == (const PartitionsStatsResult & rhs) const
  {
    if (!(partStats == rhs.partStats))
      return false;
    if (__isset.isStatsCompliant != rhs.__isset.isStatsCompliant)
      return false;
    else if (__isset.isStatsCompliant && !(isStatsCompliant == rhs.isStatsCompliant))
      return false;
    return true;
  }
  bool operator != (const PartitionsStatsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsStatsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsStatsResult &a, PartitionsStatsResult &b);

std::ostream& operator<<(std::ostream& out, const PartitionsStatsResult& obj);

typedef struct _TableStatsRequest__isset {
  _TableStatsRequest__isset() : catName(false), validWriteIdList(false), engine(true), id(true) {}
  bool catName :1;
  bool validWriteIdList :1;
  bool engine :1;
  bool id :1;
} _TableStatsRequest__isset;

class TableStatsRequest : public virtual ::apache::thrift::TBase {
 public:

  TableStatsRequest(const TableStatsRequest&);
  TableStatsRequest& operator=(const TableStatsRequest&);
  TableStatsRequest() : dbName(),
                        tblName(),
                        catName(),
                        validWriteIdList(),
                        engine("hive"),
                        id(-1LL) {
  }

  virtual ~TableStatsRequest() noexcept;
  std::string dbName;
  std::string tblName;
  std::vector<std::string>  colNames;
  std::string catName;
  std::string validWriteIdList;
  std::string engine;
  int64_t id;

  _TableStatsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_colNames(const std::vector<std::string> & val);

  void __set_catName(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_engine(const std::string& val);

  void __set_id(const int64_t val);

  bool operator == (const TableStatsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(colNames == rhs.colNames))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.engine != rhs.__isset.engine)
      return false;
    else if (__isset.engine && !(engine == rhs.engine))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TableStatsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableStatsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableStatsRequest &a, TableStatsRequest &b);

std::ostream& operator<<(std::ostream& out, const TableStatsRequest& obj);

typedef struct _PartitionsStatsRequest__isset {
  _PartitionsStatsRequest__isset() : catName(false), validWriteIdList(false), engine(true) {}
  bool catName :1;
  bool validWriteIdList :1;
  bool engine :1;
} _PartitionsStatsRequest__isset;

class PartitionsStatsRequest : public virtual ::apache::thrift::TBase {
 public:

  PartitionsStatsRequest(const PartitionsStatsRequest&);
  PartitionsStatsRequest& operator=(const PartitionsStatsRequest&);
  PartitionsStatsRequest() : dbName(),
                             tblName(),
                             catName(),
                             validWriteIdList(),
                             engine("hive") {
  }

  virtual ~PartitionsStatsRequest() noexcept;
  std::string dbName;
  std::string tblName;
  std::vector<std::string>  colNames;
  std::vector<std::string>  partNames;
  std::string catName;
  std::string validWriteIdList;
  std::string engine;

  _PartitionsStatsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_colNames(const std::vector<std::string> & val);

  void __set_partNames(const std::vector<std::string> & val);

  void __set_catName(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_engine(const std::string& val);

  bool operator == (const PartitionsStatsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(colNames == rhs.colNames))
      return false;
    if (!(partNames == rhs.partNames))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.engine != rhs.__isset.engine)
      return false;
    else if (__isset.engine && !(engine == rhs.engine))
      return false;
    return true;
  }
  bool operator != (const PartitionsStatsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsStatsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsStatsRequest &a, PartitionsStatsRequest &b);

std::ostream& operator<<(std::ostream& out, const PartitionsStatsRequest& obj);

typedef struct _AddPartitionsResult__isset {
  _AddPartitionsResult__isset() : partitions(false), isStatsCompliant(false), partitionColSchema(false) {}
  bool partitions :1;
  bool isStatsCompliant :1;
  bool partitionColSchema :1;
} _AddPartitionsResult__isset;

class AddPartitionsResult : public virtual ::apache::thrift::TBase {
 public:

  AddPartitionsResult(const AddPartitionsResult&);
  AddPartitionsResult& operator=(const AddPartitionsResult&);
  AddPartitionsResult() noexcept
                      : isStatsCompliant(0) {
  }

  virtual ~AddPartitionsResult() noexcept;
  std::vector<Partition>  partitions;
  bool isStatsCompliant;
  std::vector<FieldSchema>  partitionColSchema;

  _AddPartitionsResult__isset __isset;

  void __set_partitions(const std::vector<Partition> & val);

  void __set_isStatsCompliant(const bool val);

  void __set_partitionColSchema(const std::vector<FieldSchema> & val);

  bool operator == (const AddPartitionsResult & rhs) const
  {
    if (__isset.partitions != rhs.__isset.partitions)
      return false;
    else if (__isset.partitions && !(partitions == rhs.partitions))
      return false;
    if (__isset.isStatsCompliant != rhs.__isset.isStatsCompliant)
      return false;
    else if (__isset.isStatsCompliant && !(isStatsCompliant == rhs.isStatsCompliant))
      return false;
    if (__isset.partitionColSchema != rhs.__isset.partitionColSchema)
      return false;
    else if (__isset.partitionColSchema && !(partitionColSchema == rhs.partitionColSchema))
      return false;
    return true;
  }
  bool operator != (const AddPartitionsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddPartitionsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddPartitionsResult &a, AddPartitionsResult &b);

std::ostream& operator<<(std::ostream& out, const AddPartitionsResult& obj);

typedef struct _AddPartitionsRequest__isset {
  _AddPartitionsRequest__isset() : needResult(true), catName(false), validWriteIdList(false), skipColumnSchemaForPartition(false), partitionColSchema(false), environmentContext(false) {}
  bool needResult :1;
  bool catName :1;
  bool validWriteIdList :1;
  bool skipColumnSchemaForPartition :1;
  bool partitionColSchema :1;
  bool environmentContext :1;
} _AddPartitionsRequest__isset;

class AddPartitionsRequest : public virtual ::apache::thrift::TBase {
 public:

  AddPartitionsRequest(const AddPartitionsRequest&);
  AddPartitionsRequest& operator=(const AddPartitionsRequest&);
  AddPartitionsRequest() noexcept
                       : dbName(),
                         tblName(),
                         ifNotExists(0),
                         needResult(true),
                         catName(),
                         validWriteIdList(),
                         skipColumnSchemaForPartition(0) {
  }

  virtual ~AddPartitionsRequest() noexcept;
  std::string dbName;
  std::string tblName;
  std::vector<Partition>  parts;
  bool ifNotExists;
  bool needResult;
  std::string catName;
  std::string validWriteIdList;
  bool skipColumnSchemaForPartition;
  std::vector<FieldSchema>  partitionColSchema;
  EnvironmentContext environmentContext;

  _AddPartitionsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_parts(const std::vector<Partition> & val);

  void __set_ifNotExists(const bool val);

  void __set_needResult(const bool val);

  void __set_catName(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_skipColumnSchemaForPartition(const bool val);

  void __set_partitionColSchema(const std::vector<FieldSchema> & val);

  void __set_environmentContext(const EnvironmentContext& val);

  bool operator == (const AddPartitionsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(parts == rhs.parts))
      return false;
    if (!(ifNotExists == rhs.ifNotExists))
      return false;
    if (__isset.needResult != rhs.__isset.needResult)
      return false;
    else if (__isset.needResult && !(needResult == rhs.needResult))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.skipColumnSchemaForPartition != rhs.__isset.skipColumnSchemaForPartition)
      return false;
    else if (__isset.skipColumnSchemaForPartition && !(skipColumnSchemaForPartition == rhs.skipColumnSchemaForPartition))
      return false;
    if (__isset.partitionColSchema != rhs.__isset.partitionColSchema)
      return false;
    else if (__isset.partitionColSchema && !(partitionColSchema == rhs.partitionColSchema))
      return false;
    if (__isset.environmentContext != rhs.__isset.environmentContext)
      return false;
    else if (__isset.environmentContext && !(environmentContext == rhs.environmentContext))
      return false;
    return true;
  }
  bool operator != (const AddPartitionsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddPartitionsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddPartitionsRequest &a, AddPartitionsRequest &b);

std::ostream& operator<<(std::ostream& out, const AddPartitionsRequest& obj);

typedef struct _DropPartitionsResult__isset {
  _DropPartitionsResult__isset() : partitions(false) {}
  bool partitions :1;
} _DropPartitionsResult__isset;

class DropPartitionsResult : public virtual ::apache::thrift::TBase {
 public:

  DropPartitionsResult(const DropPartitionsResult&);
  DropPartitionsResult& operator=(const DropPartitionsResult&);
  DropPartitionsResult() noexcept {
  }

  virtual ~DropPartitionsResult() noexcept;
  std::vector<Partition>  partitions;

  _DropPartitionsResult__isset __isset;

  void __set_partitions(const std::vector<Partition> & val);

  bool operator == (const DropPartitionsResult & rhs) const
  {
    if (__isset.partitions != rhs.__isset.partitions)
      return false;
    else if (__isset.partitions && !(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const DropPartitionsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropPartitionsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropPartitionsResult &a, DropPartitionsResult &b);

std::ostream& operator<<(std::ostream& out, const DropPartitionsResult& obj);

typedef struct _DropPartitionsExpr__isset {
  _DropPartitionsExpr__isset() : partArchiveLevel(false) {}
  bool partArchiveLevel :1;
} _DropPartitionsExpr__isset;

class DropPartitionsExpr : public virtual ::apache::thrift::TBase {
 public:

  DropPartitionsExpr(const DropPartitionsExpr&);
  DropPartitionsExpr& operator=(const DropPartitionsExpr&);
  DropPartitionsExpr() noexcept
                     : expr(),
                       partArchiveLevel(0) {
  }

  virtual ~DropPartitionsExpr() noexcept;
  std::string expr;
  int32_t partArchiveLevel;

  _DropPartitionsExpr__isset __isset;

  void __set_expr(const std::string& val);

  void __set_partArchiveLevel(const int32_t val);

  bool operator == (const DropPartitionsExpr & rhs) const
  {
    if (!(expr == rhs.expr))
      return false;
    if (__isset.partArchiveLevel != rhs.__isset.partArchiveLevel)
      return false;
    else if (__isset.partArchiveLevel && !(partArchiveLevel == rhs.partArchiveLevel))
      return false;
    return true;
  }
  bool operator != (const DropPartitionsExpr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropPartitionsExpr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropPartitionsExpr &a, DropPartitionsExpr &b);

std::ostream& operator<<(std::ostream& out, const DropPartitionsExpr& obj);

typedef struct _RequestPartsSpec__isset {
  _RequestPartsSpec__isset() : names(false), exprs(false) {}
  bool names :1;
  bool exprs :1;
} _RequestPartsSpec__isset;

class RequestPartsSpec : public virtual ::apache::thrift::TBase {
 public:

  RequestPartsSpec(const RequestPartsSpec&);
  RequestPartsSpec& operator=(const RequestPartsSpec&);
  RequestPartsSpec() noexcept {
  }

  virtual ~RequestPartsSpec() noexcept;
  std::vector<std::string>  names;
  std::vector<DropPartitionsExpr>  exprs;

  _RequestPartsSpec__isset __isset;

  void __set_names(const std::vector<std::string> & val);

  void __set_exprs(const std::vector<DropPartitionsExpr> & val);

  bool operator == (const RequestPartsSpec & rhs) const
  {
    if (__isset.names != rhs.__isset.names)
      return false;
    else if (__isset.names && !(names == rhs.names))
      return false;
    if (__isset.exprs != rhs.__isset.exprs)
      return false;
    else if (__isset.exprs && !(exprs == rhs.exprs))
      return false;
    return true;
  }
  bool operator != (const RequestPartsSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RequestPartsSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RequestPartsSpec &a, RequestPartsSpec &b);

std::ostream& operator<<(std::ostream& out, const RequestPartsSpec& obj);

typedef struct _DropPartitionsRequest__isset {
  _DropPartitionsRequest__isset() : deleteData(false), ifExists(true), ignoreProtection(false), environmentContext(false), needResult(true), catName(false), skipColumnSchemaForPartition(false) {}
  bool deleteData :1;
  bool ifExists :1;
  bool ignoreProtection :1;
  bool environmentContext :1;
  bool needResult :1;
  bool catName :1;
  bool skipColumnSchemaForPartition :1;
} _DropPartitionsRequest__isset;

class DropPartitionsRequest : public virtual ::apache::thrift::TBase {
 public:

  DropPartitionsRequest(const DropPartitionsRequest&);
  DropPartitionsRequest& operator=(const DropPartitionsRequest&);
  DropPartitionsRequest() noexcept
                        : dbName(),
                          tblName(),
                          deleteData(0),
                          ifExists(true),
                          ignoreProtection(0),
                          needResult(true),
                          catName(),
                          skipColumnSchemaForPartition(0) {
  }

  virtual ~DropPartitionsRequest() noexcept;
  std::string dbName;
  std::string tblName;
  RequestPartsSpec parts;
  bool deleteData;
  bool ifExists;
  bool ignoreProtection;
  EnvironmentContext environmentContext;
  bool needResult;
  std::string catName;
  bool skipColumnSchemaForPartition;

  _DropPartitionsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_parts(const RequestPartsSpec& val);

  void __set_deleteData(const bool val);

  void __set_ifExists(const bool val);

  void __set_ignoreProtection(const bool val);

  void __set_environmentContext(const EnvironmentContext& val);

  void __set_needResult(const bool val);

  void __set_catName(const std::string& val);

  void __set_skipColumnSchemaForPartition(const bool val);

  bool operator == (const DropPartitionsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(parts == rhs.parts))
      return false;
    if (__isset.deleteData != rhs.__isset.deleteData)
      return false;
    else if (__isset.deleteData && !(deleteData == rhs.deleteData))
      return false;
    if (__isset.ifExists != rhs.__isset.ifExists)
      return false;
    else if (__isset.ifExists && !(ifExists == rhs.ifExists))
      return false;
    if (__isset.ignoreProtection != rhs.__isset.ignoreProtection)
      return false;
    else if (__isset.ignoreProtection && !(ignoreProtection == rhs.ignoreProtection))
      return false;
    if (__isset.environmentContext != rhs.__isset.environmentContext)
      return false;
    else if (__isset.environmentContext && !(environmentContext == rhs.environmentContext))
      return false;
    if (__isset.needResult != rhs.__isset.needResult)
      return false;
    else if (__isset.needResult && !(needResult == rhs.needResult))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.skipColumnSchemaForPartition != rhs.__isset.skipColumnSchemaForPartition)
      return false;
    else if (__isset.skipColumnSchemaForPartition && !(skipColumnSchemaForPartition == rhs.skipColumnSchemaForPartition))
      return false;
    return true;
  }
  bool operator != (const DropPartitionsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropPartitionsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropPartitionsRequest &a, DropPartitionsRequest &b);

std::ostream& operator<<(std::ostream& out, const DropPartitionsRequest& obj);

typedef struct _DropPartitionRequest__isset {
  _DropPartitionRequest__isset() : catName(false), partName(false), partVals(false), deleteData(false), environmentContext(false) {}
  bool catName :1;
  bool partName :1;
  bool partVals :1;
  bool deleteData :1;
  bool environmentContext :1;
} _DropPartitionRequest__isset;

class DropPartitionRequest : public virtual ::apache::thrift::TBase {
 public:

  DropPartitionRequest(const DropPartitionRequest&);
  DropPartitionRequest& operator=(const DropPartitionRequest&);
  DropPartitionRequest() noexcept
                       : catName(),
                         dbName(),
                         tblName(),
                         partName(),
                         deleteData(0) {
  }

  virtual ~DropPartitionRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  std::string partName;
  std::vector<std::string>  partVals;
  bool deleteData;
  EnvironmentContext environmentContext;

  _DropPartitionRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_partName(const std::string& val);

  void __set_partVals(const std::vector<std::string> & val);

  void __set_deleteData(const bool val);

  void __set_environmentContext(const EnvironmentContext& val);

  bool operator == (const DropPartitionRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.partName != rhs.__isset.partName)
      return false;
    else if (__isset.partName && !(partName == rhs.partName))
      return false;
    if (__isset.partVals != rhs.__isset.partVals)
      return false;
    else if (__isset.partVals && !(partVals == rhs.partVals))
      return false;
    if (__isset.deleteData != rhs.__isset.deleteData)
      return false;
    else if (__isset.deleteData && !(deleteData == rhs.deleteData))
      return false;
    if (__isset.environmentContext != rhs.__isset.environmentContext)
      return false;
    else if (__isset.environmentContext && !(environmentContext == rhs.environmentContext))
      return false;
    return true;
  }
  bool operator != (const DropPartitionRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropPartitionRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropPartitionRequest &a, DropPartitionRequest &b);

std::ostream& operator<<(std::ostream& out, const DropPartitionRequest& obj);

typedef struct _PartitionValuesRequest__isset {
  _PartitionValuesRequest__isset() : applyDistinct(true), filter(false), partitionOrder(false), ascending(true), maxParts(true), catName(false), validWriteIdList(false) {}
  bool applyDistinct :1;
  bool filter :1;
  bool partitionOrder :1;
  bool ascending :1;
  bool maxParts :1;
  bool catName :1;
  bool validWriteIdList :1;
} _PartitionValuesRequest__isset;

class PartitionValuesRequest : public virtual ::apache::thrift::TBase {
 public:

  PartitionValuesRequest(const PartitionValuesRequest&);
  PartitionValuesRequest& operator=(const PartitionValuesRequest&);
  PartitionValuesRequest() noexcept
                         : dbName(),
                           tblName(),
                           applyDistinct(true),
                           filter(),
                           ascending(true),
                           maxParts(-1LL),
                           catName(),
                           validWriteIdList() {
  }

  virtual ~PartitionValuesRequest() noexcept;
  std::string dbName;
  std::string tblName;
  std::vector<FieldSchema>  partitionKeys;
  bool applyDistinct;
  std::string filter;
  std::vector<FieldSchema>  partitionOrder;
  bool ascending;
  int64_t maxParts;
  std::string catName;
  std::string validWriteIdList;

  _PartitionValuesRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_partitionKeys(const std::vector<FieldSchema> & val);

  void __set_applyDistinct(const bool val);

  void __set_filter(const std::string& val);

  void __set_partitionOrder(const std::vector<FieldSchema> & val);

  void __set_ascending(const bool val);

  void __set_maxParts(const int64_t val);

  void __set_catName(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  bool operator == (const PartitionValuesRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(partitionKeys == rhs.partitionKeys))
      return false;
    if (__isset.applyDistinct != rhs.__isset.applyDistinct)
      return false;
    else if (__isset.applyDistinct && !(applyDistinct == rhs.applyDistinct))
      return false;
    if (__isset.filter != rhs.__isset.filter)
      return false;
    else if (__isset.filter && !(filter == rhs.filter))
      return false;
    if (__isset.partitionOrder != rhs.__isset.partitionOrder)
      return false;
    else if (__isset.partitionOrder && !(partitionOrder == rhs.partitionOrder))
      return false;
    if (__isset.ascending != rhs.__isset.ascending)
      return false;
    else if (__isset.ascending && !(ascending == rhs.ascending))
      return false;
    if (__isset.maxParts != rhs.__isset.maxParts)
      return false;
    else if (__isset.maxParts && !(maxParts == rhs.maxParts))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    return true;
  }
  bool operator != (const PartitionValuesRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionValuesRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionValuesRequest &a, PartitionValuesRequest &b);

std::ostream& operator<<(std::ostream& out, const PartitionValuesRequest& obj);


class PartitionValuesRow : public virtual ::apache::thrift::TBase {
 public:

  PartitionValuesRow(const PartitionValuesRow&);
  PartitionValuesRow& operator=(const PartitionValuesRow&);
  PartitionValuesRow() noexcept {
  }

  virtual ~PartitionValuesRow() noexcept;
  std::vector<std::string>  row;

  void __set_row(const std::vector<std::string> & val);

  bool operator == (const PartitionValuesRow & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const PartitionValuesRow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionValuesRow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionValuesRow &a, PartitionValuesRow &b);

std::ostream& operator<<(std::ostream& out, const PartitionValuesRow& obj);


class PartitionValuesResponse : public virtual ::apache::thrift::TBase {
 public:

  PartitionValuesResponse(const PartitionValuesResponse&);
  PartitionValuesResponse& operator=(const PartitionValuesResponse&);
  PartitionValuesResponse() noexcept {
  }

  virtual ~PartitionValuesResponse() noexcept;
  std::vector<PartitionValuesRow>  partitionValues;

  void __set_partitionValues(const std::vector<PartitionValuesRow> & val);

  bool operator == (const PartitionValuesResponse & rhs) const
  {
    if (!(partitionValues == rhs.partitionValues))
      return false;
    return true;
  }
  bool operator != (const PartitionValuesResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionValuesResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionValuesResponse &a, PartitionValuesResponse &b);

std::ostream& operator<<(std::ostream& out, const PartitionValuesResponse& obj);

typedef struct _GetPartitionsByNamesRequest__isset {
  _GetPartitionsByNamesRequest__isset() : names(false), get_col_stats(false), processorCapabilities(false), processorIdentifier(false), engine(true), validWriteIdList(false), getFileMetadata(false), id(true), skipColumnSchemaForPartition(false), includeParamKeyPattern(false), excludeParamKeyPattern(false) {}
  bool names :1;
  bool get_col_stats :1;
  bool processorCapabilities :1;
  bool processorIdentifier :1;
  bool engine :1;
  bool validWriteIdList :1;
  bool getFileMetadata :1;
  bool id :1;
  bool skipColumnSchemaForPartition :1;
  bool includeParamKeyPattern :1;
  bool excludeParamKeyPattern :1;
} _GetPartitionsByNamesRequest__isset;

class GetPartitionsByNamesRequest : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionsByNamesRequest(const GetPartitionsByNamesRequest&);
  GetPartitionsByNamesRequest& operator=(const GetPartitionsByNamesRequest&);
  GetPartitionsByNamesRequest() : db_name(),
                                  tbl_name(),
                                  get_col_stats(0),
                                  processorIdentifier(),
                                  engine("hive"),
                                  validWriteIdList(),
                                  getFileMetadata(0),
                                  id(-1LL),
                                  skipColumnSchemaForPartition(0),
                                  includeParamKeyPattern(),
                                  excludeParamKeyPattern() {
  }

  virtual ~GetPartitionsByNamesRequest() noexcept;
  std::string db_name;
  std::string tbl_name;
  std::vector<std::string>  names;
  bool get_col_stats;
  std::vector<std::string>  processorCapabilities;
  std::string processorIdentifier;
  std::string engine;
  std::string validWriteIdList;
  bool getFileMetadata;
  int64_t id;
  bool skipColumnSchemaForPartition;
  std::string includeParamKeyPattern;
  std::string excludeParamKeyPattern;

  _GetPartitionsByNamesRequest__isset __isset;

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  void __set_names(const std::vector<std::string> & val);

  void __set_get_col_stats(const bool val);

  void __set_processorCapabilities(const std::vector<std::string> & val);

  void __set_processorIdentifier(const std::string& val);

  void __set_engine(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_getFileMetadata(const bool val);

  void __set_id(const int64_t val);

  void __set_skipColumnSchemaForPartition(const bool val);

  void __set_includeParamKeyPattern(const std::string& val);

  void __set_excludeParamKeyPattern(const std::string& val);

  bool operator == (const GetPartitionsByNamesRequest & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (__isset.names != rhs.__isset.names)
      return false;
    else if (__isset.names && !(names == rhs.names))
      return false;
    if (__isset.get_col_stats != rhs.__isset.get_col_stats)
      return false;
    else if (__isset.get_col_stats && !(get_col_stats == rhs.get_col_stats))
      return false;
    if (__isset.processorCapabilities != rhs.__isset.processorCapabilities)
      return false;
    else if (__isset.processorCapabilities && !(processorCapabilities == rhs.processorCapabilities))
      return false;
    if (__isset.processorIdentifier != rhs.__isset.processorIdentifier)
      return false;
    else if (__isset.processorIdentifier && !(processorIdentifier == rhs.processorIdentifier))
      return false;
    if (__isset.engine != rhs.__isset.engine)
      return false;
    else if (__isset.engine && !(engine == rhs.engine))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.getFileMetadata != rhs.__isset.getFileMetadata)
      return false;
    else if (__isset.getFileMetadata && !(getFileMetadata == rhs.getFileMetadata))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.skipColumnSchemaForPartition != rhs.__isset.skipColumnSchemaForPartition)
      return false;
    else if (__isset.skipColumnSchemaForPartition && !(skipColumnSchemaForPartition == rhs.skipColumnSchemaForPartition))
      return false;
    if (__isset.includeParamKeyPattern != rhs.__isset.includeParamKeyPattern)
      return false;
    else if (__isset.includeParamKeyPattern && !(includeParamKeyPattern == rhs.includeParamKeyPattern))
      return false;
    if (__isset.excludeParamKeyPattern != rhs.__isset.excludeParamKeyPattern)
      return false;
    else if (__isset.excludeParamKeyPattern && !(excludeParamKeyPattern == rhs.excludeParamKeyPattern))
      return false;
    return true;
  }
  bool operator != (const GetPartitionsByNamesRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionsByNamesRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionsByNamesRequest &a, GetPartitionsByNamesRequest &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionsByNamesRequest& obj);

typedef struct _GetPartitionsByNamesResult__isset {
  _GetPartitionsByNamesResult__isset() : dictionary(false) {}
  bool dictionary :1;
} _GetPartitionsByNamesResult__isset;

class GetPartitionsByNamesResult : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionsByNamesResult(const GetPartitionsByNamesResult&);
  GetPartitionsByNamesResult& operator=(const GetPartitionsByNamesResult&);
  GetPartitionsByNamesResult() noexcept {
  }

  virtual ~GetPartitionsByNamesResult() noexcept;
  std::vector<Partition>  partitions;
  ObjectDictionary dictionary;

  _GetPartitionsByNamesResult__isset __isset;

  void __set_partitions(const std::vector<Partition> & val);

  void __set_dictionary(const ObjectDictionary& val);

  bool operator == (const GetPartitionsByNamesResult & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    if (__isset.dictionary != rhs.__isset.dictionary)
      return false;
    else if (__isset.dictionary && !(dictionary == rhs.dictionary))
      return false;
    return true;
  }
  bool operator != (const GetPartitionsByNamesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionsByNamesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionsByNamesResult &a, GetPartitionsByNamesResult &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionsByNamesResult& obj);

typedef struct _DataConnector__isset {
  _DataConnector__isset() : name(false), type(false), url(false), description(false), parameters(false), ownerName(false), ownerType(false), createTime(false) {}
  bool name :1;
  bool type :1;
  bool url :1;
  bool description :1;
  bool parameters :1;
  bool ownerName :1;
  bool ownerType :1;
  bool createTime :1;
} _DataConnector__isset;

class DataConnector : public virtual ::apache::thrift::TBase {
 public:

  DataConnector(const DataConnector&);
  DataConnector& operator=(const DataConnector&);
  DataConnector() noexcept
                : name(),
                  type(),
                  url(),
                  description(),
                  ownerName(),
                  ownerType(static_cast<PrincipalType::type>(0)),
                  createTime(0) {
  }

  virtual ~DataConnector() noexcept;
  std::string name;
  std::string type;
  std::string url;
  std::string description;
  std::map<std::string, std::string>  parameters;
  std::string ownerName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type ownerType;
  int32_t createTime;

  _DataConnector__isset __isset;

  void __set_name(const std::string& val);

  void __set_type(const std::string& val);

  void __set_url(const std::string& val);

  void __set_description(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_ownerName(const std::string& val);

  void __set_ownerType(const PrincipalType::type val);

  void __set_createTime(const int32_t val);

  bool operator == (const DataConnector & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(url == rhs.url))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.parameters != rhs.__isset.parameters)
      return false;
    else if (__isset.parameters && !(parameters == rhs.parameters))
      return false;
    if (__isset.ownerName != rhs.__isset.ownerName)
      return false;
    else if (__isset.ownerName && !(ownerName == rhs.ownerName))
      return false;
    if (__isset.ownerType != rhs.__isset.ownerType)
      return false;
    else if (__isset.ownerType && !(ownerType == rhs.ownerType))
      return false;
    if (__isset.createTime != rhs.__isset.createTime)
      return false;
    else if (__isset.createTime && !(createTime == rhs.createTime))
      return false;
    return true;
  }
  bool operator != (const DataConnector &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataConnector & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataConnector &a, DataConnector &b);

std::ostream& operator<<(std::ostream& out, const DataConnector& obj);

typedef struct _ResourceUri__isset {
  _ResourceUri__isset() : resourceType(false), uri(false) {}
  bool resourceType :1;
  bool uri :1;
} _ResourceUri__isset;

class ResourceUri : public virtual ::apache::thrift::TBase {
 public:

  ResourceUri(const ResourceUri&);
  ResourceUri& operator=(const ResourceUri&);
  ResourceUri() noexcept
              : resourceType(static_cast<ResourceType::type>(0)),
                uri() {
  }

  virtual ~ResourceUri() noexcept;
  /**
   *
   * @see ResourceType
   */
  ResourceType::type resourceType;
  std::string uri;

  _ResourceUri__isset __isset;

  void __set_resourceType(const ResourceType::type val);

  void __set_uri(const std::string& val);

  bool operator == (const ResourceUri & rhs) const
  {
    if (!(resourceType == rhs.resourceType))
      return false;
    if (!(uri == rhs.uri))
      return false;
    return true;
  }
  bool operator != (const ResourceUri &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResourceUri & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ResourceUri &a, ResourceUri &b);

std::ostream& operator<<(std::ostream& out, const ResourceUri& obj);

typedef struct _Function__isset {
  _Function__isset() : functionName(false), dbName(false), className(false), ownerName(false), ownerType(false), createTime(false), functionType(false), resourceUris(false), catName(false) {}
  bool functionName :1;
  bool dbName :1;
  bool className :1;
  bool ownerName :1;
  bool ownerType :1;
  bool createTime :1;
  bool functionType :1;
  bool resourceUris :1;
  bool catName :1;
} _Function__isset;

class Function : public virtual ::apache::thrift::TBase {
 public:

  Function(const Function&);
  Function& operator=(const Function&);
  Function() noexcept
           : functionName(),
             dbName(),
             className(),
             ownerName(),
             ownerType(static_cast<PrincipalType::type>(0)),
             createTime(0),
             functionType(static_cast<FunctionType::type>(0)),
             catName() {
  }

  virtual ~Function() noexcept;
  std::string functionName;
  std::string dbName;
  std::string className;
  std::string ownerName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type ownerType;
  int32_t createTime;
  /**
   *
   * @see FunctionType
   */
  FunctionType::type functionType;
  std::vector<ResourceUri>  resourceUris;
  std::string catName;

  _Function__isset __isset;

  void __set_functionName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_className(const std::string& val);

  void __set_ownerName(const std::string& val);

  void __set_ownerType(const PrincipalType::type val);

  void __set_createTime(const int32_t val);

  void __set_functionType(const FunctionType::type val);

  void __set_resourceUris(const std::vector<ResourceUri> & val);

  void __set_catName(const std::string& val);

  bool operator == (const Function & rhs) const
  {
    if (!(functionName == rhs.functionName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(className == rhs.className))
      return false;
    if (!(ownerName == rhs.ownerName))
      return false;
    if (!(ownerType == rhs.ownerType))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(functionType == rhs.functionType))
      return false;
    if (!(resourceUris == rhs.resourceUris))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const Function &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Function & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Function &a, Function &b);

std::ostream& operator<<(std::ostream& out, const Function& obj);

typedef struct _TxnInfo__isset {
  _TxnInfo__isset() : agentInfo(true), heartbeatCount(true), metaInfo(false), startedTime(false), lastHeartbeatTime(false) {}
  bool agentInfo :1;
  bool heartbeatCount :1;
  bool metaInfo :1;
  bool startedTime :1;
  bool lastHeartbeatTime :1;
} _TxnInfo__isset;

class TxnInfo : public virtual ::apache::thrift::TBase {
 public:

  TxnInfo(const TxnInfo&);
  TxnInfo& operator=(const TxnInfo&);
  TxnInfo() : id(0),
              state(static_cast<TxnState::type>(0)),
              user(),
              hostname(),
              agentInfo("Unknown"),
              heartbeatCount(0),
              metaInfo(),
              startedTime(0),
              lastHeartbeatTime(0) {
  }

  virtual ~TxnInfo() noexcept;
  int64_t id;
  /**
   *
   * @see TxnState
   */
  TxnState::type state;
  std::string user;
  std::string hostname;
  std::string agentInfo;
  int32_t heartbeatCount;
  std::string metaInfo;
  int64_t startedTime;
  int64_t lastHeartbeatTime;

  _TxnInfo__isset __isset;

  void __set_id(const int64_t val);

  void __set_state(const TxnState::type val);

  void __set_user(const std::string& val);

  void __set_hostname(const std::string& val);

  void __set_agentInfo(const std::string& val);

  void __set_heartbeatCount(const int32_t val);

  void __set_metaInfo(const std::string& val);

  void __set_startedTime(const int64_t val);

  void __set_lastHeartbeatTime(const int64_t val);

  bool operator == (const TxnInfo & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (__isset.agentInfo != rhs.__isset.agentInfo)
      return false;
    else if (__isset.agentInfo && !(agentInfo == rhs.agentInfo))
      return false;
    if (__isset.heartbeatCount != rhs.__isset.heartbeatCount)
      return false;
    else if (__isset.heartbeatCount && !(heartbeatCount == rhs.heartbeatCount))
      return false;
    if (__isset.metaInfo != rhs.__isset.metaInfo)
      return false;
    else if (__isset.metaInfo && !(metaInfo == rhs.metaInfo))
      return false;
    if (__isset.startedTime != rhs.__isset.startedTime)
      return false;
    else if (__isset.startedTime && !(startedTime == rhs.startedTime))
      return false;
    if (__isset.lastHeartbeatTime != rhs.__isset.lastHeartbeatTime)
      return false;
    else if (__isset.lastHeartbeatTime && !(lastHeartbeatTime == rhs.lastHeartbeatTime))
      return false;
    return true;
  }
  bool operator != (const TxnInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TxnInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TxnInfo &a, TxnInfo &b);

std::ostream& operator<<(std::ostream& out, const TxnInfo& obj);


class GetOpenTxnsInfoResponse : public virtual ::apache::thrift::TBase {
 public:

  GetOpenTxnsInfoResponse(const GetOpenTxnsInfoResponse&);
  GetOpenTxnsInfoResponse& operator=(const GetOpenTxnsInfoResponse&);
  GetOpenTxnsInfoResponse() noexcept
                          : txn_high_water_mark(0) {
  }

  virtual ~GetOpenTxnsInfoResponse() noexcept;
  int64_t txn_high_water_mark;
  std::vector<TxnInfo>  open_txns;

  void __set_txn_high_water_mark(const int64_t val);

  void __set_open_txns(const std::vector<TxnInfo> & val);

  bool operator == (const GetOpenTxnsInfoResponse & rhs) const
  {
    if (!(txn_high_water_mark == rhs.txn_high_water_mark))
      return false;
    if (!(open_txns == rhs.open_txns))
      return false;
    return true;
  }
  bool operator != (const GetOpenTxnsInfoResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetOpenTxnsInfoResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetOpenTxnsInfoResponse &a, GetOpenTxnsInfoResponse &b);

std::ostream& operator<<(std::ostream& out, const GetOpenTxnsInfoResponse& obj);

typedef struct _GetOpenTxnsResponse__isset {
  _GetOpenTxnsResponse__isset() : min_open_txn(false) {}
  bool min_open_txn :1;
} _GetOpenTxnsResponse__isset;

class GetOpenTxnsResponse : public virtual ::apache::thrift::TBase {
 public:

  GetOpenTxnsResponse(const GetOpenTxnsResponse&);
  GetOpenTxnsResponse& operator=(const GetOpenTxnsResponse&);
  GetOpenTxnsResponse() noexcept
                      : txn_high_water_mark(0),
                        min_open_txn(0),
                        abortedBits() {
  }

  virtual ~GetOpenTxnsResponse() noexcept;
  int64_t txn_high_water_mark;
  std::vector<int64_t>  open_txns;
  int64_t min_open_txn;
  std::string abortedBits;

  _GetOpenTxnsResponse__isset __isset;

  void __set_txn_high_water_mark(const int64_t val);

  void __set_open_txns(const std::vector<int64_t> & val);

  void __set_min_open_txn(const int64_t val);

  void __set_abortedBits(const std::string& val);

  bool operator == (const GetOpenTxnsResponse & rhs) const
  {
    if (!(txn_high_water_mark == rhs.txn_high_water_mark))
      return false;
    if (!(open_txns == rhs.open_txns))
      return false;
    if (__isset.min_open_txn != rhs.__isset.min_open_txn)
      return false;
    else if (__isset.min_open_txn && !(min_open_txn == rhs.min_open_txn))
      return false;
    if (!(abortedBits == rhs.abortedBits))
      return false;
    return true;
  }
  bool operator != (const GetOpenTxnsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetOpenTxnsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetOpenTxnsResponse &a, GetOpenTxnsResponse &b);

std::ostream& operator<<(std::ostream& out, const GetOpenTxnsResponse& obj);

typedef struct _OpenTxnRequest__isset {
  _OpenTxnRequest__isset() : agentInfo(true), replPolicy(false), replSrcTxnIds(false), txn_type(true) {}
  bool agentInfo :1;
  bool replPolicy :1;
  bool replSrcTxnIds :1;
  bool txn_type :1;
} _OpenTxnRequest__isset;

class OpenTxnRequest : public virtual ::apache::thrift::TBase {
 public:

  OpenTxnRequest(const OpenTxnRequest&);
  OpenTxnRequest& operator=(const OpenTxnRequest&);
  OpenTxnRequest() : num_txns(0),
                     user(),
                     hostname(),
                     agentInfo("Unknown"),
                     replPolicy(),
                     txn_type((TxnType::type)0) {
    txn_type = (TxnType::type)0;

  }

  virtual ~OpenTxnRequest() noexcept;
  int32_t num_txns;
  std::string user;
  std::string hostname;
  std::string agentInfo;
  std::string replPolicy;
  std::vector<int64_t>  replSrcTxnIds;
  /**
   *
   * @see TxnType
   */
  TxnType::type txn_type;

  _OpenTxnRequest__isset __isset;

  void __set_num_txns(const int32_t val);

  void __set_user(const std::string& val);

  void __set_hostname(const std::string& val);

  void __set_agentInfo(const std::string& val);

  void __set_replPolicy(const std::string& val);

  void __set_replSrcTxnIds(const std::vector<int64_t> & val);

  void __set_txn_type(const TxnType::type val);

  bool operator == (const OpenTxnRequest & rhs) const
  {
    if (!(num_txns == rhs.num_txns))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (__isset.agentInfo != rhs.__isset.agentInfo)
      return false;
    else if (__isset.agentInfo && !(agentInfo == rhs.agentInfo))
      return false;
    if (__isset.replPolicy != rhs.__isset.replPolicy)
      return false;
    else if (__isset.replPolicy && !(replPolicy == rhs.replPolicy))
      return false;
    if (__isset.replSrcTxnIds != rhs.__isset.replSrcTxnIds)
      return false;
    else if (__isset.replSrcTxnIds && !(replSrcTxnIds == rhs.replSrcTxnIds))
      return false;
    if (__isset.txn_type != rhs.__isset.txn_type)
      return false;
    else if (__isset.txn_type && !(txn_type == rhs.txn_type))
      return false;
    return true;
  }
  bool operator != (const OpenTxnRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OpenTxnRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(OpenTxnRequest &a, OpenTxnRequest &b);

std::ostream& operator<<(std::ostream& out, const OpenTxnRequest& obj);


class OpenTxnsResponse : public virtual ::apache::thrift::TBase {
 public:

  OpenTxnsResponse(const OpenTxnsResponse&);
  OpenTxnsResponse& operator=(const OpenTxnsResponse&);
  OpenTxnsResponse() noexcept {
  }

  virtual ~OpenTxnsResponse() noexcept;
  std::vector<int64_t>  txn_ids;

  void __set_txn_ids(const std::vector<int64_t> & val);

  bool operator == (const OpenTxnsResponse & rhs) const
  {
    if (!(txn_ids == rhs.txn_ids))
      return false;
    return true;
  }
  bool operator != (const OpenTxnsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OpenTxnsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(OpenTxnsResponse &a, OpenTxnsResponse &b);

std::ostream& operator<<(std::ostream& out, const OpenTxnsResponse& obj);

typedef struct _AbortTxnRequest__isset {
  _AbortTxnRequest__isset() : replPolicy(false), txn_type(false), errorCode(false) {}
  bool replPolicy :1;
  bool txn_type :1;
  bool errorCode :1;
} _AbortTxnRequest__isset;

class AbortTxnRequest : public virtual ::apache::thrift::TBase {
 public:

  AbortTxnRequest(const AbortTxnRequest&);
  AbortTxnRequest& operator=(const AbortTxnRequest&);
  AbortTxnRequest() noexcept
                  : txnid(0),
                    replPolicy(),
                    txn_type(static_cast<TxnType::type>(0)),
                    errorCode(0) {
  }

  virtual ~AbortTxnRequest() noexcept;
  int64_t txnid;
  std::string replPolicy;
  /**
   *
   * @see TxnType
   */
  TxnType::type txn_type;
  int64_t errorCode;

  _AbortTxnRequest__isset __isset;

  void __set_txnid(const int64_t val);

  void __set_replPolicy(const std::string& val);

  void __set_txn_type(const TxnType::type val);

  void __set_errorCode(const int64_t val);

  bool operator == (const AbortTxnRequest & rhs) const
  {
    if (!(txnid == rhs.txnid))
      return false;
    if (__isset.replPolicy != rhs.__isset.replPolicy)
      return false;
    else if (__isset.replPolicy && !(replPolicy == rhs.replPolicy))
      return false;
    if (__isset.txn_type != rhs.__isset.txn_type)
      return false;
    else if (__isset.txn_type && !(txn_type == rhs.txn_type))
      return false;
    if (__isset.errorCode != rhs.__isset.errorCode)
      return false;
    else if (__isset.errorCode && !(errorCode == rhs.errorCode))
      return false;
    return true;
  }
  bool operator != (const AbortTxnRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AbortTxnRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AbortTxnRequest &a, AbortTxnRequest &b);

std::ostream& operator<<(std::ostream& out, const AbortTxnRequest& obj);

typedef struct _AbortTxnsRequest__isset {
  _AbortTxnsRequest__isset() : errorCode(false) {}
  bool errorCode :1;
} _AbortTxnsRequest__isset;

class AbortTxnsRequest : public virtual ::apache::thrift::TBase {
 public:

  AbortTxnsRequest(const AbortTxnsRequest&);
  AbortTxnsRequest& operator=(const AbortTxnsRequest&);
  AbortTxnsRequest() noexcept
                   : errorCode(0) {
  }

  virtual ~AbortTxnsRequest() noexcept;
  std::vector<int64_t>  txn_ids;
  int64_t errorCode;

  _AbortTxnsRequest__isset __isset;

  void __set_txn_ids(const std::vector<int64_t> & val);

  void __set_errorCode(const int64_t val);

  bool operator == (const AbortTxnsRequest & rhs) const
  {
    if (!(txn_ids == rhs.txn_ids))
      return false;
    if (__isset.errorCode != rhs.__isset.errorCode)
      return false;
    else if (__isset.errorCode && !(errorCode == rhs.errorCode))
      return false;
    return true;
  }
  bool operator != (const AbortTxnsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AbortTxnsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AbortTxnsRequest &a, AbortTxnsRequest &b);

std::ostream& operator<<(std::ostream& out, const AbortTxnsRequest& obj);


class CommitTxnKeyValue : public virtual ::apache::thrift::TBase {
 public:

  CommitTxnKeyValue(const CommitTxnKeyValue&);
  CommitTxnKeyValue& operator=(const CommitTxnKeyValue&);
  CommitTxnKeyValue() noexcept
                    : tableId(0),
                      key(),
                      value() {
  }

  virtual ~CommitTxnKeyValue() noexcept;
  int64_t tableId;
  std::string key;
  std::string value;

  void __set_tableId(const int64_t val);

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  bool operator == (const CommitTxnKeyValue & rhs) const
  {
    if (!(tableId == rhs.tableId))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const CommitTxnKeyValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CommitTxnKeyValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CommitTxnKeyValue &a, CommitTxnKeyValue &b);

std::ostream& operator<<(std::ostream& out, const CommitTxnKeyValue& obj);

typedef struct _WriteEventInfo__isset {
  _WriteEventInfo__isset() : partition(false), tableObj(false), partitionObj(false) {}
  bool partition :1;
  bool tableObj :1;
  bool partitionObj :1;
} _WriteEventInfo__isset;

class WriteEventInfo : public virtual ::apache::thrift::TBase {
 public:

  WriteEventInfo(const WriteEventInfo&);
  WriteEventInfo& operator=(const WriteEventInfo&);
  WriteEventInfo() noexcept
                 : writeId(0),
                   database(),
                   table(),
                   files(),
                   partition(),
                   tableObj(),
                   partitionObj() {
  }

  virtual ~WriteEventInfo() noexcept;
  int64_t writeId;
  std::string database;
  std::string table;
  std::string files;
  std::string partition;
  std::string tableObj;
  std::string partitionObj;

  _WriteEventInfo__isset __isset;

  void __set_writeId(const int64_t val);

  void __set_database(const std::string& val);

  void __set_table(const std::string& val);

  void __set_files(const std::string& val);

  void __set_partition(const std::string& val);

  void __set_tableObj(const std::string& val);

  void __set_partitionObj(const std::string& val);

  bool operator == (const WriteEventInfo & rhs) const
  {
    if (!(writeId == rhs.writeId))
      return false;
    if (!(database == rhs.database))
      return false;
    if (!(table == rhs.table))
      return false;
    if (!(files == rhs.files))
      return false;
    if (__isset.partition != rhs.__isset.partition)
      return false;
    else if (__isset.partition && !(partition == rhs.partition))
      return false;
    if (__isset.tableObj != rhs.__isset.tableObj)
      return false;
    else if (__isset.tableObj && !(tableObj == rhs.tableObj))
      return false;
    if (__isset.partitionObj != rhs.__isset.partitionObj)
      return false;
    else if (__isset.partitionObj && !(partitionObj == rhs.partitionObj))
      return false;
    return true;
  }
  bool operator != (const WriteEventInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WriteEventInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WriteEventInfo &a, WriteEventInfo &b);

std::ostream& operator<<(std::ostream& out, const WriteEventInfo& obj);

typedef struct _ReplLastIdInfo__isset {
  _ReplLastIdInfo__isset() : table(false), catalog(false), partitionList(false) {}
  bool table :1;
  bool catalog :1;
  bool partitionList :1;
} _ReplLastIdInfo__isset;

class ReplLastIdInfo : public virtual ::apache::thrift::TBase {
 public:

  ReplLastIdInfo(const ReplLastIdInfo&);
  ReplLastIdInfo& operator=(const ReplLastIdInfo&);
  ReplLastIdInfo() noexcept
                 : database(),
                   lastReplId(0),
                   table(),
                   catalog() {
  }

  virtual ~ReplLastIdInfo() noexcept;
  std::string database;
  int64_t lastReplId;
  std::string table;
  std::string catalog;
  std::vector<std::string>  partitionList;

  _ReplLastIdInfo__isset __isset;

  void __set_database(const std::string& val);

  void __set_lastReplId(const int64_t val);

  void __set_table(const std::string& val);

  void __set_catalog(const std::string& val);

  void __set_partitionList(const std::vector<std::string> & val);

  bool operator == (const ReplLastIdInfo & rhs) const
  {
    if (!(database == rhs.database))
      return false;
    if (!(lastReplId == rhs.lastReplId))
      return false;
    if (__isset.table != rhs.__isset.table)
      return false;
    else if (__isset.table && !(table == rhs.table))
      return false;
    if (__isset.catalog != rhs.__isset.catalog)
      return false;
    else if (__isset.catalog && !(catalog == rhs.catalog))
      return false;
    if (__isset.partitionList != rhs.__isset.partitionList)
      return false;
    else if (__isset.partitionList && !(partitionList == rhs.partitionList))
      return false;
    return true;
  }
  bool operator != (const ReplLastIdInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplLastIdInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReplLastIdInfo &a, ReplLastIdInfo &b);

std::ostream& operator<<(std::ostream& out, const ReplLastIdInfo& obj);


class UpdateTransactionalStatsRequest : public virtual ::apache::thrift::TBase {
 public:

  UpdateTransactionalStatsRequest(const UpdateTransactionalStatsRequest&) noexcept;
  UpdateTransactionalStatsRequest& operator=(const UpdateTransactionalStatsRequest&) noexcept;
  UpdateTransactionalStatsRequest() noexcept
                                  : tableId(0),
                                    insertCount(0),
                                    updatedCount(0),
                                    deletedCount(0) {
  }

  virtual ~UpdateTransactionalStatsRequest() noexcept;
  int64_t tableId;
  int64_t insertCount;
  int64_t updatedCount;
  int64_t deletedCount;

  void __set_tableId(const int64_t val);

  void __set_insertCount(const int64_t val);

  void __set_updatedCount(const int64_t val);

  void __set_deletedCount(const int64_t val);

  bool operator == (const UpdateTransactionalStatsRequest & rhs) const
  {
    if (!(tableId == rhs.tableId))
      return false;
    if (!(insertCount == rhs.insertCount))
      return false;
    if (!(updatedCount == rhs.updatedCount))
      return false;
    if (!(deletedCount == rhs.deletedCount))
      return false;
    return true;
  }
  bool operator != (const UpdateTransactionalStatsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UpdateTransactionalStatsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UpdateTransactionalStatsRequest &a, UpdateTransactionalStatsRequest &b);

std::ostream& operator<<(std::ostream& out, const UpdateTransactionalStatsRequest& obj);

typedef struct _CommitTxnRequest__isset {
  _CommitTxnRequest__isset() : replPolicy(false), writeEventInfos(false), replLastIdInfo(false), keyValue(false), exclWriteEnabled(true), txn_type(false) {}
  bool replPolicy :1;
  bool writeEventInfos :1;
  bool replLastIdInfo :1;
  bool keyValue :1;
  bool exclWriteEnabled :1;
  bool txn_type :1;
} _CommitTxnRequest__isset;

class CommitTxnRequest : public virtual ::apache::thrift::TBase {
 public:

  CommitTxnRequest(const CommitTxnRequest&);
  CommitTxnRequest& operator=(const CommitTxnRequest&);
  CommitTxnRequest() noexcept
                   : txnid(0),
                     replPolicy(),
                     exclWriteEnabled(true),
                     txn_type(static_cast<TxnType::type>(0)) {
  }

  virtual ~CommitTxnRequest() noexcept;
  int64_t txnid;
  std::string replPolicy;
  std::vector<WriteEventInfo>  writeEventInfos;
  ReplLastIdInfo replLastIdInfo;
  CommitTxnKeyValue keyValue;
  bool exclWriteEnabled;
  /**
   *
   * @see TxnType
   */
  TxnType::type txn_type;

  _CommitTxnRequest__isset __isset;

  void __set_txnid(const int64_t val);

  void __set_replPolicy(const std::string& val);

  void __set_writeEventInfos(const std::vector<WriteEventInfo> & val);

  void __set_replLastIdInfo(const ReplLastIdInfo& val);

  void __set_keyValue(const CommitTxnKeyValue& val);

  void __set_exclWriteEnabled(const bool val);

  void __set_txn_type(const TxnType::type val);

  bool operator == (const CommitTxnRequest & rhs) const
  {
    if (!(txnid == rhs.txnid))
      return false;
    if (__isset.replPolicy != rhs.__isset.replPolicy)
      return false;
    else if (__isset.replPolicy && !(replPolicy == rhs.replPolicy))
      return false;
    if (__isset.writeEventInfos != rhs.__isset.writeEventInfos)
      return false;
    else if (__isset.writeEventInfos && !(writeEventInfos == rhs.writeEventInfos))
      return false;
    if (__isset.replLastIdInfo != rhs.__isset.replLastIdInfo)
      return false;
    else if (__isset.replLastIdInfo && !(replLastIdInfo == rhs.replLastIdInfo))
      return false;
    if (__isset.keyValue != rhs.__isset.keyValue)
      return false;
    else if (__isset.keyValue && !(keyValue == rhs.keyValue))
      return false;
    if (__isset.exclWriteEnabled != rhs.__isset.exclWriteEnabled)
      return false;
    else if (__isset.exclWriteEnabled && !(exclWriteEnabled == rhs.exclWriteEnabled))
      return false;
    if (__isset.txn_type != rhs.__isset.txn_type)
      return false;
    else if (__isset.txn_type && !(txn_type == rhs.txn_type))
      return false;
    return true;
  }
  bool operator != (const CommitTxnRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CommitTxnRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CommitTxnRequest &a, CommitTxnRequest &b);

std::ostream& operator<<(std::ostream& out, const CommitTxnRequest& obj);

typedef struct _ReplTblWriteIdStateRequest__isset {
  _ReplTblWriteIdStateRequest__isset() : partNames(false) {}
  bool partNames :1;
} _ReplTblWriteIdStateRequest__isset;

class ReplTblWriteIdStateRequest : public virtual ::apache::thrift::TBase {
 public:

  ReplTblWriteIdStateRequest(const ReplTblWriteIdStateRequest&);
  ReplTblWriteIdStateRequest& operator=(const ReplTblWriteIdStateRequest&);
  ReplTblWriteIdStateRequest() noexcept
                             : validWriteIdlist(),
                               user(),
                               hostName(),
                               dbName(),
                               tableName() {
  }

  virtual ~ReplTblWriteIdStateRequest() noexcept;
  std::string validWriteIdlist;
  std::string user;
  std::string hostName;
  std::string dbName;
  std::string tableName;
  std::vector<std::string>  partNames;

  _ReplTblWriteIdStateRequest__isset __isset;

  void __set_validWriteIdlist(const std::string& val);

  void __set_user(const std::string& val);

  void __set_hostName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_partNames(const std::vector<std::string> & val);

  bool operator == (const ReplTblWriteIdStateRequest & rhs) const
  {
    if (!(validWriteIdlist == rhs.validWriteIdlist))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(hostName == rhs.hostName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.partNames != rhs.__isset.partNames)
      return false;
    else if (__isset.partNames && !(partNames == rhs.partNames))
      return false;
    return true;
  }
  bool operator != (const ReplTblWriteIdStateRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplTblWriteIdStateRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReplTblWriteIdStateRequest &a, ReplTblWriteIdStateRequest &b);

std::ostream& operator<<(std::ostream& out, const ReplTblWriteIdStateRequest& obj);

typedef struct _GetValidWriteIdsRequest__isset {
  _GetValidWriteIdsRequest__isset() : validTxnList(false), writeId(false) {}
  bool validTxnList :1;
  bool writeId :1;
} _GetValidWriteIdsRequest__isset;

class GetValidWriteIdsRequest : public virtual ::apache::thrift::TBase {
 public:

  GetValidWriteIdsRequest(const GetValidWriteIdsRequest&);
  GetValidWriteIdsRequest& operator=(const GetValidWriteIdsRequest&);
  GetValidWriteIdsRequest() noexcept
                          : validTxnList(),
                            writeId(0) {
  }

  virtual ~GetValidWriteIdsRequest() noexcept;
  std::vector<std::string>  fullTableNames;
  std::string validTxnList;
  int64_t writeId;

  _GetValidWriteIdsRequest__isset __isset;

  void __set_fullTableNames(const std::vector<std::string> & val);

  void __set_validTxnList(const std::string& val);

  void __set_writeId(const int64_t val);

  bool operator == (const GetValidWriteIdsRequest & rhs) const
  {
    if (!(fullTableNames == rhs.fullTableNames))
      return false;
    if (__isset.validTxnList != rhs.__isset.validTxnList)
      return false;
    else if (__isset.validTxnList && !(validTxnList == rhs.validTxnList))
      return false;
    if (__isset.writeId != rhs.__isset.writeId)
      return false;
    else if (__isset.writeId && !(writeId == rhs.writeId))
      return false;
    return true;
  }
  bool operator != (const GetValidWriteIdsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetValidWriteIdsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetValidWriteIdsRequest &a, GetValidWriteIdsRequest &b);

std::ostream& operator<<(std::ostream& out, const GetValidWriteIdsRequest& obj);

typedef struct _TableValidWriteIds__isset {
  _TableValidWriteIds__isset() : minOpenWriteId(false) {}
  bool minOpenWriteId :1;
} _TableValidWriteIds__isset;

class TableValidWriteIds : public virtual ::apache::thrift::TBase {
 public:

  TableValidWriteIds(const TableValidWriteIds&);
  TableValidWriteIds& operator=(const TableValidWriteIds&);
  TableValidWriteIds() noexcept
                     : fullTableName(),
                       writeIdHighWaterMark(0),
                       minOpenWriteId(0),
                       abortedBits() {
  }

  virtual ~TableValidWriteIds() noexcept;
  std::string fullTableName;
  int64_t writeIdHighWaterMark;
  std::vector<int64_t>  invalidWriteIds;
  int64_t minOpenWriteId;
  std::string abortedBits;

  _TableValidWriteIds__isset __isset;

  void __set_fullTableName(const std::string& val);

  void __set_writeIdHighWaterMark(const int64_t val);

  void __set_invalidWriteIds(const std::vector<int64_t> & val);

  void __set_minOpenWriteId(const int64_t val);

  void __set_abortedBits(const std::string& val);

  bool operator == (const TableValidWriteIds & rhs) const
  {
    if (!(fullTableName == rhs.fullTableName))
      return false;
    if (!(writeIdHighWaterMark == rhs.writeIdHighWaterMark))
      return false;
    if (!(invalidWriteIds == rhs.invalidWriteIds))
      return false;
    if (__isset.minOpenWriteId != rhs.__isset.minOpenWriteId)
      return false;
    else if (__isset.minOpenWriteId && !(minOpenWriteId == rhs.minOpenWriteId))
      return false;
    if (!(abortedBits == rhs.abortedBits))
      return false;
    return true;
  }
  bool operator != (const TableValidWriteIds &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableValidWriteIds & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableValidWriteIds &a, TableValidWriteIds &b);

std::ostream& operator<<(std::ostream& out, const TableValidWriteIds& obj);


class GetValidWriteIdsResponse : public virtual ::apache::thrift::TBase {
 public:

  GetValidWriteIdsResponse(const GetValidWriteIdsResponse&);
  GetValidWriteIdsResponse& operator=(const GetValidWriteIdsResponse&);
  GetValidWriteIdsResponse() noexcept {
  }

  virtual ~GetValidWriteIdsResponse() noexcept;
  std::vector<TableValidWriteIds>  tblValidWriteIds;

  void __set_tblValidWriteIds(const std::vector<TableValidWriteIds> & val);

  bool operator == (const GetValidWriteIdsResponse & rhs) const
  {
    if (!(tblValidWriteIds == rhs.tblValidWriteIds))
      return false;
    return true;
  }
  bool operator != (const GetValidWriteIdsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetValidWriteIdsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetValidWriteIdsResponse &a, GetValidWriteIdsResponse &b);

std::ostream& operator<<(std::ostream& out, const GetValidWriteIdsResponse& obj);


class TxnToWriteId : public virtual ::apache::thrift::TBase {
 public:

  TxnToWriteId(const TxnToWriteId&) noexcept;
  TxnToWriteId& operator=(const TxnToWriteId&) noexcept;
  TxnToWriteId() noexcept
               : txnId(0),
                 writeId(0) {
  }

  virtual ~TxnToWriteId() noexcept;
  int64_t txnId;
  int64_t writeId;

  void __set_txnId(const int64_t val);

  void __set_writeId(const int64_t val);

  bool operator == (const TxnToWriteId & rhs) const
  {
    if (!(txnId == rhs.txnId))
      return false;
    if (!(writeId == rhs.writeId))
      return false;
    return true;
  }
  bool operator != (const TxnToWriteId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TxnToWriteId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TxnToWriteId &a, TxnToWriteId &b);

std::ostream& operator<<(std::ostream& out, const TxnToWriteId& obj);

typedef struct _AllocateTableWriteIdsRequest__isset {
  _AllocateTableWriteIdsRequest__isset() : txnIds(false), replPolicy(false), srcTxnToWriteIdList(false), reallocate(true) {}
  bool txnIds :1;
  bool replPolicy :1;
  bool srcTxnToWriteIdList :1;
  bool reallocate :1;
} _AllocateTableWriteIdsRequest__isset;

class AllocateTableWriteIdsRequest : public virtual ::apache::thrift::TBase {
 public:

  AllocateTableWriteIdsRequest(const AllocateTableWriteIdsRequest&);
  AllocateTableWriteIdsRequest& operator=(const AllocateTableWriteIdsRequest&);
  AllocateTableWriteIdsRequest() noexcept
                               : dbName(),
                                 tableName(),
                                 replPolicy(),
                                 reallocate(false) {
  }

  virtual ~AllocateTableWriteIdsRequest() noexcept;
  std::string dbName;
  std::string tableName;
  std::vector<int64_t>  txnIds;
  std::string replPolicy;
  std::vector<TxnToWriteId>  srcTxnToWriteIdList;
  bool reallocate;

  _AllocateTableWriteIdsRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_txnIds(const std::vector<int64_t> & val);

  void __set_replPolicy(const std::string& val);

  void __set_srcTxnToWriteIdList(const std::vector<TxnToWriteId> & val);

  void __set_reallocate(const bool val);

  bool operator == (const AllocateTableWriteIdsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.txnIds != rhs.__isset.txnIds)
      return false;
    else if (__isset.txnIds && !(txnIds == rhs.txnIds))
      return false;
    if (__isset.replPolicy != rhs.__isset.replPolicy)
      return false;
    else if (__isset.replPolicy && !(replPolicy == rhs.replPolicy))
      return false;
    if (__isset.srcTxnToWriteIdList != rhs.__isset.srcTxnToWriteIdList)
      return false;
    else if (__isset.srcTxnToWriteIdList && !(srcTxnToWriteIdList == rhs.srcTxnToWriteIdList))
      return false;
    if (__isset.reallocate != rhs.__isset.reallocate)
      return false;
    else if (__isset.reallocate && !(reallocate == rhs.reallocate))
      return false;
    return true;
  }
  bool operator != (const AllocateTableWriteIdsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AllocateTableWriteIdsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AllocateTableWriteIdsRequest &a, AllocateTableWriteIdsRequest &b);

std::ostream& operator<<(std::ostream& out, const AllocateTableWriteIdsRequest& obj);


class AllocateTableWriteIdsResponse : public virtual ::apache::thrift::TBase {
 public:

  AllocateTableWriteIdsResponse(const AllocateTableWriteIdsResponse&);
  AllocateTableWriteIdsResponse& operator=(const AllocateTableWriteIdsResponse&);
  AllocateTableWriteIdsResponse() noexcept {
  }

  virtual ~AllocateTableWriteIdsResponse() noexcept;
  std::vector<TxnToWriteId>  txnToWriteIds;

  void __set_txnToWriteIds(const std::vector<TxnToWriteId> & val);

  bool operator == (const AllocateTableWriteIdsResponse & rhs) const
  {
    if (!(txnToWriteIds == rhs.txnToWriteIds))
      return false;
    return true;
  }
  bool operator != (const AllocateTableWriteIdsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AllocateTableWriteIdsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AllocateTableWriteIdsResponse &a, AllocateTableWriteIdsResponse &b);

std::ostream& operator<<(std::ostream& out, const AllocateTableWriteIdsResponse& obj);


class MaxAllocatedTableWriteIdRequest : public virtual ::apache::thrift::TBase {
 public:

  MaxAllocatedTableWriteIdRequest(const MaxAllocatedTableWriteIdRequest&);
  MaxAllocatedTableWriteIdRequest& operator=(const MaxAllocatedTableWriteIdRequest&);
  MaxAllocatedTableWriteIdRequest() noexcept
                                  : dbName(),
                                    tableName() {
  }

  virtual ~MaxAllocatedTableWriteIdRequest() noexcept;
  std::string dbName;
  std::string tableName;

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  bool operator == (const MaxAllocatedTableWriteIdRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const MaxAllocatedTableWriteIdRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MaxAllocatedTableWriteIdRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(MaxAllocatedTableWriteIdRequest &a, MaxAllocatedTableWriteIdRequest &b);

std::ostream& operator<<(std::ostream& out, const MaxAllocatedTableWriteIdRequest& obj);


class MaxAllocatedTableWriteIdResponse : public virtual ::apache::thrift::TBase {
 public:

  MaxAllocatedTableWriteIdResponse(const MaxAllocatedTableWriteIdResponse&) noexcept;
  MaxAllocatedTableWriteIdResponse& operator=(const MaxAllocatedTableWriteIdResponse&) noexcept;
  MaxAllocatedTableWriteIdResponse() noexcept
                                   : maxWriteId(0) {
  }

  virtual ~MaxAllocatedTableWriteIdResponse() noexcept;
  int64_t maxWriteId;

  void __set_maxWriteId(const int64_t val);

  bool operator == (const MaxAllocatedTableWriteIdResponse & rhs) const
  {
    if (!(maxWriteId == rhs.maxWriteId))
      return false;
    return true;
  }
  bool operator != (const MaxAllocatedTableWriteIdResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MaxAllocatedTableWriteIdResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(MaxAllocatedTableWriteIdResponse &a, MaxAllocatedTableWriteIdResponse &b);

std::ostream& operator<<(std::ostream& out, const MaxAllocatedTableWriteIdResponse& obj);


class SeedTableWriteIdsRequest : public virtual ::apache::thrift::TBase {
 public:

  SeedTableWriteIdsRequest(const SeedTableWriteIdsRequest&);
  SeedTableWriteIdsRequest& operator=(const SeedTableWriteIdsRequest&);
  SeedTableWriteIdsRequest() noexcept
                           : dbName(),
                             tableName(),
                             seedWriteId(0) {
  }

  virtual ~SeedTableWriteIdsRequest() noexcept;
  std::string dbName;
  std::string tableName;
  int64_t seedWriteId;

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_seedWriteId(const int64_t val);

  bool operator == (const SeedTableWriteIdsRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(seedWriteId == rhs.seedWriteId))
      return false;
    return true;
  }
  bool operator != (const SeedTableWriteIdsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SeedTableWriteIdsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SeedTableWriteIdsRequest &a, SeedTableWriteIdsRequest &b);

std::ostream& operator<<(std::ostream& out, const SeedTableWriteIdsRequest& obj);


class SeedTxnIdRequest : public virtual ::apache::thrift::TBase {
 public:

  SeedTxnIdRequest(const SeedTxnIdRequest&) noexcept;
  SeedTxnIdRequest& operator=(const SeedTxnIdRequest&) noexcept;
  SeedTxnIdRequest() noexcept
                   : seedTxnId(0) {
  }

  virtual ~SeedTxnIdRequest() noexcept;
  int64_t seedTxnId;

  void __set_seedTxnId(const int64_t val);

  bool operator == (const SeedTxnIdRequest & rhs) const
  {
    if (!(seedTxnId == rhs.seedTxnId))
      return false;
    return true;
  }
  bool operator != (const SeedTxnIdRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SeedTxnIdRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SeedTxnIdRequest &a, SeedTxnIdRequest &b);

std::ostream& operator<<(std::ostream& out, const SeedTxnIdRequest& obj);

typedef struct _LockComponent__isset {
  _LockComponent__isset() : tablename(false), partitionname(false), operationType(true), isTransactional(true), isDynamicPartitionWrite(true) {}
  bool tablename :1;
  bool partitionname :1;
  bool operationType :1;
  bool isTransactional :1;
  bool isDynamicPartitionWrite :1;
} _LockComponent__isset;

class LockComponent : public virtual ::apache::thrift::TBase {
 public:

  LockComponent(const LockComponent&);
  LockComponent& operator=(const LockComponent&);
  LockComponent() noexcept
                : type(static_cast<LockType::type>(0)),
                  level(static_cast<LockLevel::type>(0)),
                  dbname(),
                  tablename(),
                  partitionname(),
                  operationType((DataOperationType::type)5),
                  isTransactional(false),
                  isDynamicPartitionWrite(false) {
    operationType = (DataOperationType::type)5;

  }

  virtual ~LockComponent() noexcept;
  /**
   *
   * @see LockType
   */
  LockType::type type;
  /**
   *
   * @see LockLevel
   */
  LockLevel::type level;
  std::string dbname;
  std::string tablename;
  std::string partitionname;
  /**
   *
   * @see DataOperationType
   */
  DataOperationType::type operationType;
  bool isTransactional;
  bool isDynamicPartitionWrite;

  _LockComponent__isset __isset;

  void __set_type(const LockType::type val);

  void __set_level(const LockLevel::type val);

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionname(const std::string& val);

  void __set_operationType(const DataOperationType::type val);

  void __set_isTransactional(const bool val);

  void __set_isDynamicPartitionWrite(const bool val);

  bool operator == (const LockComponent & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(level == rhs.level))
      return false;
    if (!(dbname == rhs.dbname))
      return false;
    if (__isset.tablename != rhs.__isset.tablename)
      return false;
    else if (__isset.tablename && !(tablename == rhs.tablename))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    if (__isset.operationType != rhs.__isset.operationType)
      return false;
    else if (__isset.operationType && !(operationType == rhs.operationType))
      return false;
    if (__isset.isTransactional != rhs.__isset.isTransactional)
      return false;
    else if (__isset.isTransactional && !(isTransactional == rhs.isTransactional))
      return false;
    if (__isset.isDynamicPartitionWrite != rhs.__isset.isDynamicPartitionWrite)
      return false;
    else if (__isset.isDynamicPartitionWrite && !(isDynamicPartitionWrite == rhs.isDynamicPartitionWrite))
      return false;
    return true;
  }
  bool operator != (const LockComponent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LockComponent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(LockComponent &a, LockComponent &b);

std::ostream& operator<<(std::ostream& out, const LockComponent& obj);

typedef struct _LockRequest__isset {
  _LockRequest__isset() : txnid(false), agentInfo(true), zeroWaitReadEnabled(true), exclusiveCTAS(true), locklessReadsEnabled(true) {}
  bool txnid :1;
  bool agentInfo :1;
  bool zeroWaitReadEnabled :1;
  bool exclusiveCTAS :1;
  bool locklessReadsEnabled :1;
} _LockRequest__isset;

class LockRequest : public virtual ::apache::thrift::TBase {
 public:

  LockRequest(const LockRequest&);
  LockRequest& operator=(const LockRequest&);
  LockRequest() : txnid(0),
                  user(),
                  hostname(),
                  agentInfo("Unknown"),
                  zeroWaitReadEnabled(false),
                  exclusiveCTAS(false),
                  locklessReadsEnabled(false) {
  }

  virtual ~LockRequest() noexcept;
  std::vector<LockComponent>  component;
  int64_t txnid;
  std::string user;
  std::string hostname;
  std::string agentInfo;
  bool zeroWaitReadEnabled;
  bool exclusiveCTAS;
  bool locklessReadsEnabled;

  _LockRequest__isset __isset;

  void __set_component(const std::vector<LockComponent> & val);

  void __set_txnid(const int64_t val);

  void __set_user(const std::string& val);

  void __set_hostname(const std::string& val);

  void __set_agentInfo(const std::string& val);

  void __set_zeroWaitReadEnabled(const bool val);

  void __set_exclusiveCTAS(const bool val);

  void __set_locklessReadsEnabled(const bool val);

  bool operator == (const LockRequest & rhs) const
  {
    if (!(component == rhs.component))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (__isset.agentInfo != rhs.__isset.agentInfo)
      return false;
    else if (__isset.agentInfo && !(agentInfo == rhs.agentInfo))
      return false;
    if (__isset.zeroWaitReadEnabled != rhs.__isset.zeroWaitReadEnabled)
      return false;
    else if (__isset.zeroWaitReadEnabled && !(zeroWaitReadEnabled == rhs.zeroWaitReadEnabled))
      return false;
    if (__isset.exclusiveCTAS != rhs.__isset.exclusiveCTAS)
      return false;
    else if (__isset.exclusiveCTAS && !(exclusiveCTAS == rhs.exclusiveCTAS))
      return false;
    if (__isset.locklessReadsEnabled != rhs.__isset.locklessReadsEnabled)
      return false;
    else if (__isset.locklessReadsEnabled && !(locklessReadsEnabled == rhs.locklessReadsEnabled))
      return false;
    return true;
  }
  bool operator != (const LockRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LockRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(LockRequest &a, LockRequest &b);

std::ostream& operator<<(std::ostream& out, const LockRequest& obj);

typedef struct _LockResponse__isset {
  _LockResponse__isset() : errorMessage(false) {}
  bool errorMessage :1;
} _LockResponse__isset;

class LockResponse : public virtual ::apache::thrift::TBase {
 public:

  LockResponse(const LockResponse&);
  LockResponse& operator=(const LockResponse&);
  LockResponse() noexcept
               : lockid(0),
                 state(static_cast<LockState::type>(0)),
                 errorMessage() {
  }

  virtual ~LockResponse() noexcept;
  int64_t lockid;
  /**
   *
   * @see LockState
   */
  LockState::type state;
  std::string errorMessage;

  _LockResponse__isset __isset;

  void __set_lockid(const int64_t val);

  void __set_state(const LockState::type val);

  void __set_errorMessage(const std::string& val);

  bool operator == (const LockResponse & rhs) const
  {
    if (!(lockid == rhs.lockid))
      return false;
    if (!(state == rhs.state))
      return false;
    if (__isset.errorMessage != rhs.__isset.errorMessage)
      return false;
    else if (__isset.errorMessage && !(errorMessage == rhs.errorMessage))
      return false;
    return true;
  }
  bool operator != (const LockResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LockResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(LockResponse &a, LockResponse &b);

std::ostream& operator<<(std::ostream& out, const LockResponse& obj);

typedef struct _CheckLockRequest__isset {
  _CheckLockRequest__isset() : txnid(false), elapsed_ms(false) {}
  bool txnid :1;
  bool elapsed_ms :1;
} _CheckLockRequest__isset;

class CheckLockRequest : public virtual ::apache::thrift::TBase {
 public:

  CheckLockRequest(const CheckLockRequest&) noexcept;
  CheckLockRequest& operator=(const CheckLockRequest&) noexcept;
  CheckLockRequest() noexcept
                   : lockid(0),
                     txnid(0),
                     elapsed_ms(0) {
  }

  virtual ~CheckLockRequest() noexcept;
  int64_t lockid;
  int64_t txnid;
  int64_t elapsed_ms;

  _CheckLockRequest__isset __isset;

  void __set_lockid(const int64_t val);

  void __set_txnid(const int64_t val);

  void __set_elapsed_ms(const int64_t val);

  bool operator == (const CheckLockRequest & rhs) const
  {
    if (!(lockid == rhs.lockid))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    if (__isset.elapsed_ms != rhs.__isset.elapsed_ms)
      return false;
    else if (__isset.elapsed_ms && !(elapsed_ms == rhs.elapsed_ms))
      return false;
    return true;
  }
  bool operator != (const CheckLockRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CheckLockRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CheckLockRequest &a, CheckLockRequest &b);

std::ostream& operator<<(std::ostream& out, const CheckLockRequest& obj);


class UnlockRequest : public virtual ::apache::thrift::TBase {
 public:

  UnlockRequest(const UnlockRequest&) noexcept;
  UnlockRequest& operator=(const UnlockRequest&) noexcept;
  UnlockRequest() noexcept
                : lockid(0) {
  }

  virtual ~UnlockRequest() noexcept;
  int64_t lockid;

  void __set_lockid(const int64_t val);

  bool operator == (const UnlockRequest & rhs) const
  {
    if (!(lockid == rhs.lockid))
      return false;
    return true;
  }
  bool operator != (const UnlockRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnlockRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UnlockRequest &a, UnlockRequest &b);

std::ostream& operator<<(std::ostream& out, const UnlockRequest& obj);

typedef struct _ShowLocksRequest__isset {
  _ShowLocksRequest__isset() : dbname(false), tablename(false), partname(false), isExtended(true), txnid(false) {}
  bool dbname :1;
  bool tablename :1;
  bool partname :1;
  bool isExtended :1;
  bool txnid :1;
} _ShowLocksRequest__isset;

class ShowLocksRequest : public virtual ::apache::thrift::TBase {
 public:

  ShowLocksRequest(const ShowLocksRequest&);
  ShowLocksRequest& operator=(const ShowLocksRequest&);
  ShowLocksRequest() noexcept
                   : dbname(),
                     tablename(),
                     partname(),
                     isExtended(false),
                     txnid(0) {
  }

  virtual ~ShowLocksRequest() noexcept;
  std::string dbname;
  std::string tablename;
  std::string partname;
  bool isExtended;
  int64_t txnid;

  _ShowLocksRequest__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partname(const std::string& val);

  void __set_isExtended(const bool val);

  void __set_txnid(const int64_t val);

  bool operator == (const ShowLocksRequest & rhs) const
  {
    if (__isset.dbname != rhs.__isset.dbname)
      return false;
    else if (__isset.dbname && !(dbname == rhs.dbname))
      return false;
    if (__isset.tablename != rhs.__isset.tablename)
      return false;
    else if (__isset.tablename && !(tablename == rhs.tablename))
      return false;
    if (__isset.partname != rhs.__isset.partname)
      return false;
    else if (__isset.partname && !(partname == rhs.partname))
      return false;
    if (__isset.isExtended != rhs.__isset.isExtended)
      return false;
    else if (__isset.isExtended && !(isExtended == rhs.isExtended))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    return true;
  }
  bool operator != (const ShowLocksRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowLocksRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowLocksRequest &a, ShowLocksRequest &b);

std::ostream& operator<<(std::ostream& out, const ShowLocksRequest& obj);

typedef struct _ShowLocksResponseElement__isset {
  _ShowLocksResponseElement__isset() : tablename(false), partname(false), txnid(false), acquiredat(false), heartbeatCount(true), agentInfo(false), blockedByExtId(false), blockedByIntId(false), lockIdInternal(false) {}
  bool tablename :1;
  bool partname :1;
  bool txnid :1;
  bool acquiredat :1;
  bool heartbeatCount :1;
  bool agentInfo :1;
  bool blockedByExtId :1;
  bool blockedByIntId :1;
  bool lockIdInternal :1;
} _ShowLocksResponseElement__isset;

class ShowLocksResponseElement : public virtual ::apache::thrift::TBase {
 public:

  ShowLocksResponseElement(const ShowLocksResponseElement&);
  ShowLocksResponseElement& operator=(const ShowLocksResponseElement&);
  ShowLocksResponseElement() noexcept
                           : lockid(0),
                             dbname(),
                             tablename(),
                             partname(),
                             state(static_cast<LockState::type>(0)),
                             type(static_cast<LockType::type>(0)),
                             txnid(0),
                             lastheartbeat(0),
                             acquiredat(0),
                             user(),
                             hostname(),
                             heartbeatCount(0),
                             agentInfo(),
                             blockedByExtId(0),
                             blockedByIntId(0),
                             lockIdInternal(0) {
  }

  virtual ~ShowLocksResponseElement() noexcept;
  int64_t lockid;
  std::string dbname;
  std::string tablename;
  std::string partname;
  /**
   *
   * @see LockState
   */
  LockState::type state;
  /**
   *
   * @see LockType
   */
  LockType::type type;
  int64_t txnid;
  int64_t lastheartbeat;
  int64_t acquiredat;
  std::string user;
  std::string hostname;
  int32_t heartbeatCount;
  std::string agentInfo;
  int64_t blockedByExtId;
  int64_t blockedByIntId;
  int64_t lockIdInternal;

  _ShowLocksResponseElement__isset __isset;

  void __set_lockid(const int64_t val);

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partname(const std::string& val);

  void __set_state(const LockState::type val);

  void __set_type(const LockType::type val);

  void __set_txnid(const int64_t val);

  void __set_lastheartbeat(const int64_t val);

  void __set_acquiredat(const int64_t val);

  void __set_user(const std::string& val);

  void __set_hostname(const std::string& val);

  void __set_heartbeatCount(const int32_t val);

  void __set_agentInfo(const std::string& val);

  void __set_blockedByExtId(const int64_t val);

  void __set_blockedByIntId(const int64_t val);

  void __set_lockIdInternal(const int64_t val);

  bool operator == (const ShowLocksResponseElement & rhs) const
  {
    if (!(lockid == rhs.lockid))
      return false;
    if (!(dbname == rhs.dbname))
      return false;
    if (__isset.tablename != rhs.__isset.tablename)
      return false;
    else if (__isset.tablename && !(tablename == rhs.tablename))
      return false;
    if (__isset.partname != rhs.__isset.partname)
      return false;
    else if (__isset.partname && !(partname == rhs.partname))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    if (!(lastheartbeat == rhs.lastheartbeat))
      return false;
    if (__isset.acquiredat != rhs.__isset.acquiredat)
      return false;
    else if (__isset.acquiredat && !(acquiredat == rhs.acquiredat))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (__isset.heartbeatCount != rhs.__isset.heartbeatCount)
      return false;
    else if (__isset.heartbeatCount && !(heartbeatCount == rhs.heartbeatCount))
      return false;
    if (__isset.agentInfo != rhs.__isset.agentInfo)
      return false;
    else if (__isset.agentInfo && !(agentInfo == rhs.agentInfo))
      return false;
    if (__isset.blockedByExtId != rhs.__isset.blockedByExtId)
      return false;
    else if (__isset.blockedByExtId && !(blockedByExtId == rhs.blockedByExtId))
      return false;
    if (__isset.blockedByIntId != rhs.__isset.blockedByIntId)
      return false;
    else if (__isset.blockedByIntId && !(blockedByIntId == rhs.blockedByIntId))
      return false;
    if (__isset.lockIdInternal != rhs.__isset.lockIdInternal)
      return false;
    else if (__isset.lockIdInternal && !(lockIdInternal == rhs.lockIdInternal))
      return false;
    return true;
  }
  bool operator != (const ShowLocksResponseElement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowLocksResponseElement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowLocksResponseElement &a, ShowLocksResponseElement &b);

std::ostream& operator<<(std::ostream& out, const ShowLocksResponseElement& obj);

typedef struct _ShowLocksResponse__isset {
  _ShowLocksResponse__isset() : locks(false) {}
  bool locks :1;
} _ShowLocksResponse__isset;

class ShowLocksResponse : public virtual ::apache::thrift::TBase {
 public:

  ShowLocksResponse(const ShowLocksResponse&);
  ShowLocksResponse& operator=(const ShowLocksResponse&);
  ShowLocksResponse() noexcept {
  }

  virtual ~ShowLocksResponse() noexcept;
  std::vector<ShowLocksResponseElement>  locks;

  _ShowLocksResponse__isset __isset;

  void __set_locks(const std::vector<ShowLocksResponseElement> & val);

  bool operator == (const ShowLocksResponse & rhs) const
  {
    if (!(locks == rhs.locks))
      return false;
    return true;
  }
  bool operator != (const ShowLocksResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowLocksResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowLocksResponse &a, ShowLocksResponse &b);

std::ostream& operator<<(std::ostream& out, const ShowLocksResponse& obj);

typedef struct _HeartbeatRequest__isset {
  _HeartbeatRequest__isset() : lockid(false), txnid(false) {}
  bool lockid :1;
  bool txnid :1;
} _HeartbeatRequest__isset;

class HeartbeatRequest : public virtual ::apache::thrift::TBase {
 public:

  HeartbeatRequest(const HeartbeatRequest&) noexcept;
  HeartbeatRequest& operator=(const HeartbeatRequest&) noexcept;
  HeartbeatRequest() noexcept
                   : lockid(0),
                     txnid(0) {
  }

  virtual ~HeartbeatRequest() noexcept;
  int64_t lockid;
  int64_t txnid;

  _HeartbeatRequest__isset __isset;

  void __set_lockid(const int64_t val);

  void __set_txnid(const int64_t val);

  bool operator == (const HeartbeatRequest & rhs) const
  {
    if (__isset.lockid != rhs.__isset.lockid)
      return false;
    else if (__isset.lockid && !(lockid == rhs.lockid))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    return true;
  }
  bool operator != (const HeartbeatRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartbeatRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeartbeatRequest &a, HeartbeatRequest &b);

std::ostream& operator<<(std::ostream& out, const HeartbeatRequest& obj);


class HeartbeatTxnRangeRequest : public virtual ::apache::thrift::TBase {
 public:

  HeartbeatTxnRangeRequest(const HeartbeatTxnRangeRequest&) noexcept;
  HeartbeatTxnRangeRequest& operator=(const HeartbeatTxnRangeRequest&) noexcept;
  HeartbeatTxnRangeRequest() noexcept
                           : min(0),
                             max(0) {
  }

  virtual ~HeartbeatTxnRangeRequest() noexcept;
  int64_t min;
  int64_t max;

  void __set_min(const int64_t val);

  void __set_max(const int64_t val);

  bool operator == (const HeartbeatTxnRangeRequest & rhs) const
  {
    if (!(min == rhs.min))
      return false;
    if (!(max == rhs.max))
      return false;
    return true;
  }
  bool operator != (const HeartbeatTxnRangeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartbeatTxnRangeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeartbeatTxnRangeRequest &a, HeartbeatTxnRangeRequest &b);

std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeRequest& obj);


class HeartbeatTxnRangeResponse : public virtual ::apache::thrift::TBase {
 public:

  HeartbeatTxnRangeResponse(const HeartbeatTxnRangeResponse&);
  HeartbeatTxnRangeResponse& operator=(const HeartbeatTxnRangeResponse&);
  HeartbeatTxnRangeResponse() noexcept {
  }

  virtual ~HeartbeatTxnRangeResponse() noexcept;
  std::set<int64_t>  aborted;
  std::set<int64_t>  nosuch;

  void __set_aborted(const std::set<int64_t> & val);

  void __set_nosuch(const std::set<int64_t> & val);

  bool operator == (const HeartbeatTxnRangeResponse & rhs) const
  {
    if (!(aborted == rhs.aborted))
      return false;
    if (!(nosuch == rhs.nosuch))
      return false;
    return true;
  }
  bool operator != (const HeartbeatTxnRangeResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartbeatTxnRangeResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeartbeatTxnRangeResponse &a, HeartbeatTxnRangeResponse &b);

std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeResponse& obj);

typedef struct _CompactionRequest__isset {
  _CompactionRequest__isset() : partitionname(false), runas(false), properties(false), initiatorId(false), initiatorVersion(false), poolName(false), numberOfBuckets(false), orderByClause(false) {}
  bool partitionname :1;
  bool runas :1;
  bool properties :1;
  bool initiatorId :1;
  bool initiatorVersion :1;
  bool poolName :1;
  bool numberOfBuckets :1;
  bool orderByClause :1;
} _CompactionRequest__isset;

class CompactionRequest : public virtual ::apache::thrift::TBase {
 public:

  CompactionRequest(const CompactionRequest&);
  CompactionRequest& operator=(const CompactionRequest&);
  CompactionRequest() noexcept
                    : dbname(),
                      tablename(),
                      partitionname(),
                      type(static_cast<CompactionType::type>(0)),
                      runas(),
                      initiatorId(),
                      initiatorVersion(),
                      poolName(),
                      numberOfBuckets(0),
                      orderByClause() {
  }

  virtual ~CompactionRequest() noexcept;
  std::string dbname;
  std::string tablename;
  std::string partitionname;
  /**
   *
   * @see CompactionType
   */
  CompactionType::type type;
  std::string runas;
  std::map<std::string, std::string>  properties;
  std::string initiatorId;
  std::string initiatorVersion;
  std::string poolName;
  int32_t numberOfBuckets;
  std::string orderByClause;

  _CompactionRequest__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionname(const std::string& val);

  void __set_type(const CompactionType::type val);

  void __set_runas(const std::string& val);

  void __set_properties(const std::map<std::string, std::string> & val);

  void __set_initiatorId(const std::string& val);

  void __set_initiatorVersion(const std::string& val);

  void __set_poolName(const std::string& val);

  void __set_numberOfBuckets(const int32_t val);

  void __set_orderByClause(const std::string& val);

  bool operator == (const CompactionRequest & rhs) const
  {
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.runas != rhs.__isset.runas)
      return false;
    else if (__isset.runas && !(runas == rhs.runas))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    if (__isset.initiatorId != rhs.__isset.initiatorId)
      return false;
    else if (__isset.initiatorId && !(initiatorId == rhs.initiatorId))
      return false;
    if (__isset.initiatorVersion != rhs.__isset.initiatorVersion)
      return false;
    else if (__isset.initiatorVersion && !(initiatorVersion == rhs.initiatorVersion))
      return false;
    if (__isset.poolName != rhs.__isset.poolName)
      return false;
    else if (__isset.poolName && !(poolName == rhs.poolName))
      return false;
    if (__isset.numberOfBuckets != rhs.__isset.numberOfBuckets)
      return false;
    else if (__isset.numberOfBuckets && !(numberOfBuckets == rhs.numberOfBuckets))
      return false;
    if (__isset.orderByClause != rhs.__isset.orderByClause)
      return false;
    else if (__isset.orderByClause && !(orderByClause == rhs.orderByClause))
      return false;
    return true;
  }
  bool operator != (const CompactionRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactionRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactionRequest &a, CompactionRequest &b);

std::ostream& operator<<(std::ostream& out, const CompactionRequest& obj);

typedef struct _CompactionInfoStruct__isset {
  _CompactionInfoStruct__isset() : partitionname(false), runas(false), properties(false), toomanyaborts(false), state(false), workerId(false), start(false), highestWriteId(false), errorMessage(false), hasoldabort(false), enqueueTime(false), retryRetention(false), poolname(false), numberOfBuckets(false), orderByClause(false) {}
  bool partitionname :1;
  bool runas :1;
  bool properties :1;
  bool toomanyaborts :1;
  bool state :1;
  bool workerId :1;
  bool start :1;
  bool highestWriteId :1;
  bool errorMessage :1;
  bool hasoldabort :1;
  bool enqueueTime :1;
  bool retryRetention :1;
  bool poolname :1;
  bool numberOfBuckets :1;
  bool orderByClause :1;
} _CompactionInfoStruct__isset;

class CompactionInfoStruct : public virtual ::apache::thrift::TBase {
 public:

  CompactionInfoStruct(const CompactionInfoStruct&);
  CompactionInfoStruct& operator=(const CompactionInfoStruct&);
  CompactionInfoStruct() noexcept
                       : id(0),
                         dbname(),
                         tablename(),
                         partitionname(),
                         type(static_cast<CompactionType::type>(0)),
                         runas(),
                         properties(),
                         toomanyaborts(0),
                         state(),
                         workerId(),
                         start(0),
                         highestWriteId(0),
                         errorMessage(),
                         hasoldabort(0),
                         enqueueTime(0),
                         retryRetention(0),
                         poolname(),
                         numberOfBuckets(0),
                         orderByClause() {
  }

  virtual ~CompactionInfoStruct() noexcept;
  int64_t id;
  std::string dbname;
  std::string tablename;
  std::string partitionname;
  /**
   *
   * @see CompactionType
   */
  CompactionType::type type;
  std::string runas;
  std::string properties;
  bool toomanyaborts;
  std::string state;
  std::string workerId;
  int64_t start;
  int64_t highestWriteId;
  std::string errorMessage;
  bool hasoldabort;
  int64_t enqueueTime;
  int64_t retryRetention;
  std::string poolname;
  int32_t numberOfBuckets;
  std::string orderByClause;

  _CompactionInfoStruct__isset __isset;

  void __set_id(const int64_t val);

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionname(const std::string& val);

  void __set_type(const CompactionType::type val);

  void __set_runas(const std::string& val);

  void __set_properties(const std::string& val);

  void __set_toomanyaborts(const bool val);

  void __set_state(const std::string& val);

  void __set_workerId(const std::string& val);

  void __set_start(const int64_t val);

  void __set_highestWriteId(const int64_t val);

  void __set_errorMessage(const std::string& val);

  void __set_hasoldabort(const bool val);

  void __set_enqueueTime(const int64_t val);

  void __set_retryRetention(const int64_t val);

  void __set_poolname(const std::string& val);

  void __set_numberOfBuckets(const int32_t val);

  void __set_orderByClause(const std::string& val);

  bool operator == (const CompactionInfoStruct & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.runas != rhs.__isset.runas)
      return false;
    else if (__isset.runas && !(runas == rhs.runas))
      return false;
    if (__isset.properties != rhs.__isset.properties)
      return false;
    else if (__isset.properties && !(properties == rhs.properties))
      return false;
    if (__isset.toomanyaborts != rhs.__isset.toomanyaborts)
      return false;
    else if (__isset.toomanyaborts && !(toomanyaborts == rhs.toomanyaborts))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.workerId != rhs.__isset.workerId)
      return false;
    else if (__isset.workerId && !(workerId == rhs.workerId))
      return false;
    if (__isset.start != rhs.__isset.start)
      return false;
    else if (__isset.start && !(start == rhs.start))
      return false;
    if (__isset.highestWriteId != rhs.__isset.highestWriteId)
      return false;
    else if (__isset.highestWriteId && !(highestWriteId == rhs.highestWriteId))
      return false;
    if (__isset.errorMessage != rhs.__isset.errorMessage)
      return false;
    else if (__isset.errorMessage && !(errorMessage == rhs.errorMessage))
      return false;
    if (__isset.hasoldabort != rhs.__isset.hasoldabort)
      return false;
    else if (__isset.hasoldabort && !(hasoldabort == rhs.hasoldabort))
      return false;
    if (__isset.enqueueTime != rhs.__isset.enqueueTime)
      return false;
    else if (__isset.enqueueTime && !(enqueueTime == rhs.enqueueTime))
      return false;
    if (__isset.retryRetention != rhs.__isset.retryRetention)
      return false;
    else if (__isset.retryRetention && !(retryRetention == rhs.retryRetention))
      return false;
    if (__isset.poolname != rhs.__isset.poolname)
      return false;
    else if (__isset.poolname && !(poolname == rhs.poolname))
      return false;
    if (__isset.numberOfBuckets != rhs.__isset.numberOfBuckets)
      return false;
    else if (__isset.numberOfBuckets && !(numberOfBuckets == rhs.numberOfBuckets))
      return false;
    if (__isset.orderByClause != rhs.__isset.orderByClause)
      return false;
    else if (__isset.orderByClause && !(orderByClause == rhs.orderByClause))
      return false;
    return true;
  }
  bool operator != (const CompactionInfoStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactionInfoStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactionInfoStruct &a, CompactionInfoStruct &b);

std::ostream& operator<<(std::ostream& out, const CompactionInfoStruct& obj);

typedef struct _OptionalCompactionInfoStruct__isset {
  _OptionalCompactionInfoStruct__isset() : ci(false) {}
  bool ci :1;
} _OptionalCompactionInfoStruct__isset;

class OptionalCompactionInfoStruct : public virtual ::apache::thrift::TBase {
 public:

  OptionalCompactionInfoStruct(const OptionalCompactionInfoStruct&);
  OptionalCompactionInfoStruct& operator=(const OptionalCompactionInfoStruct&);
  OptionalCompactionInfoStruct() noexcept {
  }

  virtual ~OptionalCompactionInfoStruct() noexcept;
  CompactionInfoStruct ci;

  _OptionalCompactionInfoStruct__isset __isset;

  void __set_ci(const CompactionInfoStruct& val);

  bool operator == (const OptionalCompactionInfoStruct & rhs) const
  {
    if (__isset.ci != rhs.__isset.ci)
      return false;
    else if (__isset.ci && !(ci == rhs.ci))
      return false;
    return true;
  }
  bool operator != (const OptionalCompactionInfoStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OptionalCompactionInfoStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(OptionalCompactionInfoStruct &a, OptionalCompactionInfoStruct &b);

std::ostream& operator<<(std::ostream& out, const OptionalCompactionInfoStruct& obj);

typedef struct _CompactionMetricsDataStruct__isset {
  _CompactionMetricsDataStruct__isset() : partitionname(false) {}
  bool partitionname :1;
} _CompactionMetricsDataStruct__isset;

class CompactionMetricsDataStruct : public virtual ::apache::thrift::TBase {
 public:

  CompactionMetricsDataStruct(const CompactionMetricsDataStruct&);
  CompactionMetricsDataStruct& operator=(const CompactionMetricsDataStruct&);
  CompactionMetricsDataStruct() noexcept
                              : dbname(),
                                tblname(),
                                partitionname(),
                                type(static_cast<CompactionMetricsMetricType::type>(0)),
                                metricvalue(0),
                                version(0),
                                threshold(0) {
  }

  virtual ~CompactionMetricsDataStruct() noexcept;
  std::string dbname;
  std::string tblname;
  std::string partitionname;
  /**
   *
   * @see CompactionMetricsMetricType
   */
  CompactionMetricsMetricType::type type;
  int32_t metricvalue;
  int32_t version;
  int32_t threshold;

  _CompactionMetricsDataStruct__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tblname(const std::string& val);

  void __set_partitionname(const std::string& val);

  void __set_type(const CompactionMetricsMetricType::type val);

  void __set_metricvalue(const int32_t val);

  void __set_version(const int32_t val);

  void __set_threshold(const int32_t val);

  bool operator == (const CompactionMetricsDataStruct & rhs) const
  {
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tblname == rhs.tblname))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(metricvalue == rhs.metricvalue))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(threshold == rhs.threshold))
      return false;
    return true;
  }
  bool operator != (const CompactionMetricsDataStruct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactionMetricsDataStruct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactionMetricsDataStruct &a, CompactionMetricsDataStruct &b);

std::ostream& operator<<(std::ostream& out, const CompactionMetricsDataStruct& obj);

typedef struct _CompactionMetricsDataResponse__isset {
  _CompactionMetricsDataResponse__isset() : data(false) {}
  bool data :1;
} _CompactionMetricsDataResponse__isset;

class CompactionMetricsDataResponse : public virtual ::apache::thrift::TBase {
 public:

  CompactionMetricsDataResponse(const CompactionMetricsDataResponse&);
  CompactionMetricsDataResponse& operator=(const CompactionMetricsDataResponse&);
  CompactionMetricsDataResponse() noexcept {
  }

  virtual ~CompactionMetricsDataResponse() noexcept;
  CompactionMetricsDataStruct data;

  _CompactionMetricsDataResponse__isset __isset;

  void __set_data(const CompactionMetricsDataStruct& val);

  bool operator == (const CompactionMetricsDataResponse & rhs) const
  {
    if (__isset.data != rhs.__isset.data)
      return false;
    else if (__isset.data && !(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const CompactionMetricsDataResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactionMetricsDataResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactionMetricsDataResponse &a, CompactionMetricsDataResponse &b);

std::ostream& operator<<(std::ostream& out, const CompactionMetricsDataResponse& obj);

typedef struct _CompactionMetricsDataRequest__isset {
  _CompactionMetricsDataRequest__isset() : partitionName(false) {}
  bool partitionName :1;
} _CompactionMetricsDataRequest__isset;

class CompactionMetricsDataRequest : public virtual ::apache::thrift::TBase {
 public:

  CompactionMetricsDataRequest(const CompactionMetricsDataRequest&);
  CompactionMetricsDataRequest& operator=(const CompactionMetricsDataRequest&);
  CompactionMetricsDataRequest() noexcept
                               : dbName(),
                                 tblName(),
                                 partitionName(),
                                 type(static_cast<CompactionMetricsMetricType::type>(0)) {
  }

  virtual ~CompactionMetricsDataRequest() noexcept;
  std::string dbName;
  std::string tblName;
  std::string partitionName;
  /**
   *
   * @see CompactionMetricsMetricType
   */
  CompactionMetricsMetricType::type type;

  _CompactionMetricsDataRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_partitionName(const std::string& val);

  void __set_type(const CompactionMetricsMetricType::type val);

  bool operator == (const CompactionMetricsDataRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.partitionName != rhs.__isset.partitionName)
      return false;
    else if (__isset.partitionName && !(partitionName == rhs.partitionName))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const CompactionMetricsDataRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactionMetricsDataRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactionMetricsDataRequest &a, CompactionMetricsDataRequest &b);

std::ostream& operator<<(std::ostream& out, const CompactionMetricsDataRequest& obj);

typedef struct _CompactionResponse__isset {
  _CompactionResponse__isset() : errormessage(false) {}
  bool errormessage :1;
} _CompactionResponse__isset;

class CompactionResponse : public virtual ::apache::thrift::TBase {
 public:

  CompactionResponse(const CompactionResponse&);
  CompactionResponse& operator=(const CompactionResponse&);
  CompactionResponse() noexcept
                     : id(0),
                       state(),
                       accepted(0),
                       errormessage() {
  }

  virtual ~CompactionResponse() noexcept;
  int64_t id;
  std::string state;
  bool accepted;
  std::string errormessage;

  _CompactionResponse__isset __isset;

  void __set_id(const int64_t val);

  void __set_state(const std::string& val);

  void __set_accepted(const bool val);

  void __set_errormessage(const std::string& val);

  bool operator == (const CompactionResponse & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(accepted == rhs.accepted))
      return false;
    if (__isset.errormessage != rhs.__isset.errormessage)
      return false;
    else if (__isset.errormessage && !(errormessage == rhs.errormessage))
      return false;
    return true;
  }
  bool operator != (const CompactionResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactionResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactionResponse &a, CompactionResponse &b);

std::ostream& operator<<(std::ostream& out, const CompactionResponse& obj);

typedef struct _ShowCompactRequest__isset {
  _ShowCompactRequest__isset() : id(false), poolName(false), dbName(false), tbName(false), partName(false), type(false), state(false), limit(false), order(false) {}
  bool id :1;
  bool poolName :1;
  bool dbName :1;
  bool tbName :1;
  bool partName :1;
  bool type :1;
  bool state :1;
  bool limit :1;
  bool order :1;
} _ShowCompactRequest__isset;

class ShowCompactRequest : public virtual ::apache::thrift::TBase {
 public:

  ShowCompactRequest(const ShowCompactRequest&);
  ShowCompactRequest& operator=(const ShowCompactRequest&);
  ShowCompactRequest() noexcept
                     : id(0),
                       poolName(),
                       dbName(),
                       tbName(),
                       partName(),
                       type(static_cast<CompactionType::type>(0)),
                       state(),
                       limit(0),
                       order() {
  }

  virtual ~ShowCompactRequest() noexcept;
  int64_t id;
  std::string poolName;
  std::string dbName;
  std::string tbName;
  std::string partName;
  /**
   *
   * @see CompactionType
   */
  CompactionType::type type;
  std::string state;
  int64_t limit;
  std::string order;

  _ShowCompactRequest__isset __isset;

  void __set_id(const int64_t val);

  void __set_poolName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tbName(const std::string& val);

  void __set_partName(const std::string& val);

  void __set_type(const CompactionType::type val);

  void __set_state(const std::string& val);

  void __set_limit(const int64_t val);

  void __set_order(const std::string& val);

  bool operator == (const ShowCompactRequest & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.poolName != rhs.__isset.poolName)
      return false;
    else if (__isset.poolName && !(poolName == rhs.poolName))
      return false;
    if (__isset.dbName != rhs.__isset.dbName)
      return false;
    else if (__isset.dbName && !(dbName == rhs.dbName))
      return false;
    if (__isset.tbName != rhs.__isset.tbName)
      return false;
    else if (__isset.tbName && !(tbName == rhs.tbName))
      return false;
    if (__isset.partName != rhs.__isset.partName)
      return false;
    else if (__isset.partName && !(partName == rhs.partName))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.limit != rhs.__isset.limit)
      return false;
    else if (__isset.limit && !(limit == rhs.limit))
      return false;
    if (__isset.order != rhs.__isset.order)
      return false;
    else if (__isset.order && !(order == rhs.order))
      return false;
    return true;
  }
  bool operator != (const ShowCompactRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowCompactRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowCompactRequest &a, ShowCompactRequest &b);

std::ostream& operator<<(std::ostream& out, const ShowCompactRequest& obj);

typedef struct _ShowCompactResponseElement__isset {
  _ShowCompactResponseElement__isset() : partitionname(false), workerid(false), start(false), runAs(false), hightestTxnId(false), metaInfo(false), endTime(false), hadoopJobId(true), id(false), errorMessage(false), enqueueTime(false), workerVersion(false), initiatorId(false), initiatorVersion(false), cleanerStart(false), poolName(false), nextTxnId(false), txnId(false), commitTime(false), hightestWriteId(false) {}
  bool partitionname :1;
  bool workerid :1;
  bool start :1;
  bool runAs :1;
  bool hightestTxnId :1;
  bool metaInfo :1;
  bool endTime :1;
  bool hadoopJobId :1;
  bool id :1;
  bool errorMessage :1;
  bool enqueueTime :1;
  bool workerVersion :1;
  bool initiatorId :1;
  bool initiatorVersion :1;
  bool cleanerStart :1;
  bool poolName :1;
  bool nextTxnId :1;
  bool txnId :1;
  bool commitTime :1;
  bool hightestWriteId :1;
} _ShowCompactResponseElement__isset;

class ShowCompactResponseElement : public virtual ::apache::thrift::TBase {
 public:

  ShowCompactResponseElement(const ShowCompactResponseElement&);
  ShowCompactResponseElement& operator=(const ShowCompactResponseElement&);
  ShowCompactResponseElement() : dbname(),
                                 tablename(),
                                 partitionname(),
                                 type(static_cast<CompactionType::type>(0)),
                                 state(),
                                 workerid(),
                                 start(0),
                                 runAs(),
                                 hightestTxnId(0),
                                 metaInfo(),
                                 endTime(0),
                                 hadoopJobId("None"),
                                 id(0),
                                 errorMessage(),
                                 enqueueTime(0),
                                 workerVersion(),
                                 initiatorId(),
                                 initiatorVersion(),
                                 cleanerStart(0),
                                 poolName(),
                                 nextTxnId(0),
                                 txnId(0),
                                 commitTime(0),
                                 hightestWriteId(0) {
  }

  virtual ~ShowCompactResponseElement() noexcept;
  std::string dbname;
  std::string tablename;
  std::string partitionname;
  /**
   *
   * @see CompactionType
   */
  CompactionType::type type;
  std::string state;
  std::string workerid;
  int64_t start;
  std::string runAs;
  int64_t hightestTxnId;
  std::string metaInfo;
  int64_t endTime;
  std::string hadoopJobId;
  int64_t id;
  std::string errorMessage;
  int64_t enqueueTime;
  std::string workerVersion;
  std::string initiatorId;
  std::string initiatorVersion;
  int64_t cleanerStart;
  std::string poolName;
  int64_t nextTxnId;
  int64_t txnId;
  int64_t commitTime;
  int64_t hightestWriteId;

  _ShowCompactResponseElement__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionname(const std::string& val);

  void __set_type(const CompactionType::type val);

  void __set_state(const std::string& val);

  void __set_workerid(const std::string& val);

  void __set_start(const int64_t val);

  void __set_runAs(const std::string& val);

  void __set_hightestTxnId(const int64_t val);

  void __set_metaInfo(const std::string& val);

  void __set_endTime(const int64_t val);

  void __set_hadoopJobId(const std::string& val);

  void __set_id(const int64_t val);

  void __set_errorMessage(const std::string& val);

  void __set_enqueueTime(const int64_t val);

  void __set_workerVersion(const std::string& val);

  void __set_initiatorId(const std::string& val);

  void __set_initiatorVersion(const std::string& val);

  void __set_cleanerStart(const int64_t val);

  void __set_poolName(const std::string& val);

  void __set_nextTxnId(const int64_t val);

  void __set_txnId(const int64_t val);

  void __set_commitTime(const int64_t val);

  void __set_hightestWriteId(const int64_t val);

  bool operator == (const ShowCompactResponseElement & rhs) const
  {
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(state == rhs.state))
      return false;
    if (__isset.workerid != rhs.__isset.workerid)
      return false;
    else if (__isset.workerid && !(workerid == rhs.workerid))
      return false;
    if (__isset.start != rhs.__isset.start)
      return false;
    else if (__isset.start && !(start == rhs.start))
      return false;
    if (__isset.runAs != rhs.__isset.runAs)
      return false;
    else if (__isset.runAs && !(runAs == rhs.runAs))
      return false;
    if (__isset.hightestTxnId != rhs.__isset.hightestTxnId)
      return false;
    else if (__isset.hightestTxnId && !(hightestTxnId == rhs.hightestTxnId))
      return false;
    if (__isset.metaInfo != rhs.__isset.metaInfo)
      return false;
    else if (__isset.metaInfo && !(metaInfo == rhs.metaInfo))
      return false;
    if (__isset.endTime != rhs.__isset.endTime)
      return false;
    else if (__isset.endTime && !(endTime == rhs.endTime))
      return false;
    if (__isset.hadoopJobId != rhs.__isset.hadoopJobId)
      return false;
    else if (__isset.hadoopJobId && !(hadoopJobId == rhs.hadoopJobId))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.errorMessage != rhs.__isset.errorMessage)
      return false;
    else if (__isset.errorMessage && !(errorMessage == rhs.errorMessage))
      return false;
    if (__isset.enqueueTime != rhs.__isset.enqueueTime)
      return false;
    else if (__isset.enqueueTime && !(enqueueTime == rhs.enqueueTime))
      return false;
    if (__isset.workerVersion != rhs.__isset.workerVersion)
      return false;
    else if (__isset.workerVersion && !(workerVersion == rhs.workerVersion))
      return false;
    if (__isset.initiatorId != rhs.__isset.initiatorId)
      return false;
    else if (__isset.initiatorId && !(initiatorId == rhs.initiatorId))
      return false;
    if (__isset.initiatorVersion != rhs.__isset.initiatorVersion)
      return false;
    else if (__isset.initiatorVersion && !(initiatorVersion == rhs.initiatorVersion))
      return false;
    if (__isset.cleanerStart != rhs.__isset.cleanerStart)
      return false;
    else if (__isset.cleanerStart && !(cleanerStart == rhs.cleanerStart))
      return false;
    if (__isset.poolName != rhs.__isset.poolName)
      return false;
    else if (__isset.poolName && !(poolName == rhs.poolName))
      return false;
    if (__isset.nextTxnId != rhs.__isset.nextTxnId)
      return false;
    else if (__isset.nextTxnId && !(nextTxnId == rhs.nextTxnId))
      return false;
    if (__isset.txnId != rhs.__isset.txnId)
      return false;
    else if (__isset.txnId && !(txnId == rhs.txnId))
      return false;
    if (__isset.commitTime != rhs.__isset.commitTime)
      return false;
    else if (__isset.commitTime && !(commitTime == rhs.commitTime))
      return false;
    if (__isset.hightestWriteId != rhs.__isset.hightestWriteId)
      return false;
    else if (__isset.hightestWriteId && !(hightestWriteId == rhs.hightestWriteId))
      return false;
    return true;
  }
  bool operator != (const ShowCompactResponseElement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowCompactResponseElement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowCompactResponseElement &a, ShowCompactResponseElement &b);

std::ostream& operator<<(std::ostream& out, const ShowCompactResponseElement& obj);


class ShowCompactResponse : public virtual ::apache::thrift::TBase {
 public:

  ShowCompactResponse(const ShowCompactResponse&);
  ShowCompactResponse& operator=(const ShowCompactResponse&);
  ShowCompactResponse() noexcept {
  }

  virtual ~ShowCompactResponse() noexcept;
  std::vector<ShowCompactResponseElement>  compacts;

  void __set_compacts(const std::vector<ShowCompactResponseElement> & val);

  bool operator == (const ShowCompactResponse & rhs) const
  {
    if (!(compacts == rhs.compacts))
      return false;
    return true;
  }
  bool operator != (const ShowCompactResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ShowCompactResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ShowCompactResponse &a, ShowCompactResponse &b);

std::ostream& operator<<(std::ostream& out, const ShowCompactResponse& obj);

typedef struct _AbortCompactionRequest__isset {
  _AbortCompactionRequest__isset() : type(false), poolName(false) {}
  bool type :1;
  bool poolName :1;
} _AbortCompactionRequest__isset;

class AbortCompactionRequest : public virtual ::apache::thrift::TBase {
 public:

  AbortCompactionRequest(const AbortCompactionRequest&);
  AbortCompactionRequest& operator=(const AbortCompactionRequest&);
  AbortCompactionRequest() noexcept
                         : type(),
                           poolName() {
  }

  virtual ~AbortCompactionRequest() noexcept;
  std::vector<int64_t>  compactionIds;
  std::string type;
  std::string poolName;

  _AbortCompactionRequest__isset __isset;

  void __set_compactionIds(const std::vector<int64_t> & val);

  void __set_type(const std::string& val);

  void __set_poolName(const std::string& val);

  bool operator == (const AbortCompactionRequest & rhs) const
  {
    if (!(compactionIds == rhs.compactionIds))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.poolName != rhs.__isset.poolName)
      return false;
    else if (__isset.poolName && !(poolName == rhs.poolName))
      return false;
    return true;
  }
  bool operator != (const AbortCompactionRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AbortCompactionRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AbortCompactionRequest &a, AbortCompactionRequest &b);

std::ostream& operator<<(std::ostream& out, const AbortCompactionRequest& obj);

typedef struct _AbortCompactionResponseElement__isset {
  _AbortCompactionResponseElement__isset() : status(false), message(false) {}
  bool status :1;
  bool message :1;
} _AbortCompactionResponseElement__isset;

class AbortCompactionResponseElement : public virtual ::apache::thrift::TBase {
 public:

  AbortCompactionResponseElement(const AbortCompactionResponseElement&);
  AbortCompactionResponseElement& operator=(const AbortCompactionResponseElement&);
  AbortCompactionResponseElement() noexcept
                                 : compactionId(0),
                                   status(),
                                   message() {
  }

  virtual ~AbortCompactionResponseElement() noexcept;
  int64_t compactionId;
  std::string status;
  std::string message;

  _AbortCompactionResponseElement__isset __isset;

  void __set_compactionId(const int64_t val);

  void __set_status(const std::string& val);

  void __set_message(const std::string& val);

  bool operator == (const AbortCompactionResponseElement & rhs) const
  {
    if (!(compactionId == rhs.compactionId))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const AbortCompactionResponseElement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AbortCompactionResponseElement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AbortCompactionResponseElement &a, AbortCompactionResponseElement &b);

std::ostream& operator<<(std::ostream& out, const AbortCompactionResponseElement& obj);


class AbortCompactResponse : public virtual ::apache::thrift::TBase {
 public:

  AbortCompactResponse(const AbortCompactResponse&);
  AbortCompactResponse& operator=(const AbortCompactResponse&);
  AbortCompactResponse() noexcept {
  }

  virtual ~AbortCompactResponse() noexcept;
  std::map<int64_t, AbortCompactionResponseElement>  abortedcompacts;

  void __set_abortedcompacts(const std::map<int64_t, AbortCompactionResponseElement> & val);

  bool operator == (const AbortCompactResponse & rhs) const
  {
    if (!(abortedcompacts == rhs.abortedcompacts))
      return false;
    return true;
  }
  bool operator != (const AbortCompactResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AbortCompactResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AbortCompactResponse &a, AbortCompactResponse &b);

std::ostream& operator<<(std::ostream& out, const AbortCompactResponse& obj);

typedef struct _GetLatestCommittedCompactionInfoRequest__isset {
  _GetLatestCommittedCompactionInfoRequest__isset() : partitionnames(false), lastCompactionId(false) {}
  bool partitionnames :1;
  bool lastCompactionId :1;
} _GetLatestCommittedCompactionInfoRequest__isset;

class GetLatestCommittedCompactionInfoRequest : public virtual ::apache::thrift::TBase {
 public:

  GetLatestCommittedCompactionInfoRequest(const GetLatestCommittedCompactionInfoRequest&);
  GetLatestCommittedCompactionInfoRequest& operator=(const GetLatestCommittedCompactionInfoRequest&);
  GetLatestCommittedCompactionInfoRequest() noexcept
                                          : dbname(),
                                            tablename(),
                                            lastCompactionId(0) {
  }

  virtual ~GetLatestCommittedCompactionInfoRequest() noexcept;
  std::string dbname;
  std::string tablename;
  std::vector<std::string>  partitionnames;
  int64_t lastCompactionId;

  _GetLatestCommittedCompactionInfoRequest__isset __isset;

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionnames(const std::vector<std::string> & val);

  void __set_lastCompactionId(const int64_t val);

  bool operator == (const GetLatestCommittedCompactionInfoRequest & rhs) const
  {
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (__isset.partitionnames != rhs.__isset.partitionnames)
      return false;
    else if (__isset.partitionnames && !(partitionnames == rhs.partitionnames))
      return false;
    if (__isset.lastCompactionId != rhs.__isset.lastCompactionId)
      return false;
    else if (__isset.lastCompactionId && !(lastCompactionId == rhs.lastCompactionId))
      return false;
    return true;
  }
  bool operator != (const GetLatestCommittedCompactionInfoRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetLatestCommittedCompactionInfoRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetLatestCommittedCompactionInfoRequest &a, GetLatestCommittedCompactionInfoRequest &b);

std::ostream& operator<<(std::ostream& out, const GetLatestCommittedCompactionInfoRequest& obj);


class GetLatestCommittedCompactionInfoResponse : public virtual ::apache::thrift::TBase {
 public:

  GetLatestCommittedCompactionInfoResponse(const GetLatestCommittedCompactionInfoResponse&);
  GetLatestCommittedCompactionInfoResponse& operator=(const GetLatestCommittedCompactionInfoResponse&);
  GetLatestCommittedCompactionInfoResponse() noexcept {
  }

  virtual ~GetLatestCommittedCompactionInfoResponse() noexcept;
  std::vector<CompactionInfoStruct>  compactions;

  void __set_compactions(const std::vector<CompactionInfoStruct> & val);

  bool operator == (const GetLatestCommittedCompactionInfoResponse & rhs) const
  {
    if (!(compactions == rhs.compactions))
      return false;
    return true;
  }
  bool operator != (const GetLatestCommittedCompactionInfoResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetLatestCommittedCompactionInfoResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetLatestCommittedCompactionInfoResponse &a, GetLatestCommittedCompactionInfoResponse &b);

std::ostream& operator<<(std::ostream& out, const GetLatestCommittedCompactionInfoResponse& obj);

typedef struct _FindNextCompactRequest__isset {
  _FindNextCompactRequest__isset() : workerId(false), workerVersion(false), poolName(false) {}
  bool workerId :1;
  bool workerVersion :1;
  bool poolName :1;
} _FindNextCompactRequest__isset;

class FindNextCompactRequest : public virtual ::apache::thrift::TBase {
 public:

  FindNextCompactRequest(const FindNextCompactRequest&);
  FindNextCompactRequest& operator=(const FindNextCompactRequest&);
  FindNextCompactRequest() noexcept
                         : workerId(),
                           workerVersion(),
                           poolName() {
  }

  virtual ~FindNextCompactRequest() noexcept;
  std::string workerId;
  std::string workerVersion;
  std::string poolName;

  _FindNextCompactRequest__isset __isset;

  void __set_workerId(const std::string& val);

  void __set_workerVersion(const std::string& val);

  void __set_poolName(const std::string& val);

  bool operator == (const FindNextCompactRequest & rhs) const
  {
    if (__isset.workerId != rhs.__isset.workerId)
      return false;
    else if (__isset.workerId && !(workerId == rhs.workerId))
      return false;
    if (__isset.workerVersion != rhs.__isset.workerVersion)
      return false;
    else if (__isset.workerVersion && !(workerVersion == rhs.workerVersion))
      return false;
    if (__isset.poolName != rhs.__isset.poolName)
      return false;
    else if (__isset.poolName && !(poolName == rhs.poolName))
      return false;
    return true;
  }
  bool operator != (const FindNextCompactRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FindNextCompactRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FindNextCompactRequest &a, FindNextCompactRequest &b);

std::ostream& operator<<(std::ostream& out, const FindNextCompactRequest& obj);

typedef struct _AddDynamicPartitions__isset {
  _AddDynamicPartitions__isset() : operationType(true) {}
  bool operationType :1;
} _AddDynamicPartitions__isset;

class AddDynamicPartitions : public virtual ::apache::thrift::TBase {
 public:

  AddDynamicPartitions(const AddDynamicPartitions&);
  AddDynamicPartitions& operator=(const AddDynamicPartitions&);
  AddDynamicPartitions() noexcept
                       : txnid(0),
                         writeid(0),
                         dbname(),
                         tablename(),
                         operationType((DataOperationType::type)5) {
    operationType = (DataOperationType::type)5;

  }

  virtual ~AddDynamicPartitions() noexcept;
  int64_t txnid;
  int64_t writeid;
  std::string dbname;
  std::string tablename;
  std::vector<std::string>  partitionnames;
  /**
   *
   * @see DataOperationType
   */
  DataOperationType::type operationType;

  _AddDynamicPartitions__isset __isset;

  void __set_txnid(const int64_t val);

  void __set_writeid(const int64_t val);

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionnames(const std::vector<std::string> & val);

  void __set_operationType(const DataOperationType::type val);

  bool operator == (const AddDynamicPartitions & rhs) const
  {
    if (!(txnid == rhs.txnid))
      return false;
    if (!(writeid == rhs.writeid))
      return false;
    if (!(dbname == rhs.dbname))
      return false;
    if (!(tablename == rhs.tablename))
      return false;
    if (!(partitionnames == rhs.partitionnames))
      return false;
    if (__isset.operationType != rhs.__isset.operationType)
      return false;
    else if (__isset.operationType && !(operationType == rhs.operationType))
      return false;
    return true;
  }
  bool operator != (const AddDynamicPartitions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddDynamicPartitions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddDynamicPartitions &a, AddDynamicPartitions &b);

std::ostream& operator<<(std::ostream& out, const AddDynamicPartitions& obj);

typedef struct _BasicTxnInfo__isset {
  _BasicTxnInfo__isset() : time(false), txnid(false), dbname(false), tablename(false), partitionname(false) {}
  bool time :1;
  bool txnid :1;
  bool dbname :1;
  bool tablename :1;
  bool partitionname :1;
} _BasicTxnInfo__isset;

class BasicTxnInfo : public virtual ::apache::thrift::TBase {
 public:

  BasicTxnInfo(const BasicTxnInfo&);
  BasicTxnInfo& operator=(const BasicTxnInfo&);
  BasicTxnInfo() noexcept
               : isnull(0),
                 time(0),
                 txnid(0),
                 dbname(),
                 tablename(),
                 partitionname() {
  }

  virtual ~BasicTxnInfo() noexcept;
  bool isnull;
  int64_t time;
  int64_t txnid;
  std::string dbname;
  std::string tablename;
  std::string partitionname;

  _BasicTxnInfo__isset __isset;

  void __set_isnull(const bool val);

  void __set_time(const int64_t val);

  void __set_txnid(const int64_t val);

  void __set_dbname(const std::string& val);

  void __set_tablename(const std::string& val);

  void __set_partitionname(const std::string& val);

  bool operator == (const BasicTxnInfo & rhs) const
  {
    if (!(isnull == rhs.isnull))
      return false;
    if (__isset.time != rhs.__isset.time)
      return false;
    else if (__isset.time && !(time == rhs.time))
      return false;
    if (__isset.txnid != rhs.__isset.txnid)
      return false;
    else if (__isset.txnid && !(txnid == rhs.txnid))
      return false;
    if (__isset.dbname != rhs.__isset.dbname)
      return false;
    else if (__isset.dbname && !(dbname == rhs.dbname))
      return false;
    if (__isset.tablename != rhs.__isset.tablename)
      return false;
    else if (__isset.tablename && !(tablename == rhs.tablename))
      return false;
    if (__isset.partitionname != rhs.__isset.partitionname)
      return false;
    else if (__isset.partitionname && !(partitionname == rhs.partitionname))
      return false;
    return true;
  }
  bool operator != (const BasicTxnInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BasicTxnInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(BasicTxnInfo &a, BasicTxnInfo &b);

std::ostream& operator<<(std::ostream& out, const BasicTxnInfo& obj);

typedef struct _NotificationEventRequest__isset {
  _NotificationEventRequest__isset() : maxEvents(false), eventTypeSkipList(false), catName(false), dbName(false), tableNames(false) {}
  bool maxEvents :1;
  bool eventTypeSkipList :1;
  bool catName :1;
  bool dbName :1;
  bool tableNames :1;
} _NotificationEventRequest__isset;

class NotificationEventRequest : public virtual ::apache::thrift::TBase {
 public:

  NotificationEventRequest(const NotificationEventRequest&);
  NotificationEventRequest& operator=(const NotificationEventRequest&);
  NotificationEventRequest() noexcept
                           : lastEvent(0),
                             maxEvents(0),
                             catName(),
                             dbName() {
  }

  virtual ~NotificationEventRequest() noexcept;
  int64_t lastEvent;
  int32_t maxEvents;
  std::vector<std::string>  eventTypeSkipList;
  std::string catName;
  std::string dbName;
  std::vector<std::string>  tableNames;

  _NotificationEventRequest__isset __isset;

  void __set_lastEvent(const int64_t val);

  void __set_maxEvents(const int32_t val);

  void __set_eventTypeSkipList(const std::vector<std::string> & val);

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tableNames(const std::vector<std::string> & val);

  bool operator == (const NotificationEventRequest & rhs) const
  {
    if (!(lastEvent == rhs.lastEvent))
      return false;
    if (__isset.maxEvents != rhs.__isset.maxEvents)
      return false;
    else if (__isset.maxEvents && !(maxEvents == rhs.maxEvents))
      return false;
    if (__isset.eventTypeSkipList != rhs.__isset.eventTypeSkipList)
      return false;
    else if (__isset.eventTypeSkipList && !(eventTypeSkipList == rhs.eventTypeSkipList))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.dbName != rhs.__isset.dbName)
      return false;
    else if (__isset.dbName && !(dbName == rhs.dbName))
      return false;
    if (__isset.tableNames != rhs.__isset.tableNames)
      return false;
    else if (__isset.tableNames && !(tableNames == rhs.tableNames))
      return false;
    return true;
  }
  bool operator != (const NotificationEventRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEventRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEventRequest &a, NotificationEventRequest &b);

std::ostream& operator<<(std::ostream& out, const NotificationEventRequest& obj);

typedef struct _NotificationEvent__isset {
  _NotificationEvent__isset() : dbName(false), tableName(false), messageFormat(false), catName(false) {}
  bool dbName :1;
  bool tableName :1;
  bool messageFormat :1;
  bool catName :1;
} _NotificationEvent__isset;

class NotificationEvent : public virtual ::apache::thrift::TBase {
 public:

  NotificationEvent(const NotificationEvent&);
  NotificationEvent& operator=(const NotificationEvent&);
  NotificationEvent() noexcept
                    : eventId(0),
                      eventTime(0),
                      eventType(),
                      dbName(),
                      tableName(),
                      message(),
                      messageFormat(),
                      catName() {
  }

  virtual ~NotificationEvent() noexcept;
  int64_t eventId;
  int32_t eventTime;
  std::string eventType;
  std::string dbName;
  std::string tableName;
  std::string message;
  std::string messageFormat;
  std::string catName;

  _NotificationEvent__isset __isset;

  void __set_eventId(const int64_t val);

  void __set_eventTime(const int32_t val);

  void __set_eventType(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_message(const std::string& val);

  void __set_messageFormat(const std::string& val);

  void __set_catName(const std::string& val);

  bool operator == (const NotificationEvent & rhs) const
  {
    if (!(eventId == rhs.eventId))
      return false;
    if (!(eventTime == rhs.eventTime))
      return false;
    if (!(eventType == rhs.eventType))
      return false;
    if (__isset.dbName != rhs.__isset.dbName)
      return false;
    else if (__isset.dbName && !(dbName == rhs.dbName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (!(message == rhs.message))
      return false;
    if (__isset.messageFormat != rhs.__isset.messageFormat)
      return false;
    else if (__isset.messageFormat && !(messageFormat == rhs.messageFormat))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    return true;
  }
  bool operator != (const NotificationEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEvent &a, NotificationEvent &b);

std::ostream& operator<<(std::ostream& out, const NotificationEvent& obj);


class NotificationEventResponse : public virtual ::apache::thrift::TBase {
 public:

  NotificationEventResponse(const NotificationEventResponse&);
  NotificationEventResponse& operator=(const NotificationEventResponse&);
  NotificationEventResponse() noexcept {
  }

  virtual ~NotificationEventResponse() noexcept;
  std::vector<NotificationEvent>  events;

  void __set_events(const std::vector<NotificationEvent> & val);

  bool operator == (const NotificationEventResponse & rhs) const
  {
    if (!(events == rhs.events))
      return false;
    return true;
  }
  bool operator != (const NotificationEventResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEventResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEventResponse &a, NotificationEventResponse &b);

std::ostream& operator<<(std::ostream& out, const NotificationEventResponse& obj);


class CurrentNotificationEventId : public virtual ::apache::thrift::TBase {
 public:

  CurrentNotificationEventId(const CurrentNotificationEventId&) noexcept;
  CurrentNotificationEventId& operator=(const CurrentNotificationEventId&) noexcept;
  CurrentNotificationEventId() noexcept
                             : eventId(0) {
  }

  virtual ~CurrentNotificationEventId() noexcept;
  int64_t eventId;

  void __set_eventId(const int64_t val);

  bool operator == (const CurrentNotificationEventId & rhs) const
  {
    if (!(eventId == rhs.eventId))
      return false;
    return true;
  }
  bool operator != (const CurrentNotificationEventId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CurrentNotificationEventId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CurrentNotificationEventId &a, CurrentNotificationEventId &b);

std::ostream& operator<<(std::ostream& out, const CurrentNotificationEventId& obj);

typedef struct _NotificationEventsCountRequest__isset {
  _NotificationEventsCountRequest__isset() : catName(false), toEventId(false), limit(false), tableNames(false) {}
  bool catName :1;
  bool toEventId :1;
  bool limit :1;
  bool tableNames :1;
} _NotificationEventsCountRequest__isset;

class NotificationEventsCountRequest : public virtual ::apache::thrift::TBase {
 public:

  NotificationEventsCountRequest(const NotificationEventsCountRequest&);
  NotificationEventsCountRequest& operator=(const NotificationEventsCountRequest&);
  NotificationEventsCountRequest() noexcept
                                 : fromEventId(0),
                                   dbName(),
                                   catName(),
                                   toEventId(0),
                                   limit(0) {
  }

  virtual ~NotificationEventsCountRequest() noexcept;
  int64_t fromEventId;
  std::string dbName;
  std::string catName;
  int64_t toEventId;
  int64_t limit;
  std::vector<std::string>  tableNames;

  _NotificationEventsCountRequest__isset __isset;

  void __set_fromEventId(const int64_t val);

  void __set_dbName(const std::string& val);

  void __set_catName(const std::string& val);

  void __set_toEventId(const int64_t val);

  void __set_limit(const int64_t val);

  void __set_tableNames(const std::vector<std::string> & val);

  bool operator == (const NotificationEventsCountRequest & rhs) const
  {
    if (!(fromEventId == rhs.fromEventId))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.toEventId != rhs.__isset.toEventId)
      return false;
    else if (__isset.toEventId && !(toEventId == rhs.toEventId))
      return false;
    if (__isset.limit != rhs.__isset.limit)
      return false;
    else if (__isset.limit && !(limit == rhs.limit))
      return false;
    if (__isset.tableNames != rhs.__isset.tableNames)
      return false;
    else if (__isset.tableNames && !(tableNames == rhs.tableNames))
      return false;
    return true;
  }
  bool operator != (const NotificationEventsCountRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEventsCountRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEventsCountRequest &a, NotificationEventsCountRequest &b);

std::ostream& operator<<(std::ostream& out, const NotificationEventsCountRequest& obj);


class NotificationEventsCountResponse : public virtual ::apache::thrift::TBase {
 public:

  NotificationEventsCountResponse(const NotificationEventsCountResponse&) noexcept;
  NotificationEventsCountResponse& operator=(const NotificationEventsCountResponse&) noexcept;
  NotificationEventsCountResponse() noexcept
                                  : eventsCount(0) {
  }

  virtual ~NotificationEventsCountResponse() noexcept;
  int64_t eventsCount;

  void __set_eventsCount(const int64_t val);

  bool operator == (const NotificationEventsCountResponse & rhs) const
  {
    if (!(eventsCount == rhs.eventsCount))
      return false;
    return true;
  }
  bool operator != (const NotificationEventsCountResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotificationEventsCountResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(NotificationEventsCountResponse &a, NotificationEventsCountResponse &b);

std::ostream& operator<<(std::ostream& out, const NotificationEventsCountResponse& obj);

typedef struct _InsertEventRequestData__isset {
  _InsertEventRequestData__isset() : replace(false), filesAddedChecksum(false), subDirectoryList(false), partitionVal(false) {}
  bool replace :1;
  bool filesAddedChecksum :1;
  bool subDirectoryList :1;
  bool partitionVal :1;
} _InsertEventRequestData__isset;

class InsertEventRequestData : public virtual ::apache::thrift::TBase {
 public:

  InsertEventRequestData(const InsertEventRequestData&);
  InsertEventRequestData& operator=(const InsertEventRequestData&);
  InsertEventRequestData() noexcept
                         : replace(0) {
  }

  virtual ~InsertEventRequestData() noexcept;
  bool replace;
  std::vector<std::string>  filesAdded;
  std::vector<std::string>  filesAddedChecksum;
  std::vector<std::string>  subDirectoryList;
  std::vector<std::string>  partitionVal;

  _InsertEventRequestData__isset __isset;

  void __set_replace(const bool val);

  void __set_filesAdded(const std::vector<std::string> & val);

  void __set_filesAddedChecksum(const std::vector<std::string> & val);

  void __set_subDirectoryList(const std::vector<std::string> & val);

  void __set_partitionVal(const std::vector<std::string> & val);

  bool operator == (const InsertEventRequestData & rhs) const
  {
    if (__isset.replace != rhs.__isset.replace)
      return false;
    else if (__isset.replace && !(replace == rhs.replace))
      return false;
    if (!(filesAdded == rhs.filesAdded))
      return false;
    if (__isset.filesAddedChecksum != rhs.__isset.filesAddedChecksum)
      return false;
    else if (__isset.filesAddedChecksum && !(filesAddedChecksum == rhs.filesAddedChecksum))
      return false;
    if (__isset.subDirectoryList != rhs.__isset.subDirectoryList)
      return false;
    else if (__isset.subDirectoryList && !(subDirectoryList == rhs.subDirectoryList))
      return false;
    if (__isset.partitionVal != rhs.__isset.partitionVal)
      return false;
    else if (__isset.partitionVal && !(partitionVal == rhs.partitionVal))
      return false;
    return true;
  }
  bool operator != (const InsertEventRequestData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InsertEventRequestData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(InsertEventRequestData &a, InsertEventRequestData &b);

std::ostream& operator<<(std::ostream& out, const InsertEventRequestData& obj);

typedef struct _FireEventRequestData__isset {
  _FireEventRequestData__isset() : insertData(false), insertDatas(false), refreshEvent(false) {}
  bool insertData :1;
  bool insertDatas :1;
  bool refreshEvent :1;
} _FireEventRequestData__isset;

class FireEventRequestData : public virtual ::apache::thrift::TBase {
 public:

  FireEventRequestData(const FireEventRequestData&);
  FireEventRequestData& operator=(const FireEventRequestData&);
  FireEventRequestData() noexcept
                       : refreshEvent(0) {
  }

  virtual ~FireEventRequestData() noexcept;
  InsertEventRequestData insertData;
  std::vector<InsertEventRequestData>  insertDatas;
  bool refreshEvent;

  _FireEventRequestData__isset __isset;

  void __set_insertData(const InsertEventRequestData& val);

  void __set_insertDatas(const std::vector<InsertEventRequestData> & val);

  void __set_refreshEvent(const bool val);

  bool operator == (const FireEventRequestData & rhs) const
  {
    if (__isset.insertData != rhs.__isset.insertData)
      return false;
    else if (__isset.insertData && !(insertData == rhs.insertData))
      return false;
    if (__isset.insertDatas != rhs.__isset.insertDatas)
      return false;
    else if (__isset.insertDatas && !(insertDatas == rhs.insertDatas))
      return false;
    if (__isset.refreshEvent != rhs.__isset.refreshEvent)
      return false;
    else if (__isset.refreshEvent && !(refreshEvent == rhs.refreshEvent))
      return false;
    return true;
  }
  bool operator != (const FireEventRequestData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FireEventRequestData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FireEventRequestData &a, FireEventRequestData &b);

std::ostream& operator<<(std::ostream& out, const FireEventRequestData& obj);

typedef struct _FireEventRequest__isset {
  _FireEventRequest__isset() : dbName(false), tableName(false), partitionVals(false), catName(false), tblParams(false) {}
  bool dbName :1;
  bool tableName :1;
  bool partitionVals :1;
  bool catName :1;
  bool tblParams :1;
} _FireEventRequest__isset;

class FireEventRequest : public virtual ::apache::thrift::TBase {
 public:

  FireEventRequest(const FireEventRequest&);
  FireEventRequest& operator=(const FireEventRequest&);
  FireEventRequest() noexcept
                   : successful(0),
                     dbName(),
                     tableName(),
                     catName() {
  }

  virtual ~FireEventRequest() noexcept;
  bool successful;
  FireEventRequestData data;
  std::string dbName;
  std::string tableName;
  std::vector<std::string>  partitionVals;
  std::string catName;
  std::map<std::string, std::string>  tblParams;

  _FireEventRequest__isset __isset;

  void __set_successful(const bool val);

  void __set_data(const FireEventRequestData& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_partitionVals(const std::vector<std::string> & val);

  void __set_catName(const std::string& val);

  void __set_tblParams(const std::map<std::string, std::string> & val);

  bool operator == (const FireEventRequest & rhs) const
  {
    if (!(successful == rhs.successful))
      return false;
    if (!(data == rhs.data))
      return false;
    if (__isset.dbName != rhs.__isset.dbName)
      return false;
    else if (__isset.dbName && !(dbName == rhs.dbName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (__isset.partitionVals != rhs.__isset.partitionVals)
      return false;
    else if (__isset.partitionVals && !(partitionVals == rhs.partitionVals))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.tblParams != rhs.__isset.tblParams)
      return false;
    else if (__isset.tblParams && !(tblParams == rhs.tblParams))
      return false;
    return true;
  }
  bool operator != (const FireEventRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FireEventRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FireEventRequest &a, FireEventRequest &b);

std::ostream& operator<<(std::ostream& out, const FireEventRequest& obj);

typedef struct _FireEventResponse__isset {
  _FireEventResponse__isset() : eventIds(false) {}
  bool eventIds :1;
} _FireEventResponse__isset;

class FireEventResponse : public virtual ::apache::thrift::TBase {
 public:

  FireEventResponse(const FireEventResponse&);
  FireEventResponse& operator=(const FireEventResponse&);
  FireEventResponse() noexcept {
  }

  virtual ~FireEventResponse() noexcept;
  std::vector<int64_t>  eventIds;

  _FireEventResponse__isset __isset;

  void __set_eventIds(const std::vector<int64_t> & val);

  bool operator == (const FireEventResponse & rhs) const
  {
    if (!(eventIds == rhs.eventIds))
      return false;
    return true;
  }
  bool operator != (const FireEventResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FireEventResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FireEventResponse &a, FireEventResponse &b);

std::ostream& operator<<(std::ostream& out, const FireEventResponse& obj);

typedef struct _WriteNotificationLogRequest__isset {
  _WriteNotificationLogRequest__isset() : partitionVals(false) {}
  bool partitionVals :1;
} _WriteNotificationLogRequest__isset;

class WriteNotificationLogRequest : public virtual ::apache::thrift::TBase {
 public:

  WriteNotificationLogRequest(const WriteNotificationLogRequest&);
  WriteNotificationLogRequest& operator=(const WriteNotificationLogRequest&);
  WriteNotificationLogRequest() noexcept
                              : txnId(0),
                                writeId(0),
                                db(),
                                table() {
  }

  virtual ~WriteNotificationLogRequest() noexcept;
  int64_t txnId;
  int64_t writeId;
  std::string db;
  std::string table;
  InsertEventRequestData fileInfo;
  std::vector<std::string>  partitionVals;

  _WriteNotificationLogRequest__isset __isset;

  void __set_txnId(const int64_t val);

  void __set_writeId(const int64_t val);

  void __set_db(const std::string& val);

  void __set_table(const std::string& val);

  void __set_fileInfo(const InsertEventRequestData& val);

  void __set_partitionVals(const std::vector<std::string> & val);

  bool operator == (const WriteNotificationLogRequest & rhs) const
  {
    if (!(txnId == rhs.txnId))
      return false;
    if (!(writeId == rhs.writeId))
      return false;
    if (!(db == rhs.db))
      return false;
    if (!(table == rhs.table))
      return false;
    if (!(fileInfo == rhs.fileInfo))
      return false;
    if (__isset.partitionVals != rhs.__isset.partitionVals)
      return false;
    else if (__isset.partitionVals && !(partitionVals == rhs.partitionVals))
      return false;
    return true;
  }
  bool operator != (const WriteNotificationLogRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WriteNotificationLogRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WriteNotificationLogRequest &a, WriteNotificationLogRequest &b);

std::ostream& operator<<(std::ostream& out, const WriteNotificationLogRequest& obj);


class WriteNotificationLogResponse : public virtual ::apache::thrift::TBase {
 public:

  WriteNotificationLogResponse(const WriteNotificationLogResponse&) noexcept;
  WriteNotificationLogResponse& operator=(const WriteNotificationLogResponse&) noexcept;
  WriteNotificationLogResponse() noexcept {
  }

  virtual ~WriteNotificationLogResponse() noexcept;

  bool operator == (const WriteNotificationLogResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WriteNotificationLogResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WriteNotificationLogResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WriteNotificationLogResponse &a, WriteNotificationLogResponse &b);

std::ostream& operator<<(std::ostream& out, const WriteNotificationLogResponse& obj);


class WriteNotificationLogBatchRequest : public virtual ::apache::thrift::TBase {
 public:

  WriteNotificationLogBatchRequest(const WriteNotificationLogBatchRequest&);
  WriteNotificationLogBatchRequest& operator=(const WriteNotificationLogBatchRequest&);
  WriteNotificationLogBatchRequest() noexcept
                                   : catalog(),
                                     db(),
                                     table() {
  }

  virtual ~WriteNotificationLogBatchRequest() noexcept;
  std::string catalog;
  std::string db;
  std::string table;
  std::vector<WriteNotificationLogRequest>  requestList;

  void __set_catalog(const std::string& val);

  void __set_db(const std::string& val);

  void __set_table(const std::string& val);

  void __set_requestList(const std::vector<WriteNotificationLogRequest> & val);

  bool operator == (const WriteNotificationLogBatchRequest & rhs) const
  {
    if (!(catalog == rhs.catalog))
      return false;
    if (!(db == rhs.db))
      return false;
    if (!(table == rhs.table))
      return false;
    if (!(requestList == rhs.requestList))
      return false;
    return true;
  }
  bool operator != (const WriteNotificationLogBatchRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WriteNotificationLogBatchRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WriteNotificationLogBatchRequest &a, WriteNotificationLogBatchRequest &b);

std::ostream& operator<<(std::ostream& out, const WriteNotificationLogBatchRequest& obj);


class WriteNotificationLogBatchResponse : public virtual ::apache::thrift::TBase {
 public:

  WriteNotificationLogBatchResponse(const WriteNotificationLogBatchResponse&) noexcept;
  WriteNotificationLogBatchResponse& operator=(const WriteNotificationLogBatchResponse&) noexcept;
  WriteNotificationLogBatchResponse() noexcept {
  }

  virtual ~WriteNotificationLogBatchResponse() noexcept;

  bool operator == (const WriteNotificationLogBatchResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WriteNotificationLogBatchResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WriteNotificationLogBatchResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WriteNotificationLogBatchResponse &a, WriteNotificationLogBatchResponse &b);

std::ostream& operator<<(std::ostream& out, const WriteNotificationLogBatchResponse& obj);

typedef struct _MetadataPpdResult__isset {
  _MetadataPpdResult__isset() : metadata(false), includeBitset(false) {}
  bool metadata :1;
  bool includeBitset :1;
} _MetadataPpdResult__isset;

class MetadataPpdResult : public virtual ::apache::thrift::TBase {
 public:

  MetadataPpdResult(const MetadataPpdResult&);
  MetadataPpdResult& operator=(const MetadataPpdResult&);
  MetadataPpdResult() noexcept
                    : metadata(),
                      includeBitset() {
  }

  virtual ~MetadataPpdResult() noexcept;
  std::string metadata;
  std::string includeBitset;

  _MetadataPpdResult__isset __isset;

  void __set_metadata(const std::string& val);

  void __set_includeBitset(const std::string& val);

  bool operator == (const MetadataPpdResult & rhs) const
  {
    if (__isset.metadata != rhs.__isset.metadata)
      return false;
    else if (__isset.metadata && !(metadata == rhs.metadata))
      return false;
    if (__isset.includeBitset != rhs.__isset.includeBitset)
      return false;
    else if (__isset.includeBitset && !(includeBitset == rhs.includeBitset))
      return false;
    return true;
  }
  bool operator != (const MetadataPpdResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MetadataPpdResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(MetadataPpdResult &a, MetadataPpdResult &b);

std::ostream& operator<<(std::ostream& out, const MetadataPpdResult& obj);


class GetFileMetadataByExprResult : public virtual ::apache::thrift::TBase {
 public:

  GetFileMetadataByExprResult(const GetFileMetadataByExprResult&);
  GetFileMetadataByExprResult& operator=(const GetFileMetadataByExprResult&);
  GetFileMetadataByExprResult() noexcept
                              : isSupported(0) {
  }

  virtual ~GetFileMetadataByExprResult() noexcept;
  std::map<int64_t, MetadataPpdResult>  metadata;
  bool isSupported;

  void __set_metadata(const std::map<int64_t, MetadataPpdResult> & val);

  void __set_isSupported(const bool val);

  bool operator == (const GetFileMetadataByExprResult & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (!(isSupported == rhs.isSupported))
      return false;
    return true;
  }
  bool operator != (const GetFileMetadataByExprResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFileMetadataByExprResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFileMetadataByExprResult &a, GetFileMetadataByExprResult &b);

std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprResult& obj);

typedef struct _GetFileMetadataByExprRequest__isset {
  _GetFileMetadataByExprRequest__isset() : doGetFooters(false), type(false) {}
  bool doGetFooters :1;
  bool type :1;
} _GetFileMetadataByExprRequest__isset;

class GetFileMetadataByExprRequest : public virtual ::apache::thrift::TBase {
 public:

  GetFileMetadataByExprRequest(const GetFileMetadataByExprRequest&);
  GetFileMetadataByExprRequest& operator=(const GetFileMetadataByExprRequest&);
  GetFileMetadataByExprRequest() noexcept
                               : expr(),
                                 doGetFooters(0),
                                 type(static_cast<FileMetadataExprType::type>(0)) {
  }

  virtual ~GetFileMetadataByExprRequest() noexcept;
  std::vector<int64_t>  fileIds;
  std::string expr;
  bool doGetFooters;
  /**
   *
   * @see FileMetadataExprType
   */
  FileMetadataExprType::type type;

  _GetFileMetadataByExprRequest__isset __isset;

  void __set_fileIds(const std::vector<int64_t> & val);

  void __set_expr(const std::string& val);

  void __set_doGetFooters(const bool val);

  void __set_type(const FileMetadataExprType::type val);

  bool operator == (const GetFileMetadataByExprRequest & rhs) const
  {
    if (!(fileIds == rhs.fileIds))
      return false;
    if (!(expr == rhs.expr))
      return false;
    if (__isset.doGetFooters != rhs.__isset.doGetFooters)
      return false;
    else if (__isset.doGetFooters && !(doGetFooters == rhs.doGetFooters))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const GetFileMetadataByExprRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFileMetadataByExprRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFileMetadataByExprRequest &a, GetFileMetadataByExprRequest &b);

std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprRequest& obj);


class GetFileMetadataResult : public virtual ::apache::thrift::TBase {
 public:

  GetFileMetadataResult(const GetFileMetadataResult&);
  GetFileMetadataResult& operator=(const GetFileMetadataResult&);
  GetFileMetadataResult() noexcept
                        : isSupported(0) {
  }

  virtual ~GetFileMetadataResult() noexcept;
  std::map<int64_t, std::string>  metadata;
  bool isSupported;

  void __set_metadata(const std::map<int64_t, std::string> & val);

  void __set_isSupported(const bool val);

  bool operator == (const GetFileMetadataResult & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (!(isSupported == rhs.isSupported))
      return false;
    return true;
  }
  bool operator != (const GetFileMetadataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFileMetadataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFileMetadataResult &a, GetFileMetadataResult &b);

std::ostream& operator<<(std::ostream& out, const GetFileMetadataResult& obj);


class GetFileMetadataRequest : public virtual ::apache::thrift::TBase {
 public:

  GetFileMetadataRequest(const GetFileMetadataRequest&);
  GetFileMetadataRequest& operator=(const GetFileMetadataRequest&);
  GetFileMetadataRequest() noexcept {
  }

  virtual ~GetFileMetadataRequest() noexcept;
  std::vector<int64_t>  fileIds;

  void __set_fileIds(const std::vector<int64_t> & val);

  bool operator == (const GetFileMetadataRequest & rhs) const
  {
    if (!(fileIds == rhs.fileIds))
      return false;
    return true;
  }
  bool operator != (const GetFileMetadataRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFileMetadataRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFileMetadataRequest &a, GetFileMetadataRequest &b);

std::ostream& operator<<(std::ostream& out, const GetFileMetadataRequest& obj);


class PutFileMetadataResult : public virtual ::apache::thrift::TBase {
 public:

  PutFileMetadataResult(const PutFileMetadataResult&) noexcept;
  PutFileMetadataResult& operator=(const PutFileMetadataResult&) noexcept;
  PutFileMetadataResult() noexcept {
  }

  virtual ~PutFileMetadataResult() noexcept;

  bool operator == (const PutFileMetadataResult & /* rhs */) const
  {
    return true;
  }
  bool operator != (const PutFileMetadataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PutFileMetadataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PutFileMetadataResult &a, PutFileMetadataResult &b);

std::ostream& operator<<(std::ostream& out, const PutFileMetadataResult& obj);

typedef struct _PutFileMetadataRequest__isset {
  _PutFileMetadataRequest__isset() : type(false) {}
  bool type :1;
} _PutFileMetadataRequest__isset;

class PutFileMetadataRequest : public virtual ::apache::thrift::TBase {
 public:

  PutFileMetadataRequest(const PutFileMetadataRequest&);
  PutFileMetadataRequest& operator=(const PutFileMetadataRequest&);
  PutFileMetadataRequest() noexcept
                         : type(static_cast<FileMetadataExprType::type>(0)) {
  }

  virtual ~PutFileMetadataRequest() noexcept;
  std::vector<int64_t>  fileIds;
  std::vector<std::string>  metadata;
  /**
   *
   * @see FileMetadataExprType
   */
  FileMetadataExprType::type type;

  _PutFileMetadataRequest__isset __isset;

  void __set_fileIds(const std::vector<int64_t> & val);

  void __set_metadata(const std::vector<std::string> & val);

  void __set_type(const FileMetadataExprType::type val);

  bool operator == (const PutFileMetadataRequest & rhs) const
  {
    if (!(fileIds == rhs.fileIds))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const PutFileMetadataRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PutFileMetadataRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PutFileMetadataRequest &a, PutFileMetadataRequest &b);

std::ostream& operator<<(std::ostream& out, const PutFileMetadataRequest& obj);


class ClearFileMetadataResult : public virtual ::apache::thrift::TBase {
 public:

  ClearFileMetadataResult(const ClearFileMetadataResult&) noexcept;
  ClearFileMetadataResult& operator=(const ClearFileMetadataResult&) noexcept;
  ClearFileMetadataResult() noexcept {
  }

  virtual ~ClearFileMetadataResult() noexcept;

  bool operator == (const ClearFileMetadataResult & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ClearFileMetadataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClearFileMetadataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ClearFileMetadataResult &a, ClearFileMetadataResult &b);

std::ostream& operator<<(std::ostream& out, const ClearFileMetadataResult& obj);


class ClearFileMetadataRequest : public virtual ::apache::thrift::TBase {
 public:

  ClearFileMetadataRequest(const ClearFileMetadataRequest&);
  ClearFileMetadataRequest& operator=(const ClearFileMetadataRequest&);
  ClearFileMetadataRequest() noexcept {
  }

  virtual ~ClearFileMetadataRequest() noexcept;
  std::vector<int64_t>  fileIds;

  void __set_fileIds(const std::vector<int64_t> & val);

  bool operator == (const ClearFileMetadataRequest & rhs) const
  {
    if (!(fileIds == rhs.fileIds))
      return false;
    return true;
  }
  bool operator != (const ClearFileMetadataRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClearFileMetadataRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ClearFileMetadataRequest &a, ClearFileMetadataRequest &b);

std::ostream& operator<<(std::ostream& out, const ClearFileMetadataRequest& obj);


class CacheFileMetadataResult : public virtual ::apache::thrift::TBase {
 public:

  CacheFileMetadataResult(const CacheFileMetadataResult&) noexcept;
  CacheFileMetadataResult& operator=(const CacheFileMetadataResult&) noexcept;
  CacheFileMetadataResult() noexcept
                          : isSupported(0) {
  }

  virtual ~CacheFileMetadataResult() noexcept;
  bool isSupported;

  void __set_isSupported(const bool val);

  bool operator == (const CacheFileMetadataResult & rhs) const
  {
    if (!(isSupported == rhs.isSupported))
      return false;
    return true;
  }
  bool operator != (const CacheFileMetadataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CacheFileMetadataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CacheFileMetadataResult &a, CacheFileMetadataResult &b);

std::ostream& operator<<(std::ostream& out, const CacheFileMetadataResult& obj);

typedef struct _CacheFileMetadataRequest__isset {
  _CacheFileMetadataRequest__isset() : partName(false), isAllParts(false) {}
  bool partName :1;
  bool isAllParts :1;
} _CacheFileMetadataRequest__isset;

class CacheFileMetadataRequest : public virtual ::apache::thrift::TBase {
 public:

  CacheFileMetadataRequest(const CacheFileMetadataRequest&);
  CacheFileMetadataRequest& operator=(const CacheFileMetadataRequest&);
  CacheFileMetadataRequest() noexcept
                           : dbName(),
                             tblName(),
                             partName(),
                             isAllParts(0) {
  }

  virtual ~CacheFileMetadataRequest() noexcept;
  std::string dbName;
  std::string tblName;
  std::string partName;
  bool isAllParts;

  _CacheFileMetadataRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_partName(const std::string& val);

  void __set_isAllParts(const bool val);

  bool operator == (const CacheFileMetadataRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.partName != rhs.__isset.partName)
      return false;
    else if (__isset.partName && !(partName == rhs.partName))
      return false;
    if (__isset.isAllParts != rhs.__isset.isAllParts)
      return false;
    else if (__isset.isAllParts && !(isAllParts == rhs.isAllParts))
      return false;
    return true;
  }
  bool operator != (const CacheFileMetadataRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CacheFileMetadataRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CacheFileMetadataRequest &a, CacheFileMetadataRequest &b);

std::ostream& operator<<(std::ostream& out, const CacheFileMetadataRequest& obj);

typedef struct _GetAllFunctionsResponse__isset {
  _GetAllFunctionsResponse__isset() : functions(false) {}
  bool functions :1;
} _GetAllFunctionsResponse__isset;

class GetAllFunctionsResponse : public virtual ::apache::thrift::TBase {
 public:

  GetAllFunctionsResponse(const GetAllFunctionsResponse&);
  GetAllFunctionsResponse& operator=(const GetAllFunctionsResponse&);
  GetAllFunctionsResponse() noexcept {
  }

  virtual ~GetAllFunctionsResponse() noexcept;
  std::vector<Function>  functions;

  _GetAllFunctionsResponse__isset __isset;

  void __set_functions(const std::vector<Function> & val);

  bool operator == (const GetAllFunctionsResponse & rhs) const
  {
    if (__isset.functions != rhs.__isset.functions)
      return false;
    else if (__isset.functions && !(functions == rhs.functions))
      return false;
    return true;
  }
  bool operator != (const GetAllFunctionsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetAllFunctionsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetAllFunctionsResponse &a, GetAllFunctionsResponse &b);

std::ostream& operator<<(std::ostream& out, const GetAllFunctionsResponse& obj);


class ClientCapabilities : public virtual ::apache::thrift::TBase {
 public:

  ClientCapabilities(const ClientCapabilities&);
  ClientCapabilities& operator=(const ClientCapabilities&);
  ClientCapabilities() noexcept {
  }

  virtual ~ClientCapabilities() noexcept;
  std::vector<ClientCapability::type>  values;

  void __set_values(const std::vector<ClientCapability::type> & val);

  bool operator == (const ClientCapabilities & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    return true;
  }
  bool operator != (const ClientCapabilities &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClientCapabilities & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ClientCapabilities &a, ClientCapabilities &b);

std::ostream& operator<<(std::ostream& out, const ClientCapabilities& obj);

typedef struct _GetProjectionsSpec__isset {
  _GetProjectionsSpec__isset() : fieldList(false), includeParamKeyPattern(false), excludeParamKeyPattern(false) {}
  bool fieldList :1;
  bool includeParamKeyPattern :1;
  bool excludeParamKeyPattern :1;
} _GetProjectionsSpec__isset;

class GetProjectionsSpec : public virtual ::apache::thrift::TBase {
 public:

  GetProjectionsSpec(const GetProjectionsSpec&);
  GetProjectionsSpec& operator=(const GetProjectionsSpec&);
  GetProjectionsSpec() noexcept
                     : includeParamKeyPattern(),
                       excludeParamKeyPattern() {
  }

  virtual ~GetProjectionsSpec() noexcept;
  std::vector<std::string>  fieldList;
  std::string includeParamKeyPattern;
  std::string excludeParamKeyPattern;

  _GetProjectionsSpec__isset __isset;

  void __set_fieldList(const std::vector<std::string> & val);

  void __set_includeParamKeyPattern(const std::string& val);

  void __set_excludeParamKeyPattern(const std::string& val);

  bool operator == (const GetProjectionsSpec & rhs) const
  {
    if (!(fieldList == rhs.fieldList))
      return false;
    if (!(includeParamKeyPattern == rhs.includeParamKeyPattern))
      return false;
    if (!(excludeParamKeyPattern == rhs.excludeParamKeyPattern))
      return false;
    return true;
  }
  bool operator != (const GetProjectionsSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetProjectionsSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetProjectionsSpec &a, GetProjectionsSpec &b);

std::ostream& operator<<(std::ostream& out, const GetProjectionsSpec& obj);

typedef struct _GetTableRequest__isset {
  _GetTableRequest__isset() : capabilities(false), catName(false), validWriteIdList(false), getColumnStats(false), processorCapabilities(false), processorIdentifier(false), engine(true), id(true) {}
  bool capabilities :1;
  bool catName :1;
  bool validWriteIdList :1;
  bool getColumnStats :1;
  bool processorCapabilities :1;
  bool processorIdentifier :1;
  bool engine :1;
  bool id :1;
} _GetTableRequest__isset;

class GetTableRequest : public virtual ::apache::thrift::TBase {
 public:

  GetTableRequest(const GetTableRequest&);
  GetTableRequest& operator=(const GetTableRequest&);
  GetTableRequest() : dbName(),
                      tblName(),
                      catName(),
                      validWriteIdList(),
                      getColumnStats(0),
                      processorIdentifier(),
                      engine("hive"),
                      id(-1LL) {
  }

  virtual ~GetTableRequest() noexcept;
  std::string dbName;
  std::string tblName;
  ClientCapabilities capabilities;
  std::string catName;
  std::string validWriteIdList;
  bool getColumnStats;
  std::vector<std::string>  processorCapabilities;
  std::string processorIdentifier;
  std::string engine;
  int64_t id;

  _GetTableRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_capabilities(const ClientCapabilities& val);

  void __set_catName(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_getColumnStats(const bool val);

  void __set_processorCapabilities(const std::vector<std::string> & val);

  void __set_processorIdentifier(const std::string& val);

  void __set_engine(const std::string& val);

  void __set_id(const int64_t val);

  bool operator == (const GetTableRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.capabilities != rhs.__isset.capabilities)
      return false;
    else if (__isset.capabilities && !(capabilities == rhs.capabilities))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.getColumnStats != rhs.__isset.getColumnStats)
      return false;
    else if (__isset.getColumnStats && !(getColumnStats == rhs.getColumnStats))
      return false;
    if (__isset.processorCapabilities != rhs.__isset.processorCapabilities)
      return false;
    else if (__isset.processorCapabilities && !(processorCapabilities == rhs.processorCapabilities))
      return false;
    if (__isset.processorIdentifier != rhs.__isset.processorIdentifier)
      return false;
    else if (__isset.processorIdentifier && !(processorIdentifier == rhs.processorIdentifier))
      return false;
    if (__isset.engine != rhs.__isset.engine)
      return false;
    else if (__isset.engine && !(engine == rhs.engine))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const GetTableRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTableRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTableRequest &a, GetTableRequest &b);

std::ostream& operator<<(std::ostream& out, const GetTableRequest& obj);

typedef struct _GetTableResult__isset {
  _GetTableResult__isset() : isStatsCompliant(false) {}
  bool isStatsCompliant :1;
} _GetTableResult__isset;

class GetTableResult : public virtual ::apache::thrift::TBase {
 public:

  GetTableResult(const GetTableResult&);
  GetTableResult& operator=(const GetTableResult&);
  GetTableResult() noexcept
                 : isStatsCompliant(0) {
  }

  virtual ~GetTableResult() noexcept;
  Table table;
  bool isStatsCompliant;

  _GetTableResult__isset __isset;

  void __set_table(const Table& val);

  void __set_isStatsCompliant(const bool val);

  bool operator == (const GetTableResult & rhs) const
  {
    if (!(table == rhs.table))
      return false;
    if (__isset.isStatsCompliant != rhs.__isset.isStatsCompliant)
      return false;
    else if (__isset.isStatsCompliant && !(isStatsCompliant == rhs.isStatsCompliant))
      return false;
    return true;
  }
  bool operator != (const GetTableResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTableResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTableResult &a, GetTableResult &b);

std::ostream& operator<<(std::ostream& out, const GetTableResult& obj);

typedef struct _GetTablesRequest__isset {
  _GetTablesRequest__isset() : tblNames(false), capabilities(false), catName(false), processorCapabilities(false), processorIdentifier(false), projectionSpec(false), tablesPattern(false) {}
  bool tblNames :1;
  bool capabilities :1;
  bool catName :1;
  bool processorCapabilities :1;
  bool processorIdentifier :1;
  bool projectionSpec :1;
  bool tablesPattern :1;
} _GetTablesRequest__isset;

class GetTablesRequest : public virtual ::apache::thrift::TBase {
 public:

  GetTablesRequest(const GetTablesRequest&);
  GetTablesRequest& operator=(const GetTablesRequest&);
  GetTablesRequest() noexcept
                   : dbName(),
                     catName(),
                     processorIdentifier(),
                     tablesPattern() {
  }

  virtual ~GetTablesRequest() noexcept;
  std::string dbName;
  std::vector<std::string>  tblNames;
  ClientCapabilities capabilities;
  std::string catName;
  std::vector<std::string>  processorCapabilities;
  std::string processorIdentifier;
  GetProjectionsSpec projectionSpec;
  std::string tablesPattern;

  _GetTablesRequest__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tblNames(const std::vector<std::string> & val);

  void __set_capabilities(const ClientCapabilities& val);

  void __set_catName(const std::string& val);

  void __set_processorCapabilities(const std::vector<std::string> & val);

  void __set_processorIdentifier(const std::string& val);

  void __set_projectionSpec(const GetProjectionsSpec& val);

  void __set_tablesPattern(const std::string& val);

  bool operator == (const GetTablesRequest & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (__isset.tblNames != rhs.__isset.tblNames)
      return false;
    else if (__isset.tblNames && !(tblNames == rhs.tblNames))
      return false;
    if (__isset.capabilities != rhs.__isset.capabilities)
      return false;
    else if (__isset.capabilities && !(capabilities == rhs.capabilities))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.processorCapabilities != rhs.__isset.processorCapabilities)
      return false;
    else if (__isset.processorCapabilities && !(processorCapabilities == rhs.processorCapabilities))
      return false;
    if (__isset.processorIdentifier != rhs.__isset.processorIdentifier)
      return false;
    else if (__isset.processorIdentifier && !(processorIdentifier == rhs.processorIdentifier))
      return false;
    if (__isset.projectionSpec != rhs.__isset.projectionSpec)
      return false;
    else if (__isset.projectionSpec && !(projectionSpec == rhs.projectionSpec))
      return false;
    if (__isset.tablesPattern != rhs.__isset.tablesPattern)
      return false;
    else if (__isset.tablesPattern && !(tablesPattern == rhs.tablesPattern))
      return false;
    return true;
  }
  bool operator != (const GetTablesRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTablesRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTablesRequest &a, GetTablesRequest &b);

std::ostream& operator<<(std::ostream& out, const GetTablesRequest& obj);


class GetTablesResult : public virtual ::apache::thrift::TBase {
 public:

  GetTablesResult(const GetTablesResult&);
  GetTablesResult& operator=(const GetTablesResult&);
  GetTablesResult() noexcept {
  }

  virtual ~GetTablesResult() noexcept;
  std::vector<Table>  tables;

  void __set_tables(const std::vector<Table> & val);

  bool operator == (const GetTablesResult & rhs) const
  {
    if (!(tables == rhs.tables))
      return false;
    return true;
  }
  bool operator != (const GetTablesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTablesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTablesResult &a, GetTablesResult &b);

std::ostream& operator<<(std::ostream& out, const GetTablesResult& obj);

typedef struct _GetTablesExtRequest__isset {
  _GetTablesExtRequest__isset() : limit(false), processorCapabilities(false), processorIdentifier(false) {}
  bool limit :1;
  bool processorCapabilities :1;
  bool processorIdentifier :1;
} _GetTablesExtRequest__isset;

class GetTablesExtRequest : public virtual ::apache::thrift::TBase {
 public:

  GetTablesExtRequest(const GetTablesExtRequest&);
  GetTablesExtRequest& operator=(const GetTablesExtRequest&);
  GetTablesExtRequest() noexcept
                      : catalog(),
                        database(),
                        tableNamePattern(),
                        requestedFields(0),
                        limit(0),
                        processorIdentifier() {
  }

  virtual ~GetTablesExtRequest() noexcept;
  std::string catalog;
  std::string database;
  std::string tableNamePattern;
  int32_t requestedFields;
  int32_t limit;
  std::vector<std::string>  processorCapabilities;
  std::string processorIdentifier;

  _GetTablesExtRequest__isset __isset;

  void __set_catalog(const std::string& val);

  void __set_database(const std::string& val);

  void __set_tableNamePattern(const std::string& val);

  void __set_requestedFields(const int32_t val);

  void __set_limit(const int32_t val);

  void __set_processorCapabilities(const std::vector<std::string> & val);

  void __set_processorIdentifier(const std::string& val);

  bool operator == (const GetTablesExtRequest & rhs) const
  {
    if (!(catalog == rhs.catalog))
      return false;
    if (!(database == rhs.database))
      return false;
    if (!(tableNamePattern == rhs.tableNamePattern))
      return false;
    if (!(requestedFields == rhs.requestedFields))
      return false;
    if (__isset.limit != rhs.__isset.limit)
      return false;
    else if (__isset.limit && !(limit == rhs.limit))
      return false;
    if (__isset.processorCapabilities != rhs.__isset.processorCapabilities)
      return false;
    else if (__isset.processorCapabilities && !(processorCapabilities == rhs.processorCapabilities))
      return false;
    if (__isset.processorIdentifier != rhs.__isset.processorIdentifier)
      return false;
    else if (__isset.processorIdentifier && !(processorIdentifier == rhs.processorIdentifier))
      return false;
    return true;
  }
  bool operator != (const GetTablesExtRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetTablesExtRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetTablesExtRequest &a, GetTablesExtRequest &b);

std::ostream& operator<<(std::ostream& out, const GetTablesExtRequest& obj);

typedef struct _ExtendedTableInfo__isset {
  _ExtendedTableInfo__isset() : accessType(false), requiredReadCapabilities(false), requiredWriteCapabilities(false) {}
  bool accessType :1;
  bool requiredReadCapabilities :1;
  bool requiredWriteCapabilities :1;
} _ExtendedTableInfo__isset;

class ExtendedTableInfo : public virtual ::apache::thrift::TBase {
 public:

  ExtendedTableInfo(const ExtendedTableInfo&);
  ExtendedTableInfo& operator=(const ExtendedTableInfo&);
  ExtendedTableInfo() noexcept
                    : tblName(),
                      accessType(0) {
  }

  virtual ~ExtendedTableInfo() noexcept;
  std::string tblName;
  int32_t accessType;
  std::vector<std::string>  requiredReadCapabilities;
  std::vector<std::string>  requiredWriteCapabilities;

  _ExtendedTableInfo__isset __isset;

  void __set_tblName(const std::string& val);

  void __set_accessType(const int32_t val);

  void __set_requiredReadCapabilities(const std::vector<std::string> & val);

  void __set_requiredWriteCapabilities(const std::vector<std::string> & val);

  bool operator == (const ExtendedTableInfo & rhs) const
  {
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.accessType != rhs.__isset.accessType)
      return false;
    else if (__isset.accessType && !(accessType == rhs.accessType))
      return false;
    if (__isset.requiredReadCapabilities != rhs.__isset.requiredReadCapabilities)
      return false;
    else if (__isset.requiredReadCapabilities && !(requiredReadCapabilities == rhs.requiredReadCapabilities))
      return false;
    if (__isset.requiredWriteCapabilities != rhs.__isset.requiredWriteCapabilities)
      return false;
    else if (__isset.requiredWriteCapabilities && !(requiredWriteCapabilities == rhs.requiredWriteCapabilities))
      return false;
    return true;
  }
  bool operator != (const ExtendedTableInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExtendedTableInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ExtendedTableInfo &a, ExtendedTableInfo &b);

std::ostream& operator<<(std::ostream& out, const ExtendedTableInfo& obj);

typedef struct _DropTableRequest__isset {
  _DropTableRequest__isset() : catalogName(false), deleteData(false), envContext(false), dropPartitions(false) {}
  bool catalogName :1;
  bool deleteData :1;
  bool envContext :1;
  bool dropPartitions :1;
} _DropTableRequest__isset;

class DropTableRequest : public virtual ::apache::thrift::TBase {
 public:

  DropTableRequest(const DropTableRequest&);
  DropTableRequest& operator=(const DropTableRequest&);
  DropTableRequest() noexcept
                   : catalogName(),
                     dbName(),
                     tableName(),
                     deleteData(0),
                     dropPartitions(0) {
  }

  virtual ~DropTableRequest() noexcept;
  std::string catalogName;
  std::string dbName;
  std::string tableName;
  bool deleteData;
  EnvironmentContext envContext;
  bool dropPartitions;

  _DropTableRequest__isset __isset;

  void __set_catalogName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_deleteData(const bool val);

  void __set_envContext(const EnvironmentContext& val);

  void __set_dropPartitions(const bool val);

  bool operator == (const DropTableRequest & rhs) const
  {
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.deleteData != rhs.__isset.deleteData)
      return false;
    else if (__isset.deleteData && !(deleteData == rhs.deleteData))
      return false;
    if (__isset.envContext != rhs.__isset.envContext)
      return false;
    else if (__isset.envContext && !(envContext == rhs.envContext))
      return false;
    if (__isset.dropPartitions != rhs.__isset.dropPartitions)
      return false;
    else if (__isset.dropPartitions && !(dropPartitions == rhs.dropPartitions))
      return false;
    return true;
  }
  bool operator != (const DropTableRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropTableRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropTableRequest &a, DropTableRequest &b);

std::ostream& operator<<(std::ostream& out, const DropTableRequest& obj);

typedef struct _GetDatabaseRequest__isset {
  _GetDatabaseRequest__isset() : name(false), catalogName(false), processorCapabilities(false), processorIdentifier(false) {}
  bool name :1;
  bool catalogName :1;
  bool processorCapabilities :1;
  bool processorIdentifier :1;
} _GetDatabaseRequest__isset;

class GetDatabaseRequest : public virtual ::apache::thrift::TBase {
 public:

  GetDatabaseRequest(const GetDatabaseRequest&);
  GetDatabaseRequest& operator=(const GetDatabaseRequest&);
  GetDatabaseRequest() noexcept
                     : name(),
                       catalogName(),
                       processorIdentifier() {
  }

  virtual ~GetDatabaseRequest() noexcept;
  std::string name;
  std::string catalogName;
  std::vector<std::string>  processorCapabilities;
  std::string processorIdentifier;

  _GetDatabaseRequest__isset __isset;

  void __set_name(const std::string& val);

  void __set_catalogName(const std::string& val);

  void __set_processorCapabilities(const std::vector<std::string> & val);

  void __set_processorIdentifier(const std::string& val);

  bool operator == (const GetDatabaseRequest & rhs) const
  {
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.processorCapabilities != rhs.__isset.processorCapabilities)
      return false;
    else if (__isset.processorCapabilities && !(processorCapabilities == rhs.processorCapabilities))
      return false;
    if (__isset.processorIdentifier != rhs.__isset.processorIdentifier)
      return false;
    else if (__isset.processorIdentifier && !(processorIdentifier == rhs.processorIdentifier))
      return false;
    return true;
  }
  bool operator != (const GetDatabaseRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetDatabaseRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetDatabaseRequest &a, GetDatabaseRequest &b);

std::ostream& operator<<(std::ostream& out, const GetDatabaseRequest& obj);


class AlterDatabaseRequest : public virtual ::apache::thrift::TBase {
 public:

  AlterDatabaseRequest(const AlterDatabaseRequest&);
  AlterDatabaseRequest& operator=(const AlterDatabaseRequest&);
  AlterDatabaseRequest() noexcept
                       : oldDbName() {
  }

  virtual ~AlterDatabaseRequest() noexcept;
  std::string oldDbName;
  Database newDb;

  void __set_oldDbName(const std::string& val);

  void __set_newDb(const Database& val);

  bool operator == (const AlterDatabaseRequest & rhs) const
  {
    if (!(oldDbName == rhs.oldDbName))
      return false;
    if (!(newDb == rhs.newDb))
      return false;
    return true;
  }
  bool operator != (const AlterDatabaseRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlterDatabaseRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AlterDatabaseRequest &a, AlterDatabaseRequest &b);

std::ostream& operator<<(std::ostream& out, const AlterDatabaseRequest& obj);

typedef struct _DropDatabaseRequest__isset {
  _DropDatabaseRequest__isset() : catalogName(false), softDelete(true), txnId(true), deleteManagedDir(true) {}
  bool catalogName :1;
  bool softDelete :1;
  bool txnId :1;
  bool deleteManagedDir :1;
} _DropDatabaseRequest__isset;

class DropDatabaseRequest : public virtual ::apache::thrift::TBase {
 public:

  DropDatabaseRequest(const DropDatabaseRequest&);
  DropDatabaseRequest& operator=(const DropDatabaseRequest&);
  DropDatabaseRequest() noexcept
                      : name(),
                        catalogName(),
                        ignoreUnknownDb(0),
                        deleteData(0),
                        cascade(0),
                        softDelete(false),
                        txnId(0LL),
                        deleteManagedDir(true) {
  }

  virtual ~DropDatabaseRequest() noexcept;
  std::string name;
  std::string catalogName;
  bool ignoreUnknownDb;
  bool deleteData;
  bool cascade;
  bool softDelete;
  int64_t txnId;
  bool deleteManagedDir;

  _DropDatabaseRequest__isset __isset;

  void __set_name(const std::string& val);

  void __set_catalogName(const std::string& val);

  void __set_ignoreUnknownDb(const bool val);

  void __set_deleteData(const bool val);

  void __set_cascade(const bool val);

  void __set_softDelete(const bool val);

  void __set_txnId(const int64_t val);

  void __set_deleteManagedDir(const bool val);

  bool operator == (const DropDatabaseRequest & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (!(ignoreUnknownDb == rhs.ignoreUnknownDb))
      return false;
    if (!(deleteData == rhs.deleteData))
      return false;
    if (!(cascade == rhs.cascade))
      return false;
    if (__isset.softDelete != rhs.__isset.softDelete)
      return false;
    else if (__isset.softDelete && !(softDelete == rhs.softDelete))
      return false;
    if (__isset.txnId != rhs.__isset.txnId)
      return false;
    else if (__isset.txnId && !(txnId == rhs.txnId))
      return false;
    if (__isset.deleteManagedDir != rhs.__isset.deleteManagedDir)
      return false;
    else if (__isset.deleteManagedDir && !(deleteManagedDir == rhs.deleteManagedDir))
      return false;
    return true;
  }
  bool operator != (const DropDatabaseRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropDatabaseRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropDatabaseRequest &a, DropDatabaseRequest &b);

std::ostream& operator<<(std::ostream& out, const DropDatabaseRequest& obj);


class CmRecycleRequest : public virtual ::apache::thrift::TBase {
 public:

  CmRecycleRequest(const CmRecycleRequest&);
  CmRecycleRequest& operator=(const CmRecycleRequest&);
  CmRecycleRequest() noexcept
                   : dataPath(),
                     purge(0) {
  }

  virtual ~CmRecycleRequest() noexcept;
  std::string dataPath;
  bool purge;

  void __set_dataPath(const std::string& val);

  void __set_purge(const bool val);

  bool operator == (const CmRecycleRequest & rhs) const
  {
    if (!(dataPath == rhs.dataPath))
      return false;
    if (!(purge == rhs.purge))
      return false;
    return true;
  }
  bool operator != (const CmRecycleRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CmRecycleRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CmRecycleRequest &a, CmRecycleRequest &b);

std::ostream& operator<<(std::ostream& out, const CmRecycleRequest& obj);


class CmRecycleResponse : public virtual ::apache::thrift::TBase {
 public:

  CmRecycleResponse(const CmRecycleResponse&) noexcept;
  CmRecycleResponse& operator=(const CmRecycleResponse&) noexcept;
  CmRecycleResponse() noexcept {
  }

  virtual ~CmRecycleResponse() noexcept;

  bool operator == (const CmRecycleResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const CmRecycleResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CmRecycleResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CmRecycleResponse &a, CmRecycleResponse &b);

std::ostream& operator<<(std::ostream& out, const CmRecycleResponse& obj);

typedef struct _TableMeta__isset {
  _TableMeta__isset() : comments(false), catName(false), ownerName(false), ownerType(false) {}
  bool comments :1;
  bool catName :1;
  bool ownerName :1;
  bool ownerType :1;
} _TableMeta__isset;

class TableMeta : public virtual ::apache::thrift::TBase {
 public:

  TableMeta(const TableMeta&);
  TableMeta& operator=(const TableMeta&);
  TableMeta() noexcept
            : dbName(),
              tableName(),
              tableType(),
              comments(),
              catName(),
              ownerName(),
              ownerType(static_cast<PrincipalType::type>(0)) {
  }

  virtual ~TableMeta() noexcept;
  std::string dbName;
  std::string tableName;
  std::string tableType;
  std::string comments;
  std::string catName;
  std::string ownerName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type ownerType;

  _TableMeta__isset __isset;

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_tableType(const std::string& val);

  void __set_comments(const std::string& val);

  void __set_catName(const std::string& val);

  void __set_ownerName(const std::string& val);

  void __set_ownerType(const PrincipalType::type val);

  bool operator == (const TableMeta & rhs) const
  {
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(tableType == rhs.tableType))
      return false;
    if (__isset.comments != rhs.__isset.comments)
      return false;
    else if (__isset.comments && !(comments == rhs.comments))
      return false;
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (__isset.ownerName != rhs.__isset.ownerName)
      return false;
    else if (__isset.ownerName && !(ownerName == rhs.ownerName))
      return false;
    if (__isset.ownerType != rhs.__isset.ownerType)
      return false;
    else if (__isset.ownerType && !(ownerType == rhs.ownerType))
      return false;
    return true;
  }
  bool operator != (const TableMeta &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TableMeta & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(TableMeta &a, TableMeta &b);

std::ostream& operator<<(std::ostream& out, const TableMeta& obj);


class Materialization : public virtual ::apache::thrift::TBase {
 public:

  Materialization(const Materialization&) noexcept;
  Materialization& operator=(const Materialization&) noexcept;
  Materialization() noexcept
                  : sourceTablesUpdateDeleteModified(0),
                    sourceTablesCompacted(0) {
  }

  virtual ~Materialization() noexcept;
  bool sourceTablesUpdateDeleteModified;
  bool sourceTablesCompacted;

  void __set_sourceTablesUpdateDeleteModified(const bool val);

  void __set_sourceTablesCompacted(const bool val);

  bool operator == (const Materialization & rhs) const
  {
    if (!(sourceTablesUpdateDeleteModified == rhs.sourceTablesUpdateDeleteModified))
      return false;
    if (!(sourceTablesCompacted == rhs.sourceTablesCompacted))
      return false;
    return true;
  }
  bool operator != (const Materialization &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Materialization & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Materialization &a, Materialization &b);

std::ostream& operator<<(std::ostream& out, const Materialization& obj);

typedef struct _WMResourcePlan__isset {
  _WMResourcePlan__isset() : status(false), queryParallelism(false), defaultPoolPath(false), ns(false) {}
  bool status :1;
  bool queryParallelism :1;
  bool defaultPoolPath :1;
  bool ns :1;
} _WMResourcePlan__isset;

class WMResourcePlan : public virtual ::apache::thrift::TBase {
 public:

  WMResourcePlan(const WMResourcePlan&);
  WMResourcePlan& operator=(const WMResourcePlan&);
  WMResourcePlan() noexcept
                 : name(),
                   status(static_cast<WMResourcePlanStatus::type>(0)),
                   queryParallelism(0),
                   defaultPoolPath(),
                   ns() {
  }

  virtual ~WMResourcePlan() noexcept;
  std::string name;
  /**
   *
   * @see WMResourcePlanStatus
   */
  WMResourcePlanStatus::type status;
  int32_t queryParallelism;
  std::string defaultPoolPath;
  std::string ns;

  _WMResourcePlan__isset __isset;

  void __set_name(const std::string& val);

  void __set_status(const WMResourcePlanStatus::type val);

  void __set_queryParallelism(const int32_t val);

  void __set_defaultPoolPath(const std::string& val);

  void __set_ns(const std::string& val);

  bool operator == (const WMResourcePlan & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.queryParallelism != rhs.__isset.queryParallelism)
      return false;
    else if (__isset.queryParallelism && !(queryParallelism == rhs.queryParallelism))
      return false;
    if (__isset.defaultPoolPath != rhs.__isset.defaultPoolPath)
      return false;
    else if (__isset.defaultPoolPath && !(defaultPoolPath == rhs.defaultPoolPath))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMResourcePlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMResourcePlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMResourcePlan &a, WMResourcePlan &b);

std::ostream& operator<<(std::ostream& out, const WMResourcePlan& obj);

typedef struct _WMNullableResourcePlan__isset {
  _WMNullableResourcePlan__isset() : name(false), status(false), queryParallelism(false), isSetQueryParallelism(false), defaultPoolPath(false), isSetDefaultPoolPath(false), ns(false) {}
  bool name :1;
  bool status :1;
  bool queryParallelism :1;
  bool isSetQueryParallelism :1;
  bool defaultPoolPath :1;
  bool isSetDefaultPoolPath :1;
  bool ns :1;
} _WMNullableResourcePlan__isset;

class WMNullableResourcePlan : public virtual ::apache::thrift::TBase {
 public:

  WMNullableResourcePlan(const WMNullableResourcePlan&);
  WMNullableResourcePlan& operator=(const WMNullableResourcePlan&);
  WMNullableResourcePlan() noexcept
                         : name(),
                           status(static_cast<WMResourcePlanStatus::type>(0)),
                           queryParallelism(0),
                           isSetQueryParallelism(0),
                           defaultPoolPath(),
                           isSetDefaultPoolPath(0),
                           ns() {
  }

  virtual ~WMNullableResourcePlan() noexcept;
  std::string name;
  /**
   *
   * @see WMResourcePlanStatus
   */
  WMResourcePlanStatus::type status;
  int32_t queryParallelism;
  bool isSetQueryParallelism;
  std::string defaultPoolPath;
  bool isSetDefaultPoolPath;
  std::string ns;

  _WMNullableResourcePlan__isset __isset;

  void __set_name(const std::string& val);

  void __set_status(const WMResourcePlanStatus::type val);

  void __set_queryParallelism(const int32_t val);

  void __set_isSetQueryParallelism(const bool val);

  void __set_defaultPoolPath(const std::string& val);

  void __set_isSetDefaultPoolPath(const bool val);

  void __set_ns(const std::string& val);

  bool operator == (const WMNullableResourcePlan & rhs) const
  {
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.queryParallelism != rhs.__isset.queryParallelism)
      return false;
    else if (__isset.queryParallelism && !(queryParallelism == rhs.queryParallelism))
      return false;
    if (__isset.isSetQueryParallelism != rhs.__isset.isSetQueryParallelism)
      return false;
    else if (__isset.isSetQueryParallelism && !(isSetQueryParallelism == rhs.isSetQueryParallelism))
      return false;
    if (__isset.defaultPoolPath != rhs.__isset.defaultPoolPath)
      return false;
    else if (__isset.defaultPoolPath && !(defaultPoolPath == rhs.defaultPoolPath))
      return false;
    if (__isset.isSetDefaultPoolPath != rhs.__isset.isSetDefaultPoolPath)
      return false;
    else if (__isset.isSetDefaultPoolPath && !(isSetDefaultPoolPath == rhs.isSetDefaultPoolPath))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMNullableResourcePlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMNullableResourcePlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMNullableResourcePlan &a, WMNullableResourcePlan &b);

std::ostream& operator<<(std::ostream& out, const WMNullableResourcePlan& obj);

typedef struct _WMPool__isset {
  _WMPool__isset() : allocFraction(false), queryParallelism(false), schedulingPolicy(false), ns(false) {}
  bool allocFraction :1;
  bool queryParallelism :1;
  bool schedulingPolicy :1;
  bool ns :1;
} _WMPool__isset;

class WMPool : public virtual ::apache::thrift::TBase {
 public:

  WMPool(const WMPool&);
  WMPool& operator=(const WMPool&);
  WMPool() noexcept
         : resourcePlanName(),
           poolPath(),
           allocFraction(0),
           queryParallelism(0),
           schedulingPolicy(),
           ns() {
  }

  virtual ~WMPool() noexcept;
  std::string resourcePlanName;
  std::string poolPath;
  double allocFraction;
  int32_t queryParallelism;
  std::string schedulingPolicy;
  std::string ns;

  _WMPool__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_poolPath(const std::string& val);

  void __set_allocFraction(const double val);

  void __set_queryParallelism(const int32_t val);

  void __set_schedulingPolicy(const std::string& val);

  void __set_ns(const std::string& val);

  bool operator == (const WMPool & rhs) const
  {
    if (!(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (!(poolPath == rhs.poolPath))
      return false;
    if (__isset.allocFraction != rhs.__isset.allocFraction)
      return false;
    else if (__isset.allocFraction && !(allocFraction == rhs.allocFraction))
      return false;
    if (__isset.queryParallelism != rhs.__isset.queryParallelism)
      return false;
    else if (__isset.queryParallelism && !(queryParallelism == rhs.queryParallelism))
      return false;
    if (__isset.schedulingPolicy != rhs.__isset.schedulingPolicy)
      return false;
    else if (__isset.schedulingPolicy && !(schedulingPolicy == rhs.schedulingPolicy))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMPool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMPool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMPool &a, WMPool &b);

std::ostream& operator<<(std::ostream& out, const WMPool& obj);

typedef struct _WMNullablePool__isset {
  _WMNullablePool__isset() : allocFraction(false), queryParallelism(false), schedulingPolicy(false), isSetSchedulingPolicy(false), ns(false) {}
  bool allocFraction :1;
  bool queryParallelism :1;
  bool schedulingPolicy :1;
  bool isSetSchedulingPolicy :1;
  bool ns :1;
} _WMNullablePool__isset;

class WMNullablePool : public virtual ::apache::thrift::TBase {
 public:

  WMNullablePool(const WMNullablePool&);
  WMNullablePool& operator=(const WMNullablePool&);
  WMNullablePool() noexcept
                 : resourcePlanName(),
                   poolPath(),
                   allocFraction(0),
                   queryParallelism(0),
                   schedulingPolicy(),
                   isSetSchedulingPolicy(0),
                   ns() {
  }

  virtual ~WMNullablePool() noexcept;
  std::string resourcePlanName;
  std::string poolPath;
  double allocFraction;
  int32_t queryParallelism;
  std::string schedulingPolicy;
  bool isSetSchedulingPolicy;
  std::string ns;

  _WMNullablePool__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_poolPath(const std::string& val);

  void __set_allocFraction(const double val);

  void __set_queryParallelism(const int32_t val);

  void __set_schedulingPolicy(const std::string& val);

  void __set_isSetSchedulingPolicy(const bool val);

  void __set_ns(const std::string& val);

  bool operator == (const WMNullablePool & rhs) const
  {
    if (!(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (!(poolPath == rhs.poolPath))
      return false;
    if (__isset.allocFraction != rhs.__isset.allocFraction)
      return false;
    else if (__isset.allocFraction && !(allocFraction == rhs.allocFraction))
      return false;
    if (__isset.queryParallelism != rhs.__isset.queryParallelism)
      return false;
    else if (__isset.queryParallelism && !(queryParallelism == rhs.queryParallelism))
      return false;
    if (__isset.schedulingPolicy != rhs.__isset.schedulingPolicy)
      return false;
    else if (__isset.schedulingPolicy && !(schedulingPolicy == rhs.schedulingPolicy))
      return false;
    if (__isset.isSetSchedulingPolicy != rhs.__isset.isSetSchedulingPolicy)
      return false;
    else if (__isset.isSetSchedulingPolicy && !(isSetSchedulingPolicy == rhs.isSetSchedulingPolicy))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMNullablePool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMNullablePool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMNullablePool &a, WMNullablePool &b);

std::ostream& operator<<(std::ostream& out, const WMNullablePool& obj);

typedef struct _WMTrigger__isset {
  _WMTrigger__isset() : triggerExpression(false), actionExpression(false), isInUnmanaged(false), ns(false) {}
  bool triggerExpression :1;
  bool actionExpression :1;
  bool isInUnmanaged :1;
  bool ns :1;
} _WMTrigger__isset;

class WMTrigger : public virtual ::apache::thrift::TBase {
 public:

  WMTrigger(const WMTrigger&);
  WMTrigger& operator=(const WMTrigger&);
  WMTrigger() noexcept
            : resourcePlanName(),
              triggerName(),
              triggerExpression(),
              actionExpression(),
              isInUnmanaged(0),
              ns() {
  }

  virtual ~WMTrigger() noexcept;
  std::string resourcePlanName;
  std::string triggerName;
  std::string triggerExpression;
  std::string actionExpression;
  bool isInUnmanaged;
  std::string ns;

  _WMTrigger__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_triggerName(const std::string& val);

  void __set_triggerExpression(const std::string& val);

  void __set_actionExpression(const std::string& val);

  void __set_isInUnmanaged(const bool val);

  void __set_ns(const std::string& val);

  bool operator == (const WMTrigger & rhs) const
  {
    if (!(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (!(triggerName == rhs.triggerName))
      return false;
    if (__isset.triggerExpression != rhs.__isset.triggerExpression)
      return false;
    else if (__isset.triggerExpression && !(triggerExpression == rhs.triggerExpression))
      return false;
    if (__isset.actionExpression != rhs.__isset.actionExpression)
      return false;
    else if (__isset.actionExpression && !(actionExpression == rhs.actionExpression))
      return false;
    if (__isset.isInUnmanaged != rhs.__isset.isInUnmanaged)
      return false;
    else if (__isset.isInUnmanaged && !(isInUnmanaged == rhs.isInUnmanaged))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMTrigger &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMTrigger & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMTrigger &a, WMTrigger &b);

std::ostream& operator<<(std::ostream& out, const WMTrigger& obj);

typedef struct _WMMapping__isset {
  _WMMapping__isset() : poolPath(false), ordering(false), ns(false) {}
  bool poolPath :1;
  bool ordering :1;
  bool ns :1;
} _WMMapping__isset;

class WMMapping : public virtual ::apache::thrift::TBase {
 public:

  WMMapping(const WMMapping&);
  WMMapping& operator=(const WMMapping&);
  WMMapping() noexcept
            : resourcePlanName(),
              entityType(),
              entityName(),
              poolPath(),
              ordering(0),
              ns() {
  }

  virtual ~WMMapping() noexcept;
  std::string resourcePlanName;
  std::string entityType;
  std::string entityName;
  std::string poolPath;
  int32_t ordering;
  std::string ns;

  _WMMapping__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_entityType(const std::string& val);

  void __set_entityName(const std::string& val);

  void __set_poolPath(const std::string& val);

  void __set_ordering(const int32_t val);

  void __set_ns(const std::string& val);

  bool operator == (const WMMapping & rhs) const
  {
    if (!(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (!(entityType == rhs.entityType))
      return false;
    if (!(entityName == rhs.entityName))
      return false;
    if (__isset.poolPath != rhs.__isset.poolPath)
      return false;
    else if (__isset.poolPath && !(poolPath == rhs.poolPath))
      return false;
    if (__isset.ordering != rhs.__isset.ordering)
      return false;
    else if (__isset.ordering && !(ordering == rhs.ordering))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMMapping &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMMapping & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMMapping &a, WMMapping &b);

std::ostream& operator<<(std::ostream& out, const WMMapping& obj);

typedef struct _WMPoolTrigger__isset {
  _WMPoolTrigger__isset() : ns(false) {}
  bool ns :1;
} _WMPoolTrigger__isset;

class WMPoolTrigger : public virtual ::apache::thrift::TBase {
 public:

  WMPoolTrigger(const WMPoolTrigger&);
  WMPoolTrigger& operator=(const WMPoolTrigger&);
  WMPoolTrigger() noexcept
                : pool(),
                  trigger(),
                  ns() {
  }

  virtual ~WMPoolTrigger() noexcept;
  std::string pool;
  std::string trigger;
  std::string ns;

  _WMPoolTrigger__isset __isset;

  void __set_pool(const std::string& val);

  void __set_trigger(const std::string& val);

  void __set_ns(const std::string& val);

  bool operator == (const WMPoolTrigger & rhs) const
  {
    if (!(pool == rhs.pool))
      return false;
    if (!(trigger == rhs.trigger))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMPoolTrigger &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMPoolTrigger & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMPoolTrigger &a, WMPoolTrigger &b);

std::ostream& operator<<(std::ostream& out, const WMPoolTrigger& obj);

typedef struct _WMFullResourcePlan__isset {
  _WMFullResourcePlan__isset() : mappings(false), triggers(false), poolTriggers(false) {}
  bool mappings :1;
  bool triggers :1;
  bool poolTriggers :1;
} _WMFullResourcePlan__isset;

class WMFullResourcePlan : public virtual ::apache::thrift::TBase {
 public:

  WMFullResourcePlan(const WMFullResourcePlan&);
  WMFullResourcePlan& operator=(const WMFullResourcePlan&);
  WMFullResourcePlan() noexcept {
  }

  virtual ~WMFullResourcePlan() noexcept;
  WMResourcePlan plan;
  std::vector<WMPool>  pools;
  std::vector<WMMapping>  mappings;
  std::vector<WMTrigger>  triggers;
  std::vector<WMPoolTrigger>  poolTriggers;

  _WMFullResourcePlan__isset __isset;

  void __set_plan(const WMResourcePlan& val);

  void __set_pools(const std::vector<WMPool> & val);

  void __set_mappings(const std::vector<WMMapping> & val);

  void __set_triggers(const std::vector<WMTrigger> & val);

  void __set_poolTriggers(const std::vector<WMPoolTrigger> & val);

  bool operator == (const WMFullResourcePlan & rhs) const
  {
    if (!(plan == rhs.plan))
      return false;
    if (!(pools == rhs.pools))
      return false;
    if (__isset.mappings != rhs.__isset.mappings)
      return false;
    else if (__isset.mappings && !(mappings == rhs.mappings))
      return false;
    if (__isset.triggers != rhs.__isset.triggers)
      return false;
    else if (__isset.triggers && !(triggers == rhs.triggers))
      return false;
    if (__isset.poolTriggers != rhs.__isset.poolTriggers)
      return false;
    else if (__isset.poolTriggers && !(poolTriggers == rhs.poolTriggers))
      return false;
    return true;
  }
  bool operator != (const WMFullResourcePlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMFullResourcePlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMFullResourcePlan &a, WMFullResourcePlan &b);

std::ostream& operator<<(std::ostream& out, const WMFullResourcePlan& obj);

typedef struct _WMCreateResourcePlanRequest__isset {
  _WMCreateResourcePlanRequest__isset() : resourcePlan(false), copyFrom(false) {}
  bool resourcePlan :1;
  bool copyFrom :1;
} _WMCreateResourcePlanRequest__isset;

class WMCreateResourcePlanRequest : public virtual ::apache::thrift::TBase {
 public:

  WMCreateResourcePlanRequest(const WMCreateResourcePlanRequest&);
  WMCreateResourcePlanRequest& operator=(const WMCreateResourcePlanRequest&);
  WMCreateResourcePlanRequest() noexcept
                              : copyFrom() {
  }

  virtual ~WMCreateResourcePlanRequest() noexcept;
  WMResourcePlan resourcePlan;
  std::string copyFrom;

  _WMCreateResourcePlanRequest__isset __isset;

  void __set_resourcePlan(const WMResourcePlan& val);

  void __set_copyFrom(const std::string& val);

  bool operator == (const WMCreateResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlan != rhs.__isset.resourcePlan)
      return false;
    else if (__isset.resourcePlan && !(resourcePlan == rhs.resourcePlan))
      return false;
    if (__isset.copyFrom != rhs.__isset.copyFrom)
      return false;
    else if (__isset.copyFrom && !(copyFrom == rhs.copyFrom))
      return false;
    return true;
  }
  bool operator != (const WMCreateResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateResourcePlanRequest &a, WMCreateResourcePlanRequest &b);

std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanRequest& obj);


class WMCreateResourcePlanResponse : public virtual ::apache::thrift::TBase {
 public:

  WMCreateResourcePlanResponse(const WMCreateResourcePlanResponse&) noexcept;
  WMCreateResourcePlanResponse& operator=(const WMCreateResourcePlanResponse&) noexcept;
  WMCreateResourcePlanResponse() noexcept {
  }

  virtual ~WMCreateResourcePlanResponse() noexcept;

  bool operator == (const WMCreateResourcePlanResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreateResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateResourcePlanResponse &a, WMCreateResourcePlanResponse &b);

std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanResponse& obj);

typedef struct _WMGetActiveResourcePlanRequest__isset {
  _WMGetActiveResourcePlanRequest__isset() : ns(false) {}
  bool ns :1;
} _WMGetActiveResourcePlanRequest__isset;

class WMGetActiveResourcePlanRequest : public virtual ::apache::thrift::TBase {
 public:

  WMGetActiveResourcePlanRequest(const WMGetActiveResourcePlanRequest&);
  WMGetActiveResourcePlanRequest& operator=(const WMGetActiveResourcePlanRequest&);
  WMGetActiveResourcePlanRequest() noexcept
                                 : ns() {
  }

  virtual ~WMGetActiveResourcePlanRequest() noexcept;
  std::string ns;

  _WMGetActiveResourcePlanRequest__isset __isset;

  void __set_ns(const std::string& val);

  bool operator == (const WMGetActiveResourcePlanRequest & rhs) const
  {
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMGetActiveResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetActiveResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetActiveResourcePlanRequest &a, WMGetActiveResourcePlanRequest &b);

std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanRequest& obj);

typedef struct _WMGetActiveResourcePlanResponse__isset {
  _WMGetActiveResourcePlanResponse__isset() : resourcePlan(false) {}
  bool resourcePlan :1;
} _WMGetActiveResourcePlanResponse__isset;

class WMGetActiveResourcePlanResponse : public virtual ::apache::thrift::TBase {
 public:

  WMGetActiveResourcePlanResponse(const WMGetActiveResourcePlanResponse&);
  WMGetActiveResourcePlanResponse& operator=(const WMGetActiveResourcePlanResponse&);
  WMGetActiveResourcePlanResponse() noexcept {
  }

  virtual ~WMGetActiveResourcePlanResponse() noexcept;
  WMFullResourcePlan resourcePlan;

  _WMGetActiveResourcePlanResponse__isset __isset;

  void __set_resourcePlan(const WMFullResourcePlan& val);

  bool operator == (const WMGetActiveResourcePlanResponse & rhs) const
  {
    if (__isset.resourcePlan != rhs.__isset.resourcePlan)
      return false;
    else if (__isset.resourcePlan && !(resourcePlan == rhs.resourcePlan))
      return false;
    return true;
  }
  bool operator != (const WMGetActiveResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetActiveResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetActiveResourcePlanResponse &a, WMGetActiveResourcePlanResponse &b);

std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanResponse& obj);

typedef struct _WMGetResourcePlanRequest__isset {
  _WMGetResourcePlanRequest__isset() : resourcePlanName(false), ns(false) {}
  bool resourcePlanName :1;
  bool ns :1;
} _WMGetResourcePlanRequest__isset;

class WMGetResourcePlanRequest : public virtual ::apache::thrift::TBase {
 public:

  WMGetResourcePlanRequest(const WMGetResourcePlanRequest&);
  WMGetResourcePlanRequest& operator=(const WMGetResourcePlanRequest&);
  WMGetResourcePlanRequest() noexcept
                           : resourcePlanName(),
                             ns() {
  }

  virtual ~WMGetResourcePlanRequest() noexcept;
  std::string resourcePlanName;
  std::string ns;

  _WMGetResourcePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_ns(const std::string& val);

  bool operator == (const WMGetResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMGetResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetResourcePlanRequest &a, WMGetResourcePlanRequest &b);

std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanRequest& obj);

typedef struct _WMGetResourcePlanResponse__isset {
  _WMGetResourcePlanResponse__isset() : resourcePlan(false) {}
  bool resourcePlan :1;
} _WMGetResourcePlanResponse__isset;

class WMGetResourcePlanResponse : public virtual ::apache::thrift::TBase {
 public:

  WMGetResourcePlanResponse(const WMGetResourcePlanResponse&);
  WMGetResourcePlanResponse& operator=(const WMGetResourcePlanResponse&);
  WMGetResourcePlanResponse() noexcept {
  }

  virtual ~WMGetResourcePlanResponse() noexcept;
  WMFullResourcePlan resourcePlan;

  _WMGetResourcePlanResponse__isset __isset;

  void __set_resourcePlan(const WMFullResourcePlan& val);

  bool operator == (const WMGetResourcePlanResponse & rhs) const
  {
    if (__isset.resourcePlan != rhs.__isset.resourcePlan)
      return false;
    else if (__isset.resourcePlan && !(resourcePlan == rhs.resourcePlan))
      return false;
    return true;
  }
  bool operator != (const WMGetResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetResourcePlanResponse &a, WMGetResourcePlanResponse &b);

std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanResponse& obj);

typedef struct _WMGetAllResourcePlanRequest__isset {
  _WMGetAllResourcePlanRequest__isset() : ns(false) {}
  bool ns :1;
} _WMGetAllResourcePlanRequest__isset;

class WMGetAllResourcePlanRequest : public virtual ::apache::thrift::TBase {
 public:

  WMGetAllResourcePlanRequest(const WMGetAllResourcePlanRequest&);
  WMGetAllResourcePlanRequest& operator=(const WMGetAllResourcePlanRequest&);
  WMGetAllResourcePlanRequest() noexcept
                              : ns() {
  }

  virtual ~WMGetAllResourcePlanRequest() noexcept;
  std::string ns;

  _WMGetAllResourcePlanRequest__isset __isset;

  void __set_ns(const std::string& val);

  bool operator == (const WMGetAllResourcePlanRequest & rhs) const
  {
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMGetAllResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetAllResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetAllResourcePlanRequest &a, WMGetAllResourcePlanRequest &b);

std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanRequest& obj);

typedef struct _WMGetAllResourcePlanResponse__isset {
  _WMGetAllResourcePlanResponse__isset() : resourcePlans(false) {}
  bool resourcePlans :1;
} _WMGetAllResourcePlanResponse__isset;

class WMGetAllResourcePlanResponse : public virtual ::apache::thrift::TBase {
 public:

  WMGetAllResourcePlanResponse(const WMGetAllResourcePlanResponse&);
  WMGetAllResourcePlanResponse& operator=(const WMGetAllResourcePlanResponse&);
  WMGetAllResourcePlanResponse() noexcept {
  }

  virtual ~WMGetAllResourcePlanResponse() noexcept;
  std::vector<WMResourcePlan>  resourcePlans;

  _WMGetAllResourcePlanResponse__isset __isset;

  void __set_resourcePlans(const std::vector<WMResourcePlan> & val);

  bool operator == (const WMGetAllResourcePlanResponse & rhs) const
  {
    if (__isset.resourcePlans != rhs.__isset.resourcePlans)
      return false;
    else if (__isset.resourcePlans && !(resourcePlans == rhs.resourcePlans))
      return false;
    return true;
  }
  bool operator != (const WMGetAllResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetAllResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetAllResourcePlanResponse &a, WMGetAllResourcePlanResponse &b);

std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanResponse& obj);

typedef struct _WMAlterResourcePlanRequest__isset {
  _WMAlterResourcePlanRequest__isset() : resourcePlanName(false), resourcePlan(false), isEnableAndActivate(false), isForceDeactivate(false), isReplace(false), ns(false) {}
  bool resourcePlanName :1;
  bool resourcePlan :1;
  bool isEnableAndActivate :1;
  bool isForceDeactivate :1;
  bool isReplace :1;
  bool ns :1;
} _WMAlterResourcePlanRequest__isset;

class WMAlterResourcePlanRequest : public virtual ::apache::thrift::TBase {
 public:

  WMAlterResourcePlanRequest(const WMAlterResourcePlanRequest&);
  WMAlterResourcePlanRequest& operator=(const WMAlterResourcePlanRequest&);
  WMAlterResourcePlanRequest() noexcept
                             : resourcePlanName(),
                               isEnableAndActivate(0),
                               isForceDeactivate(0),
                               isReplace(0),
                               ns() {
  }

  virtual ~WMAlterResourcePlanRequest() noexcept;
  std::string resourcePlanName;
  WMNullableResourcePlan resourcePlan;
  bool isEnableAndActivate;
  bool isForceDeactivate;
  bool isReplace;
  std::string ns;

  _WMAlterResourcePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_resourcePlan(const WMNullableResourcePlan& val);

  void __set_isEnableAndActivate(const bool val);

  void __set_isForceDeactivate(const bool val);

  void __set_isReplace(const bool val);

  void __set_ns(const std::string& val);

  bool operator == (const WMAlterResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.resourcePlan != rhs.__isset.resourcePlan)
      return false;
    else if (__isset.resourcePlan && !(resourcePlan == rhs.resourcePlan))
      return false;
    if (__isset.isEnableAndActivate != rhs.__isset.isEnableAndActivate)
      return false;
    else if (__isset.isEnableAndActivate && !(isEnableAndActivate == rhs.isEnableAndActivate))
      return false;
    if (__isset.isForceDeactivate != rhs.__isset.isForceDeactivate)
      return false;
    else if (__isset.isForceDeactivate && !(isForceDeactivate == rhs.isForceDeactivate))
      return false;
    if (__isset.isReplace != rhs.__isset.isReplace)
      return false;
    else if (__isset.isReplace && !(isReplace == rhs.isReplace))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMAlterResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterResourcePlanRequest &a, WMAlterResourcePlanRequest &b);

std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanRequest& obj);

typedef struct _WMAlterResourcePlanResponse__isset {
  _WMAlterResourcePlanResponse__isset() : fullResourcePlan(false) {}
  bool fullResourcePlan :1;
} _WMAlterResourcePlanResponse__isset;

class WMAlterResourcePlanResponse : public virtual ::apache::thrift::TBase {
 public:

  WMAlterResourcePlanResponse(const WMAlterResourcePlanResponse&);
  WMAlterResourcePlanResponse& operator=(const WMAlterResourcePlanResponse&);
  WMAlterResourcePlanResponse() noexcept {
  }

  virtual ~WMAlterResourcePlanResponse() noexcept;
  WMFullResourcePlan fullResourcePlan;

  _WMAlterResourcePlanResponse__isset __isset;

  void __set_fullResourcePlan(const WMFullResourcePlan& val);

  bool operator == (const WMAlterResourcePlanResponse & rhs) const
  {
    if (__isset.fullResourcePlan != rhs.__isset.fullResourcePlan)
      return false;
    else if (__isset.fullResourcePlan && !(fullResourcePlan == rhs.fullResourcePlan))
      return false;
    return true;
  }
  bool operator != (const WMAlterResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterResourcePlanResponse &a, WMAlterResourcePlanResponse &b);

std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanResponse& obj);

typedef struct _WMValidateResourcePlanRequest__isset {
  _WMValidateResourcePlanRequest__isset() : resourcePlanName(false), ns(false) {}
  bool resourcePlanName :1;
  bool ns :1;
} _WMValidateResourcePlanRequest__isset;

class WMValidateResourcePlanRequest : public virtual ::apache::thrift::TBase {
 public:

  WMValidateResourcePlanRequest(const WMValidateResourcePlanRequest&);
  WMValidateResourcePlanRequest& operator=(const WMValidateResourcePlanRequest&);
  WMValidateResourcePlanRequest() noexcept
                                : resourcePlanName(),
                                  ns() {
  }

  virtual ~WMValidateResourcePlanRequest() noexcept;
  std::string resourcePlanName;
  std::string ns;

  _WMValidateResourcePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_ns(const std::string& val);

  bool operator == (const WMValidateResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMValidateResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMValidateResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMValidateResourcePlanRequest &a, WMValidateResourcePlanRequest &b);

std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanRequest& obj);

typedef struct _WMValidateResourcePlanResponse__isset {
  _WMValidateResourcePlanResponse__isset() : errors(false), warnings(false) {}
  bool errors :1;
  bool warnings :1;
} _WMValidateResourcePlanResponse__isset;

class WMValidateResourcePlanResponse : public virtual ::apache::thrift::TBase {
 public:

  WMValidateResourcePlanResponse(const WMValidateResourcePlanResponse&);
  WMValidateResourcePlanResponse& operator=(const WMValidateResourcePlanResponse&);
  WMValidateResourcePlanResponse() noexcept {
  }

  virtual ~WMValidateResourcePlanResponse() noexcept;
  std::vector<std::string>  errors;
  std::vector<std::string>  warnings;

  _WMValidateResourcePlanResponse__isset __isset;

  void __set_errors(const std::vector<std::string> & val);

  void __set_warnings(const std::vector<std::string> & val);

  bool operator == (const WMValidateResourcePlanResponse & rhs) const
  {
    if (__isset.errors != rhs.__isset.errors)
      return false;
    else if (__isset.errors && !(errors == rhs.errors))
      return false;
    if (__isset.warnings != rhs.__isset.warnings)
      return false;
    else if (__isset.warnings && !(warnings == rhs.warnings))
      return false;
    return true;
  }
  bool operator != (const WMValidateResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMValidateResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMValidateResourcePlanResponse &a, WMValidateResourcePlanResponse &b);

std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanResponse& obj);

typedef struct _WMDropResourcePlanRequest__isset {
  _WMDropResourcePlanRequest__isset() : resourcePlanName(false), ns(false) {}
  bool resourcePlanName :1;
  bool ns :1;
} _WMDropResourcePlanRequest__isset;

class WMDropResourcePlanRequest : public virtual ::apache::thrift::TBase {
 public:

  WMDropResourcePlanRequest(const WMDropResourcePlanRequest&);
  WMDropResourcePlanRequest& operator=(const WMDropResourcePlanRequest&);
  WMDropResourcePlanRequest() noexcept
                            : resourcePlanName(),
                              ns() {
  }

  virtual ~WMDropResourcePlanRequest() noexcept;
  std::string resourcePlanName;
  std::string ns;

  _WMDropResourcePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_ns(const std::string& val);

  bool operator == (const WMDropResourcePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMDropResourcePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropResourcePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropResourcePlanRequest &a, WMDropResourcePlanRequest &b);

std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanRequest& obj);


class WMDropResourcePlanResponse : public virtual ::apache::thrift::TBase {
 public:

  WMDropResourcePlanResponse(const WMDropResourcePlanResponse&) noexcept;
  WMDropResourcePlanResponse& operator=(const WMDropResourcePlanResponse&) noexcept;
  WMDropResourcePlanResponse() noexcept {
  }

  virtual ~WMDropResourcePlanResponse() noexcept;

  bool operator == (const WMDropResourcePlanResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMDropResourcePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropResourcePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropResourcePlanResponse &a, WMDropResourcePlanResponse &b);

std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanResponse& obj);

typedef struct _WMCreateTriggerRequest__isset {
  _WMCreateTriggerRequest__isset() : trigger(false) {}
  bool trigger :1;
} _WMCreateTriggerRequest__isset;

class WMCreateTriggerRequest : public virtual ::apache::thrift::TBase {
 public:

  WMCreateTriggerRequest(const WMCreateTriggerRequest&);
  WMCreateTriggerRequest& operator=(const WMCreateTriggerRequest&);
  WMCreateTriggerRequest() noexcept {
  }

  virtual ~WMCreateTriggerRequest() noexcept;
  WMTrigger trigger;

  _WMCreateTriggerRequest__isset __isset;

  void __set_trigger(const WMTrigger& val);

  bool operator == (const WMCreateTriggerRequest & rhs) const
  {
    if (__isset.trigger != rhs.__isset.trigger)
      return false;
    else if (__isset.trigger && !(trigger == rhs.trigger))
      return false;
    return true;
  }
  bool operator != (const WMCreateTriggerRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateTriggerRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateTriggerRequest &a, WMCreateTriggerRequest &b);

std::ostream& operator<<(std::ostream& out, const WMCreateTriggerRequest& obj);


class WMCreateTriggerResponse : public virtual ::apache::thrift::TBase {
 public:

  WMCreateTriggerResponse(const WMCreateTriggerResponse&) noexcept;
  WMCreateTriggerResponse& operator=(const WMCreateTriggerResponse&) noexcept;
  WMCreateTriggerResponse() noexcept {
  }

  virtual ~WMCreateTriggerResponse() noexcept;

  bool operator == (const WMCreateTriggerResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreateTriggerResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateTriggerResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateTriggerResponse &a, WMCreateTriggerResponse &b);

std::ostream& operator<<(std::ostream& out, const WMCreateTriggerResponse& obj);

typedef struct _WMAlterTriggerRequest__isset {
  _WMAlterTriggerRequest__isset() : trigger(false) {}
  bool trigger :1;
} _WMAlterTriggerRequest__isset;

class WMAlterTriggerRequest : public virtual ::apache::thrift::TBase {
 public:

  WMAlterTriggerRequest(const WMAlterTriggerRequest&);
  WMAlterTriggerRequest& operator=(const WMAlterTriggerRequest&);
  WMAlterTriggerRequest() noexcept {
  }

  virtual ~WMAlterTriggerRequest() noexcept;
  WMTrigger trigger;

  _WMAlterTriggerRequest__isset __isset;

  void __set_trigger(const WMTrigger& val);

  bool operator == (const WMAlterTriggerRequest & rhs) const
  {
    if (__isset.trigger != rhs.__isset.trigger)
      return false;
    else if (__isset.trigger && !(trigger == rhs.trigger))
      return false;
    return true;
  }
  bool operator != (const WMAlterTriggerRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterTriggerRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterTriggerRequest &a, WMAlterTriggerRequest &b);

std::ostream& operator<<(std::ostream& out, const WMAlterTriggerRequest& obj);


class WMAlterTriggerResponse : public virtual ::apache::thrift::TBase {
 public:

  WMAlterTriggerResponse(const WMAlterTriggerResponse&) noexcept;
  WMAlterTriggerResponse& operator=(const WMAlterTriggerResponse&) noexcept;
  WMAlterTriggerResponse() noexcept {
  }

  virtual ~WMAlterTriggerResponse() noexcept;

  bool operator == (const WMAlterTriggerResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMAlterTriggerResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterTriggerResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterTriggerResponse &a, WMAlterTriggerResponse &b);

std::ostream& operator<<(std::ostream& out, const WMAlterTriggerResponse& obj);

typedef struct _WMDropTriggerRequest__isset {
  _WMDropTriggerRequest__isset() : resourcePlanName(false), triggerName(false), ns(false) {}
  bool resourcePlanName :1;
  bool triggerName :1;
  bool ns :1;
} _WMDropTriggerRequest__isset;

class WMDropTriggerRequest : public virtual ::apache::thrift::TBase {
 public:

  WMDropTriggerRequest(const WMDropTriggerRequest&);
  WMDropTriggerRequest& operator=(const WMDropTriggerRequest&);
  WMDropTriggerRequest() noexcept
                       : resourcePlanName(),
                         triggerName(),
                         ns() {
  }

  virtual ~WMDropTriggerRequest() noexcept;
  std::string resourcePlanName;
  std::string triggerName;
  std::string ns;

  _WMDropTriggerRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_triggerName(const std::string& val);

  void __set_ns(const std::string& val);

  bool operator == (const WMDropTriggerRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.triggerName != rhs.__isset.triggerName)
      return false;
    else if (__isset.triggerName && !(triggerName == rhs.triggerName))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMDropTriggerRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropTriggerRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropTriggerRequest &a, WMDropTriggerRequest &b);

std::ostream& operator<<(std::ostream& out, const WMDropTriggerRequest& obj);


class WMDropTriggerResponse : public virtual ::apache::thrift::TBase {
 public:

  WMDropTriggerResponse(const WMDropTriggerResponse&) noexcept;
  WMDropTriggerResponse& operator=(const WMDropTriggerResponse&) noexcept;
  WMDropTriggerResponse() noexcept {
  }

  virtual ~WMDropTriggerResponse() noexcept;

  bool operator == (const WMDropTriggerResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMDropTriggerResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropTriggerResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropTriggerResponse &a, WMDropTriggerResponse &b);

std::ostream& operator<<(std::ostream& out, const WMDropTriggerResponse& obj);

typedef struct _WMGetTriggersForResourePlanRequest__isset {
  _WMGetTriggersForResourePlanRequest__isset() : resourcePlanName(false), ns(false) {}
  bool resourcePlanName :1;
  bool ns :1;
} _WMGetTriggersForResourePlanRequest__isset;

class WMGetTriggersForResourePlanRequest : public virtual ::apache::thrift::TBase {
 public:

  WMGetTriggersForResourePlanRequest(const WMGetTriggersForResourePlanRequest&);
  WMGetTriggersForResourePlanRequest& operator=(const WMGetTriggersForResourePlanRequest&);
  WMGetTriggersForResourePlanRequest() noexcept
                                     : resourcePlanName(),
                                       ns() {
  }

  virtual ~WMGetTriggersForResourePlanRequest() noexcept;
  std::string resourcePlanName;
  std::string ns;

  _WMGetTriggersForResourePlanRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_ns(const std::string& val);

  bool operator == (const WMGetTriggersForResourePlanRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMGetTriggersForResourePlanRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetTriggersForResourePlanRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetTriggersForResourePlanRequest &a, WMGetTriggersForResourePlanRequest &b);

std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanRequest& obj);

typedef struct _WMGetTriggersForResourePlanResponse__isset {
  _WMGetTriggersForResourePlanResponse__isset() : triggers(false) {}
  bool triggers :1;
} _WMGetTriggersForResourePlanResponse__isset;

class WMGetTriggersForResourePlanResponse : public virtual ::apache::thrift::TBase {
 public:

  WMGetTriggersForResourePlanResponse(const WMGetTriggersForResourePlanResponse&);
  WMGetTriggersForResourePlanResponse& operator=(const WMGetTriggersForResourePlanResponse&);
  WMGetTriggersForResourePlanResponse() noexcept {
  }

  virtual ~WMGetTriggersForResourePlanResponse() noexcept;
  std::vector<WMTrigger>  triggers;

  _WMGetTriggersForResourePlanResponse__isset __isset;

  void __set_triggers(const std::vector<WMTrigger> & val);

  bool operator == (const WMGetTriggersForResourePlanResponse & rhs) const
  {
    if (__isset.triggers != rhs.__isset.triggers)
      return false;
    else if (__isset.triggers && !(triggers == rhs.triggers))
      return false;
    return true;
  }
  bool operator != (const WMGetTriggersForResourePlanResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMGetTriggersForResourePlanResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMGetTriggersForResourePlanResponse &a, WMGetTriggersForResourePlanResponse &b);

std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanResponse& obj);

typedef struct _WMCreatePoolRequest__isset {
  _WMCreatePoolRequest__isset() : pool(false) {}
  bool pool :1;
} _WMCreatePoolRequest__isset;

class WMCreatePoolRequest : public virtual ::apache::thrift::TBase {
 public:

  WMCreatePoolRequest(const WMCreatePoolRequest&);
  WMCreatePoolRequest& operator=(const WMCreatePoolRequest&);
  WMCreatePoolRequest() noexcept {
  }

  virtual ~WMCreatePoolRequest() noexcept;
  WMPool pool;

  _WMCreatePoolRequest__isset __isset;

  void __set_pool(const WMPool& val);

  bool operator == (const WMCreatePoolRequest & rhs) const
  {
    if (__isset.pool != rhs.__isset.pool)
      return false;
    else if (__isset.pool && !(pool == rhs.pool))
      return false;
    return true;
  }
  bool operator != (const WMCreatePoolRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreatePoolRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreatePoolRequest &a, WMCreatePoolRequest &b);

std::ostream& operator<<(std::ostream& out, const WMCreatePoolRequest& obj);


class WMCreatePoolResponse : public virtual ::apache::thrift::TBase {
 public:

  WMCreatePoolResponse(const WMCreatePoolResponse&) noexcept;
  WMCreatePoolResponse& operator=(const WMCreatePoolResponse&) noexcept;
  WMCreatePoolResponse() noexcept {
  }

  virtual ~WMCreatePoolResponse() noexcept;

  bool operator == (const WMCreatePoolResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreatePoolResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreatePoolResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreatePoolResponse &a, WMCreatePoolResponse &b);

std::ostream& operator<<(std::ostream& out, const WMCreatePoolResponse& obj);

typedef struct _WMAlterPoolRequest__isset {
  _WMAlterPoolRequest__isset() : pool(false), poolPath(false) {}
  bool pool :1;
  bool poolPath :1;
} _WMAlterPoolRequest__isset;

class WMAlterPoolRequest : public virtual ::apache::thrift::TBase {
 public:

  WMAlterPoolRequest(const WMAlterPoolRequest&);
  WMAlterPoolRequest& operator=(const WMAlterPoolRequest&);
  WMAlterPoolRequest() noexcept
                     : poolPath() {
  }

  virtual ~WMAlterPoolRequest() noexcept;
  WMNullablePool pool;
  std::string poolPath;

  _WMAlterPoolRequest__isset __isset;

  void __set_pool(const WMNullablePool& val);

  void __set_poolPath(const std::string& val);

  bool operator == (const WMAlterPoolRequest & rhs) const
  {
    if (__isset.pool != rhs.__isset.pool)
      return false;
    else if (__isset.pool && !(pool == rhs.pool))
      return false;
    if (__isset.poolPath != rhs.__isset.poolPath)
      return false;
    else if (__isset.poolPath && !(poolPath == rhs.poolPath))
      return false;
    return true;
  }
  bool operator != (const WMAlterPoolRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterPoolRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterPoolRequest &a, WMAlterPoolRequest &b);

std::ostream& operator<<(std::ostream& out, const WMAlterPoolRequest& obj);


class WMAlterPoolResponse : public virtual ::apache::thrift::TBase {
 public:

  WMAlterPoolResponse(const WMAlterPoolResponse&) noexcept;
  WMAlterPoolResponse& operator=(const WMAlterPoolResponse&) noexcept;
  WMAlterPoolResponse() noexcept {
  }

  virtual ~WMAlterPoolResponse() noexcept;

  bool operator == (const WMAlterPoolResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMAlterPoolResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMAlterPoolResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMAlterPoolResponse &a, WMAlterPoolResponse &b);

std::ostream& operator<<(std::ostream& out, const WMAlterPoolResponse& obj);

typedef struct _WMDropPoolRequest__isset {
  _WMDropPoolRequest__isset() : resourcePlanName(false), poolPath(false), ns(false) {}
  bool resourcePlanName :1;
  bool poolPath :1;
  bool ns :1;
} _WMDropPoolRequest__isset;

class WMDropPoolRequest : public virtual ::apache::thrift::TBase {
 public:

  WMDropPoolRequest(const WMDropPoolRequest&);
  WMDropPoolRequest& operator=(const WMDropPoolRequest&);
  WMDropPoolRequest() noexcept
                    : resourcePlanName(),
                      poolPath(),
                      ns() {
  }

  virtual ~WMDropPoolRequest() noexcept;
  std::string resourcePlanName;
  std::string poolPath;
  std::string ns;

  _WMDropPoolRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_poolPath(const std::string& val);

  void __set_ns(const std::string& val);

  bool operator == (const WMDropPoolRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.poolPath != rhs.__isset.poolPath)
      return false;
    else if (__isset.poolPath && !(poolPath == rhs.poolPath))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMDropPoolRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropPoolRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropPoolRequest &a, WMDropPoolRequest &b);

std::ostream& operator<<(std::ostream& out, const WMDropPoolRequest& obj);


class WMDropPoolResponse : public virtual ::apache::thrift::TBase {
 public:

  WMDropPoolResponse(const WMDropPoolResponse&) noexcept;
  WMDropPoolResponse& operator=(const WMDropPoolResponse&) noexcept;
  WMDropPoolResponse() noexcept {
  }

  virtual ~WMDropPoolResponse() noexcept;

  bool operator == (const WMDropPoolResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMDropPoolResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropPoolResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropPoolResponse &a, WMDropPoolResponse &b);

std::ostream& operator<<(std::ostream& out, const WMDropPoolResponse& obj);

typedef struct _WMCreateOrUpdateMappingRequest__isset {
  _WMCreateOrUpdateMappingRequest__isset() : mapping(false), update(false) {}
  bool mapping :1;
  bool update :1;
} _WMCreateOrUpdateMappingRequest__isset;

class WMCreateOrUpdateMappingRequest : public virtual ::apache::thrift::TBase {
 public:

  WMCreateOrUpdateMappingRequest(const WMCreateOrUpdateMappingRequest&);
  WMCreateOrUpdateMappingRequest& operator=(const WMCreateOrUpdateMappingRequest&);
  WMCreateOrUpdateMappingRequest() noexcept
                                 : update(0) {
  }

  virtual ~WMCreateOrUpdateMappingRequest() noexcept;
  WMMapping mapping;
  bool update;

  _WMCreateOrUpdateMappingRequest__isset __isset;

  void __set_mapping(const WMMapping& val);

  void __set_update(const bool val);

  bool operator == (const WMCreateOrUpdateMappingRequest & rhs) const
  {
    if (__isset.mapping != rhs.__isset.mapping)
      return false;
    else if (__isset.mapping && !(mapping == rhs.mapping))
      return false;
    if (__isset.update != rhs.__isset.update)
      return false;
    else if (__isset.update && !(update == rhs.update))
      return false;
    return true;
  }
  bool operator != (const WMCreateOrUpdateMappingRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateOrUpdateMappingRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateOrUpdateMappingRequest &a, WMCreateOrUpdateMappingRequest &b);

std::ostream& operator<<(std::ostream& out, const WMCreateOrUpdateMappingRequest& obj);


class WMCreateOrUpdateMappingResponse : public virtual ::apache::thrift::TBase {
 public:

  WMCreateOrUpdateMappingResponse(const WMCreateOrUpdateMappingResponse&) noexcept;
  WMCreateOrUpdateMappingResponse& operator=(const WMCreateOrUpdateMappingResponse&) noexcept;
  WMCreateOrUpdateMappingResponse() noexcept {
  }

  virtual ~WMCreateOrUpdateMappingResponse() noexcept;

  bool operator == (const WMCreateOrUpdateMappingResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreateOrUpdateMappingResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateOrUpdateMappingResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateOrUpdateMappingResponse &a, WMCreateOrUpdateMappingResponse &b);

std::ostream& operator<<(std::ostream& out, const WMCreateOrUpdateMappingResponse& obj);

typedef struct _WMDropMappingRequest__isset {
  _WMDropMappingRequest__isset() : mapping(false) {}
  bool mapping :1;
} _WMDropMappingRequest__isset;

class WMDropMappingRequest : public virtual ::apache::thrift::TBase {
 public:

  WMDropMappingRequest(const WMDropMappingRequest&);
  WMDropMappingRequest& operator=(const WMDropMappingRequest&);
  WMDropMappingRequest() noexcept {
  }

  virtual ~WMDropMappingRequest() noexcept;
  WMMapping mapping;

  _WMDropMappingRequest__isset __isset;

  void __set_mapping(const WMMapping& val);

  bool operator == (const WMDropMappingRequest & rhs) const
  {
    if (__isset.mapping != rhs.__isset.mapping)
      return false;
    else if (__isset.mapping && !(mapping == rhs.mapping))
      return false;
    return true;
  }
  bool operator != (const WMDropMappingRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropMappingRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropMappingRequest &a, WMDropMappingRequest &b);

std::ostream& operator<<(std::ostream& out, const WMDropMappingRequest& obj);


class WMDropMappingResponse : public virtual ::apache::thrift::TBase {
 public:

  WMDropMappingResponse(const WMDropMappingResponse&) noexcept;
  WMDropMappingResponse& operator=(const WMDropMappingResponse&) noexcept;
  WMDropMappingResponse() noexcept {
  }

  virtual ~WMDropMappingResponse() noexcept;

  bool operator == (const WMDropMappingResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMDropMappingResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMDropMappingResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMDropMappingResponse &a, WMDropMappingResponse &b);

std::ostream& operator<<(std::ostream& out, const WMDropMappingResponse& obj);

typedef struct _WMCreateOrDropTriggerToPoolMappingRequest__isset {
  _WMCreateOrDropTriggerToPoolMappingRequest__isset() : resourcePlanName(false), triggerName(false), poolPath(false), drop(false), ns(false) {}
  bool resourcePlanName :1;
  bool triggerName :1;
  bool poolPath :1;
  bool drop :1;
  bool ns :1;
} _WMCreateOrDropTriggerToPoolMappingRequest__isset;

class WMCreateOrDropTriggerToPoolMappingRequest : public virtual ::apache::thrift::TBase {
 public:

  WMCreateOrDropTriggerToPoolMappingRequest(const WMCreateOrDropTriggerToPoolMappingRequest&);
  WMCreateOrDropTriggerToPoolMappingRequest& operator=(const WMCreateOrDropTriggerToPoolMappingRequest&);
  WMCreateOrDropTriggerToPoolMappingRequest() noexcept
                                            : resourcePlanName(),
                                              triggerName(),
                                              poolPath(),
                                              drop(0),
                                              ns() {
  }

  virtual ~WMCreateOrDropTriggerToPoolMappingRequest() noexcept;
  std::string resourcePlanName;
  std::string triggerName;
  std::string poolPath;
  bool drop;
  std::string ns;

  _WMCreateOrDropTriggerToPoolMappingRequest__isset __isset;

  void __set_resourcePlanName(const std::string& val);

  void __set_triggerName(const std::string& val);

  void __set_poolPath(const std::string& val);

  void __set_drop(const bool val);

  void __set_ns(const std::string& val);

  bool operator == (const WMCreateOrDropTriggerToPoolMappingRequest & rhs) const
  {
    if (__isset.resourcePlanName != rhs.__isset.resourcePlanName)
      return false;
    else if (__isset.resourcePlanName && !(resourcePlanName == rhs.resourcePlanName))
      return false;
    if (__isset.triggerName != rhs.__isset.triggerName)
      return false;
    else if (__isset.triggerName && !(triggerName == rhs.triggerName))
      return false;
    if (__isset.poolPath != rhs.__isset.poolPath)
      return false;
    else if (__isset.poolPath && !(poolPath == rhs.poolPath))
      return false;
    if (__isset.drop != rhs.__isset.drop)
      return false;
    else if (__isset.drop && !(drop == rhs.drop))
      return false;
    if (__isset.ns != rhs.__isset.ns)
      return false;
    else if (__isset.ns && !(ns == rhs.ns))
      return false;
    return true;
  }
  bool operator != (const WMCreateOrDropTriggerToPoolMappingRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateOrDropTriggerToPoolMappingRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateOrDropTriggerToPoolMappingRequest &a, WMCreateOrDropTriggerToPoolMappingRequest &b);

std::ostream& operator<<(std::ostream& out, const WMCreateOrDropTriggerToPoolMappingRequest& obj);


class WMCreateOrDropTriggerToPoolMappingResponse : public virtual ::apache::thrift::TBase {
 public:

  WMCreateOrDropTriggerToPoolMappingResponse(const WMCreateOrDropTriggerToPoolMappingResponse&) noexcept;
  WMCreateOrDropTriggerToPoolMappingResponse& operator=(const WMCreateOrDropTriggerToPoolMappingResponse&) noexcept;
  WMCreateOrDropTriggerToPoolMappingResponse() noexcept {
  }

  virtual ~WMCreateOrDropTriggerToPoolMappingResponse() noexcept;

  bool operator == (const WMCreateOrDropTriggerToPoolMappingResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WMCreateOrDropTriggerToPoolMappingResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WMCreateOrDropTriggerToPoolMappingResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(WMCreateOrDropTriggerToPoolMappingResponse &a, WMCreateOrDropTriggerToPoolMappingResponse &b);

std::ostream& operator<<(std::ostream& out, const WMCreateOrDropTriggerToPoolMappingResponse& obj);

typedef struct _ISchema__isset {
  _ISchema__isset() : schemaType(false), name(false), catName(false), dbName(false), compatibility(false), validationLevel(false), canEvolve(false), schemaGroup(false), description(false) {}
  bool schemaType :1;
  bool name :1;
  bool catName :1;
  bool dbName :1;
  bool compatibility :1;
  bool validationLevel :1;
  bool canEvolve :1;
  bool schemaGroup :1;
  bool description :1;
} _ISchema__isset;

class ISchema : public virtual ::apache::thrift::TBase {
 public:

  ISchema(const ISchema&);
  ISchema& operator=(const ISchema&);
  ISchema() noexcept
          : schemaType(static_cast<SchemaType::type>(0)),
            name(),
            catName(),
            dbName(),
            compatibility(static_cast<SchemaCompatibility::type>(0)),
            validationLevel(static_cast<SchemaValidation::type>(0)),
            canEvolve(0),
            schemaGroup(),
            description() {
  }

  virtual ~ISchema() noexcept;
  /**
   *
   * @see SchemaType
   */
  SchemaType::type schemaType;
  std::string name;
  std::string catName;
  std::string dbName;
  /**
   *
   * @see SchemaCompatibility
   */
  SchemaCompatibility::type compatibility;
  /**
   *
   * @see SchemaValidation
   */
  SchemaValidation::type validationLevel;
  bool canEvolve;
  std::string schemaGroup;
  std::string description;

  _ISchema__isset __isset;

  void __set_schemaType(const SchemaType::type val);

  void __set_name(const std::string& val);

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_compatibility(const SchemaCompatibility::type val);

  void __set_validationLevel(const SchemaValidation::type val);

  void __set_canEvolve(const bool val);

  void __set_schemaGroup(const std::string& val);

  void __set_description(const std::string& val);

  bool operator == (const ISchema & rhs) const
  {
    if (!(schemaType == rhs.schemaType))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(compatibility == rhs.compatibility))
      return false;
    if (!(validationLevel == rhs.validationLevel))
      return false;
    if (!(canEvolve == rhs.canEvolve))
      return false;
    if (__isset.schemaGroup != rhs.__isset.schemaGroup)
      return false;
    else if (__isset.schemaGroup && !(schemaGroup == rhs.schemaGroup))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    return true;
  }
  bool operator != (const ISchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ISchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ISchema &a, ISchema &b);

std::ostream& operator<<(std::ostream& out, const ISchema& obj);

typedef struct _ISchemaName__isset {
  _ISchemaName__isset() : catName(false), dbName(false), schemaName(false) {}
  bool catName :1;
  bool dbName :1;
  bool schemaName :1;
} _ISchemaName__isset;

class ISchemaName : public virtual ::apache::thrift::TBase {
 public:

  ISchemaName(const ISchemaName&);
  ISchemaName& operator=(const ISchemaName&);
  ISchemaName() noexcept
              : catName(),
                dbName(),
                schemaName() {
  }

  virtual ~ISchemaName() noexcept;
  std::string catName;
  std::string dbName;
  std::string schemaName;

  _ISchemaName__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_schemaName(const std::string& val);

  bool operator == (const ISchemaName & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(schemaName == rhs.schemaName))
      return false;
    return true;
  }
  bool operator != (const ISchemaName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ISchemaName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ISchemaName &a, ISchemaName &b);

std::ostream& operator<<(std::ostream& out, const ISchemaName& obj);

typedef struct _AlterISchemaRequest__isset {
  _AlterISchemaRequest__isset() : name(false), newSchema(false) {}
  bool name :1;
  bool newSchema :1;
} _AlterISchemaRequest__isset;

class AlterISchemaRequest : public virtual ::apache::thrift::TBase {
 public:

  AlterISchemaRequest(const AlterISchemaRequest&);
  AlterISchemaRequest& operator=(const AlterISchemaRequest&);
  AlterISchemaRequest() noexcept {
  }

  virtual ~AlterISchemaRequest() noexcept;
  ISchemaName name;
  ISchema newSchema;

  _AlterISchemaRequest__isset __isset;

  void __set_name(const ISchemaName& val);

  void __set_newSchema(const ISchema& val);

  bool operator == (const AlterISchemaRequest & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(newSchema == rhs.newSchema))
      return false;
    return true;
  }
  bool operator != (const AlterISchemaRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlterISchemaRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AlterISchemaRequest &a, AlterISchemaRequest &b);

std::ostream& operator<<(std::ostream& out, const AlterISchemaRequest& obj);

typedef struct _SchemaVersion__isset {
  _SchemaVersion__isset() : schema(false), version(false), createdAt(false), cols(false), state(false), description(false), schemaText(false), fingerprint(false), name(false), serDe(false) {}
  bool schema :1;
  bool version :1;
  bool createdAt :1;
  bool cols :1;
  bool state :1;
  bool description :1;
  bool schemaText :1;
  bool fingerprint :1;
  bool name :1;
  bool serDe :1;
} _SchemaVersion__isset;

class SchemaVersion : public virtual ::apache::thrift::TBase {
 public:

  SchemaVersion(const SchemaVersion&);
  SchemaVersion& operator=(const SchemaVersion&);
  SchemaVersion() noexcept
                : version(0),
                  createdAt(0),
                  state(static_cast<SchemaVersionState::type>(0)),
                  description(),
                  schemaText(),
                  fingerprint(),
                  name() {
  }

  virtual ~SchemaVersion() noexcept;
  ISchemaName schema;
  int32_t version;
  int64_t createdAt;
  std::vector<FieldSchema>  cols;
  /**
   *
   * @see SchemaVersionState
   */
  SchemaVersionState::type state;
  std::string description;
  std::string schemaText;
  std::string fingerprint;
  std::string name;
  SerDeInfo serDe;

  _SchemaVersion__isset __isset;

  void __set_schema(const ISchemaName& val);

  void __set_version(const int32_t val);

  void __set_createdAt(const int64_t val);

  void __set_cols(const std::vector<FieldSchema> & val);

  void __set_state(const SchemaVersionState::type val);

  void __set_description(const std::string& val);

  void __set_schemaText(const std::string& val);

  void __set_fingerprint(const std::string& val);

  void __set_name(const std::string& val);

  void __set_serDe(const SerDeInfo& val);

  bool operator == (const SchemaVersion & rhs) const
  {
    if (!(schema == rhs.schema))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(createdAt == rhs.createdAt))
      return false;
    if (!(cols == rhs.cols))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.schemaText != rhs.__isset.schemaText)
      return false;
    else if (__isset.schemaText && !(schemaText == rhs.schemaText))
      return false;
    if (__isset.fingerprint != rhs.__isset.fingerprint)
      return false;
    else if (__isset.fingerprint && !(fingerprint == rhs.fingerprint))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.serDe != rhs.__isset.serDe)
      return false;
    else if (__isset.serDe && !(serDe == rhs.serDe))
      return false;
    return true;
  }
  bool operator != (const SchemaVersion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SchemaVersion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaVersion &a, SchemaVersion &b);

std::ostream& operator<<(std::ostream& out, const SchemaVersion& obj);

typedef struct _SchemaVersionDescriptor__isset {
  _SchemaVersionDescriptor__isset() : schema(false), version(false) {}
  bool schema :1;
  bool version :1;
} _SchemaVersionDescriptor__isset;

class SchemaVersionDescriptor : public virtual ::apache::thrift::TBase {
 public:

  SchemaVersionDescriptor(const SchemaVersionDescriptor&);
  SchemaVersionDescriptor& operator=(const SchemaVersionDescriptor&);
  SchemaVersionDescriptor() noexcept
                          : version(0) {
  }

  virtual ~SchemaVersionDescriptor() noexcept;
  ISchemaName schema;
  int32_t version;

  _SchemaVersionDescriptor__isset __isset;

  void __set_schema(const ISchemaName& val);

  void __set_version(const int32_t val);

  bool operator == (const SchemaVersionDescriptor & rhs) const
  {
    if (!(schema == rhs.schema))
      return false;
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const SchemaVersionDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SchemaVersionDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaVersionDescriptor &a, SchemaVersionDescriptor &b);

std::ostream& operator<<(std::ostream& out, const SchemaVersionDescriptor& obj);

typedef struct _FindSchemasByColsRqst__isset {
  _FindSchemasByColsRqst__isset() : colName(false), colNamespace(false), type(false) {}
  bool colName :1;
  bool colNamespace :1;
  bool type :1;
} _FindSchemasByColsRqst__isset;

class FindSchemasByColsRqst : public virtual ::apache::thrift::TBase {
 public:

  FindSchemasByColsRqst(const FindSchemasByColsRqst&);
  FindSchemasByColsRqst& operator=(const FindSchemasByColsRqst&);
  FindSchemasByColsRqst() noexcept
                        : colName(),
                          colNamespace(),
                          type() {
  }

  virtual ~FindSchemasByColsRqst() noexcept;
  std::string colName;
  std::string colNamespace;
  std::string type;

  _FindSchemasByColsRqst__isset __isset;

  void __set_colName(const std::string& val);

  void __set_colNamespace(const std::string& val);

  void __set_type(const std::string& val);

  bool operator == (const FindSchemasByColsRqst & rhs) const
  {
    if (__isset.colName != rhs.__isset.colName)
      return false;
    else if (__isset.colName && !(colName == rhs.colName))
      return false;
    if (__isset.colNamespace != rhs.__isset.colNamespace)
      return false;
    else if (__isset.colNamespace && !(colNamespace == rhs.colNamespace))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const FindSchemasByColsRqst &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FindSchemasByColsRqst & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FindSchemasByColsRqst &a, FindSchemasByColsRqst &b);

std::ostream& operator<<(std::ostream& out, const FindSchemasByColsRqst& obj);

typedef struct _FindSchemasByColsResp__isset {
  _FindSchemasByColsResp__isset() : schemaVersions(false) {}
  bool schemaVersions :1;
} _FindSchemasByColsResp__isset;

class FindSchemasByColsResp : public virtual ::apache::thrift::TBase {
 public:

  FindSchemasByColsResp(const FindSchemasByColsResp&);
  FindSchemasByColsResp& operator=(const FindSchemasByColsResp&);
  FindSchemasByColsResp() noexcept {
  }

  virtual ~FindSchemasByColsResp() noexcept;
  std::vector<SchemaVersionDescriptor>  schemaVersions;

  _FindSchemasByColsResp__isset __isset;

  void __set_schemaVersions(const std::vector<SchemaVersionDescriptor> & val);

  bool operator == (const FindSchemasByColsResp & rhs) const
  {
    if (!(schemaVersions == rhs.schemaVersions))
      return false;
    return true;
  }
  bool operator != (const FindSchemasByColsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FindSchemasByColsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FindSchemasByColsResp &a, FindSchemasByColsResp &b);

std::ostream& operator<<(std::ostream& out, const FindSchemasByColsResp& obj);

typedef struct _MapSchemaVersionToSerdeRequest__isset {
  _MapSchemaVersionToSerdeRequest__isset() : schemaVersion(false), serdeName(false) {}
  bool schemaVersion :1;
  bool serdeName :1;
} _MapSchemaVersionToSerdeRequest__isset;

class MapSchemaVersionToSerdeRequest : public virtual ::apache::thrift::TBase {
 public:

  MapSchemaVersionToSerdeRequest(const MapSchemaVersionToSerdeRequest&);
  MapSchemaVersionToSerdeRequest& operator=(const MapSchemaVersionToSerdeRequest&);
  MapSchemaVersionToSerdeRequest() noexcept
                                 : serdeName() {
  }

  virtual ~MapSchemaVersionToSerdeRequest() noexcept;
  SchemaVersionDescriptor schemaVersion;
  std::string serdeName;

  _MapSchemaVersionToSerdeRequest__isset __isset;

  void __set_schemaVersion(const SchemaVersionDescriptor& val);

  void __set_serdeName(const std::string& val);

  bool operator == (const MapSchemaVersionToSerdeRequest & rhs) const
  {
    if (!(schemaVersion == rhs.schemaVersion))
      return false;
    if (!(serdeName == rhs.serdeName))
      return false;
    return true;
  }
  bool operator != (const MapSchemaVersionToSerdeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MapSchemaVersionToSerdeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(MapSchemaVersionToSerdeRequest &a, MapSchemaVersionToSerdeRequest &b);

std::ostream& operator<<(std::ostream& out, const MapSchemaVersionToSerdeRequest& obj);

typedef struct _SetSchemaVersionStateRequest__isset {
  _SetSchemaVersionStateRequest__isset() : schemaVersion(false), state(false) {}
  bool schemaVersion :1;
  bool state :1;
} _SetSchemaVersionStateRequest__isset;

class SetSchemaVersionStateRequest : public virtual ::apache::thrift::TBase {
 public:

  SetSchemaVersionStateRequest(const SetSchemaVersionStateRequest&);
  SetSchemaVersionStateRequest& operator=(const SetSchemaVersionStateRequest&);
  SetSchemaVersionStateRequest() noexcept
                               : state(static_cast<SchemaVersionState::type>(0)) {
  }

  virtual ~SetSchemaVersionStateRequest() noexcept;
  SchemaVersionDescriptor schemaVersion;
  /**
   *
   * @see SchemaVersionState
   */
  SchemaVersionState::type state;

  _SetSchemaVersionStateRequest__isset __isset;

  void __set_schemaVersion(const SchemaVersionDescriptor& val);

  void __set_state(const SchemaVersionState::type val);

  bool operator == (const SetSchemaVersionStateRequest & rhs) const
  {
    if (!(schemaVersion == rhs.schemaVersion))
      return false;
    if (!(state == rhs.state))
      return false;
    return true;
  }
  bool operator != (const SetSchemaVersionStateRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetSchemaVersionStateRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SetSchemaVersionStateRequest &a, SetSchemaVersionStateRequest &b);

std::ostream& operator<<(std::ostream& out, const SetSchemaVersionStateRequest& obj);

typedef struct _GetSerdeRequest__isset {
  _GetSerdeRequest__isset() : serdeName(false) {}
  bool serdeName :1;
} _GetSerdeRequest__isset;

class GetSerdeRequest : public virtual ::apache::thrift::TBase {
 public:

  GetSerdeRequest(const GetSerdeRequest&);
  GetSerdeRequest& operator=(const GetSerdeRequest&);
  GetSerdeRequest() noexcept
                  : serdeName() {
  }

  virtual ~GetSerdeRequest() noexcept;
  std::string serdeName;

  _GetSerdeRequest__isset __isset;

  void __set_serdeName(const std::string& val);

  bool operator == (const GetSerdeRequest & rhs) const
  {
    if (!(serdeName == rhs.serdeName))
      return false;
    return true;
  }
  bool operator != (const GetSerdeRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetSerdeRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetSerdeRequest &a, GetSerdeRequest &b);

std::ostream& operator<<(std::ostream& out, const GetSerdeRequest& obj);

typedef struct _RuntimeStat__isset {
  _RuntimeStat__isset() : createTime(false) {}
  bool createTime :1;
} _RuntimeStat__isset;

class RuntimeStat : public virtual ::apache::thrift::TBase {
 public:

  RuntimeStat(const RuntimeStat&);
  RuntimeStat& operator=(const RuntimeStat&);
  RuntimeStat() noexcept
              : createTime(0),
                weight(0),
                payload() {
  }

  virtual ~RuntimeStat() noexcept;
  int32_t createTime;
  int32_t weight;
  std::string payload;

  _RuntimeStat__isset __isset;

  void __set_createTime(const int32_t val);

  void __set_weight(const int32_t val);

  void __set_payload(const std::string& val);

  bool operator == (const RuntimeStat & rhs) const
  {
    if (__isset.createTime != rhs.__isset.createTime)
      return false;
    else if (__isset.createTime && !(createTime == rhs.createTime))
      return false;
    if (!(weight == rhs.weight))
      return false;
    if (!(payload == rhs.payload))
      return false;
    return true;
  }
  bool operator != (const RuntimeStat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RuntimeStat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RuntimeStat &a, RuntimeStat &b);

std::ostream& operator<<(std::ostream& out, const RuntimeStat& obj);


class GetRuntimeStatsRequest : public virtual ::apache::thrift::TBase {
 public:

  GetRuntimeStatsRequest(const GetRuntimeStatsRequest&) noexcept;
  GetRuntimeStatsRequest& operator=(const GetRuntimeStatsRequest&) noexcept;
  GetRuntimeStatsRequest() noexcept
                         : maxWeight(0),
                           maxCreateTime(0) {
  }

  virtual ~GetRuntimeStatsRequest() noexcept;
  int32_t maxWeight;
  int32_t maxCreateTime;

  void __set_maxWeight(const int32_t val);

  void __set_maxCreateTime(const int32_t val);

  bool operator == (const GetRuntimeStatsRequest & rhs) const
  {
    if (!(maxWeight == rhs.maxWeight))
      return false;
    if (!(maxCreateTime == rhs.maxCreateTime))
      return false;
    return true;
  }
  bool operator != (const GetRuntimeStatsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetRuntimeStatsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetRuntimeStatsRequest &a, GetRuntimeStatsRequest &b);

std::ostream& operator<<(std::ostream& out, const GetRuntimeStatsRequest& obj);

typedef struct _CreateTableRequest__isset {
  _CreateTableRequest__isset() : envContext(false), primaryKeys(false), foreignKeys(false), uniqueConstraints(false), notNullConstraints(false), defaultConstraints(false), checkConstraints(false), processorCapabilities(false), processorIdentifier(false) {}
  bool envContext :1;
  bool primaryKeys :1;
  bool foreignKeys :1;
  bool uniqueConstraints :1;
  bool notNullConstraints :1;
  bool defaultConstraints :1;
  bool checkConstraints :1;
  bool processorCapabilities :1;
  bool processorIdentifier :1;
} _CreateTableRequest__isset;

class CreateTableRequest : public virtual ::apache::thrift::TBase {
 public:

  CreateTableRequest(const CreateTableRequest&);
  CreateTableRequest& operator=(const CreateTableRequest&);
  CreateTableRequest() noexcept
                     : processorIdentifier() {
  }

  virtual ~CreateTableRequest() noexcept;
  Table table;
  EnvironmentContext envContext;
  std::vector<SQLPrimaryKey>  primaryKeys;
  std::vector<SQLForeignKey>  foreignKeys;
  std::vector<SQLUniqueConstraint>  uniqueConstraints;
  std::vector<SQLNotNullConstraint>  notNullConstraints;
  std::vector<SQLDefaultConstraint>  defaultConstraints;
  std::vector<SQLCheckConstraint>  checkConstraints;
  std::vector<std::string>  processorCapabilities;
  std::string processorIdentifier;

  _CreateTableRequest__isset __isset;

  void __set_table(const Table& val);

  void __set_envContext(const EnvironmentContext& val);

  void __set_primaryKeys(const std::vector<SQLPrimaryKey> & val);

  void __set_foreignKeys(const std::vector<SQLForeignKey> & val);

  void __set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val);

  void __set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val);

  void __set_defaultConstraints(const std::vector<SQLDefaultConstraint> & val);

  void __set_checkConstraints(const std::vector<SQLCheckConstraint> & val);

  void __set_processorCapabilities(const std::vector<std::string> & val);

  void __set_processorIdentifier(const std::string& val);

  bool operator == (const CreateTableRequest & rhs) const
  {
    if (!(table == rhs.table))
      return false;
    if (__isset.envContext != rhs.__isset.envContext)
      return false;
    else if (__isset.envContext && !(envContext == rhs.envContext))
      return false;
    if (__isset.primaryKeys != rhs.__isset.primaryKeys)
      return false;
    else if (__isset.primaryKeys && !(primaryKeys == rhs.primaryKeys))
      return false;
    if (__isset.foreignKeys != rhs.__isset.foreignKeys)
      return false;
    else if (__isset.foreignKeys && !(foreignKeys == rhs.foreignKeys))
      return false;
    if (__isset.uniqueConstraints != rhs.__isset.uniqueConstraints)
      return false;
    else if (__isset.uniqueConstraints && !(uniqueConstraints == rhs.uniqueConstraints))
      return false;
    if (__isset.notNullConstraints != rhs.__isset.notNullConstraints)
      return false;
    else if (__isset.notNullConstraints && !(notNullConstraints == rhs.notNullConstraints))
      return false;
    if (__isset.defaultConstraints != rhs.__isset.defaultConstraints)
      return false;
    else if (__isset.defaultConstraints && !(defaultConstraints == rhs.defaultConstraints))
      return false;
    if (__isset.checkConstraints != rhs.__isset.checkConstraints)
      return false;
    else if (__isset.checkConstraints && !(checkConstraints == rhs.checkConstraints))
      return false;
    if (__isset.processorCapabilities != rhs.__isset.processorCapabilities)
      return false;
    else if (__isset.processorCapabilities && !(processorCapabilities == rhs.processorCapabilities))
      return false;
    if (__isset.processorIdentifier != rhs.__isset.processorIdentifier)
      return false;
    else if (__isset.processorIdentifier && !(processorIdentifier == rhs.processorIdentifier))
      return false;
    return true;
  }
  bool operator != (const CreateTableRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreateTableRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreateTableRequest &a, CreateTableRequest &b);

std::ostream& operator<<(std::ostream& out, const CreateTableRequest& obj);

typedef struct _CreateDatabaseRequest__isset {
  _CreateDatabaseRequest__isset() : description(false), locationUri(false), parameters(false), privileges(false), ownerName(false), ownerType(false), catalogName(false), createTime(false), managedLocationUri(false), type(false), dataConnectorName(false), remote_dbname(false) {}
  bool description :1;
  bool locationUri :1;
  bool parameters :1;
  bool privileges :1;
  bool ownerName :1;
  bool ownerType :1;
  bool catalogName :1;
  bool createTime :1;
  bool managedLocationUri :1;
  bool type :1;
  bool dataConnectorName :1;
  bool remote_dbname :1;
} _CreateDatabaseRequest__isset;

class CreateDatabaseRequest : public virtual ::apache::thrift::TBase {
 public:

  CreateDatabaseRequest(const CreateDatabaseRequest&);
  CreateDatabaseRequest& operator=(const CreateDatabaseRequest&);
  CreateDatabaseRequest() noexcept
                        : databaseName(),
                          description(),
                          locationUri(),
                          ownerName(),
                          ownerType(static_cast<PrincipalType::type>(0)),
                          catalogName(),
                          createTime(0),
                          managedLocationUri(),
                          type(static_cast<DatabaseType::type>(0)),
                          dataConnectorName(),
                          remote_dbname() {
  }

  virtual ~CreateDatabaseRequest() noexcept;
  std::string databaseName;
  std::string description;
  std::string locationUri;
  std::map<std::string, std::string>  parameters;
  PrincipalPrivilegeSet privileges;
  std::string ownerName;
  /**
   *
   * @see PrincipalType
   */
  PrincipalType::type ownerType;
  std::string catalogName;
  int32_t createTime;
  std::string managedLocationUri;
  /**
   *
   * @see DatabaseType
   */
  DatabaseType::type type;
  std::string dataConnectorName;
  std::string remote_dbname;

  _CreateDatabaseRequest__isset __isset;

  void __set_databaseName(const std::string& val);

  void __set_description(const std::string& val);

  void __set_locationUri(const std::string& val);

  void __set_parameters(const std::map<std::string, std::string> & val);

  void __set_privileges(const PrincipalPrivilegeSet& val);

  void __set_ownerName(const std::string& val);

  void __set_ownerType(const PrincipalType::type val);

  void __set_catalogName(const std::string& val);

  void __set_createTime(const int32_t val);

  void __set_managedLocationUri(const std::string& val);

  void __set_type(const DatabaseType::type val);

  void __set_dataConnectorName(const std::string& val);

  void __set_remote_dbname(const std::string& val);

  bool operator == (const CreateDatabaseRequest & rhs) const
  {
    if (!(databaseName == rhs.databaseName))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.locationUri != rhs.__isset.locationUri)
      return false;
    else if (__isset.locationUri && !(locationUri == rhs.locationUri))
      return false;
    if (__isset.parameters != rhs.__isset.parameters)
      return false;
    else if (__isset.parameters && !(parameters == rhs.parameters))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    if (__isset.ownerName != rhs.__isset.ownerName)
      return false;
    else if (__isset.ownerName && !(ownerName == rhs.ownerName))
      return false;
    if (__isset.ownerType != rhs.__isset.ownerType)
      return false;
    else if (__isset.ownerType && !(ownerType == rhs.ownerType))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.createTime != rhs.__isset.createTime)
      return false;
    else if (__isset.createTime && !(createTime == rhs.createTime))
      return false;
    if (__isset.managedLocationUri != rhs.__isset.managedLocationUri)
      return false;
    else if (__isset.managedLocationUri && !(managedLocationUri == rhs.managedLocationUri))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.dataConnectorName != rhs.__isset.dataConnectorName)
      return false;
    else if (__isset.dataConnectorName && !(dataConnectorName == rhs.dataConnectorName))
      return false;
    if (__isset.remote_dbname != rhs.__isset.remote_dbname)
      return false;
    else if (__isset.remote_dbname && !(remote_dbname == rhs.remote_dbname))
      return false;
    return true;
  }
  bool operator != (const CreateDatabaseRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreateDatabaseRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreateDatabaseRequest &a, CreateDatabaseRequest &b);

std::ostream& operator<<(std::ostream& out, const CreateDatabaseRequest& obj);


class CreateDataConnectorRequest : public virtual ::apache::thrift::TBase {
 public:

  CreateDataConnectorRequest(const CreateDataConnectorRequest&);
  CreateDataConnectorRequest& operator=(const CreateDataConnectorRequest&);
  CreateDataConnectorRequest() noexcept {
  }

  virtual ~CreateDataConnectorRequest() noexcept;
  DataConnector connector;

  void __set_connector(const DataConnector& val);

  bool operator == (const CreateDataConnectorRequest & rhs) const
  {
    if (!(connector == rhs.connector))
      return false;
    return true;
  }
  bool operator != (const CreateDataConnectorRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreateDataConnectorRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreateDataConnectorRequest &a, CreateDataConnectorRequest &b);

std::ostream& operator<<(std::ostream& out, const CreateDataConnectorRequest& obj);


class GetDataConnectorRequest : public virtual ::apache::thrift::TBase {
 public:

  GetDataConnectorRequest(const GetDataConnectorRequest&);
  GetDataConnectorRequest& operator=(const GetDataConnectorRequest&);
  GetDataConnectorRequest() noexcept
                          : connectorName() {
  }

  virtual ~GetDataConnectorRequest() noexcept;
  std::string connectorName;

  void __set_connectorName(const std::string& val);

  bool operator == (const GetDataConnectorRequest & rhs) const
  {
    if (!(connectorName == rhs.connectorName))
      return false;
    return true;
  }
  bool operator != (const GetDataConnectorRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetDataConnectorRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetDataConnectorRequest &a, GetDataConnectorRequest &b);

std::ostream& operator<<(std::ostream& out, const GetDataConnectorRequest& obj);


class AlterDataConnectorRequest : public virtual ::apache::thrift::TBase {
 public:

  AlterDataConnectorRequest(const AlterDataConnectorRequest&);
  AlterDataConnectorRequest& operator=(const AlterDataConnectorRequest&);
  AlterDataConnectorRequest() noexcept
                            : connectorName() {
  }

  virtual ~AlterDataConnectorRequest() noexcept;
  std::string connectorName;
  DataConnector newConnector;

  void __set_connectorName(const std::string& val);

  void __set_newConnector(const DataConnector& val);

  bool operator == (const AlterDataConnectorRequest & rhs) const
  {
    if (!(connectorName == rhs.connectorName))
      return false;
    if (!(newConnector == rhs.newConnector))
      return false;
    return true;
  }
  bool operator != (const AlterDataConnectorRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlterDataConnectorRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AlterDataConnectorRequest &a, AlterDataConnectorRequest &b);

std::ostream& operator<<(std::ostream& out, const AlterDataConnectorRequest& obj);

typedef struct _DropDataConnectorRequest__isset {
  _DropDataConnectorRequest__isset() : ifNotExists(false), checkReferences(false) {}
  bool ifNotExists :1;
  bool checkReferences :1;
} _DropDataConnectorRequest__isset;

class DropDataConnectorRequest : public virtual ::apache::thrift::TBase {
 public:

  DropDataConnectorRequest(const DropDataConnectorRequest&);
  DropDataConnectorRequest& operator=(const DropDataConnectorRequest&);
  DropDataConnectorRequest() noexcept
                           : connectorName(),
                             ifNotExists(0),
                             checkReferences(0) {
  }

  virtual ~DropDataConnectorRequest() noexcept;
  std::string connectorName;
  bool ifNotExists;
  bool checkReferences;

  _DropDataConnectorRequest__isset __isset;

  void __set_connectorName(const std::string& val);

  void __set_ifNotExists(const bool val);

  void __set_checkReferences(const bool val);

  bool operator == (const DropDataConnectorRequest & rhs) const
  {
    if (!(connectorName == rhs.connectorName))
      return false;
    if (__isset.ifNotExists != rhs.__isset.ifNotExists)
      return false;
    else if (__isset.ifNotExists && !(ifNotExists == rhs.ifNotExists))
      return false;
    if (__isset.checkReferences != rhs.__isset.checkReferences)
      return false;
    else if (__isset.checkReferences && !(checkReferences == rhs.checkReferences))
      return false;
    return true;
  }
  bool operator != (const DropDataConnectorRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropDataConnectorRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropDataConnectorRequest &a, DropDataConnectorRequest &b);

std::ostream& operator<<(std::ostream& out, const DropDataConnectorRequest& obj);


class ScheduledQueryPollRequest : public virtual ::apache::thrift::TBase {
 public:

  ScheduledQueryPollRequest(const ScheduledQueryPollRequest&);
  ScheduledQueryPollRequest& operator=(const ScheduledQueryPollRequest&);
  ScheduledQueryPollRequest() noexcept
                            : clusterNamespace() {
  }

  virtual ~ScheduledQueryPollRequest() noexcept;
  std::string clusterNamespace;

  void __set_clusterNamespace(const std::string& val);

  bool operator == (const ScheduledQueryPollRequest & rhs) const
  {
    if (!(clusterNamespace == rhs.clusterNamespace))
      return false;
    return true;
  }
  bool operator != (const ScheduledQueryPollRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScheduledQueryPollRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScheduledQueryPollRequest &a, ScheduledQueryPollRequest &b);

std::ostream& operator<<(std::ostream& out, const ScheduledQueryPollRequest& obj);


class ScheduledQueryKey : public virtual ::apache::thrift::TBase {
 public:

  ScheduledQueryKey(const ScheduledQueryKey&);
  ScheduledQueryKey& operator=(const ScheduledQueryKey&);
  ScheduledQueryKey() noexcept
                    : scheduleName(),
                      clusterNamespace() {
  }

  virtual ~ScheduledQueryKey() noexcept;
  std::string scheduleName;
  std::string clusterNamespace;

  void __set_scheduleName(const std::string& val);

  void __set_clusterNamespace(const std::string& val);

  bool operator == (const ScheduledQueryKey & rhs) const
  {
    if (!(scheduleName == rhs.scheduleName))
      return false;
    if (!(clusterNamespace == rhs.clusterNamespace))
      return false;
    return true;
  }
  bool operator != (const ScheduledQueryKey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScheduledQueryKey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScheduledQueryKey &a, ScheduledQueryKey &b);

std::ostream& operator<<(std::ostream& out, const ScheduledQueryKey& obj);

typedef struct _ScheduledQueryPollResponse__isset {
  _ScheduledQueryPollResponse__isset() : scheduleKey(false), executionId(false), query(false), user(false) {}
  bool scheduleKey :1;
  bool executionId :1;
  bool query :1;
  bool user :1;
} _ScheduledQueryPollResponse__isset;

class ScheduledQueryPollResponse : public virtual ::apache::thrift::TBase {
 public:

  ScheduledQueryPollResponse(const ScheduledQueryPollResponse&);
  ScheduledQueryPollResponse& operator=(const ScheduledQueryPollResponse&);
  ScheduledQueryPollResponse() noexcept
                             : executionId(0),
                               query(),
                               user() {
  }

  virtual ~ScheduledQueryPollResponse() noexcept;
  ScheduledQueryKey scheduleKey;
  int64_t executionId;
  std::string query;
  std::string user;

  _ScheduledQueryPollResponse__isset __isset;

  void __set_scheduleKey(const ScheduledQueryKey& val);

  void __set_executionId(const int64_t val);

  void __set_query(const std::string& val);

  void __set_user(const std::string& val);

  bool operator == (const ScheduledQueryPollResponse & rhs) const
  {
    if (__isset.scheduleKey != rhs.__isset.scheduleKey)
      return false;
    else if (__isset.scheduleKey && !(scheduleKey == rhs.scheduleKey))
      return false;
    if (__isset.executionId != rhs.__isset.executionId)
      return false;
    else if (__isset.executionId && !(executionId == rhs.executionId))
      return false;
    if (__isset.query != rhs.__isset.query)
      return false;
    else if (__isset.query && !(query == rhs.query))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    return true;
  }
  bool operator != (const ScheduledQueryPollResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScheduledQueryPollResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScheduledQueryPollResponse &a, ScheduledQueryPollResponse &b);

std::ostream& operator<<(std::ostream& out, const ScheduledQueryPollResponse& obj);

typedef struct _ScheduledQuery__isset {
  _ScheduledQuery__isset() : enabled(false), schedule(false), user(false), query(false), nextExecution(false) {}
  bool enabled :1;
  bool schedule :1;
  bool user :1;
  bool query :1;
  bool nextExecution :1;
} _ScheduledQuery__isset;

class ScheduledQuery : public virtual ::apache::thrift::TBase {
 public:

  ScheduledQuery(const ScheduledQuery&);
  ScheduledQuery& operator=(const ScheduledQuery&);
  ScheduledQuery() noexcept
                 : enabled(0),
                   schedule(),
                   user(),
                   query(),
                   nextExecution(0) {
  }

  virtual ~ScheduledQuery() noexcept;
  ScheduledQueryKey scheduleKey;
  bool enabled;
  std::string schedule;
  std::string user;
  std::string query;
  int32_t nextExecution;

  _ScheduledQuery__isset __isset;

  void __set_scheduleKey(const ScheduledQueryKey& val);

  void __set_enabled(const bool val);

  void __set_schedule(const std::string& val);

  void __set_user(const std::string& val);

  void __set_query(const std::string& val);

  void __set_nextExecution(const int32_t val);

  bool operator == (const ScheduledQuery & rhs) const
  {
    if (!(scheduleKey == rhs.scheduleKey))
      return false;
    if (__isset.enabled != rhs.__isset.enabled)
      return false;
    else if (__isset.enabled && !(enabled == rhs.enabled))
      return false;
    if (__isset.schedule != rhs.__isset.schedule)
      return false;
    else if (__isset.schedule && !(schedule == rhs.schedule))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    if (__isset.query != rhs.__isset.query)
      return false;
    else if (__isset.query && !(query == rhs.query))
      return false;
    if (__isset.nextExecution != rhs.__isset.nextExecution)
      return false;
    else if (__isset.nextExecution && !(nextExecution == rhs.nextExecution))
      return false;
    return true;
  }
  bool operator != (const ScheduledQuery &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScheduledQuery & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScheduledQuery &a, ScheduledQuery &b);

std::ostream& operator<<(std::ostream& out, const ScheduledQuery& obj);


class ScheduledQueryMaintenanceRequest : public virtual ::apache::thrift::TBase {
 public:

  ScheduledQueryMaintenanceRequest(const ScheduledQueryMaintenanceRequest&);
  ScheduledQueryMaintenanceRequest& operator=(const ScheduledQueryMaintenanceRequest&);
  ScheduledQueryMaintenanceRequest() noexcept
                                   : type(static_cast<ScheduledQueryMaintenanceRequestType::type>(0)) {
  }

  virtual ~ScheduledQueryMaintenanceRequest() noexcept;
  /**
   *
   * @see ScheduledQueryMaintenanceRequestType
   */
  ScheduledQueryMaintenanceRequestType::type type;
  ScheduledQuery scheduledQuery;

  void __set_type(const ScheduledQueryMaintenanceRequestType::type val);

  void __set_scheduledQuery(const ScheduledQuery& val);

  bool operator == (const ScheduledQueryMaintenanceRequest & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(scheduledQuery == rhs.scheduledQuery))
      return false;
    return true;
  }
  bool operator != (const ScheduledQueryMaintenanceRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScheduledQueryMaintenanceRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScheduledQueryMaintenanceRequest &a, ScheduledQueryMaintenanceRequest &b);

std::ostream& operator<<(std::ostream& out, const ScheduledQueryMaintenanceRequest& obj);

typedef struct _ScheduledQueryProgressInfo__isset {
  _ScheduledQueryProgressInfo__isset() : errorMessage(false) {}
  bool errorMessage :1;
} _ScheduledQueryProgressInfo__isset;

class ScheduledQueryProgressInfo : public virtual ::apache::thrift::TBase {
 public:

  ScheduledQueryProgressInfo(const ScheduledQueryProgressInfo&);
  ScheduledQueryProgressInfo& operator=(const ScheduledQueryProgressInfo&);
  ScheduledQueryProgressInfo() noexcept
                             : scheduledExecutionId(0),
                               state(static_cast<QueryState::type>(0)),
                               executorQueryId(),
                               errorMessage() {
  }

  virtual ~ScheduledQueryProgressInfo() noexcept;
  int64_t scheduledExecutionId;
  /**
   *
   * @see QueryState
   */
  QueryState::type state;
  std::string executorQueryId;
  std::string errorMessage;

  _ScheduledQueryProgressInfo__isset __isset;

  void __set_scheduledExecutionId(const int64_t val);

  void __set_state(const QueryState::type val);

  void __set_executorQueryId(const std::string& val);

  void __set_errorMessage(const std::string& val);

  bool operator == (const ScheduledQueryProgressInfo & rhs) const
  {
    if (!(scheduledExecutionId == rhs.scheduledExecutionId))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(executorQueryId == rhs.executorQueryId))
      return false;
    if (__isset.errorMessage != rhs.__isset.errorMessage)
      return false;
    else if (__isset.errorMessage && !(errorMessage == rhs.errorMessage))
      return false;
    return true;
  }
  bool operator != (const ScheduledQueryProgressInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScheduledQueryProgressInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScheduledQueryProgressInfo &a, ScheduledQueryProgressInfo &b);

std::ostream& operator<<(std::ostream& out, const ScheduledQueryProgressInfo& obj);

typedef struct _AlterPartitionsRequest__isset {
  _AlterPartitionsRequest__isset() : catName(false), environmentContext(false), writeId(true), validWriteIdList(false), skipColumnSchemaForPartition(false), partitionColSchema(false) {}
  bool catName :1;
  bool environmentContext :1;
  bool writeId :1;
  bool validWriteIdList :1;
  bool skipColumnSchemaForPartition :1;
  bool partitionColSchema :1;
} _AlterPartitionsRequest__isset;

class AlterPartitionsRequest : public virtual ::apache::thrift::TBase {
 public:

  AlterPartitionsRequest(const AlterPartitionsRequest&);
  AlterPartitionsRequest& operator=(const AlterPartitionsRequest&);
  AlterPartitionsRequest() noexcept
                         : catName(),
                           dbName(),
                           tableName(),
                           writeId(-1LL),
                           validWriteIdList(),
                           skipColumnSchemaForPartition(0) {
  }

  virtual ~AlterPartitionsRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tableName;
  std::vector<Partition>  partitions;
  EnvironmentContext environmentContext;
  int64_t writeId;
  std::string validWriteIdList;
  bool skipColumnSchemaForPartition;
  std::vector<FieldSchema>  partitionColSchema;

  _AlterPartitionsRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_partitions(const std::vector<Partition> & val);

  void __set_environmentContext(const EnvironmentContext& val);

  void __set_writeId(const int64_t val);

  void __set_validWriteIdList(const std::string& val);

  void __set_skipColumnSchemaForPartition(const bool val);

  void __set_partitionColSchema(const std::vector<FieldSchema> & val);

  bool operator == (const AlterPartitionsRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    if (__isset.environmentContext != rhs.__isset.environmentContext)
      return false;
    else if (__isset.environmentContext && !(environmentContext == rhs.environmentContext))
      return false;
    if (__isset.writeId != rhs.__isset.writeId)
      return false;
    else if (__isset.writeId && !(writeId == rhs.writeId))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.skipColumnSchemaForPartition != rhs.__isset.skipColumnSchemaForPartition)
      return false;
    else if (__isset.skipColumnSchemaForPartition && !(skipColumnSchemaForPartition == rhs.skipColumnSchemaForPartition))
      return false;
    if (__isset.partitionColSchema != rhs.__isset.partitionColSchema)
      return false;
    else if (__isset.partitionColSchema && !(partitionColSchema == rhs.partitionColSchema))
      return false;
    return true;
  }
  bool operator != (const AlterPartitionsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlterPartitionsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AlterPartitionsRequest &a, AlterPartitionsRequest &b);

std::ostream& operator<<(std::ostream& out, const AlterPartitionsRequest& obj);

typedef struct _AppendPartitionsRequest__isset {
  _AppendPartitionsRequest__isset() : catalogName(false), name(false), partVals(false), environmentContext(false) {}
  bool catalogName :1;
  bool name :1;
  bool partVals :1;
  bool environmentContext :1;
} _AppendPartitionsRequest__isset;

class AppendPartitionsRequest : public virtual ::apache::thrift::TBase {
 public:

  AppendPartitionsRequest(const AppendPartitionsRequest&);
  AppendPartitionsRequest& operator=(const AppendPartitionsRequest&);
  AppendPartitionsRequest() noexcept
                          : catalogName(),
                            dbName(),
                            tableName(),
                            name() {
  }

  virtual ~AppendPartitionsRequest() noexcept;
  std::string catalogName;
  std::string dbName;
  std::string tableName;
  std::string name;
  std::vector<std::string>  partVals;
  EnvironmentContext environmentContext;

  _AppendPartitionsRequest__isset __isset;

  void __set_catalogName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_name(const std::string& val);

  void __set_partVals(const std::vector<std::string> & val);

  void __set_environmentContext(const EnvironmentContext& val);

  bool operator == (const AppendPartitionsRequest & rhs) const
  {
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.partVals != rhs.__isset.partVals)
      return false;
    else if (__isset.partVals && !(partVals == rhs.partVals))
      return false;
    if (__isset.environmentContext != rhs.__isset.environmentContext)
      return false;
    else if (__isset.environmentContext && !(environmentContext == rhs.environmentContext))
      return false;
    return true;
  }
  bool operator != (const AppendPartitionsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AppendPartitionsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AppendPartitionsRequest &a, AppendPartitionsRequest &b);

std::ostream& operator<<(std::ostream& out, const AppendPartitionsRequest& obj);


class AlterPartitionsResponse : public virtual ::apache::thrift::TBase {
 public:

  AlterPartitionsResponse(const AlterPartitionsResponse&) noexcept;
  AlterPartitionsResponse& operator=(const AlterPartitionsResponse&) noexcept;
  AlterPartitionsResponse() noexcept {
  }

  virtual ~AlterPartitionsResponse() noexcept;

  bool operator == (const AlterPartitionsResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const AlterPartitionsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlterPartitionsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AlterPartitionsResponse &a, AlterPartitionsResponse &b);

std::ostream& operator<<(std::ostream& out, const AlterPartitionsResponse& obj);

typedef struct _RenamePartitionRequest__isset {
  _RenamePartitionRequest__isset() : catName(false), validWriteIdList(false), txnId(false), clonePart(false) {}
  bool catName :1;
  bool validWriteIdList :1;
  bool txnId :1;
  bool clonePart :1;
} _RenamePartitionRequest__isset;

class RenamePartitionRequest : public virtual ::apache::thrift::TBase {
 public:

  RenamePartitionRequest(const RenamePartitionRequest&);
  RenamePartitionRequest& operator=(const RenamePartitionRequest&);
  RenamePartitionRequest() noexcept
                         : catName(),
                           dbName(),
                           tableName(),
                           validWriteIdList(),
                           txnId(0),
                           clonePart(0) {
  }

  virtual ~RenamePartitionRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tableName;
  std::vector<std::string>  partVals;
  Partition newPart;
  std::string validWriteIdList;
  int64_t txnId;
  bool clonePart;

  _RenamePartitionRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_partVals(const std::vector<std::string> & val);

  void __set_newPart(const Partition& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_txnId(const int64_t val);

  void __set_clonePart(const bool val);

  bool operator == (const RenamePartitionRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(partVals == rhs.partVals))
      return false;
    if (!(newPart == rhs.newPart))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.txnId != rhs.__isset.txnId)
      return false;
    else if (__isset.txnId && !(txnId == rhs.txnId))
      return false;
    if (__isset.clonePart != rhs.__isset.clonePart)
      return false;
    else if (__isset.clonePart && !(clonePart == rhs.clonePart))
      return false;
    return true;
  }
  bool operator != (const RenamePartitionRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RenamePartitionRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RenamePartitionRequest &a, RenamePartitionRequest &b);

std::ostream& operator<<(std::ostream& out, const RenamePartitionRequest& obj);


class RenamePartitionResponse : public virtual ::apache::thrift::TBase {
 public:

  RenamePartitionResponse(const RenamePartitionResponse&) noexcept;
  RenamePartitionResponse& operator=(const RenamePartitionResponse&) noexcept;
  RenamePartitionResponse() noexcept {
  }

  virtual ~RenamePartitionResponse() noexcept;

  bool operator == (const RenamePartitionResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const RenamePartitionResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RenamePartitionResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RenamePartitionResponse &a, RenamePartitionResponse &b);

std::ostream& operator<<(std::ostream& out, const RenamePartitionResponse& obj);

typedef struct _AlterTableRequest__isset {
  _AlterTableRequest__isset() : catName(false), environmentContext(false), writeId(true), validWriteIdList(false), processorCapabilities(false), processorIdentifier(false), expectedParameterKey(false), expectedParameterValue(false) {}
  bool catName :1;
  bool environmentContext :1;
  bool writeId :1;
  bool validWriteIdList :1;
  bool processorCapabilities :1;
  bool processorIdentifier :1;
  bool expectedParameterKey :1;
  bool expectedParameterValue :1;
} _AlterTableRequest__isset;

class AlterTableRequest : public virtual ::apache::thrift::TBase {
 public:

  AlterTableRequest(const AlterTableRequest&);
  AlterTableRequest& operator=(const AlterTableRequest&);
  AlterTableRequest() noexcept
                    : catName(),
                      dbName(),
                      tableName(),
                      writeId(-1LL),
                      validWriteIdList(),
                      processorIdentifier(),
                      expectedParameterKey(),
                      expectedParameterValue() {
  }

  virtual ~AlterTableRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tableName;
  Table table;
  EnvironmentContext environmentContext;
  int64_t writeId;
  std::string validWriteIdList;
  std::vector<std::string>  processorCapabilities;
  std::string processorIdentifier;
  std::string expectedParameterKey;
  std::string expectedParameterValue;

  _AlterTableRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  void __set_table(const Table& val);

  void __set_environmentContext(const EnvironmentContext& val);

  void __set_writeId(const int64_t val);

  void __set_validWriteIdList(const std::string& val);

  void __set_processorCapabilities(const std::vector<std::string> & val);

  void __set_processorIdentifier(const std::string& val);

  void __set_expectedParameterKey(const std::string& val);

  void __set_expectedParameterValue(const std::string& val);

  bool operator == (const AlterTableRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(table == rhs.table))
      return false;
    if (__isset.environmentContext != rhs.__isset.environmentContext)
      return false;
    else if (__isset.environmentContext && !(environmentContext == rhs.environmentContext))
      return false;
    if (__isset.writeId != rhs.__isset.writeId)
      return false;
    else if (__isset.writeId && !(writeId == rhs.writeId))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.processorCapabilities != rhs.__isset.processorCapabilities)
      return false;
    else if (__isset.processorCapabilities && !(processorCapabilities == rhs.processorCapabilities))
      return false;
    if (__isset.processorIdentifier != rhs.__isset.processorIdentifier)
      return false;
    else if (__isset.processorIdentifier && !(processorIdentifier == rhs.processorIdentifier))
      return false;
    if (__isset.expectedParameterKey != rhs.__isset.expectedParameterKey)
      return false;
    else if (__isset.expectedParameterKey && !(expectedParameterKey == rhs.expectedParameterKey))
      return false;
    if (__isset.expectedParameterValue != rhs.__isset.expectedParameterValue)
      return false;
    else if (__isset.expectedParameterValue && !(expectedParameterValue == rhs.expectedParameterValue))
      return false;
    return true;
  }
  bool operator != (const AlterTableRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlterTableRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AlterTableRequest &a, AlterTableRequest &b);

std::ostream& operator<<(std::ostream& out, const AlterTableRequest& obj);


class AlterTableResponse : public virtual ::apache::thrift::TBase {
 public:

  AlterTableResponse(const AlterTableResponse&) noexcept;
  AlterTableResponse& operator=(const AlterTableResponse&) noexcept;
  AlterTableResponse() noexcept {
  }

  virtual ~AlterTableResponse() noexcept;

  bool operator == (const AlterTableResponse & /* rhs */) const
  {
    return true;
  }
  bool operator != (const AlterTableResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlterTableResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AlterTableResponse &a, AlterTableResponse &b);

std::ostream& operator<<(std::ostream& out, const AlterTableResponse& obj);

typedef struct _GetPartitionsFilterSpec__isset {
  _GetPartitionsFilterSpec__isset() : filterMode(false), filters(false) {}
  bool filterMode :1;
  bool filters :1;
} _GetPartitionsFilterSpec__isset;

class GetPartitionsFilterSpec : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionsFilterSpec(const GetPartitionsFilterSpec&);
  GetPartitionsFilterSpec& operator=(const GetPartitionsFilterSpec&);
  GetPartitionsFilterSpec() noexcept
                          : filterMode(static_cast<PartitionFilterMode::type>(0)) {
  }

  virtual ~GetPartitionsFilterSpec() noexcept;
  /**
   *
   * @see PartitionFilterMode
   */
  PartitionFilterMode::type filterMode;
  std::vector<std::string>  filters;

  _GetPartitionsFilterSpec__isset __isset;

  void __set_filterMode(const PartitionFilterMode::type val);

  void __set_filters(const std::vector<std::string> & val);

  bool operator == (const GetPartitionsFilterSpec & rhs) const
  {
    if (__isset.filterMode != rhs.__isset.filterMode)
      return false;
    else if (__isset.filterMode && !(filterMode == rhs.filterMode))
      return false;
    if (__isset.filters != rhs.__isset.filters)
      return false;
    else if (__isset.filters && !(filters == rhs.filters))
      return false;
    return true;
  }
  bool operator != (const GetPartitionsFilterSpec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionsFilterSpec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionsFilterSpec &a, GetPartitionsFilterSpec &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionsFilterSpec& obj);

typedef struct _GetPartitionsResponse__isset {
  _GetPartitionsResponse__isset() : partitionSpec(false) {}
  bool partitionSpec :1;
} _GetPartitionsResponse__isset;

class GetPartitionsResponse : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionsResponse(const GetPartitionsResponse&);
  GetPartitionsResponse& operator=(const GetPartitionsResponse&);
  GetPartitionsResponse() noexcept {
  }

  virtual ~GetPartitionsResponse() noexcept;
  std::vector<PartitionSpec>  partitionSpec;

  _GetPartitionsResponse__isset __isset;

  void __set_partitionSpec(const std::vector<PartitionSpec> & val);

  bool operator == (const GetPartitionsResponse & rhs) const
  {
    if (!(partitionSpec == rhs.partitionSpec))
      return false;
    return true;
  }
  bool operator != (const GetPartitionsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionsResponse &a, GetPartitionsResponse &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionsResponse& obj);

typedef struct _GetPartitionsRequest__isset {
  _GetPartitionsRequest__isset() : catName(false), dbName(false), tblName(false), withAuth(false), user(false), groupNames(false), projectionSpec(false), filterSpec(false), processorCapabilities(false), processorIdentifier(false), validWriteIdList(false) {}
  bool catName :1;
  bool dbName :1;
  bool tblName :1;
  bool withAuth :1;
  bool user :1;
  bool groupNames :1;
  bool projectionSpec :1;
  bool filterSpec :1;
  bool processorCapabilities :1;
  bool processorIdentifier :1;
  bool validWriteIdList :1;
} _GetPartitionsRequest__isset;

class GetPartitionsRequest : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionsRequest(const GetPartitionsRequest&);
  GetPartitionsRequest& operator=(const GetPartitionsRequest&);
  GetPartitionsRequest() noexcept
                       : catName(),
                         dbName(),
                         tblName(),
                         withAuth(0),
                         user(),
                         processorIdentifier(),
                         validWriteIdList() {
  }

  virtual ~GetPartitionsRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  bool withAuth;
  std::string user;
  std::vector<std::string>  groupNames;
  GetProjectionsSpec projectionSpec;
  GetPartitionsFilterSpec filterSpec;
  std::vector<std::string>  processorCapabilities;
  std::string processorIdentifier;
  std::string validWriteIdList;

  _GetPartitionsRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_withAuth(const bool val);

  void __set_user(const std::string& val);

  void __set_groupNames(const std::vector<std::string> & val);

  void __set_projectionSpec(const GetProjectionsSpec& val);

  void __set_filterSpec(const GetPartitionsFilterSpec& val);

  void __set_processorCapabilities(const std::vector<std::string> & val);

  void __set_processorIdentifier(const std::string& val);

  void __set_validWriteIdList(const std::string& val);

  bool operator == (const GetPartitionsRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.withAuth != rhs.__isset.withAuth)
      return false;
    else if (__isset.withAuth && !(withAuth == rhs.withAuth))
      return false;
    if (__isset.user != rhs.__isset.user)
      return false;
    else if (__isset.user && !(user == rhs.user))
      return false;
    if (__isset.groupNames != rhs.__isset.groupNames)
      return false;
    else if (__isset.groupNames && !(groupNames == rhs.groupNames))
      return false;
    if (!(projectionSpec == rhs.projectionSpec))
      return false;
    if (!(filterSpec == rhs.filterSpec))
      return false;
    if (__isset.processorCapabilities != rhs.__isset.processorCapabilities)
      return false;
    else if (__isset.processorCapabilities && !(processorCapabilities == rhs.processorCapabilities))
      return false;
    if (__isset.processorIdentifier != rhs.__isset.processorIdentifier)
      return false;
    else if (__isset.processorIdentifier && !(processorIdentifier == rhs.processorIdentifier))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    return true;
  }
  bool operator != (const GetPartitionsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionsRequest &a, GetPartitionsRequest &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionsRequest& obj);

typedef struct _GetFieldsRequest__isset {
  _GetFieldsRequest__isset() : catName(false), envContext(false), validWriteIdList(false), id(true) {}
  bool catName :1;
  bool envContext :1;
  bool validWriteIdList :1;
  bool id :1;
} _GetFieldsRequest__isset;

class GetFieldsRequest : public virtual ::apache::thrift::TBase {
 public:

  GetFieldsRequest(const GetFieldsRequest&);
  GetFieldsRequest& operator=(const GetFieldsRequest&);
  GetFieldsRequest() noexcept
                   : catName(),
                     dbName(),
                     tblName(),
                     validWriteIdList(),
                     id(-1LL) {
  }

  virtual ~GetFieldsRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  EnvironmentContext envContext;
  std::string validWriteIdList;
  int64_t id;

  _GetFieldsRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_envContext(const EnvironmentContext& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_id(const int64_t val);

  bool operator == (const GetFieldsRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.envContext != rhs.__isset.envContext)
      return false;
    else if (__isset.envContext && !(envContext == rhs.envContext))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const GetFieldsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFieldsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFieldsRequest &a, GetFieldsRequest &b);

std::ostream& operator<<(std::ostream& out, const GetFieldsRequest& obj);


class GetFieldsResponse : public virtual ::apache::thrift::TBase {
 public:

  GetFieldsResponse(const GetFieldsResponse&);
  GetFieldsResponse& operator=(const GetFieldsResponse&);
  GetFieldsResponse() noexcept {
  }

  virtual ~GetFieldsResponse() noexcept;
  std::vector<FieldSchema>  fields;

  void __set_fields(const std::vector<FieldSchema> & val);

  bool operator == (const GetFieldsResponse & rhs) const
  {
    if (!(fields == rhs.fields))
      return false;
    return true;
  }
  bool operator != (const GetFieldsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetFieldsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetFieldsResponse &a, GetFieldsResponse &b);

std::ostream& operator<<(std::ostream& out, const GetFieldsResponse& obj);

typedef struct _GetSchemaRequest__isset {
  _GetSchemaRequest__isset() : catName(false), envContext(false), validWriteIdList(false), id(true) {}
  bool catName :1;
  bool envContext :1;
  bool validWriteIdList :1;
  bool id :1;
} _GetSchemaRequest__isset;

class GetSchemaRequest : public virtual ::apache::thrift::TBase {
 public:

  GetSchemaRequest(const GetSchemaRequest&);
  GetSchemaRequest& operator=(const GetSchemaRequest&);
  GetSchemaRequest() noexcept
                   : catName(),
                     dbName(),
                     tblName(),
                     validWriteIdList(),
                     id(-1LL) {
  }

  virtual ~GetSchemaRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  EnvironmentContext envContext;
  std::string validWriteIdList;
  int64_t id;

  _GetSchemaRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_envContext(const EnvironmentContext& val);

  void __set_validWriteIdList(const std::string& val);

  void __set_id(const int64_t val);

  bool operator == (const GetSchemaRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.envContext != rhs.__isset.envContext)
      return false;
    else if (__isset.envContext && !(envContext == rhs.envContext))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const GetSchemaRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetSchemaRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetSchemaRequest &a, GetSchemaRequest &b);

std::ostream& operator<<(std::ostream& out, const GetSchemaRequest& obj);


class GetSchemaResponse : public virtual ::apache::thrift::TBase {
 public:

  GetSchemaResponse(const GetSchemaResponse&);
  GetSchemaResponse& operator=(const GetSchemaResponse&);
  GetSchemaResponse() noexcept {
  }

  virtual ~GetSchemaResponse() noexcept;
  std::vector<FieldSchema>  fields;

  void __set_fields(const std::vector<FieldSchema> & val);

  bool operator == (const GetSchemaResponse & rhs) const
  {
    if (!(fields == rhs.fields))
      return false;
    return true;
  }
  bool operator != (const GetSchemaResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetSchemaResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetSchemaResponse &a, GetSchemaResponse &b);

std::ostream& operator<<(std::ostream& out, const GetSchemaResponse& obj);

typedef struct _GetPartitionRequest__isset {
  _GetPartitionRequest__isset() : catName(false), validWriteIdList(false), id(true) {}
  bool catName :1;
  bool validWriteIdList :1;
  bool id :1;
} _GetPartitionRequest__isset;

class GetPartitionRequest : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionRequest(const GetPartitionRequest&);
  GetPartitionRequest& operator=(const GetPartitionRequest&);
  GetPartitionRequest() noexcept
                      : catName(),
                        dbName(),
                        tblName(),
                        validWriteIdList(),
                        id(-1LL) {
  }

  virtual ~GetPartitionRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  std::vector<std::string>  partVals;
  std::string validWriteIdList;
  int64_t id;

  _GetPartitionRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_partVals(const std::vector<std::string> & val);

  void __set_validWriteIdList(const std::string& val);

  void __set_id(const int64_t val);

  bool operator == (const GetPartitionRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(partVals == rhs.partVals))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const GetPartitionRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionRequest &a, GetPartitionRequest &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionRequest& obj);


class GetPartitionResponse : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionResponse(const GetPartitionResponse&);
  GetPartitionResponse& operator=(const GetPartitionResponse&);
  GetPartitionResponse() noexcept {
  }

  virtual ~GetPartitionResponse() noexcept;
  Partition partition;

  void __set_partition(const Partition& val);

  bool operator == (const GetPartitionResponse & rhs) const
  {
    if (!(partition == rhs.partition))
      return false;
    return true;
  }
  bool operator != (const GetPartitionResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionResponse &a, GetPartitionResponse &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionResponse& obj);

typedef struct _PartitionsRequest__isset {
  _PartitionsRequest__isset() : catName(false), maxParts(true), validWriteIdList(false), id(true), skipColumnSchemaForPartition(false), includeParamKeyPattern(false), excludeParamKeyPattern(false) {}
  bool catName :1;
  bool maxParts :1;
  bool validWriteIdList :1;
  bool id :1;
  bool skipColumnSchemaForPartition :1;
  bool includeParamKeyPattern :1;
  bool excludeParamKeyPattern :1;
} _PartitionsRequest__isset;

class PartitionsRequest : public virtual ::apache::thrift::TBase {
 public:

  PartitionsRequest(const PartitionsRequest&);
  PartitionsRequest& operator=(const PartitionsRequest&);
  PartitionsRequest() noexcept
                    : catName(),
                      dbName(),
                      tblName(),
                      maxParts(-1),
                      validWriteIdList(),
                      id(-1LL),
                      skipColumnSchemaForPartition(0),
                      includeParamKeyPattern(),
                      excludeParamKeyPattern() {
  }

  virtual ~PartitionsRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  int16_t maxParts;
  std::string validWriteIdList;
  int64_t id;
  bool skipColumnSchemaForPartition;
  std::string includeParamKeyPattern;
  std::string excludeParamKeyPattern;

  _PartitionsRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_maxParts(const int16_t val);

  void __set_validWriteIdList(const std::string& val);

  void __set_id(const int64_t val);

  void __set_skipColumnSchemaForPartition(const bool val);

  void __set_includeParamKeyPattern(const std::string& val);

  void __set_excludeParamKeyPattern(const std::string& val);

  bool operator == (const PartitionsRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.maxParts != rhs.__isset.maxParts)
      return false;
    else if (__isset.maxParts && !(maxParts == rhs.maxParts))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.skipColumnSchemaForPartition != rhs.__isset.skipColumnSchemaForPartition)
      return false;
    else if (__isset.skipColumnSchemaForPartition && !(skipColumnSchemaForPartition == rhs.skipColumnSchemaForPartition))
      return false;
    if (__isset.includeParamKeyPattern != rhs.__isset.includeParamKeyPattern)
      return false;
    else if (__isset.includeParamKeyPattern && !(includeParamKeyPattern == rhs.includeParamKeyPattern))
      return false;
    if (__isset.excludeParamKeyPattern != rhs.__isset.excludeParamKeyPattern)
      return false;
    else if (__isset.excludeParamKeyPattern && !(excludeParamKeyPattern == rhs.excludeParamKeyPattern))
      return false;
    return true;
  }
  bool operator != (const PartitionsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsRequest &a, PartitionsRequest &b);

std::ostream& operator<<(std::ostream& out, const PartitionsRequest& obj);


class PartitionsResponse : public virtual ::apache::thrift::TBase {
 public:

  PartitionsResponse(const PartitionsResponse&);
  PartitionsResponse& operator=(const PartitionsResponse&);
  PartitionsResponse() noexcept {
  }

  virtual ~PartitionsResponse() noexcept;
  std::vector<Partition>  partitions;

  void __set_partitions(const std::vector<Partition> & val);

  bool operator == (const PartitionsResponse & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const PartitionsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartitionsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(PartitionsResponse &a, PartitionsResponse &b);

std::ostream& operator<<(std::ostream& out, const PartitionsResponse& obj);

typedef struct _GetPartitionsByFilterRequest__isset {
  _GetPartitionsByFilterRequest__isset() : catName(false), dbName(false), tblName(false), filter(false), maxParts(true), skipColumnSchemaForPartition(false), includeParamKeyPattern(false), excludeParamKeyPattern(false) {}
  bool catName :1;
  bool dbName :1;
  bool tblName :1;
  bool filter :1;
  bool maxParts :1;
  bool skipColumnSchemaForPartition :1;
  bool includeParamKeyPattern :1;
  bool excludeParamKeyPattern :1;
} _GetPartitionsByFilterRequest__isset;

class GetPartitionsByFilterRequest : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionsByFilterRequest(const GetPartitionsByFilterRequest&);
  GetPartitionsByFilterRequest& operator=(const GetPartitionsByFilterRequest&);
  GetPartitionsByFilterRequest() noexcept
                               : catName(),
                                 dbName(),
                                 tblName(),
                                 filter(),
                                 maxParts(-1),
                                 skipColumnSchemaForPartition(0),
                                 includeParamKeyPattern(),
                                 excludeParamKeyPattern() {
  }

  virtual ~GetPartitionsByFilterRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  std::string filter;
  int16_t maxParts;
  bool skipColumnSchemaForPartition;
  std::string includeParamKeyPattern;
  std::string excludeParamKeyPattern;

  _GetPartitionsByFilterRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_filter(const std::string& val);

  void __set_maxParts(const int16_t val);

  void __set_skipColumnSchemaForPartition(const bool val);

  void __set_includeParamKeyPattern(const std::string& val);

  void __set_excludeParamKeyPattern(const std::string& val);

  bool operator == (const GetPartitionsByFilterRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (!(filter == rhs.filter))
      return false;
    if (__isset.maxParts != rhs.__isset.maxParts)
      return false;
    else if (__isset.maxParts && !(maxParts == rhs.maxParts))
      return false;
    if (__isset.skipColumnSchemaForPartition != rhs.__isset.skipColumnSchemaForPartition)
      return false;
    else if (__isset.skipColumnSchemaForPartition && !(skipColumnSchemaForPartition == rhs.skipColumnSchemaForPartition))
      return false;
    if (__isset.includeParamKeyPattern != rhs.__isset.includeParamKeyPattern)
      return false;
    else if (__isset.includeParamKeyPattern && !(includeParamKeyPattern == rhs.includeParamKeyPattern))
      return false;
    if (__isset.excludeParamKeyPattern != rhs.__isset.excludeParamKeyPattern)
      return false;
    else if (__isset.excludeParamKeyPattern && !(excludeParamKeyPattern == rhs.excludeParamKeyPattern))
      return false;
    return true;
  }
  bool operator != (const GetPartitionsByFilterRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionsByFilterRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionsByFilterRequest &a, GetPartitionsByFilterRequest &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionsByFilterRequest& obj);

typedef struct _GetPartitionNamesPsRequest__isset {
  _GetPartitionNamesPsRequest__isset() : catName(false), partValues(false), maxParts(true), validWriteIdList(false), id(true) {}
  bool catName :1;
  bool partValues :1;
  bool maxParts :1;
  bool validWriteIdList :1;
  bool id :1;
} _GetPartitionNamesPsRequest__isset;

class GetPartitionNamesPsRequest : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionNamesPsRequest(const GetPartitionNamesPsRequest&);
  GetPartitionNamesPsRequest& operator=(const GetPartitionNamesPsRequest&);
  GetPartitionNamesPsRequest() noexcept
                             : catName(),
                               dbName(),
                               tblName(),
                               maxParts(-1),
                               validWriteIdList(),
                               id(-1LL) {
  }

  virtual ~GetPartitionNamesPsRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  std::vector<std::string>  partValues;
  int16_t maxParts;
  std::string validWriteIdList;
  int64_t id;

  _GetPartitionNamesPsRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_partValues(const std::vector<std::string> & val);

  void __set_maxParts(const int16_t val);

  void __set_validWriteIdList(const std::string& val);

  void __set_id(const int64_t val);

  bool operator == (const GetPartitionNamesPsRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.partValues != rhs.__isset.partValues)
      return false;
    else if (__isset.partValues && !(partValues == rhs.partValues))
      return false;
    if (__isset.maxParts != rhs.__isset.maxParts)
      return false;
    else if (__isset.maxParts && !(maxParts == rhs.maxParts))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const GetPartitionNamesPsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionNamesPsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionNamesPsRequest &a, GetPartitionNamesPsRequest &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionNamesPsRequest& obj);


class GetPartitionNamesPsResponse : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionNamesPsResponse(const GetPartitionNamesPsResponse&);
  GetPartitionNamesPsResponse& operator=(const GetPartitionNamesPsResponse&);
  GetPartitionNamesPsResponse() noexcept {
  }

  virtual ~GetPartitionNamesPsResponse() noexcept;
  std::vector<std::string>  names;

  void __set_names(const std::vector<std::string> & val);

  bool operator == (const GetPartitionNamesPsResponse & rhs) const
  {
    if (!(names == rhs.names))
      return false;
    return true;
  }
  bool operator != (const GetPartitionNamesPsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionNamesPsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionNamesPsResponse &a, GetPartitionNamesPsResponse &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionNamesPsResponse& obj);

typedef struct _GetPartitionsPsWithAuthRequest__isset {
  _GetPartitionsPsWithAuthRequest__isset() : catName(false), partVals(false), maxParts(true), userName(false), groupNames(false), validWriteIdList(false), id(true), skipColumnSchemaForPartition(false), includeParamKeyPattern(false), excludeParamKeyPattern(false), partNames(false) {}
  bool catName :1;
  bool partVals :1;
  bool maxParts :1;
  bool userName :1;
  bool groupNames :1;
  bool validWriteIdList :1;
  bool id :1;
  bool skipColumnSchemaForPartition :1;
  bool includeParamKeyPattern :1;
  bool excludeParamKeyPattern :1;
  bool partNames :1;
} _GetPartitionsPsWithAuthRequest__isset;

class GetPartitionsPsWithAuthRequest : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionsPsWithAuthRequest(const GetPartitionsPsWithAuthRequest&);
  GetPartitionsPsWithAuthRequest& operator=(const GetPartitionsPsWithAuthRequest&);
  GetPartitionsPsWithAuthRequest() noexcept
                                 : catName(),
                                   dbName(),
                                   tblName(),
                                   maxParts(-1),
                                   userName(),
                                   validWriteIdList(),
                                   id(-1LL),
                                   skipColumnSchemaForPartition(0),
                                   includeParamKeyPattern(),
                                   excludeParamKeyPattern() {
  }

  virtual ~GetPartitionsPsWithAuthRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string tblName;
  std::vector<std::string>  partVals;
  int16_t maxParts;
  std::string userName;
  std::vector<std::string>  groupNames;
  std::string validWriteIdList;
  int64_t id;
  bool skipColumnSchemaForPartition;
  std::string includeParamKeyPattern;
  std::string excludeParamKeyPattern;
  std::vector<std::string>  partNames;

  _GetPartitionsPsWithAuthRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_tblName(const std::string& val);

  void __set_partVals(const std::vector<std::string> & val);

  void __set_maxParts(const int16_t val);

  void __set_userName(const std::string& val);

  void __set_groupNames(const std::vector<std::string> & val);

  void __set_validWriteIdList(const std::string& val);

  void __set_id(const int64_t val);

  void __set_skipColumnSchemaForPartition(const bool val);

  void __set_includeParamKeyPattern(const std::string& val);

  void __set_excludeParamKeyPattern(const std::string& val);

  void __set_partNames(const std::vector<std::string> & val);

  bool operator == (const GetPartitionsPsWithAuthRequest & rhs) const
  {
    if (__isset.catName != rhs.__isset.catName)
      return false;
    else if (__isset.catName && !(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tblName == rhs.tblName))
      return false;
    if (__isset.partVals != rhs.__isset.partVals)
      return false;
    else if (__isset.partVals && !(partVals == rhs.partVals))
      return false;
    if (__isset.maxParts != rhs.__isset.maxParts)
      return false;
    else if (__isset.maxParts && !(maxParts == rhs.maxParts))
      return false;
    if (__isset.userName != rhs.__isset.userName)
      return false;
    else if (__isset.userName && !(userName == rhs.userName))
      return false;
    if (__isset.groupNames != rhs.__isset.groupNames)
      return false;
    else if (__isset.groupNames && !(groupNames == rhs.groupNames))
      return false;
    if (__isset.validWriteIdList != rhs.__isset.validWriteIdList)
      return false;
    else if (__isset.validWriteIdList && !(validWriteIdList == rhs.validWriteIdList))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.skipColumnSchemaForPartition != rhs.__isset.skipColumnSchemaForPartition)
      return false;
    else if (__isset.skipColumnSchemaForPartition && !(skipColumnSchemaForPartition == rhs.skipColumnSchemaForPartition))
      return false;
    if (__isset.includeParamKeyPattern != rhs.__isset.includeParamKeyPattern)
      return false;
    else if (__isset.includeParamKeyPattern && !(includeParamKeyPattern == rhs.includeParamKeyPattern))
      return false;
    if (__isset.excludeParamKeyPattern != rhs.__isset.excludeParamKeyPattern)
      return false;
    else if (__isset.excludeParamKeyPattern && !(excludeParamKeyPattern == rhs.excludeParamKeyPattern))
      return false;
    if (__isset.partNames != rhs.__isset.partNames)
      return false;
    else if (__isset.partNames && !(partNames == rhs.partNames))
      return false;
    return true;
  }
  bool operator != (const GetPartitionsPsWithAuthRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionsPsWithAuthRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionsPsWithAuthRequest &a, GetPartitionsPsWithAuthRequest &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionsPsWithAuthRequest& obj);


class GetPartitionsPsWithAuthResponse : public virtual ::apache::thrift::TBase {
 public:

  GetPartitionsPsWithAuthResponse(const GetPartitionsPsWithAuthResponse&);
  GetPartitionsPsWithAuthResponse& operator=(const GetPartitionsPsWithAuthResponse&);
  GetPartitionsPsWithAuthResponse() noexcept {
  }

  virtual ~GetPartitionsPsWithAuthResponse() noexcept;
  std::vector<Partition>  partitions;

  void __set_partitions(const std::vector<Partition> & val);

  bool operator == (const GetPartitionsPsWithAuthResponse & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const GetPartitionsPsWithAuthResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPartitionsPsWithAuthResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPartitionsPsWithAuthResponse &a, GetPartitionsPsWithAuthResponse &b);

std::ostream& operator<<(std::ostream& out, const GetPartitionsPsWithAuthResponse& obj);

typedef struct _ReplicationMetrics__isset {
  _ReplicationMetrics__isset() : metadata(false), progress(false), messageFormat(false) {}
  bool metadata :1;
  bool progress :1;
  bool messageFormat :1;
} _ReplicationMetrics__isset;

class ReplicationMetrics : public virtual ::apache::thrift::TBase {
 public:

  ReplicationMetrics(const ReplicationMetrics&);
  ReplicationMetrics& operator=(const ReplicationMetrics&);
  ReplicationMetrics() noexcept
                     : scheduledExecutionId(0),
                       policy(),
                       dumpExecutionId(0),
                       metadata(),
                       progress(),
                       messageFormat() {
  }

  virtual ~ReplicationMetrics() noexcept;
  int64_t scheduledExecutionId;
  std::string policy;
  int64_t dumpExecutionId;
  std::string metadata;
  std::string progress;
  std::string messageFormat;

  _ReplicationMetrics__isset __isset;

  void __set_scheduledExecutionId(const int64_t val);

  void __set_policy(const std::string& val);

  void __set_dumpExecutionId(const int64_t val);

  void __set_metadata(const std::string& val);

  void __set_progress(const std::string& val);

  void __set_messageFormat(const std::string& val);

  bool operator == (const ReplicationMetrics & rhs) const
  {
    if (!(scheduledExecutionId == rhs.scheduledExecutionId))
      return false;
    if (!(policy == rhs.policy))
      return false;
    if (!(dumpExecutionId == rhs.dumpExecutionId))
      return false;
    if (__isset.metadata != rhs.__isset.metadata)
      return false;
    else if (__isset.metadata && !(metadata == rhs.metadata))
      return false;
    if (__isset.progress != rhs.__isset.progress)
      return false;
    else if (__isset.progress && !(progress == rhs.progress))
      return false;
    if (__isset.messageFormat != rhs.__isset.messageFormat)
      return false;
    else if (__isset.messageFormat && !(messageFormat == rhs.messageFormat))
      return false;
    return true;
  }
  bool operator != (const ReplicationMetrics &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicationMetrics & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReplicationMetrics &a, ReplicationMetrics &b);

std::ostream& operator<<(std::ostream& out, const ReplicationMetrics& obj);


class ReplicationMetricList : public virtual ::apache::thrift::TBase {
 public:

  ReplicationMetricList(const ReplicationMetricList&);
  ReplicationMetricList& operator=(const ReplicationMetricList&);
  ReplicationMetricList() noexcept {
  }

  virtual ~ReplicationMetricList() noexcept;
  std::vector<ReplicationMetrics>  replicationMetricList;

  void __set_replicationMetricList(const std::vector<ReplicationMetrics> & val);

  bool operator == (const ReplicationMetricList & rhs) const
  {
    if (!(replicationMetricList == rhs.replicationMetricList))
      return false;
    return true;
  }
  bool operator != (const ReplicationMetricList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReplicationMetricList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReplicationMetricList &a, ReplicationMetricList &b);

std::ostream& operator<<(std::ostream& out, const ReplicationMetricList& obj);

typedef struct _GetReplicationMetricsRequest__isset {
  _GetReplicationMetricsRequest__isset() : scheduledExecutionId(false), policy(false), dumpExecutionId(false) {}
  bool scheduledExecutionId :1;
  bool policy :1;
  bool dumpExecutionId :1;
} _GetReplicationMetricsRequest__isset;

class GetReplicationMetricsRequest : public virtual ::apache::thrift::TBase {
 public:

  GetReplicationMetricsRequest(const GetReplicationMetricsRequest&);
  GetReplicationMetricsRequest& operator=(const GetReplicationMetricsRequest&);
  GetReplicationMetricsRequest() noexcept
                               : scheduledExecutionId(0),
                                 policy(),
                                 dumpExecutionId(0) {
  }

  virtual ~GetReplicationMetricsRequest() noexcept;
  int64_t scheduledExecutionId;
  std::string policy;
  int64_t dumpExecutionId;

  _GetReplicationMetricsRequest__isset __isset;

  void __set_scheduledExecutionId(const int64_t val);

  void __set_policy(const std::string& val);

  void __set_dumpExecutionId(const int64_t val);

  bool operator == (const GetReplicationMetricsRequest & rhs) const
  {
    if (__isset.scheduledExecutionId != rhs.__isset.scheduledExecutionId)
      return false;
    else if (__isset.scheduledExecutionId && !(scheduledExecutionId == rhs.scheduledExecutionId))
      return false;
    if (__isset.policy != rhs.__isset.policy)
      return false;
    else if (__isset.policy && !(policy == rhs.policy))
      return false;
    if (__isset.dumpExecutionId != rhs.__isset.dumpExecutionId)
      return false;
    else if (__isset.dumpExecutionId && !(dumpExecutionId == rhs.dumpExecutionId))
      return false;
    return true;
  }
  bool operator != (const GetReplicationMetricsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetReplicationMetricsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetReplicationMetricsRequest &a, GetReplicationMetricsRequest &b);

std::ostream& operator<<(std::ostream& out, const GetReplicationMetricsRequest& obj);

typedef struct _GetOpenTxnsRequest__isset {
  _GetOpenTxnsRequest__isset() : excludeTxnTypes(false) {}
  bool excludeTxnTypes :1;
} _GetOpenTxnsRequest__isset;

class GetOpenTxnsRequest : public virtual ::apache::thrift::TBase {
 public:

  GetOpenTxnsRequest(const GetOpenTxnsRequest&);
  GetOpenTxnsRequest& operator=(const GetOpenTxnsRequest&);
  GetOpenTxnsRequest() noexcept {
  }

  virtual ~GetOpenTxnsRequest() noexcept;
  std::vector<TxnType::type>  excludeTxnTypes;

  _GetOpenTxnsRequest__isset __isset;

  void __set_excludeTxnTypes(const std::vector<TxnType::type> & val);

  bool operator == (const GetOpenTxnsRequest & rhs) const
  {
    if (__isset.excludeTxnTypes != rhs.__isset.excludeTxnTypes)
      return false;
    else if (__isset.excludeTxnTypes && !(excludeTxnTypes == rhs.excludeTxnTypes))
      return false;
    return true;
  }
  bool operator != (const GetOpenTxnsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetOpenTxnsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetOpenTxnsRequest &a, GetOpenTxnsRequest &b);

std::ostream& operator<<(std::ostream& out, const GetOpenTxnsRequest& obj);


class StoredProcedureRequest : public virtual ::apache::thrift::TBase {
 public:

  StoredProcedureRequest(const StoredProcedureRequest&);
  StoredProcedureRequest& operator=(const StoredProcedureRequest&);
  StoredProcedureRequest() noexcept
                         : catName(),
                           dbName(),
                           procName() {
  }

  virtual ~StoredProcedureRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string procName;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_procName(const std::string& val);

  bool operator == (const StoredProcedureRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(procName == rhs.procName))
      return false;
    return true;
  }
  bool operator != (const StoredProcedureRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StoredProcedureRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(StoredProcedureRequest &a, StoredProcedureRequest &b);

std::ostream& operator<<(std::ostream& out, const StoredProcedureRequest& obj);

typedef struct _ListStoredProcedureRequest__isset {
  _ListStoredProcedureRequest__isset() : dbName(false) {}
  bool dbName :1;
} _ListStoredProcedureRequest__isset;

class ListStoredProcedureRequest : public virtual ::apache::thrift::TBase {
 public:

  ListStoredProcedureRequest(const ListStoredProcedureRequest&);
  ListStoredProcedureRequest& operator=(const ListStoredProcedureRequest&);
  ListStoredProcedureRequest() noexcept
                             : catName(),
                               dbName() {
  }

  virtual ~ListStoredProcedureRequest() noexcept;
  std::string catName;
  std::string dbName;

  _ListStoredProcedureRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  bool operator == (const ListStoredProcedureRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (__isset.dbName != rhs.__isset.dbName)
      return false;
    else if (__isset.dbName && !(dbName == rhs.dbName))
      return false;
    return true;
  }
  bool operator != (const ListStoredProcedureRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListStoredProcedureRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListStoredProcedureRequest &a, ListStoredProcedureRequest &b);

std::ostream& operator<<(std::ostream& out, const ListStoredProcedureRequest& obj);

typedef struct _StoredProcedure__isset {
  _StoredProcedure__isset() : name(false), dbName(false), catName(false), ownerName(false), source(false) {}
  bool name :1;
  bool dbName :1;
  bool catName :1;
  bool ownerName :1;
  bool source :1;
} _StoredProcedure__isset;

class StoredProcedure : public virtual ::apache::thrift::TBase {
 public:

  StoredProcedure(const StoredProcedure&);
  StoredProcedure& operator=(const StoredProcedure&);
  StoredProcedure() noexcept
                  : name(),
                    dbName(),
                    catName(),
                    ownerName(),
                    source() {
  }

  virtual ~StoredProcedure() noexcept;
  std::string name;
  std::string dbName;
  std::string catName;
  std::string ownerName;
  std::string source;

  _StoredProcedure__isset __isset;

  void __set_name(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_catName(const std::string& val);

  void __set_ownerName(const std::string& val);

  void __set_source(const std::string& val);

  bool operator == (const StoredProcedure & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(catName == rhs.catName))
      return false;
    if (!(ownerName == rhs.ownerName))
      return false;
    if (!(source == rhs.source))
      return false;
    return true;
  }
  bool operator != (const StoredProcedure &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StoredProcedure & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(StoredProcedure &a, StoredProcedure &b);

std::ostream& operator<<(std::ostream& out, const StoredProcedure& obj);

typedef struct _AddPackageRequest__isset {
  _AddPackageRequest__isset() : catName(false), dbName(false), packageName(false), ownerName(false), header(false), body(false) {}
  bool catName :1;
  bool dbName :1;
  bool packageName :1;
  bool ownerName :1;
  bool header :1;
  bool body :1;
} _AddPackageRequest__isset;

class AddPackageRequest : public virtual ::apache::thrift::TBase {
 public:

  AddPackageRequest(const AddPackageRequest&);
  AddPackageRequest& operator=(const AddPackageRequest&);
  AddPackageRequest() noexcept
                    : catName(),
                      dbName(),
                      packageName(),
                      ownerName(),
                      header(),
                      body() {
  }

  virtual ~AddPackageRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string packageName;
  std::string ownerName;
  std::string header;
  std::string body;

  _AddPackageRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_packageName(const std::string& val);

  void __set_ownerName(const std::string& val);

  void __set_header(const std::string& val);

  void __set_body(const std::string& val);

  bool operator == (const AddPackageRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(packageName == rhs.packageName))
      return false;
    if (!(ownerName == rhs.ownerName))
      return false;
    if (!(header == rhs.header))
      return false;
    if (!(body == rhs.body))
      return false;
    return true;
  }
  bool operator != (const AddPackageRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AddPackageRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(AddPackageRequest &a, AddPackageRequest &b);

std::ostream& operator<<(std::ostream& out, const AddPackageRequest& obj);


class GetPackageRequest : public virtual ::apache::thrift::TBase {
 public:

  GetPackageRequest(const GetPackageRequest&);
  GetPackageRequest& operator=(const GetPackageRequest&);
  GetPackageRequest() noexcept
                    : catName(),
                      dbName(),
                      packageName() {
  }

  virtual ~GetPackageRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string packageName;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_packageName(const std::string& val);

  bool operator == (const GetPackageRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(packageName == rhs.packageName))
      return false;
    return true;
  }
  bool operator != (const GetPackageRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetPackageRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetPackageRequest &a, GetPackageRequest &b);

std::ostream& operator<<(std::ostream& out, const GetPackageRequest& obj);


class DropPackageRequest : public virtual ::apache::thrift::TBase {
 public:

  DropPackageRequest(const DropPackageRequest&);
  DropPackageRequest& operator=(const DropPackageRequest&);
  DropPackageRequest() noexcept
                     : catName(),
                       dbName(),
                       packageName() {
  }

  virtual ~DropPackageRequest() noexcept;
  std::string catName;
  std::string dbName;
  std::string packageName;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_packageName(const std::string& val);

  bool operator == (const DropPackageRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(packageName == rhs.packageName))
      return false;
    return true;
  }
  bool operator != (const DropPackageRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DropPackageRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DropPackageRequest &a, DropPackageRequest &b);

std::ostream& operator<<(std::ostream& out, const DropPackageRequest& obj);

typedef struct _ListPackageRequest__isset {
  _ListPackageRequest__isset() : dbName(false) {}
  bool dbName :1;
} _ListPackageRequest__isset;

class ListPackageRequest : public virtual ::apache::thrift::TBase {
 public:

  ListPackageRequest(const ListPackageRequest&);
  ListPackageRequest& operator=(const ListPackageRequest&);
  ListPackageRequest() noexcept
                     : catName(),
                       dbName() {
  }

  virtual ~ListPackageRequest() noexcept;
  std::string catName;
  std::string dbName;

  _ListPackageRequest__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  bool operator == (const ListPackageRequest & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (__isset.dbName != rhs.__isset.dbName)
      return false;
    else if (__isset.dbName && !(dbName == rhs.dbName))
      return false;
    return true;
  }
  bool operator != (const ListPackageRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListPackageRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListPackageRequest &a, ListPackageRequest &b);

std::ostream& operator<<(std::ostream& out, const ListPackageRequest& obj);

typedef struct _Package__isset {
  _Package__isset() : catName(false), dbName(false), packageName(false), ownerName(false), header(false), body(false) {}
  bool catName :1;
  bool dbName :1;
  bool packageName :1;
  bool ownerName :1;
  bool header :1;
  bool body :1;
} _Package__isset;

class Package : public virtual ::apache::thrift::TBase {
 public:

  Package(const Package&);
  Package& operator=(const Package&);
  Package() noexcept
          : catName(),
            dbName(),
            packageName(),
            ownerName(),
            header(),
            body() {
  }

  virtual ~Package() noexcept;
  std::string catName;
  std::string dbName;
  std::string packageName;
  std::string ownerName;
  std::string header;
  std::string body;

  _Package__isset __isset;

  void __set_catName(const std::string& val);

  void __set_dbName(const std::string& val);

  void __set_packageName(const std::string& val);

  void __set_ownerName(const std::string& val);

  void __set_header(const std::string& val);

  void __set_body(const std::string& val);

  bool operator == (const Package & rhs) const
  {
    if (!(catName == rhs.catName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(packageName == rhs.packageName))
      return false;
    if (!(ownerName == rhs.ownerName))
      return false;
    if (!(header == rhs.header))
      return false;
    if (!(body == rhs.body))
      return false;
    return true;
  }
  bool operator != (const Package &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Package & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Package &a, Package &b);

std::ostream& operator<<(std::ostream& out, const Package& obj);

typedef struct _GetAllWriteEventInfoRequest__isset {
  _GetAllWriteEventInfoRequest__isset() : dbName(false), tableName(false) {}
  bool dbName :1;
  bool tableName :1;
} _GetAllWriteEventInfoRequest__isset;

class GetAllWriteEventInfoRequest : public virtual ::apache::thrift::TBase {
 public:

  GetAllWriteEventInfoRequest(const GetAllWriteEventInfoRequest&);
  GetAllWriteEventInfoRequest& operator=(const GetAllWriteEventInfoRequest&);
  GetAllWriteEventInfoRequest() noexcept
                              : txnId(0),
                                dbName(),
                                tableName() {
  }

  virtual ~GetAllWriteEventInfoRequest() noexcept;
  int64_t txnId;
  std::string dbName;
  std::string tableName;

  _GetAllWriteEventInfoRequest__isset __isset;

  void __set_txnId(const int64_t val);

  void __set_dbName(const std::string& val);

  void __set_tableName(const std::string& val);

  bool operator == (const GetAllWriteEventInfoRequest & rhs) const
  {
    if (!(txnId == rhs.txnId))
      return false;
    if (__isset.dbName != rhs.__isset.dbName)
      return false;
    else if (__isset.dbName && !(dbName == rhs.dbName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const GetAllWriteEventInfoRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetAllWriteEventInfoRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(GetAllWriteEventInfoRequest &a, GetAllWriteEventInfoRequest &b);

std::ostream& operator<<(std::ostream& out, const GetAllWriteEventInfoRequest& obj);

typedef struct _MetaException__isset {
  _MetaException__isset() : message(false) {}
  bool message :1;
} _MetaException__isset;

class MetaException : public ::apache::thrift::TException {
 public:

  MetaException(const MetaException&);
  MetaException& operator=(const MetaException&);
  MetaException() noexcept
                : message() {
  }

  virtual ~MetaException() noexcept;
  std::string message;

  _MetaException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const MetaException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const MetaException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MetaException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(MetaException &a, MetaException &b);

std::ostream& operator<<(std::ostream& out, const MetaException& obj);

typedef struct _UnknownTableException__isset {
  _UnknownTableException__isset() : message(false) {}
  bool message :1;
} _UnknownTableException__isset;

class UnknownTableException : public ::apache::thrift::TException {
 public:

  UnknownTableException(const UnknownTableException&);
  UnknownTableException& operator=(const UnknownTableException&);
  UnknownTableException() noexcept
                        : message() {
  }

  virtual ~UnknownTableException() noexcept;
  std::string message;

  _UnknownTableException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const UnknownTableException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnknownTableException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownTableException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(UnknownTableException &a, UnknownTableException &b);

std::ostream& operator<<(std::ostream& out, const UnknownTableException& obj);

typedef struct _UnknownDBException__isset {
  _UnknownDBException__isset() : message(false) {}
  bool message :1;
} _UnknownDBException__isset;

class UnknownDBException : public ::apache::thrift::TException {
 public:

  UnknownDBException(const UnknownDBException&);
  UnknownDBException& operator=(const UnknownDBException&);
  UnknownDBException() noexcept
                     : message() {
  }

  virtual ~UnknownDBException() noexcept;
  std::string message;

  _UnknownDBException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const UnknownDBException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnknownDBException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownDBException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(UnknownDBException &a, UnknownDBException &b);

std::ostream& operator<<(std::ostream& out, const UnknownDBException& obj);

typedef struct _AlreadyExistsException__isset {
  _AlreadyExistsException__isset() : message(false) {}
  bool message :1;
} _AlreadyExistsException__isset;

class AlreadyExistsException : public ::apache::thrift::TException {
 public:

  AlreadyExistsException(const AlreadyExistsException&);
  AlreadyExistsException& operator=(const AlreadyExistsException&);
  AlreadyExistsException() noexcept
                         : message() {
  }

  virtual ~AlreadyExistsException() noexcept;
  std::string message;

  _AlreadyExistsException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const AlreadyExistsException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const AlreadyExistsException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlreadyExistsException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(AlreadyExistsException &a, AlreadyExistsException &b);

std::ostream& operator<<(std::ostream& out, const AlreadyExistsException& obj);

typedef struct _InvalidPartitionException__isset {
  _InvalidPartitionException__isset() : message(false) {}
  bool message :1;
} _InvalidPartitionException__isset;

class InvalidPartitionException : public ::apache::thrift::TException {
 public:

  InvalidPartitionException(const InvalidPartitionException&);
  InvalidPartitionException& operator=(const InvalidPartitionException&);
  InvalidPartitionException() noexcept
                            : message() {
  }

  virtual ~InvalidPartitionException() noexcept;
  std::string message;

  _InvalidPartitionException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const InvalidPartitionException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidPartitionException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidPartitionException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(InvalidPartitionException &a, InvalidPartitionException &b);

std::ostream& operator<<(std::ostream& out, const InvalidPartitionException& obj);

typedef struct _UnknownPartitionException__isset {
  _UnknownPartitionException__isset() : message(false) {}
  bool message :1;
} _UnknownPartitionException__isset;

class UnknownPartitionException : public ::apache::thrift::TException {
 public:

  UnknownPartitionException(const UnknownPartitionException&);
  UnknownPartitionException& operator=(const UnknownPartitionException&);
  UnknownPartitionException() noexcept
                            : message() {
  }

  virtual ~UnknownPartitionException() noexcept;
  std::string message;

  _UnknownPartitionException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const UnknownPartitionException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnknownPartitionException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownPartitionException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(UnknownPartitionException &a, UnknownPartitionException &b);

std::ostream& operator<<(std::ostream& out, const UnknownPartitionException& obj);

typedef struct _InvalidObjectException__isset {
  _InvalidObjectException__isset() : message(false) {}
  bool message :1;
} _InvalidObjectException__isset;

class InvalidObjectException : public ::apache::thrift::TException {
 public:

  InvalidObjectException(const InvalidObjectException&);
  InvalidObjectException& operator=(const InvalidObjectException&);
  InvalidObjectException() noexcept
                         : message() {
  }

  virtual ~InvalidObjectException() noexcept;
  std::string message;

  _InvalidObjectException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const InvalidObjectException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidObjectException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidObjectException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(InvalidObjectException &a, InvalidObjectException &b);

std::ostream& operator<<(std::ostream& out, const InvalidObjectException& obj);

typedef struct _NoSuchObjectException__isset {
  _NoSuchObjectException__isset() : message(false) {}
  bool message :1;
} _NoSuchObjectException__isset;

class NoSuchObjectException : public ::apache::thrift::TException {
 public:

  NoSuchObjectException(const NoSuchObjectException&);
  NoSuchObjectException& operator=(const NoSuchObjectException&);
  NoSuchObjectException() noexcept
                        : message() {
  }

  virtual ~NoSuchObjectException() noexcept;
  std::string message;

  _NoSuchObjectException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchObjectException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchObjectException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchObjectException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(NoSuchObjectException &a, NoSuchObjectException &b);

std::ostream& operator<<(std::ostream& out, const NoSuchObjectException& obj);

typedef struct _InvalidOperationException__isset {
  _InvalidOperationException__isset() : message(false) {}
  bool message :1;
} _InvalidOperationException__isset;

class InvalidOperationException : public ::apache::thrift::TException {
 public:

  InvalidOperationException(const InvalidOperationException&);
  InvalidOperationException& operator=(const InvalidOperationException&);
  InvalidOperationException() noexcept
                            : message() {
  }

  virtual ~InvalidOperationException() noexcept;
  std::string message;

  _InvalidOperationException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const InvalidOperationException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidOperationException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidOperationException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(InvalidOperationException &a, InvalidOperationException &b);

std::ostream& operator<<(std::ostream& out, const InvalidOperationException& obj);

typedef struct _ConfigValSecurityException__isset {
  _ConfigValSecurityException__isset() : message(false) {}
  bool message :1;
} _ConfigValSecurityException__isset;

class ConfigValSecurityException : public ::apache::thrift::TException {
 public:

  ConfigValSecurityException(const ConfigValSecurityException&);
  ConfigValSecurityException& operator=(const ConfigValSecurityException&);
  ConfigValSecurityException() noexcept
                             : message() {
  }

  virtual ~ConfigValSecurityException() noexcept;
  std::string message;

  _ConfigValSecurityException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const ConfigValSecurityException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const ConfigValSecurityException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ConfigValSecurityException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(ConfigValSecurityException &a, ConfigValSecurityException &b);

std::ostream& operator<<(std::ostream& out, const ConfigValSecurityException& obj);

typedef struct _InvalidInputException__isset {
  _InvalidInputException__isset() : message(false) {}
  bool message :1;
} _InvalidInputException__isset;

class InvalidInputException : public ::apache::thrift::TException {
 public:

  InvalidInputException(const InvalidInputException&);
  InvalidInputException& operator=(const InvalidInputException&);
  InvalidInputException() noexcept
                        : message() {
  }

  virtual ~InvalidInputException() noexcept;
  std::string message;

  _InvalidInputException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const InvalidInputException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidInputException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidInputException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(InvalidInputException &a, InvalidInputException &b);

std::ostream& operator<<(std::ostream& out, const InvalidInputException& obj);

typedef struct _NoSuchTxnException__isset {
  _NoSuchTxnException__isset() : message(false) {}
  bool message :1;
} _NoSuchTxnException__isset;

class NoSuchTxnException : public ::apache::thrift::TException {
 public:

  NoSuchTxnException(const NoSuchTxnException&);
  NoSuchTxnException& operator=(const NoSuchTxnException&);
  NoSuchTxnException() noexcept
                     : message() {
  }

  virtual ~NoSuchTxnException() noexcept;
  std::string message;

  _NoSuchTxnException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchTxnException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchTxnException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchTxnException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(NoSuchTxnException &a, NoSuchTxnException &b);

std::ostream& operator<<(std::ostream& out, const NoSuchTxnException& obj);

typedef struct _TxnAbortedException__isset {
  _TxnAbortedException__isset() : message(false) {}
  bool message :1;
} _TxnAbortedException__isset;

class TxnAbortedException : public ::apache::thrift::TException {
 public:

  TxnAbortedException(const TxnAbortedException&);
  TxnAbortedException& operator=(const TxnAbortedException&);
  TxnAbortedException() noexcept
                      : message() {
  }

  virtual ~TxnAbortedException() noexcept;
  std::string message;

  _TxnAbortedException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const TxnAbortedException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const TxnAbortedException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TxnAbortedException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(TxnAbortedException &a, TxnAbortedException &b);

std::ostream& operator<<(std::ostream& out, const TxnAbortedException& obj);

typedef struct _TxnOpenException__isset {
  _TxnOpenException__isset() : message(false) {}
  bool message :1;
} _TxnOpenException__isset;

class TxnOpenException : public ::apache::thrift::TException {
 public:

  TxnOpenException(const TxnOpenException&);
  TxnOpenException& operator=(const TxnOpenException&);
  TxnOpenException() noexcept
                   : message() {
  }

  virtual ~TxnOpenException() noexcept;
  std::string message;

  _TxnOpenException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const TxnOpenException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const TxnOpenException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TxnOpenException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(TxnOpenException &a, TxnOpenException &b);

std::ostream& operator<<(std::ostream& out, const TxnOpenException& obj);

typedef struct _NoSuchLockException__isset {
  _NoSuchLockException__isset() : message(false) {}
  bool message :1;
} _NoSuchLockException__isset;

class NoSuchLockException : public ::apache::thrift::TException {
 public:

  NoSuchLockException(const NoSuchLockException&);
  NoSuchLockException& operator=(const NoSuchLockException&);
  NoSuchLockException() noexcept
                      : message() {
  }

  virtual ~NoSuchLockException() noexcept;
  std::string message;

  _NoSuchLockException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchLockException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchLockException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchLockException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(NoSuchLockException &a, NoSuchLockException &b);

std::ostream& operator<<(std::ostream& out, const NoSuchLockException& obj);

typedef struct _CompactionAbortedException__isset {
  _CompactionAbortedException__isset() : message(false) {}
  bool message :1;
} _CompactionAbortedException__isset;

class CompactionAbortedException : public ::apache::thrift::TException {
 public:

  CompactionAbortedException(const CompactionAbortedException&);
  CompactionAbortedException& operator=(const CompactionAbortedException&);
  CompactionAbortedException() noexcept
                             : message() {
  }

  virtual ~CompactionAbortedException() noexcept;
  std::string message;

  _CompactionAbortedException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const CompactionAbortedException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const CompactionAbortedException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactionAbortedException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(CompactionAbortedException &a, CompactionAbortedException &b);

std::ostream& operator<<(std::ostream& out, const CompactionAbortedException& obj);

typedef struct _NoSuchCompactionException__isset {
  _NoSuchCompactionException__isset() : message(false) {}
  bool message :1;
} _NoSuchCompactionException__isset;

class NoSuchCompactionException : public ::apache::thrift::TException {
 public:

  NoSuchCompactionException(const NoSuchCompactionException&);
  NoSuchCompactionException& operator=(const NoSuchCompactionException&);
  NoSuchCompactionException() noexcept
                            : message() {
  }

  virtual ~NoSuchCompactionException() noexcept;
  std::string message;

  _NoSuchCompactionException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const NoSuchCompactionException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchCompactionException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchCompactionException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(NoSuchCompactionException &a, NoSuchCompactionException &b);

std::ostream& operator<<(std::ostream& out, const NoSuchCompactionException& obj);

}}} // namespace

#endif
